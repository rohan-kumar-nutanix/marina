// Code generated by protoc-gen-go. DO NOT EDIT.
// source: medusa/vdisk_block_map.proto

package medusa

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
	zeus "github.com/nutanix-core/acs-aos-go/zeus"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MedusaVDiskBlockMapEntryProto struct {
	// The list of regions that describe this block. There cannot be any holes -
	// the set of regions completely cover the complete vdisk block. Some of the
	// regions can be 'invalid' though.
	//
	// The regions below are non-overlapping and are sorted based on
	// increasing block_offsets.
	Regions []*MedusaVDiskBlockMapEntryProto_Region `protobuf:"bytes,1,rep,name=regions" json:"regions,omitempty"`
	// Absolute time when the data in this block was last written.
	TimeUsecs *int64 `protobuf:"varint,2,req,name=time_usecs,json=timeUsecs" json:"time_usecs,omitempty"`
	// Vector of logical operation clocks that corresponds to potentially
	// ongoing operations that last modified this entry.
	Locs []*zeus.LogicalOperationClock `protobuf:"bytes,3,rep,name=locs" json:"locs,omitempty"`
	// The vdisk id corresponding to the last vdisk that wrote data to this
	// vdisk block. The data in the vdisk block should change due to this write -
	// a transformation (such as converting from regular extents to dedup
	// extents) without a change in the data doesn't count.
	//
	// This field may not always be set, but if set, it accurately describes
	// the vdisk that last wrote data to the given vblock.
	LastDataMutatorVdiskId *int64 `protobuf:"varint,4,opt,name=last_data_mutator_vdisk_id,json=lastDataMutatorVdiskId" json:"last_data_mutator_vdisk_id,omitempty"`
	// This field is set to true when this vblock object does not describe the
	// full vblock. In that case, one or more regions are 'invalid'.
	Incomplete *bool `protobuf:"varint,5,opt,name=incomplete,def=0" json:"incomplete,omitempty"`
	// If true, it indicates that the vdisk block map has been nullified, and the
	// entry should not be visible to Stargate unless there is a stale cache
	// entry in Medusa.
	Nullified *bool `protobuf:"varint,6,opt,name=nullified" json:"nullified,omitempty"`
	// This field is present only in merged vblocks.
	MergedVblock *MedusaVDiskBlockMapEntryProto_MergedVBlock `protobuf:"bytes,7,opt,name=merged_vblock,json=mergedVblock" json:"merged_vblock,omitempty"`
	// VDisk id of the descendant vdisk until which vblocks have been merged
	// into the current vblock. It is set with descendant vdisk id once the merge
	// and copy up is complete for the block.
	MergedUntilVdiskId   *int64   `protobuf:"varint,8,opt,name=merged_until_vdisk_id,json=mergedUntilVdiskId,def=-1" json:"merged_until_vdisk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MedusaVDiskBlockMapEntryProto) Reset()         { *m = MedusaVDiskBlockMapEntryProto{} }
func (m *MedusaVDiskBlockMapEntryProto) String() string { return proto.CompactTextString(m) }
func (*MedusaVDiskBlockMapEntryProto) ProtoMessage()    {}
func (*MedusaVDiskBlockMapEntryProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_823cefe977c2a876, []int{0}
}

func (m *MedusaVDiskBlockMapEntryProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto.Unmarshal(m, b)
}
func (m *MedusaVDiskBlockMapEntryProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto.Marshal(b, m, deterministic)
}
func (m *MedusaVDiskBlockMapEntryProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MedusaVDiskBlockMapEntryProto.Merge(m, src)
}
func (m *MedusaVDiskBlockMapEntryProto) XXX_Size() int {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto.Size(m)
}
func (m *MedusaVDiskBlockMapEntryProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MedusaVDiskBlockMapEntryProto.DiscardUnknown(m)
}

var xxx_messageInfo_MedusaVDiskBlockMapEntryProto proto.InternalMessageInfo

const Default_MedusaVDiskBlockMapEntryProto_Incomplete bool = false
const Default_MedusaVDiskBlockMapEntryProto_MergedUntilVdiskId int64 = -1

func (m *MedusaVDiskBlockMapEntryProto) GetRegions() []*MedusaVDiskBlockMapEntryProto_Region {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *MedusaVDiskBlockMapEntryProto) GetTimeUsecs() int64 {
	if m != nil && m.TimeUsecs != nil {
		return *m.TimeUsecs
	}
	return 0
}

func (m *MedusaVDiskBlockMapEntryProto) GetLocs() []*zeus.LogicalOperationClock {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *MedusaVDiskBlockMapEntryProto) GetLastDataMutatorVdiskId() int64 {
	if m != nil && m.LastDataMutatorVdiskId != nil {
		return *m.LastDataMutatorVdiskId
	}
	return 0
}

func (m *MedusaVDiskBlockMapEntryProto) GetIncomplete() bool {
	if m != nil && m.Incomplete != nil {
		return *m.Incomplete
	}
	return Default_MedusaVDiskBlockMapEntryProto_Incomplete
}

func (m *MedusaVDiskBlockMapEntryProto) GetNullified() bool {
	if m != nil && m.Nullified != nil {
		return *m.Nullified
	}
	return false
}

func (m *MedusaVDiskBlockMapEntryProto) GetMergedVblock() *MedusaVDiskBlockMapEntryProto_MergedVBlock {
	if m != nil {
		return m.MergedVblock
	}
	return nil
}

func (m *MedusaVDiskBlockMapEntryProto) GetMergedUntilVdiskId() int64 {
	if m != nil && m.MergedUntilVdiskId != nil {
		return *m.MergedUntilVdiskId
	}
	return Default_MedusaVDiskBlockMapEntryProto_MergedUntilVdiskId
}

// A region describes a contiguous portion of a block and the corresponding
// extent to which it maps.
type MedusaVDiskBlockMapEntryProto_Region struct {
	// Offset within the block where this region begins. Default is 0 as per
	// protobufs initialization.
	BlockOffset *int32 `protobuf:"varint,1,opt,name=block_offset,json=blockOffset" json:"block_offset,omitempty"`
	// Size of this region in bytes. If not specified, then it defaults to this
	// block's size - block_offset (i.e., the remaining space until the end of
	// the block).
	Length *int32 `protobuf:"varint,2,opt,name=length" json:"length,omitempty"`
	// Offset into the extent that contains the data for this region.
	ExtentOffset *int32 `protobuf:"varint,3,opt,name=extent_offset,json=extentOffset,def=0" json:"extent_offset,omitempty"`
	// Extent id corresponding to this region. Before writing this extent_id to
	// the backend, the Medusa library can choose to uncanonicalize it.  That
	// is, get rid of the owner_id if it's clear from the context what the
	// owner id should be. For dedup'd extents, the owner id is the container
	// id to which the vdisk is assigned to. For non-dedup'd extents, the owner
	// id is the vdisk id itself (unless the extent is owned by a snapshot
	// parent of this vdisk). The curator might have gotten rid of that parent
	// vdisk's block map, but may have copied its extents to the corresponding
	// children created due to snapshots. Such extents are essentially regarded
	// as copy-on-write. Note that consumers of the Medusa library always see
	// canonicalized extents.
	//
	// If no extent_id is specified, it implies this region consists of
	// zeros.
	ExtentId *ExtentIdProto `protobuf:"bytes,4,opt,name=extent_id,json=extentId" json:"extent_id,omitempty"`
	// Extent group that contains the above extent id. This is only stored for
	// non-dedup'd extent ids.
	ExtentGroupId *int64 `protobuf:"varint,5,opt,name=extent_group_id,json=extentGroupId" json:"extent_group_id,omitempty"`
	// If 'invalid' is true, this region does not describe data or its
	// location. Instead, the range is inherited from the parent. Ancestor
	// vblock(s) may resolve this range to an extent, or to zeros. If there is
	// no parent, or none of the ancestors' vblocks describe a range, it is
	// assumed to have zeros. This flag will only be set if the block that
	// contains it has its 'incomplete' field set to true.
	Invalid *bool `protobuf:"varint,6,opt,name=invalid,def=0" json:"invalid,omitempty"`
	// If true, it indicates that the region is nullified. The region will no
	// longer serve any data nor it is inherited by any descedant. A read on
	// this region should not be encountered by Stargate while traversing up
	// the descendants unless there is a stale cache Medusa entry.
	// Alternatively, if the whole block no longer serves any data, we set the
	// block entry as 'nullified' instead of individual regions. Note that
	// we'll never set 'nullified' both at block level and region level for the
	// same vdisk block.
	Nullified            *bool    `protobuf:"varint,7,opt,name=nullified,def=0" json:"nullified,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MedusaVDiskBlockMapEntryProto_Region) Reset()         { *m = MedusaVDiskBlockMapEntryProto_Region{} }
func (m *MedusaVDiskBlockMapEntryProto_Region) String() string { return proto.CompactTextString(m) }
func (*MedusaVDiskBlockMapEntryProto_Region) ProtoMessage()    {}
func (*MedusaVDiskBlockMapEntryProto_Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_823cefe977c2a876, []int{0, 0}
}

func (m *MedusaVDiskBlockMapEntryProto_Region) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto_Region.Unmarshal(m, b)
}
func (m *MedusaVDiskBlockMapEntryProto_Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto_Region.Marshal(b, m, deterministic)
}
func (m *MedusaVDiskBlockMapEntryProto_Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MedusaVDiskBlockMapEntryProto_Region.Merge(m, src)
}
func (m *MedusaVDiskBlockMapEntryProto_Region) XXX_Size() int {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto_Region.Size(m)
}
func (m *MedusaVDiskBlockMapEntryProto_Region) XXX_DiscardUnknown() {
	xxx_messageInfo_MedusaVDiskBlockMapEntryProto_Region.DiscardUnknown(m)
}

var xxx_messageInfo_MedusaVDiskBlockMapEntryProto_Region proto.InternalMessageInfo

const Default_MedusaVDiskBlockMapEntryProto_Region_ExtentOffset int32 = 0
const Default_MedusaVDiskBlockMapEntryProto_Region_Invalid bool = false
const Default_MedusaVDiskBlockMapEntryProto_Region_Nullified bool = false

func (m *MedusaVDiskBlockMapEntryProto_Region) GetBlockOffset() int32 {
	if m != nil && m.BlockOffset != nil {
		return *m.BlockOffset
	}
	return 0
}

func (m *MedusaVDiskBlockMapEntryProto_Region) GetLength() int32 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *MedusaVDiskBlockMapEntryProto_Region) GetExtentOffset() int32 {
	if m != nil && m.ExtentOffset != nil {
		return *m.ExtentOffset
	}
	return Default_MedusaVDiskBlockMapEntryProto_Region_ExtentOffset
}

func (m *MedusaVDiskBlockMapEntryProto_Region) GetExtentId() *ExtentIdProto {
	if m != nil {
		return m.ExtentId
	}
	return nil
}

func (m *MedusaVDiskBlockMapEntryProto_Region) GetExtentGroupId() int64 {
	if m != nil && m.ExtentGroupId != nil {
		return *m.ExtentGroupId
	}
	return 0
}

func (m *MedusaVDiskBlockMapEntryProto_Region) GetInvalid() bool {
	if m != nil && m.Invalid != nil {
		return *m.Invalid
	}
	return Default_MedusaVDiskBlockMapEntryProto_Region_Invalid
}

func (m *MedusaVDiskBlockMapEntryProto_Region) GetNullified() bool {
	if m != nil && m.Nullified != nil {
		return *m.Nullified
	}
	return Default_MedusaVDiskBlockMapEntryProto_Region_Nullified
}

// Information describing a merged vblock.
// Merged vblock contains the merge of vblocks of 'merged_upto_vdisk_id'
// vdisk and all its ancestors. It also records the vdisk_id of a descendent
// vdisk, 'last_mutator_vdisk_id', which may have a user write after
// 'merged_upto_vdisk_id'. It is guaranteed that no other descendent on the
// same sub-chain has a user write. A sub-chain is a straight-line lineage of
// vdisks having the same 'snapshot_chain_id'.
type MedusaVDiskBlockMapEntryProto_MergedVBlock struct {
	MergedUptoVdiskId    *int64   `protobuf:"varint,1,opt,name=merged_upto_vdisk_id,json=mergedUptoVdiskId" json:"merged_upto_vdisk_id,omitempty"`
	LastMutatorVdiskId   *int64   `protobuf:"varint,2,opt,name=last_mutator_vdisk_id,json=lastMutatorVdiskId" json:"last_mutator_vdisk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) Reset() {
	*m = MedusaVDiskBlockMapEntryProto_MergedVBlock{}
}
func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) String() string {
	return proto.CompactTextString(m)
}
func (*MedusaVDiskBlockMapEntryProto_MergedVBlock) ProtoMessage() {}
func (*MedusaVDiskBlockMapEntryProto_MergedVBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_823cefe977c2a876, []int{0, 1}
}

func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto_MergedVBlock.Unmarshal(m, b)
}
func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto_MergedVBlock.Marshal(b, m, deterministic)
}
func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MedusaVDiskBlockMapEntryProto_MergedVBlock.Merge(m, src)
}
func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) XXX_Size() int {
	return xxx_messageInfo_MedusaVDiskBlockMapEntryProto_MergedVBlock.Size(m)
}
func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_MedusaVDiskBlockMapEntryProto_MergedVBlock.DiscardUnknown(m)
}

var xxx_messageInfo_MedusaVDiskBlockMapEntryProto_MergedVBlock proto.InternalMessageInfo

func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) GetMergedUptoVdiskId() int64 {
	if m != nil && m.MergedUptoVdiskId != nil {
		return *m.MergedUptoVdiskId
	}
	return 0
}

func (m *MedusaVDiskBlockMapEntryProto_MergedVBlock) GetLastMutatorVdiskId() int64 {
	if m != nil && m.LastMutatorVdiskId != nil {
		return *m.LastMutatorVdiskId
	}
	return 0
}

func init() {
	proto.RegisterType((*MedusaVDiskBlockMapEntryProto)(nil), "nutanix.medusa.MedusaVDiskBlockMapEntryProto")
	proto.RegisterType((*MedusaVDiskBlockMapEntryProto_Region)(nil), "nutanix.medusa.MedusaVDiskBlockMapEntryProto.Region")
	proto.RegisterType((*MedusaVDiskBlockMapEntryProto_MergedVBlock)(nil), "nutanix.medusa.MedusaVDiskBlockMapEntryProto.MergedVBlock")
}

func init() { proto.RegisterFile("medusa/vdisk_block_map.proto", fileDescriptor_823cefe977c2a876) }

var fileDescriptor_823cefe977c2a876 = []byte{
	// 542 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0x5f, 0x6b, 0x13, 0x4f,
	0x14, 0x65, 0x37, 0x4d, 0xd2, 0xde, 0xa4, 0xfd, 0xf1, 0x1b, 0x6c, 0x58, 0x42, 0x83, 0xab, 0xc5,
	0xb2, 0x3e, 0xb8, 0xb1, 0x41, 0x11, 0xf6, 0x31, 0xb6, 0x48, 0xc0, 0x58, 0x19, 0x68, 0x1e, 0x7c,
	0x59, 0xc6, 0xdd, 0x49, 0x1c, 0x32, 0xbb, 0xb3, 0xec, 0xcc, 0x86, 0xea, 0xf7, 0xf0, 0x5b, 0xfa,
	0x21, 0x64, 0xfe, 0xa4, 0x49, 0x2b, 0x08, 0x3e, 0xce, 0x39, 0xe7, 0xde, 0x3b, 0xf7, 0xdc, 0x03,
	0x67, 0x05, 0xcd, 0x1b, 0x49, 0xc6, 0x9b, 0x9c, 0xc9, 0x75, 0xfa, 0x95, 0x8b, 0x6c, 0x9d, 0x16,
	0xa4, 0x8a, 0xab, 0x5a, 0x28, 0x81, 0x4e, 0xca, 0x46, 0x91, 0x92, 0xdd, 0xc5, 0x56, 0x35, 0x1c,
	0x38, 0x35, 0xbd, 0x53, 0xb4, 0x54, 0x29, 0xcb, 0xad, 0x6e, 0x78, 0xf2, 0x83, 0x36, 0x72, 0xcc,
	0x45, 0x66, 0xdf, 0xcf, 0x7f, 0x75, 0x60, 0x34, 0x37, 0xd2, 0xc5, 0x15, 0x93, 0xeb, 0xa9, 0x6e,
	0x3b, 0x27, 0xd5, 0x75, 0xa9, 0xea, 0xef, 0x9f, 0x4d, 0xe7, 0x4f, 0xd0, 0xad, 0xe9, 0x8a, 0x89,
	0x52, 0x06, 0x5e, 0xd8, 0x8a, 0x7a, 0x93, 0x37, 0xf1, 0xc3, 0x59, 0xf1, 0x5f, 0xeb, 0x63, 0x6c,
	0x8a, 0xf1, 0xb6, 0x09, 0x1a, 0x01, 0x28, 0x56, 0xd0, 0xb4, 0x91, 0x34, 0x93, 0x81, 0x1f, 0xfa,
	0x51, 0x0b, 0x1f, 0x69, 0xe4, 0x56, 0x03, 0xe8, 0x1d, 0x1c, 0x70, 0x91, 0xc9, 0xa0, 0x65, 0x66,
	0x9d, 0xdf, 0xcf, 0xd2, 0xff, 0x8e, 0x3f, 0x8a, 0x15, 0xcb, 0x08, 0xbf, 0xa9, 0x68, 0x4d, 0x14,
	0x13, 0xe5, 0x7b, 0x3d, 0x0e, 0x9b, 0x02, 0x94, 0xc0, 0x90, 0x13, 0xa9, 0xd2, 0x9c, 0x28, 0x92,
	0x16, 0x8d, 0x22, 0x4a, 0xd4, 0xa9, 0x35, 0x8b, 0xe5, 0xc1, 0x41, 0xe8, 0x45, 0x2d, 0x3c, 0xd0,
	0x8a, 0x2b, 0xa2, 0xc8, 0xdc, 0xf2, 0x0b, 0x4d, 0xcf, 0x72, 0xf4, 0x02, 0x80, 0x95, 0x99, 0x28,
	0x2a, 0x4e, 0x15, 0x0d, 0xda, 0xa1, 0x17, 0x1d, 0x26, 0xed, 0x25, 0xe1, 0x92, 0xe2, 0x3d, 0x02,
	0x9d, 0xc1, 0x51, 0xd9, 0x70, 0xce, 0x96, 0x8c, 0xe6, 0x41, 0x47, 0xab, 0xf0, 0x0e, 0x40, 0x29,
	0x1c, 0x17, 0xb4, 0x5e, 0xd1, 0x3c, 0xdd, 0x98, 0xeb, 0x04, 0xdd, 0xd0, 0x8b, 0x7a, 0x93, 0xe4,
	0xdf, 0xec, 0x9a, 0x9b, 0x16, 0x0b, 0xc3, 0xe0, 0xbe, 0x6d, 0xb8, 0x30, 0xfd, 0xd0, 0x5b, 0x38,
	0x75, 0x03, 0x9a, 0x52, 0x31, 0xbe, 0x5b, 0xee, 0x50, 0x2f, 0x97, 0xf8, 0xaf, 0x2e, 0x31, 0xb2,
	0x82, 0x5b, 0xcd, 0xbb, 0xe5, 0x86, 0x3f, 0x7d, 0xe8, 0xd8, 0x23, 0xa0, 0x67, 0xd0, 0xb7, 0xc1,
	0x11, 0xcb, 0xa5, 0xa4, 0x2a, 0xf0, 0x42, 0x2f, 0x6a, 0xe3, 0x9e, 0xc1, 0x6e, 0x0c, 0x84, 0x06,
	0xd0, 0xe1, 0xb4, 0x5c, 0xa9, 0x6f, 0x81, 0x6f, 0x48, 0xf7, 0x42, 0x17, 0x70, 0xec, 0xb2, 0xe4,
	0x6a, 0x5b, 0x9a, 0x4e, 0xbc, 0xd7, 0xb8, 0x6f, 0x71, 0x57, 0x9f, 0xc0, 0xd1, 0x7d, 0xe6, 0x8c,
	0xeb, 0xbd, 0xc9, 0xe8, 0xb1, 0x03, 0xd7, 0x46, 0x30, 0xcb, 0xcd, 0xc6, 0xf8, 0x90, 0xba, 0x27,
	0xba, 0x80, 0xff, 0x5c, 0xed, 0xaa, 0x16, 0x4d, 0xa5, 0x3b, 0xb4, 0xcd, 0xdd, 0xdc, 0xe8, 0x0f,
	0x1a, 0x9d, 0xe5, 0xe8, 0x29, 0x74, 0x59, 0xb9, 0x21, 0x9c, 0xb9, 0x2b, 0x6c, 0x6f, 0xb5, 0x45,
	0xd1, 0xf9, 0xfe, 0xa1, 0xba, 0xfb, 0x92, 0x1d, 0x3e, 0xac, 0xa1, 0xbf, 0x6f, 0x36, 0x1a, 0xc3,
	0x93, 0xad, 0xbd, 0x95, 0x12, 0x3b, 0x77, 0x3d, 0xf3, 0x85, 0xff, 0x9d, 0xb3, 0x95, 0x12, 0xdb,
	0xd4, 0x5c, 0xc2, 0xa9, 0x49, 0xdc, 0x1f, 0x61, 0xf3, 0x4d, 0x05, 0xd2, 0xe4, 0xc3, 0xa0, 0x4d,
	0x5f, 0x02, 0xca, 0x44, 0xf1, 0xc8, 0x8f, 0x69, 0xcf, 0xfe, 0xc0, 0xd8, 0xf1, 0xa5, 0x63, 0xc1,
	0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x25, 0x3f, 0x2a, 0x9f, 0xf0, 0x03, 0x00, 0x00,
}
