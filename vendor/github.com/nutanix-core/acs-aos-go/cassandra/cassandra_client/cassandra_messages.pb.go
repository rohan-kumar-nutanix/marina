// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cassandra/cassandra_client/cassandra_messages.proto

package util_cassandra

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DeltaScanError_Type int32

const (
	// Delta scan was successful.
	DeltaScanError_kNoError DeltaScanError_Type = 0
	// Error to be returned to client before any RPCs are made to start the
	// delta scan. This error means that no scan has been done as part of a
	// delta scan yet.
	DeltaScanError_kNotInitialized DeltaScanError_Type = 1
	// The primary leader for scan in Cassandra is not in leader only read mode
	// and the scan is a normal quorum based range scan.
	DeltaScanError_kNoErrorNotInLeaderOnlyReadMode DeltaScanError_Type = 2
	// Delta scan is successful, but the result contains more data than a true
	// delta scan. Lets say the client has requested data from snapshot 10,
	// the delta scan might include data from snapshots older than 10 but not
	// include all the older snapshots.
	DeltaScanError_kNoErrorNotDeltaScan DeltaScanError_Type = 3
	// Delta scan cannot be done as Cassandra ring has changed.
	DeltaScanError_kCassandraRingChanged DeltaScanError_Type = 4
	// Delta scan cannot be done because snapshot information is not available
	// right now. Snapshot is enabled in Cassandra.
	DeltaScanError_kRetryDeltaScan DeltaScanError_Type = 5
	// Delta scans are disabled as snapshots are disabled in Cassandra.
	DeltaScanError_kDeltaScanDisabled DeltaScanError_Type = 6
)

var DeltaScanError_Type_name = map[int32]string{
	0: "kNoError",
	1: "kNotInitialized",
	2: "kNoErrorNotInLeaderOnlyReadMode",
	3: "kNoErrorNotDeltaScan",
	4: "kCassandraRingChanged",
	5: "kRetryDeltaScan",
	6: "kDeltaScanDisabled",
}

var DeltaScanError_Type_value = map[string]int32{
	"kNoError":                        0,
	"kNotInitialized":                 1,
	"kNoErrorNotInLeaderOnlyReadMode": 2,
	"kNoErrorNotDeltaScan":            3,
	"kCassandraRingChanged":           4,
	"kRetryDeltaScan":                 5,
	"kDeltaScanDisabled":              6,
}

func (x DeltaScanError_Type) Enum() *DeltaScanError_Type {
	p := new(DeltaScanError_Type)
	*p = x
	return p
}

func (x DeltaScanError_Type) String() string {
	return proto.EnumName(DeltaScanError_Type_name, int32(x))
}

func (x *DeltaScanError_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DeltaScanError_Type_value, data, "DeltaScanError_Type")
	if err != nil {
		return err
	}
	*x = DeltaScanError_Type(value)
	return nil
}

func (DeltaScanError_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9e9c024c6cb6194a, []int{2, 0}
}

// Cassandra scan cookie used to enable stateful scans.
type CassandraScanCookie struct {
	// Cassandra paxos leader's unique node id which set up the scan cookie.
	NodeId *int64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,def=-1" json:"node_id,omitempty"`
	// Key for the cookie used by the Paxos Leader.
	CookieKey *int64 `protobuf:"varint,2,opt,name=cookie_key,json=cookieKey,def=-1" json:"cookie_key,omitempty"`
	// Indicates whether the active memtable for the CF when the first scan RPC
	// was received at Paxos Leader has been flushed as SSTable or not.
	FirstMemtableFlushDone *bool    `protobuf:"varint,3,opt,name=first_memtable_flush_done,json=firstMemtableFlushDone,def=0" json:"first_memtable_flush_done,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *CassandraScanCookie) Reset()         { *m = CassandraScanCookie{} }
func (m *CassandraScanCookie) String() string { return proto.CompactTextString(m) }
func (*CassandraScanCookie) ProtoMessage()    {}
func (*CassandraScanCookie) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e9c024c6cb6194a, []int{0}
}

func (m *CassandraScanCookie) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CassandraScanCookie.Unmarshal(m, b)
}
func (m *CassandraScanCookie) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CassandraScanCookie.Marshal(b, m, deterministic)
}
func (m *CassandraScanCookie) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CassandraScanCookie.Merge(m, src)
}
func (m *CassandraScanCookie) XXX_Size() int {
	return xxx_messageInfo_CassandraScanCookie.Size(m)
}
func (m *CassandraScanCookie) XXX_DiscardUnknown() {
	xxx_messageInfo_CassandraScanCookie.DiscardUnknown(m)
}

var xxx_messageInfo_CassandraScanCookie proto.InternalMessageInfo

const Default_CassandraScanCookie_NodeId int64 = -1
const Default_CassandraScanCookie_CookieKey int64 = -1
const Default_CassandraScanCookie_FirstMemtableFlushDone bool = false

func (m *CassandraScanCookie) GetNodeId() int64 {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return Default_CassandraScanCookie_NodeId
}

func (m *CassandraScanCookie) GetCookieKey() int64 {
	if m != nil && m.CookieKey != nil {
		return *m.CookieKey
	}
	return Default_CassandraScanCookie_CookieKey
}

func (m *CassandraScanCookie) GetFirstMemtableFlushDone() bool {
	if m != nil && m.FirstMemtableFlushDone != nil {
		return *m.FirstMemtableFlushDone
	}
	return Default_CassandraScanCookie_FirstMemtableFlushDone
}

// SVM id to snapshot id mapping.
type CassandraNodeSnapshotInfo struct {
	// The svm id of the node.
	SvmId *int64 `protobuf:"varint,1,opt,name=svm_id,json=svmId" json:"svm_id,omitempty"`
	// Last successful snapshot id known for node 'svm_id'
	LastSuccessfulSnapshotId *int64   `protobuf:"varint,2,opt,name=last_successful_snapshot_id,json=lastSuccessfulSnapshotId" json:"last_successful_snapshot_id,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *CassandraNodeSnapshotInfo) Reset()         { *m = CassandraNodeSnapshotInfo{} }
func (m *CassandraNodeSnapshotInfo) String() string { return proto.CompactTextString(m) }
func (*CassandraNodeSnapshotInfo) ProtoMessage()    {}
func (*CassandraNodeSnapshotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e9c024c6cb6194a, []int{1}
}

func (m *CassandraNodeSnapshotInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CassandraNodeSnapshotInfo.Unmarshal(m, b)
}
func (m *CassandraNodeSnapshotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CassandraNodeSnapshotInfo.Marshal(b, m, deterministic)
}
func (m *CassandraNodeSnapshotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CassandraNodeSnapshotInfo.Merge(m, src)
}
func (m *CassandraNodeSnapshotInfo) XXX_Size() int {
	return xxx_messageInfo_CassandraNodeSnapshotInfo.Size(m)
}
func (m *CassandraNodeSnapshotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CassandraNodeSnapshotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CassandraNodeSnapshotInfo proto.InternalMessageInfo

func (m *CassandraNodeSnapshotInfo) GetSvmId() int64 {
	if m != nil && m.SvmId != nil {
		return *m.SvmId
	}
	return 0
}

func (m *CassandraNodeSnapshotInfo) GetLastSuccessfulSnapshotId() int64 {
	if m != nil && m.LastSuccessfulSnapshotId != nil {
		return *m.LastSuccessfulSnapshotId
	}
	return 0
}

// Error codes for delta scans.
type DeltaScanError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeltaScanError) Reset()         { *m = DeltaScanError{} }
func (m *DeltaScanError) String() string { return proto.CompactTextString(m) }
func (*DeltaScanError) ProtoMessage()    {}
func (*DeltaScanError) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e9c024c6cb6194a, []int{2}
}

func (m *DeltaScanError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeltaScanError.Unmarshal(m, b)
}
func (m *DeltaScanError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeltaScanError.Marshal(b, m, deterministic)
}
func (m *DeltaScanError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeltaScanError.Merge(m, src)
}
func (m *DeltaScanError) XXX_Size() int {
	return xxx_messageInfo_DeltaScanError.Size(m)
}
func (m *DeltaScanError) XXX_DiscardUnknown() {
	xxx_messageInfo_DeltaScanError.DiscardUnknown(m)
}

var xxx_messageInfo_DeltaScanError proto.InternalMessageInfo

// Proto message for range slice command message exchanged between two
// Cassandra nodes.
type RangeSliceCommandProto struct {
	// Optional cookie for cookie based scans.
	RangeScanCookie *CassandraScanCookie `protobuf:"bytes,1,opt,name=range_scan_cookie,json=rangeScanCookie" json:"range_scan_cookie,omitempty"`
	// Optional node snapshot information for delta scans. The scan may not
	// return values written before the snapshot ids specified below.
	// The daemon uses this as a guideline but may choose to send some data that
	// is older than the info encoded here.
	SnapshotInfoForNodes []*CassandraNodeSnapshotInfo `protobuf:"bytes,2,rep,name=snapshot_info_for_nodes,json=snapshotInfoForNodes" json:"snapshot_info_for_nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *RangeSliceCommandProto) Reset()         { *m = RangeSliceCommandProto{} }
func (m *RangeSliceCommandProto) String() string { return proto.CompactTextString(m) }
func (*RangeSliceCommandProto) ProtoMessage()    {}
func (*RangeSliceCommandProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e9c024c6cb6194a, []int{3}
}

func (m *RangeSliceCommandProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RangeSliceCommandProto.Unmarshal(m, b)
}
func (m *RangeSliceCommandProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RangeSliceCommandProto.Marshal(b, m, deterministic)
}
func (m *RangeSliceCommandProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeSliceCommandProto.Merge(m, src)
}
func (m *RangeSliceCommandProto) XXX_Size() int {
	return xxx_messageInfo_RangeSliceCommandProto.Size(m)
}
func (m *RangeSliceCommandProto) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeSliceCommandProto.DiscardUnknown(m)
}

var xxx_messageInfo_RangeSliceCommandProto proto.InternalMessageInfo

func (m *RangeSliceCommandProto) GetRangeScanCookie() *CassandraScanCookie {
	if m != nil {
		return m.RangeScanCookie
	}
	return nil
}

func (m *RangeSliceCommandProto) GetSnapshotInfoForNodes() []*CassandraNodeSnapshotInfo {
	if m != nil {
		return m.SnapshotInfoForNodes
	}
	return nil
}

// Proto message for range slice reply for an earlier sent range slice
// command between two Cassandra nodes.
type RangeSliceReplyProto struct {
	RangeScanCookie *CassandraScanCookie `protobuf:"bytes,1,opt,name=range_scan_cookie,json=rangeScanCookie" json:"range_scan_cookie,omitempty"`
	// When true indicates that leader or replica response for the delta scan
	// includes data from invalid snapshot id SSTable. This must be used only
	// when 'snapshot_info_for_nodes' in RangeSliceCommandProto is valid.
	ResponseIncludesDataFromInvalidSnapshotId *bool    `protobuf:"varint,2,opt,name=response_includes_data_from_invalid_snapshot_id,json=responseIncludesDataFromInvalidSnapshotId,def=0" json:"response_includes_data_from_invalid_snapshot_id,omitempty"`
	XXX_NoUnkeyedLiteral                      struct{} `json:"-"`
	XXX_unrecognized                          []byte   `json:"-"`
	XXX_sizecache                             int32    `json:"-"`
}

func (m *RangeSliceReplyProto) Reset()         { *m = RangeSliceReplyProto{} }
func (m *RangeSliceReplyProto) String() string { return proto.CompactTextString(m) }
func (*RangeSliceReplyProto) ProtoMessage()    {}
func (*RangeSliceReplyProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_9e9c024c6cb6194a, []int{4}
}

func (m *RangeSliceReplyProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RangeSliceReplyProto.Unmarshal(m, b)
}
func (m *RangeSliceReplyProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RangeSliceReplyProto.Marshal(b, m, deterministic)
}
func (m *RangeSliceReplyProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeSliceReplyProto.Merge(m, src)
}
func (m *RangeSliceReplyProto) XXX_Size() int {
	return xxx_messageInfo_RangeSliceReplyProto.Size(m)
}
func (m *RangeSliceReplyProto) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeSliceReplyProto.DiscardUnknown(m)
}

var xxx_messageInfo_RangeSliceReplyProto proto.InternalMessageInfo

const Default_RangeSliceReplyProto_ResponseIncludesDataFromInvalidSnapshotId bool = false

func (m *RangeSliceReplyProto) GetRangeScanCookie() *CassandraScanCookie {
	if m != nil {
		return m.RangeScanCookie
	}
	return nil
}

func (m *RangeSliceReplyProto) GetResponseIncludesDataFromInvalidSnapshotId() bool {
	if m != nil && m.ResponseIncludesDataFromInvalidSnapshotId != nil {
		return *m.ResponseIncludesDataFromInvalidSnapshotId
	}
	return Default_RangeSliceReplyProto_ResponseIncludesDataFromInvalidSnapshotId
}

func init() {
	proto.RegisterEnum("nutanix.cassandra.DeltaScanError_Type", DeltaScanError_Type_name, DeltaScanError_Type_value)
	proto.RegisterType((*CassandraScanCookie)(nil), "nutanix.cassandra.CassandraScanCookie")
	proto.RegisterType((*CassandraNodeSnapshotInfo)(nil), "nutanix.cassandra.CassandraNodeSnapshotInfo")
	proto.RegisterType((*DeltaScanError)(nil), "nutanix.cassandra.DeltaScanError")
	proto.RegisterType((*RangeSliceCommandProto)(nil), "nutanix.cassandra.RangeSliceCommandProto")
	proto.RegisterType((*RangeSliceReplyProto)(nil), "nutanix.cassandra.RangeSliceReplyProto")
}

func init() {
	proto.RegisterFile("cassandra/cassandra_client/cassandra_messages.proto", fileDescriptor_9e9c024c6cb6194a)
}

var fileDescriptor_9e9c024c6cb6194a = []byte{
	// 551 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x93, 0xcf, 0x6e, 0x13, 0x3f,
	0x10, 0xc7, 0x7f, 0x9b, 0xb4, 0xfd, 0x15, 0x17, 0xb5, 0x5b, 0xf7, 0x0f, 0x5b, 0xf5, 0x40, 0x59,
	0x24, 0x54, 0x24, 0x48, 0x45, 0xb9, 0x55, 0x42, 0x42, 0x4d, 0xa8, 0x14, 0x41, 0x0b, 0x72, 0x38,
	0x71, 0xb1, 0xcc, 0x7a, 0xb6, 0xb5, 0xd6, 0x6b, 0x07, 0x8f, 0xb7, 0x62, 0x79, 0x11, 0x5e, 0x83,
	0x77, 0xe0, 0x09, 0x38, 0xf0, 0x3e, 0x68, 0x37, 0x89, 0x13, 0x11, 0xc4, 0x8d, 0xdb, 0x7a, 0xe6,
	0x33, 0xe3, 0xef, 0x8c, 0xbf, 0x4b, 0x9e, 0x67, 0x02, 0x51, 0x18, 0xe9, 0xc4, 0x49, 0xf8, 0xe2,
	0x99, 0x56, 0x60, 0xfc, 0x42, 0xa0, 0x04, 0x44, 0x71, 0x0d, 0xd8, 0x1b, 0x3b, 0xeb, 0x2d, 0xdd,
	0x36, 0x95, 0x17, 0x46, 0x7d, 0xee, 0x05, 0x22, 0xfd, 0x1a, 0x91, 0x9d, 0xfe, 0xec, 0x34, 0xca,
	0x84, 0xe9, 0x5b, 0x5b, 0x28, 0xa0, 0x87, 0xe4, 0x7f, 0x63, 0x25, 0x70, 0x25, 0x93, 0xe8, 0x28,
	0x3a, 0xee, 0x9e, 0x75, 0x9e, 0x3e, 0x63, 0x6b, 0x4d, 0x68, 0x28, 0xe9, 0x03, 0x42, 0xb2, 0x16,
	0xe3, 0x05, 0xd4, 0x49, 0x27, 0xe4, 0xef, 0x4c, 0xa2, 0xaf, 0xa1, 0xa6, 0x2f, 0xc9, 0x41, 0xae,
	0x1c, 0x7a, 0x5e, 0x42, 0xe9, 0xc5, 0x47, 0x0d, 0x3c, 0xd7, 0x15, 0xde, 0x70, 0x69, 0x0d, 0x24,
	0xdd, 0xa3, 0xe8, 0x78, 0xfd, 0x6c, 0x35, 0x17, 0x1a, 0x81, 0xed, 0xb7, 0xdc, 0xe5, 0x14, 0xbb,
	0x68, 0xa8, 0x81, 0x35, 0x90, 0x7e, 0x22, 0x07, 0x41, 0xd8, 0x95, 0x95, 0x30, 0x32, 0x62, 0x8c,
	0x37, 0xd6, 0x0f, 0x4d, 0x6e, 0xe9, 0x1e, 0x59, 0xc3, 0xdb, 0x32, 0xa8, 0x63, 0xab, 0x78, 0x5b,
	0x0e, 0x25, 0x7d, 0x41, 0x0e, 0xb5, 0x40, 0xcf, 0xb1, 0xca, 0x32, 0x40, 0xcc, 0x2b, 0xcd, 0x71,
	0x5a, 0xd6, 0xb0, 0xad, 0x52, 0x96, 0x34, 0xc8, 0x28, 0x10, 0xa1, 0xaf, 0x4c, 0xbf, 0x47, 0x64,
	0x73, 0x00, 0xda, 0xb7, 0x8b, 0x78, 0xe5, 0x9c, 0x75, 0xe9, 0xb7, 0x88, 0xac, 0xbc, 0xaf, 0xc7,
	0x40, 0xef, 0x92, 0xf5, 0xe2, 0xca, 0xb6, 0xc1, 0xf8, 0x3f, 0xba, 0x43, 0xb6, 0x8a, 0xab, 0x46,
	0x8b, 0xf2, 0x4a, 0x68, 0xf5, 0x05, 0x64, 0x1c, 0xd1, 0x87, 0xe4, 0xfe, 0x0c, 0x69, 0x73, 0x6f,
	0x40, 0x48, 0x70, 0x6f, 0x8d, 0xae, 0x19, 0x08, 0x79, 0x69, 0x25, 0xc4, 0x1d, 0x9a, 0x90, 0xdd,
	0x05, 0x28, 0xdc, 0x16, 0x77, 0xe9, 0x01, 0xd9, 0x2b, 0xc2, 0xc4, 0x4c, 0x99, 0xeb, 0xfe, 0x8d,
	0x30, 0xd7, 0x20, 0xe3, 0x95, 0xf6, 0x3a, 0x06, 0xde, 0xd5, 0x73, 0x7e, 0x95, 0xee, 0x13, 0x5a,
	0x84, 0xf3, 0x40, 0x61, 0xb3, 0x3e, 0x19, 0xaf, 0xa5, 0x3f, 0x22, 0xb2, 0xcf, 0x9a, 0xca, 0x91,
	0x56, 0x19, 0xf4, 0x6d, 0x59, 0x0a, 0x23, 0xdf, 0xb5, 0x06, 0x60, 0x64, 0xdb, 0x35, 0x19, 0x8e,
	0x99, 0x30, 0x7c, 0xf2, 0x5a, 0xed, 0x06, 0x37, 0x4e, 0x1f, 0xf5, 0x96, 0xcc, 0xd1, 0xfb, 0x83,
	0x31, 0xd8, 0x56, 0xdb, 0x60, 0xc1, 0x29, 0x19, 0xb9, 0x37, 0xdf, 0xb1, 0xc9, 0x2d, 0xcf, 0xad,
	0xe3, 0x8d, 0x51, 0x30, 0xe9, 0x1c, 0x75, 0x8f, 0x37, 0x4e, 0x9f, 0xfc, 0xad, 0xf3, 0xef, 0x2f,
	0xcb, 0x76, 0x71, 0xe1, 0x74, 0xd1, 0x2c, 0x49, 0x02, 0xa6, 0x3f, 0x23, 0xb2, 0x3b, 0x9f, 0x89,
	0xc1, 0x58, 0xd7, 0xff, 0x6e, 0x22, 0x45, 0x4e, 0x1c, 0xe0, 0xd8, 0x1a, 0x04, 0xae, 0x4c, 0xa6,
	0x2b, 0x09, 0xc8, 0xa5, 0xf0, 0x82, 0xe7, 0xce, 0x96, 0x5c, 0x99, 0x5b, 0xa1, 0x95, 0x5c, 0x72,
	0x56, 0x70, 0xf4, 0xe3, 0x59, 0xf5, 0x70, 0x5a, 0x3c, 0x10, 0x5e, 0x5c, 0x38, 0x5b, 0x0e, 0x27,
	0x95, 0x73, 0xc7, 0x9d, 0x9f, 0x91, 0xbd, 0xcc, 0x96, 0xcb, 0x42, 0xcf, 0xb7, 0x83, 0xd2, 0xcb,
	0xe9, 0x3f, 0xfc, 0x61, 0xb3, 0xf2, 0x4a, 0xcf, 0x91, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4c,
	0x92, 0x5d, 0xc4, 0x03, 0x04, 0x00, 0x00,
}
