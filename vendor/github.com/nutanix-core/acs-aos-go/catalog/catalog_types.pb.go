// Code generated by protoc-gen-go. DO NOT EDIT.
// source: catalog/catalog_types.proto

package catalog

import (
	acropolis "github.com/nutanix-core/acs-aos-go/acropolis"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	net "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/net"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Add the item type for which spec needs to be created on PC during
// migration in gflag catalog_create_spec_item_type_list.
type CatalogItemInfo_CatalogItemType int32

const (
	// Acropolis image.
	CatalogItemInfo_kImage CatalogItemInfo_CatalogItemType = 1
	// Acropolis VM snapshot.
	CatalogItemInfo_kAcropolisVmSnapshot CatalogItemInfo_CatalogItemType = 2
	// VM snapshot (cerebro).
	CatalogItemInfo_kVmSnapshot CatalogItemInfo_CatalogItemType = 3
	// File store item
	CatalogItemInfo_kFile CatalogItemInfo_CatalogItemType = 4
	// LCM module.
	CatalogItemInfo_kLCM CatalogItemInfo_CatalogItemType = 5
	// OVA package.
	CatalogItemInfo_kOVA CatalogItemInfo_CatalogItemType = 6
	// VM Template.
	CatalogItemInfo_kVmTemplate CatalogItemInfo_CatalogItemType = 7
)

var CatalogItemInfo_CatalogItemType_name = map[int32]string{
	1: "kImage",
	2: "kAcropolisVmSnapshot",
	3: "kVmSnapshot",
	4: "kFile",
	5: "kLCM",
	6: "kOVA",
	7: "kVmTemplate",
}

var CatalogItemInfo_CatalogItemType_value = map[string]int32{
	"kImage":               1,
	"kAcropolisVmSnapshot": 2,
	"kVmSnapshot":          3,
	"kFile":                4,
	"kLCM":                 5,
	"kOVA":                 6,
	"kVmTemplate":          7,
}

func (x CatalogItemInfo_CatalogItemType) Enum() *CatalogItemInfo_CatalogItemType {
	p := new(CatalogItemInfo_CatalogItemType)
	*p = x
	return p
}

func (x CatalogItemInfo_CatalogItemType) String() string {
	return proto.EnumName(CatalogItemInfo_CatalogItemType_name, int32(x))
}

func (x *CatalogItemInfo_CatalogItemType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogItemInfo_CatalogItemType_value, data, "CatalogItemInfo_CatalogItemType")
	if err != nil {
		return err
	}
	*x = CatalogItemInfo_CatalogItemType(value)
	return nil
}

func (CatalogItemInfo_CatalogItemType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{1, 0}
}

type FileInfo_ChecksumType int32

const (
	// SHA-1 checksum.
	FileInfo_kSha1 FileInfo_ChecksumType = 1
	// SHA-256 checksum.
	FileInfo_kSha256 FileInfo_ChecksumType = 2
)

var FileInfo_ChecksumType_name = map[int32]string{
	1: "kSha1",
	2: "kSha256",
}

var FileInfo_ChecksumType_value = map[string]int32{
	"kSha1":   1,
	"kSha256": 2,
}

func (x FileInfo_ChecksumType) Enum() *FileInfo_ChecksumType {
	p := new(FileInfo_ChecksumType)
	*p = x
	return p
}

func (x FileInfo_ChecksumType) String() string {
	return proto.EnumName(FileInfo_ChecksumType_name, int32(x))
}

func (x *FileInfo_ChecksumType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FileInfo_ChecksumType_value, data, "FileInfo_ChecksumType")
	if err != nil {
		return err
	}
	*x = FileInfo_ChecksumType(value)
	return nil
}

func (FileInfo_ChecksumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{5, 0}
}

type CatalogItemUpdateSpec_CatalogItemType int32

const (
	// Acropolis image.
	CatalogItemUpdateSpec_kImage CatalogItemUpdateSpec_CatalogItemType = 1
	// Acropolis VM snapshot.
	CatalogItemUpdateSpec_kAcropolisVmSnapshot CatalogItemUpdateSpec_CatalogItemType = 2
	// VM snapshot (cerebro).
	CatalogItemUpdateSpec_kVmSnapshot CatalogItemUpdateSpec_CatalogItemType = 3
	// File store item
	CatalogItemUpdateSpec_kFile CatalogItemUpdateSpec_CatalogItemType = 4
	// LCM module.
	CatalogItemUpdateSpec_kLCM CatalogItemUpdateSpec_CatalogItemType = 5
	// OVA package.
	CatalogItemUpdateSpec_kOVA CatalogItemUpdateSpec_CatalogItemType = 6
)

var CatalogItemUpdateSpec_CatalogItemType_name = map[int32]string{
	1: "kImage",
	2: "kAcropolisVmSnapshot",
	3: "kVmSnapshot",
	4: "kFile",
	5: "kLCM",
	6: "kOVA",
}

var CatalogItemUpdateSpec_CatalogItemType_value = map[string]int32{
	"kImage":               1,
	"kAcropolisVmSnapshot": 2,
	"kVmSnapshot":          3,
	"kFile":                4,
	"kLCM":                 5,
	"kOVA":                 6,
}

func (x CatalogItemUpdateSpec_CatalogItemType) Enum() *CatalogItemUpdateSpec_CatalogItemType {
	p := new(CatalogItemUpdateSpec_CatalogItemType)
	*p = x
	return p
}

func (x CatalogItemUpdateSpec_CatalogItemType) String() string {
	return proto.EnumName(CatalogItemUpdateSpec_CatalogItemType_name, int32(x))
}

func (x *CatalogItemUpdateSpec_CatalogItemType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogItemUpdateSpec_CatalogItemType_value, data, "CatalogItemUpdateSpec_CatalogItemType")
	if err != nil {
		return err
	}
	*x = CatalogItemUpdateSpec_CatalogItemType(value)
	return nil
}

func (CatalogItemUpdateSpec_CatalogItemType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{11, 0}
}

// Entities associated with the task.
type Task_Entity int32

const (
	Task_kCatalogItem            Task_Entity = 1
	Task_kFile                   Task_Entity = 2
	Task_kImage                  Task_Entity = 3
	Task_kCluster                Task_Entity = 4
	Task_kCatalogPlacementPolicy Task_Entity = 5
	Task_kVmTemplate             Task_Entity = 6
	Task_kVmTemplateVersion      Task_Entity = 7
	Task_kCatalogRateLimit       Task_Entity = 8
)

var Task_Entity_name = map[int32]string{
	1: "kCatalogItem",
	2: "kFile",
	3: "kImage",
	4: "kCluster",
	5: "kCatalogPlacementPolicy",
	6: "kVmTemplate",
	7: "kVmTemplateVersion",
	8: "kCatalogRateLimit",
}

var Task_Entity_value = map[string]int32{
	"kCatalogItem":            1,
	"kFile":                   2,
	"kImage":                  3,
	"kCluster":                4,
	"kCatalogPlacementPolicy": 5,
	"kVmTemplate":             6,
	"kVmTemplateVersion":      7,
	"kCatalogRateLimit":       8,
}

func (x Task_Entity) Enum() *Task_Entity {
	p := new(Task_Entity)
	*p = x
	return p
}

func (x Task_Entity) String() string {
	return proto.EnumName(Task_Entity_name, int32(x))
}

func (x *Task_Entity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_Entity_value, data, "Task_Entity")
	if err != nil {
		return err
	}
	*x = Task_Entity(value)
	return nil
}

func (Task_Entity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{16, 0}
}

// Type of operation
type Task_OperationType int32

const (
	Task_kCatalogItemCreate               Task_OperationType = 1
	Task_kCatalogItemUpdate               Task_OperationType = 2
	Task_kCatalogItemDelete               Task_OperationType = 3
	Task_kFileImport                      Task_OperationType = 4
	Task_kForwardImageRpc                 Task_OperationType = 5
	Task_kFileCheckout                    Task_OperationType = 6
	Task_kImageUpload                     Task_OperationType = 7
	Task_kCatalogItemCheckout             Task_OperationType = 8
	Task_kCatalogItemUpload               Task_OperationType = 9
	Task_kCatalogMigratePc                Task_OperationType = 10
	Task_kCatalogMigratePe                Task_OperationType = 11
	Task_kImageCreate                     Task_OperationType = 12
	Task_kImageDelete                     Task_OperationType = 13
	Task_kImageUpdate                     Task_OperationType = 14
	Task_kFileLockCleanup                 Task_OperationType = 15
	Task_kCatalogRemoteSeedingSource      Task_OperationType = 16
	Task_kCatalogRemoteSeedingDestination Task_OperationType = 17
	Task_kCatalogSnapshotReplicateFiles   Task_OperationType = 18
	Task_kCatalogRemoteSeedingCleanup     Task_OperationType = 19
	Task_kCreatePeRemoteSite              Task_OperationType = 20
	Task_kCatalogPlacementPolicyCreate    Task_OperationType = 21
	Task_kCatalogPlacementPolicyUpdate    Task_OperationType = 22
	Task_kCatalogPlacementPolicyDelete    Task_OperationType = 23
	Task_kCatalogItemUncheckout           Task_OperationType = 24
	Task_kImageCheckout                   Task_OperationType = 25
	Task_kCatalogClusterUnregistration    Task_OperationType = 26
	Task_kCatalogItemUnregUpdate          Task_OperationType = 27
	Task_kCatalogClusterRegistration      Task_OperationType = 28
	Task_kCatalogItemRegUpdate            Task_OperationType = 29
	Task_kCatalogRateLimitCreate          Task_OperationType = 30
	Task_kCatalogRateLimitUpdate          Task_OperationType = 31
	Task_kCatalogRateLimitDelete          Task_OperationType = 32
	Task_kVmTemplateVersionsDelete        Task_OperationType = 33
	Task_kVmTemplateVersionRPDelete       Task_OperationType = 34
	Task_kVmTemplateDelete                Task_OperationType = 35
	Task_kVmTemplateCreate                Task_OperationType = 36
	Task_kVmTemplateAndVersionCreate      Task_OperationType = 37
	Task_kVmTemplateVersionCreate         Task_OperationType = 38
)

var Task_OperationType_name = map[int32]string{
	1:  "kCatalogItemCreate",
	2:  "kCatalogItemUpdate",
	3:  "kCatalogItemDelete",
	4:  "kFileImport",
	5:  "kForwardImageRpc",
	6:  "kFileCheckout",
	7:  "kImageUpload",
	8:  "kCatalogItemCheckout",
	9:  "kCatalogItemUpload",
	10: "kCatalogMigratePc",
	11: "kCatalogMigratePe",
	12: "kImageCreate",
	13: "kImageDelete",
	14: "kImageUpdate",
	15: "kFileLockCleanup",
	16: "kCatalogRemoteSeedingSource",
	17: "kCatalogRemoteSeedingDestination",
	18: "kCatalogSnapshotReplicateFiles",
	19: "kCatalogRemoteSeedingCleanup",
	20: "kCreatePeRemoteSite",
	21: "kCatalogPlacementPolicyCreate",
	22: "kCatalogPlacementPolicyUpdate",
	23: "kCatalogPlacementPolicyDelete",
	24: "kCatalogItemUncheckout",
	25: "kImageCheckout",
	26: "kCatalogClusterUnregistration",
	27: "kCatalogItemUnregUpdate",
	28: "kCatalogClusterRegistration",
	29: "kCatalogItemRegUpdate",
	30: "kCatalogRateLimitCreate",
	31: "kCatalogRateLimitUpdate",
	32: "kCatalogRateLimitDelete",
	33: "kVmTemplateVersionsDelete",
	34: "kVmTemplateVersionRPDelete",
	35: "kVmTemplateDelete",
	36: "kVmTemplateCreate",
	37: "kVmTemplateAndVersionCreate",
	38: "kVmTemplateVersionCreate",
}

var Task_OperationType_value = map[string]int32{
	"kCatalogItemCreate":               1,
	"kCatalogItemUpdate":               2,
	"kCatalogItemDelete":               3,
	"kFileImport":                      4,
	"kForwardImageRpc":                 5,
	"kFileCheckout":                    6,
	"kImageUpload":                     7,
	"kCatalogItemCheckout":             8,
	"kCatalogItemUpload":               9,
	"kCatalogMigratePc":                10,
	"kCatalogMigratePe":                11,
	"kImageCreate":                     12,
	"kImageDelete":                     13,
	"kImageUpdate":                     14,
	"kFileLockCleanup":                 15,
	"kCatalogRemoteSeedingSource":      16,
	"kCatalogRemoteSeedingDestination": 17,
	"kCatalogSnapshotReplicateFiles":   18,
	"kCatalogRemoteSeedingCleanup":     19,
	"kCreatePeRemoteSite":              20,
	"kCatalogPlacementPolicyCreate":    21,
	"kCatalogPlacementPolicyUpdate":    22,
	"kCatalogPlacementPolicyDelete":    23,
	"kCatalogItemUncheckout":           24,
	"kImageCheckout":                   25,
	"kCatalogClusterUnregistration":    26,
	"kCatalogItemUnregUpdate":          27,
	"kCatalogClusterRegistration":      28,
	"kCatalogItemRegUpdate":            29,
	"kCatalogRateLimitCreate":          30,
	"kCatalogRateLimitUpdate":          31,
	"kCatalogRateLimitDelete":          32,
	"kVmTemplateVersionsDelete":        33,
	"kVmTemplateVersionRPDelete":       34,
	"kVmTemplateDelete":                35,
	"kVmTemplateCreate":                36,
	"kVmTemplateAndVersionCreate":      37,
	"kVmTemplateVersionCreate":         38,
}

func (x Task_OperationType) Enum() *Task_OperationType {
	p := new(Task_OperationType)
	*p = x
	return p
}

func (x Task_OperationType) String() string {
	return proto.EnumName(Task_OperationType_name, int32(x))
}

func (x *Task_OperationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_OperationType_value, data, "Task_OperationType")
	if err != nil {
		return err
	}
	*x = Task_OperationType(value)
	return nil
}

func (Task_OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{16, 1}
}

// Current status of this task.
type Task_Status int32

const (
	Task_kQueued    Task_Status = 1
	Task_kRunning   Task_Status = 2
	Task_kSucceeded Task_Status = 3
	Task_kAborted   Task_Status = 4
	Task_kFailed    Task_Status = 5
)

var Task_Status_name = map[int32]string{
	1: "kQueued",
	2: "kRunning",
	3: "kSucceeded",
	4: "kAborted",
	5: "kFailed",
}

var Task_Status_value = map[string]int32{
	"kQueued":    1,
	"kRunning":   2,
	"kSucceeded": 3,
	"kAborted":   4,
	"kFailed":    5,
}

func (x Task_Status) Enum() *Task_Status {
	p := new(Task_Status)
	*p = x
	return p
}

func (x Task_Status) String() string {
	return proto.EnumName(Task_Status_name, int32(x))
}

func (x *Task_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_Status_value, data, "Task_Status")
	if err != nil {
		return err
	}
	*x = Task_Status(value)
	return nil
}

func (Task_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{16, 2}
}

type Task_Capability int32

const (
	// This task can be suspended and then subsequently resumed.
	Task_kTaskSuspend Task_Capability = 1
	// This task can be canceled/aborted.
	Task_kTaskCancel Task_Capability = 2
)

var Task_Capability_name = map[int32]string{
	1: "kTaskSuspend",
	2: "kTaskCancel",
}

var Task_Capability_value = map[string]int32{
	"kTaskSuspend": 1,
	"kTaskCancel":  2,
}

func (x Task_Capability) Enum() *Task_Capability {
	p := new(Task_Capability)
	*p = x
	return p
}

func (x Task_Capability) String() string {
	return proto.EnumName(Task_Capability_name, int32(x))
}

func (x *Task_Capability) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_Capability_value, data, "Task_Capability")
	if err != nil {
		return err
	}
	*x = Task_Capability(value)
	return nil
}

func (Task_Capability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{16, 3}
}

// Enum describing the placement type
type CatalogPlacementPolicyInfo_PlacementType int32

const (
	// At least
	CatalogPlacementPolicyInfo_kAtLeast CatalogPlacementPolicyInfo_PlacementType = 1
	// At most
	CatalogPlacementPolicyInfo_kAtMost CatalogPlacementPolicyInfo_PlacementType = 2
	// Exactly
	CatalogPlacementPolicyInfo_kExactly CatalogPlacementPolicyInfo_PlacementType = 3
)

var CatalogPlacementPolicyInfo_PlacementType_name = map[int32]string{
	1: "kAtLeast",
	2: "kAtMost",
	3: "kExactly",
}

var CatalogPlacementPolicyInfo_PlacementType_value = map[string]int32{
	"kAtLeast": 1,
	"kAtMost":  2,
	"kExactly": 3,
}

func (x CatalogPlacementPolicyInfo_PlacementType) Enum() *CatalogPlacementPolicyInfo_PlacementType {
	p := new(CatalogPlacementPolicyInfo_PlacementType)
	*p = x
	return p
}

func (x CatalogPlacementPolicyInfo_PlacementType) String() string {
	return proto.EnumName(CatalogPlacementPolicyInfo_PlacementType_name, int32(x))
}

func (x *CatalogPlacementPolicyInfo_PlacementType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogPlacementPolicyInfo_PlacementType_value, data, "CatalogPlacementPolicyInfo_PlacementType")
	if err != nil {
		return err
	}
	*x = CatalogPlacementPolicyInfo_PlacementType(value)
	return nil
}

func (CatalogPlacementPolicyInfo_PlacementType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{30, 0}
}

// Enum describing the category match type
type CatalogPlacementPolicyCreateSpec_CategoryMatchType int32

const (
	// Must match all cateogries
	CatalogPlacementPolicyCreateSpec_kAll CatalogPlacementPolicyCreateSpec_CategoryMatchType = 1
	// Match any of the given categories
	CatalogPlacementPolicyCreateSpec_kAny CatalogPlacementPolicyCreateSpec_CategoryMatchType = 2
)

var CatalogPlacementPolicyCreateSpec_CategoryMatchType_name = map[int32]string{
	1: "kAll",
	2: "kAny",
}

var CatalogPlacementPolicyCreateSpec_CategoryMatchType_value = map[string]int32{
	"kAll": 1,
	"kAny": 2,
}

func (x CatalogPlacementPolicyCreateSpec_CategoryMatchType) Enum() *CatalogPlacementPolicyCreateSpec_CategoryMatchType {
	p := new(CatalogPlacementPolicyCreateSpec_CategoryMatchType)
	*p = x
	return p
}

func (x CatalogPlacementPolicyCreateSpec_CategoryMatchType) String() string {
	return proto.EnumName(CatalogPlacementPolicyCreateSpec_CategoryMatchType_name, int32(x))
}

func (x *CatalogPlacementPolicyCreateSpec_CategoryMatchType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogPlacementPolicyCreateSpec_CategoryMatchType_value, data, "CatalogPlacementPolicyCreateSpec_CategoryMatchType")
	if err != nil {
		return err
	}
	*x = CatalogPlacementPolicyCreateSpec_CategoryMatchType(value)
	return nil
}

func (CatalogPlacementPolicyCreateSpec_CategoryMatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{31, 0}
}

type CatalogPlacementPolicyStatusInfo_PolicyState int32

const (
	// Compliant state
	CatalogPlacementPolicyStatusInfo_kCompliant CatalogPlacementPolicyStatusInfo_PolicyState = 1
	// Non-Compliant state
	CatalogPlacementPolicyStatusInfo_kNonCompliant CatalogPlacementPolicyStatusInfo_PolicyState = 2
)

var CatalogPlacementPolicyStatusInfo_PolicyState_name = map[int32]string{
	1: "kCompliant",
	2: "kNonCompliant",
}

var CatalogPlacementPolicyStatusInfo_PolicyState_value = map[string]int32{
	"kCompliant":    1,
	"kNonCompliant": 2,
}

func (x CatalogPlacementPolicyStatusInfo_PolicyState) Enum() *CatalogPlacementPolicyStatusInfo_PolicyState {
	p := new(CatalogPlacementPolicyStatusInfo_PolicyState)
	*p = x
	return p
}

func (x CatalogPlacementPolicyStatusInfo_PolicyState) String() string {
	return proto.EnumName(CatalogPlacementPolicyStatusInfo_PolicyState_name, int32(x))
}

func (x *CatalogPlacementPolicyStatusInfo_PolicyState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogPlacementPolicyStatusInfo_PolicyState_value, data, "CatalogPlacementPolicyStatusInfo_PolicyState")
	if err != nil {
		return err
	}
	*x = CatalogPlacementPolicyStatusInfo_PolicyState(value)
	return nil
}

func (CatalogPlacementPolicyStatusInfo_PolicyState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{32, 0}
}

type CatalogPlacementPolicyStatusInfo_PolicyAction int32

const (
	// Policy action Working
	CatalogPlacementPolicyStatusInfo_kEnforcing CatalogPlacementPolicyStatusInfo_PolicyAction = 1
	// Policy action complete
	CatalogPlacementPolicyStatusInfo_kEnforcement_failed CatalogPlacementPolicyStatusInfo_PolicyAction = 2
)

var CatalogPlacementPolicyStatusInfo_PolicyAction_name = map[int32]string{
	1: "kEnforcing",
	2: "kEnforcement_failed",
}

var CatalogPlacementPolicyStatusInfo_PolicyAction_value = map[string]int32{
	"kEnforcing":          1,
	"kEnforcement_failed": 2,
}

func (x CatalogPlacementPolicyStatusInfo_PolicyAction) Enum() *CatalogPlacementPolicyStatusInfo_PolicyAction {
	p := new(CatalogPlacementPolicyStatusInfo_PolicyAction)
	*p = x
	return p
}

func (x CatalogPlacementPolicyStatusInfo_PolicyAction) String() string {
	return proto.EnumName(CatalogPlacementPolicyStatusInfo_PolicyAction_name, int32(x))
}

func (x *CatalogPlacementPolicyStatusInfo_PolicyAction) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogPlacementPolicyStatusInfo_PolicyAction_value, data, "CatalogPlacementPolicyStatusInfo_PolicyAction")
	if err != nil {
		return err
	}
	*x = CatalogPlacementPolicyStatusInfo_PolicyAction(value)
	return nil
}

func (CatalogPlacementPolicyStatusInfo_PolicyAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{32, 1}
}

type CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus int32

const (
	// Policy is actively working.
	CatalogPlacementPolicyStatusInfo_kActive CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus = 1
	// Policy is suspended.
	CatalogPlacementPolicyStatusInfo_kSuspended CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus = 2
)

var CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus_name = map[int32]string{
	1: "kActive",
	2: "kSuspended",
}

var CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus_value = map[string]int32{
	"kActive":    1,
	"kSuspended": 2,
}

func (x CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus) Enum() *CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus {
	p := new(CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus)
	*p = x
	return p
}

func (x CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus) String() string {
	return proto.EnumName(CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus_name, int32(x))
}

func (x *CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus_value, data, "CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus")
	if err != nil {
		return err
	}
	*x = CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus(value)
	return nil
}

func (CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{32, 2}
}

type CatalogRateLimitFilter_CategoryMatchType int32

const (
	// Must match all categories
	CatalogRateLimitFilter_kAll CatalogRateLimitFilter_CategoryMatchType = 1
	// Match any of the given categories
	CatalogRateLimitFilter_kAny CatalogRateLimitFilter_CategoryMatchType = 2
)

var CatalogRateLimitFilter_CategoryMatchType_name = map[int32]string{
	1: "kAll",
	2: "kAny",
}

var CatalogRateLimitFilter_CategoryMatchType_value = map[string]int32{
	"kAll": 1,
	"kAny": 2,
}

func (x CatalogRateLimitFilter_CategoryMatchType) Enum() *CatalogRateLimitFilter_CategoryMatchType {
	p := new(CatalogRateLimitFilter_CategoryMatchType)
	*p = x
	return p
}

func (x CatalogRateLimitFilter_CategoryMatchType) String() string {
	return proto.EnumName(CatalogRateLimitFilter_CategoryMatchType_name, int32(x))
}

func (x *CatalogRateLimitFilter_CategoryMatchType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CatalogRateLimitFilter_CategoryMatchType_value, data, "CatalogRateLimitFilter_CategoryMatchType")
	if err != nil {
		return err
	}
	*x = CatalogRateLimitFilter_CategoryMatchType(value)
	return nil
}

func (CatalogRateLimitFilter_CategoryMatchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{33, 0}
}

// Template version specific info in CatalogItemInfo.
type VmTemplateVersionInfo struct {
	// Template version's associated Recovery point.
	RecoveryPointUuid []byte `protobuf:"bytes,1,opt,name=recovery_point_uuid,json=recoveryPointUuid" json:"recovery_point_uuid,omitempty"`
	// Template version's final VM spec as JSON string.
	VmSpec               *string  `protobuf:"bytes,2,opt,name=vm_spec,json=vmSpec" json:"vm_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmTemplateVersionInfo) Reset()         { *m = VmTemplateVersionInfo{} }
func (m *VmTemplateVersionInfo) String() string { return proto.CompactTextString(m) }
func (*VmTemplateVersionInfo) ProtoMessage()    {}
func (*VmTemplateVersionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{0}
}

func (m *VmTemplateVersionInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmTemplateVersionInfo.Unmarshal(m, b)
}
func (m *VmTemplateVersionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmTemplateVersionInfo.Marshal(b, m, deterministic)
}
func (m *VmTemplateVersionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmTemplateVersionInfo.Merge(m, src)
}
func (m *VmTemplateVersionInfo) XXX_Size() int {
	return xxx_messageInfo_VmTemplateVersionInfo.Size(m)
}
func (m *VmTemplateVersionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmTemplateVersionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmTemplateVersionInfo proto.InternalMessageInfo

func (m *VmTemplateVersionInfo) GetRecoveryPointUuid() []byte {
	if m != nil {
		return m.RecoveryPointUuid
	}
	return nil
}

func (m *VmTemplateVersionInfo) GetVmSpec() string {
	if m != nil && m.VmSpec != nil {
		return *m.VmSpec
	}
	return ""
}

type CatalogItemInfo struct {
	// Catalog item UUID.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Catalog item name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Annotation describing the catalog item.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Catalog item type.
	ItemType *CatalogItemInfo_CatalogItemType `protobuf:"varint,4,opt,name=item_type,json=itemType,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"item_type,omitempty"`
	// Catalog item version.
	Version *int64 `protobuf:"varint,5,opt,name=version" json:"version,omitempty"`
	// Number of copies of the catalog item to maintain. Note that these copies
	// are spread across availability zones/clusters.
	NumberOfCopies *int32 `protobuf:"varint,6,opt,name=number_of_copies,json=numberOfCopies" json:"number_of_copies,omitempty"`
	// Opaque blob that can be used by the consuming service to deploy an entity
	// from a catalog item.
	Opaque []byte `protobuf:"bytes,7,opt,name=opaque" json:"opaque,omitempty"`
	// List of source groups. Each group defines the set of physical bits that
	// need to be grouped together. Catalog service uses this to figure out how
	// to replicate data across availability zones and clusters.
	SourceGroupList []*SourceGroup `protobuf:"bytes,8,rep,name=source_group_list,json=sourceGroupList" json:"source_group_list,omitempty"`
	// The global UUID groups together versions of the same catalog item. A
	// version of a catalog item can be uniquely identified by 'uuid' or by
	// ('global_uuid', 'logical_timestamp'). In addition, this field is used to
	// group together catalog items that exist on other clusters.
	GlobalCatalogItemUuid []byte `protobuf:"bytes,9,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// Human readable version for CatalogItem
	CatalogVersion *CatalogVersion `protobuf:"bytes,10,opt,name=catalog_version,json=catalogVersion" json:"catalog_version,omitempty"`
	// List of locations where the catalog item (metadata) is currently exists.
	// For catalog items with multiple source groups the location of each source
	// group could be different from the catalog item location. This field is
	// strictly maintained by the Catalog and is not exposed via any  mutating
	// API call. Note this field is also different from other attributes on a
	// catalog item in that it can be updated without changing the version of a
	// catalog item. Also, this field should only be set from Xi portal or PC and
	// not on PE.
	LocationList []*CatalogItemInfo_CatalogItemLocation `protobuf:"bytes,11,rep,name=location_list,json=locationList" json:"location_list,omitempty"`
	// Holds uuid of cluster that is allowed to perform CUD operations
	// on this catalog item. For catalog items on PE that are not migrated
	// to PC, this will be the PE uuid. For catalog items on PE that are
	// migrated to PC, this will be the PC uuid.
	OwnerClusterUuid []byte `protobuf:"bytes,12,opt,name=owner_cluster_uuid,json=ownerClusterUuid" json:"owner_cluster_uuid,omitempty"`
	// Source catalog item from which this catalog item was created from.
	// In case of copying catalog items between a pair of PCs we use this
	// field to avoid creating multiple copies of the same catalog item of
	// same version on destination PC. Once the copie'd catalog item gets
	// updated, we erase this field. Since at that point the copied catalog
	// item has divereged and creating another copy of same catalog item
	// again is valid.
	SourceCatalogItemId *CatalogItemId `protobuf:"bytes,13,opt,name=source_catalog_item_id,json=sourceCatalogItemId" json:"source_catalog_item_id,omitempty"`
	// VM template version info.
	VmTemplateVersionInfo *VmTemplateVersionInfo `protobuf:"bytes,14,opt,name=vm_template_version_info,json=vmTemplateVersionInfo" json:"vm_template_version_info,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}               `json:"-"`
	XXX_unrecognized      []byte                 `json:"-"`
	XXX_sizecache         int32                  `json:"-"`
}

func (m *CatalogItemInfo) Reset()         { *m = CatalogItemInfo{} }
func (m *CatalogItemInfo) String() string { return proto.CompactTextString(m) }
func (*CatalogItemInfo) ProtoMessage()    {}
func (*CatalogItemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{1}
}

func (m *CatalogItemInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemInfo.Unmarshal(m, b)
}
func (m *CatalogItemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemInfo.Marshal(b, m, deterministic)
}
func (m *CatalogItemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemInfo.Merge(m, src)
}
func (m *CatalogItemInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogItemInfo.Size(m)
}
func (m *CatalogItemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemInfo proto.InternalMessageInfo

func (m *CatalogItemInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *CatalogItemInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogItemInfo) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *CatalogItemInfo) GetItemType() CatalogItemInfo_CatalogItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return CatalogItemInfo_kImage
}

func (m *CatalogItemInfo) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *CatalogItemInfo) GetNumberOfCopies() int32 {
	if m != nil && m.NumberOfCopies != nil {
		return *m.NumberOfCopies
	}
	return 0
}

func (m *CatalogItemInfo) GetOpaque() []byte {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *CatalogItemInfo) GetSourceGroupList() []*SourceGroup {
	if m != nil {
		return m.SourceGroupList
	}
	return nil
}

func (m *CatalogItemInfo) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogItemInfo) GetCatalogVersion() *CatalogVersion {
	if m != nil {
		return m.CatalogVersion
	}
	return nil
}

func (m *CatalogItemInfo) GetLocationList() []*CatalogItemInfo_CatalogItemLocation {
	if m != nil {
		return m.LocationList
	}
	return nil
}

func (m *CatalogItemInfo) GetOwnerClusterUuid() []byte {
	if m != nil {
		return m.OwnerClusterUuid
	}
	return nil
}

func (m *CatalogItemInfo) GetSourceCatalogItemId() *CatalogItemId {
	if m != nil {
		return m.SourceCatalogItemId
	}
	return nil
}

func (m *CatalogItemInfo) GetVmTemplateVersionInfo() *VmTemplateVersionInfo {
	if m != nil {
		return m.VmTemplateVersionInfo
	}
	return nil
}

type CatalogItemInfo_CatalogItemLocation struct {
	// Cluster UUID.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Availability zone logical id.
	AvailabilityZoneLogicalId *string  `protobuf:"bytes,2,opt,name=availability_zone_logical_id,json=availabilityZoneLogicalId" json:"availability_zone_logical_id,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *CatalogItemInfo_CatalogItemLocation) Reset()         { *m = CatalogItemInfo_CatalogItemLocation{} }
func (m *CatalogItemInfo_CatalogItemLocation) String() string { return proto.CompactTextString(m) }
func (*CatalogItemInfo_CatalogItemLocation) ProtoMessage()    {}
func (*CatalogItemInfo_CatalogItemLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{1, 0}
}

func (m *CatalogItemInfo_CatalogItemLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemInfo_CatalogItemLocation.Unmarshal(m, b)
}
func (m *CatalogItemInfo_CatalogItemLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemInfo_CatalogItemLocation.Marshal(b, m, deterministic)
}
func (m *CatalogItemInfo_CatalogItemLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemInfo_CatalogItemLocation.Merge(m, src)
}
func (m *CatalogItemInfo_CatalogItemLocation) XXX_Size() int {
	return xxx_messageInfo_CatalogItemInfo_CatalogItemLocation.Size(m)
}
func (m *CatalogItemInfo_CatalogItemLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemInfo_CatalogItemLocation.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemInfo_CatalogItemLocation proto.InternalMessageInfo

func (m *CatalogItemInfo_CatalogItemLocation) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *CatalogItemInfo_CatalogItemLocation) GetAvailabilityZoneLogicalId() string {
	if m != nil && m.AvailabilityZoneLogicalId != nil {
		return *m.AvailabilityZoneLogicalId
	}
	return ""
}

type CatalogVersion struct {
	// Name of the product/version of the catalog item.
	ProductName *string `protobuf:"bytes,1,opt,name=product_name,json=productName" json:"product_name,omitempty"`
	// Version string of the catalog item.
	ProductVersion       *string  `protobuf:"bytes,2,opt,name=product_version,json=productVersion" json:"product_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogVersion) Reset()         { *m = CatalogVersion{} }
func (m *CatalogVersion) String() string { return proto.CompactTextString(m) }
func (*CatalogVersion) ProtoMessage()    {}
func (*CatalogVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{2}
}

func (m *CatalogVersion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogVersion.Unmarshal(m, b)
}
func (m *CatalogVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogVersion.Marshal(b, m, deterministic)
}
func (m *CatalogVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogVersion.Merge(m, src)
}
func (m *CatalogVersion) XXX_Size() int {
	return xxx_messageInfo_CatalogVersion.Size(m)
}
func (m *CatalogVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogVersion.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogVersion proto.InternalMessageInfo

func (m *CatalogVersion) GetProductName() string {
	if m != nil && m.ProductName != nil {
		return *m.ProductName
	}
	return ""
}

func (m *CatalogVersion) GetProductVersion() string {
	if m != nil && m.ProductVersion != nil {
		return *m.ProductVersion
	}
	return ""
}

type SourceGroup struct {
	// SourceGroup UUID
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// List of UUIDs pointing at the clusters where this source group must
	// reside.
	ClusterUuidList [][]byte `protobuf:"bytes,2,rep,name=cluster_uuid_list,json=clusterUuidList" json:"cluster_uuid_list,omitempty"`
	// List of logical IDs pointing at the availability zones where this source
	// group must reside.
	AvailabilityZoneLogicalIdList []string `protobuf:"bytes,3,rep,name=availability_zone_logical_id_list,json=availabilityZoneLogicalIdList" json:"availability_zone_logical_id_list,omitempty"`
	// List of sources.
	SourceList           []*Source `protobuf:"bytes,4,rep,name=source_list,json=sourceList" json:"source_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SourceGroup) Reset()         { *m = SourceGroup{} }
func (m *SourceGroup) String() string { return proto.CompactTextString(m) }
func (*SourceGroup) ProtoMessage()    {}
func (*SourceGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{3}
}

func (m *SourceGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SourceGroup.Unmarshal(m, b)
}
func (m *SourceGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SourceGroup.Marshal(b, m, deterministic)
}
func (m *SourceGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceGroup.Merge(m, src)
}
func (m *SourceGroup) XXX_Size() int {
	return xxx_messageInfo_SourceGroup.Size(m)
}
func (m *SourceGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceGroup.DiscardUnknown(m)
}

var xxx_messageInfo_SourceGroup proto.InternalMessageInfo

func (m *SourceGroup) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SourceGroup) GetClusterUuidList() [][]byte {
	if m != nil {
		return m.ClusterUuidList
	}
	return nil
}

func (m *SourceGroup) GetAvailabilityZoneLogicalIdList() []string {
	if m != nil {
		return m.AvailabilityZoneLogicalIdList
	}
	return nil
}

func (m *SourceGroup) GetSourceList() []*Source {
	if m != nil {
		return m.SourceList
	}
	return nil
}

type Source struct {
	// UUID pointing at a child catalog item.
	CatalogItemUuid []byte `protobuf:"bytes,1,opt,name=catalog_item_uuid,json=catalogItemUuid" json:"catalog_item_uuid,omitempty"`
	// UUID pointing at a file within the file repository.
	FileUuid []byte `protobuf:"bytes,2,opt,name=file_uuid,json=fileUuid" json:"file_uuid,omitempty"`
	// UUID pointing at a cerebro snapshot.
	SnapshotUuid         []byte   `protobuf:"bytes,3,opt,name=snapshot_uuid,json=snapshotUuid" json:"snapshot_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{4}
}

func (m *Source) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Source.Unmarshal(m, b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Source.Marshal(b, m, deterministic)
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return xxx_messageInfo_Source.Size(m)
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetCatalogItemUuid() []byte {
	if m != nil {
		return m.CatalogItemUuid
	}
	return nil
}

func (m *Source) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *Source) GetSnapshotUuid() []byte {
	if m != nil {
		return m.SnapshotUuid
	}
	return nil
}

type FileInfo struct {
	// File UUID.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// File checksum.
	Checksum []byte `protobuf:"bytes,2,opt,name=checksum" json:"checksum,omitempty"`
	// File checksum type.
	ChecksumType *FileInfo_ChecksumType `protobuf:"varint,3,opt,name=checksum_type,json=checksumType,enum=nutanix.catalog.FileInfo_ChecksumType" json:"checksum_type,omitempty"`
	// List of locations where the file resides.
	LocationList []*FileLocation `protobuf:"bytes,4,rep,name=location_list,json=locationList" json:"location_list,omitempty"`
	// Logical timestamp for the file.
	LogicalTimestamp *int64 `protobuf:"varint,5,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// File size
	FileSize *int64 `protobuf:"varint,6,opt,name=file_size,json=fileSize" json:"file_size,omitempty"`
	// Source URL of the file
	SourceUrl *string `protobuf:"bytes,7,opt,name=source_url,json=sourceUrl" json:"source_url,omitempty"`
	// Source authentication credentials
	SourceAuthCred       *AuthenticationCredentials `protobuf:"bytes,8,opt,name=source_auth_cred,json=sourceAuthCred" json:"source_auth_cred,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{5}
}

func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileInfo.Unmarshal(m, b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return xxx_messageInfo_FileInfo.Size(m)
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *FileInfo) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *FileInfo) GetChecksumType() FileInfo_ChecksumType {
	if m != nil && m.ChecksumType != nil {
		return *m.ChecksumType
	}
	return FileInfo_kSha1
}

func (m *FileInfo) GetLocationList() []*FileLocation {
	if m != nil {
		return m.LocationList
	}
	return nil
}

func (m *FileInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *FileInfo) GetFileSize() int64 {
	if m != nil && m.FileSize != nil {
		return *m.FileSize
	}
	return 0
}

func (m *FileInfo) GetSourceUrl() string {
	if m != nil && m.SourceUrl != nil {
		return *m.SourceUrl
	}
	return ""
}

func (m *FileInfo) GetSourceAuthCred() *AuthenticationCredentials {
	if m != nil {
		return m.SourceAuthCred
	}
	return nil
}

type FileLocation struct {
	// Cluster UUID.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Availability zone logical id.
	AvailabilityZoneLogicalId *string `protobuf:"bytes,2,opt,name=availability_zone_logical_id,json=availabilityZoneLogicalId" json:"availability_zone_logical_id,omitempty"`
	// Container UUID.
	ContainerUuid []byte `protobuf:"bytes,3,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// List of URLs that can be used to access the file.
	UrlList []string `protobuf:"bytes,4,rep,name=url_list,json=urlList" json:"url_list,omitempty"`
	// File UUID. Should only be specified from PC where the file UUID points at
	// a file repository entry on a PE.
	FileUuid []byte `protobuf:"bytes,5,opt,name=file_uuid,json=fileUuid" json:"file_uuid,omitempty"`
	// Relative path to file inside the container specified by container_uuid.
	AdsfRelativePath *string `protobuf:"bytes,6,opt,name=adsf_relative_path,json=adsfRelativePath" json:"adsf_relative_path,omitempty"`
	// Get absolute file path.
	AdsfAbsolutePath     *string  `protobuf:"bytes,7,opt,name=adsf_absolute_path,json=adsfAbsolutePath" json:"adsf_absolute_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileLocation) Reset()         { *m = FileLocation{} }
func (m *FileLocation) String() string { return proto.CompactTextString(m) }
func (*FileLocation) ProtoMessage()    {}
func (*FileLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{6}
}

func (m *FileLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileLocation.Unmarshal(m, b)
}
func (m *FileLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileLocation.Marshal(b, m, deterministic)
}
func (m *FileLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLocation.Merge(m, src)
}
func (m *FileLocation) XXX_Size() int {
	return xxx_messageInfo_FileLocation.Size(m)
}
func (m *FileLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLocation.DiscardUnknown(m)
}

var xxx_messageInfo_FileLocation proto.InternalMessageInfo

func (m *FileLocation) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *FileLocation) GetAvailabilityZoneLogicalId() string {
	if m != nil && m.AvailabilityZoneLogicalId != nil {
		return *m.AvailabilityZoneLogicalId
	}
	return ""
}

func (m *FileLocation) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *FileLocation) GetUrlList() []string {
	if m != nil {
		return m.UrlList
	}
	return nil
}

func (m *FileLocation) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *FileLocation) GetAdsfRelativePath() string {
	if m != nil && m.AdsfRelativePath != nil {
		return *m.AdsfRelativePath
	}
	return ""
}

func (m *FileLocation) GetAdsfAbsolutePath() string {
	if m != nil && m.AdsfAbsolutePath != nil {
		return *m.AdsfAbsolutePath
	}
	return ""
}

type CatalogItemCreateSpec struct {
	// Catalog item UUID for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Catalog item name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Annotation describing the catalog item.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Catalog item type.
	ItemType *CatalogItemInfo_CatalogItemType `protobuf:"varint,4,opt,name=item_type,json=itemType,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"item_type,omitempty"`
	// Number of copies of the catalog item to maintain. Note that these copies
	// are spread across availability zones/clusters.
	NumberOfCopies *int32 `protobuf:"varint,5,opt,name=number_of_copies,json=numberOfCopies" json:"number_of_copies,omitempty"`
	// Opaque blob that can be used by the consuming service to deploy an entity
	// from a catalog item.
	Opaque []byte `protobuf:"bytes,6,opt,name=opaque" json:"opaque,omitempty"`
	// List of source groups specs.
	SourceGroupSpecList []*SourceGroupSpec `protobuf:"bytes,7,rep,name=source_group_spec_list,json=sourceGroupSpecList" json:"source_group_spec_list,omitempty"`
	// This field should only be used by the instance of the catalog living at
	// the PC level when checking out a catalog item on a cluster.
	GlobalCatalogItemUuid []byte `protobuf:"bytes,8,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// Human readable version for CatalogItem
	CatalogVersion *CatalogVersion `protobuf:"bytes,9,opt,name=catalog_version,json=catalogVersion" json:"catalog_version,omitempty"`
	// Catalog item version. This field is meant to be used only by checkout
	// task and not used by end clients.
	Version *int64 `protobuf:"varint,10,opt,name=version" json:"version,omitempty"`
	// Holds uuid of cluster that is allowed to perform CUD operations
	// on this catalog item. For catalog items on PE that are not migrated
	// to PC, this will be the PE uuid. For catalog items on PE that are
	// migrated to PC, this will be the PC uuid.
	OwnerClusterUuid []byte `protobuf:"bytes,11,opt,name=owner_cluster_uuid,json=ownerClusterUuid" json:"owner_cluster_uuid,omitempty"`
	// UUID of the source catalog item form which this catalog item is being
	// copied from.
	SourceCatalogItemId *CatalogItemId `protobuf:"bytes,12,opt,name=source_catalog_item_id,json=sourceCatalogItemId" json:"source_catalog_item_id,omitempty"`
	// Categories UUID list
	CategoriesUuidList   [][]byte `protobuf:"bytes,13,rep,name=categories_uuid_list,json=categoriesUuidList" json:"categories_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemCreateSpec) Reset()         { *m = CatalogItemCreateSpec{} }
func (m *CatalogItemCreateSpec) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCreateSpec) ProtoMessage()    {}
func (*CatalogItemCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{7}
}

func (m *CatalogItemCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCreateSpec.Unmarshal(m, b)
}
func (m *CatalogItemCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCreateSpec.Marshal(b, m, deterministic)
}
func (m *CatalogItemCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCreateSpec.Merge(m, src)
}
func (m *CatalogItemCreateSpec) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCreateSpec.Size(m)
}
func (m *CatalogItemCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCreateSpec proto.InternalMessageInfo

func (m *CatalogItemCreateSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogItemCreateSpec) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *CatalogItemCreateSpec) GetItemType() CatalogItemInfo_CatalogItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return CatalogItemInfo_kImage
}

func (m *CatalogItemCreateSpec) GetNumberOfCopies() int32 {
	if m != nil && m.NumberOfCopies != nil {
		return *m.NumberOfCopies
	}
	return 0
}

func (m *CatalogItemCreateSpec) GetOpaque() []byte {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetSourceGroupSpecList() []*SourceGroupSpec {
	if m != nil {
		return m.SourceGroupSpecList
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetCatalogVersion() *CatalogVersion {
	if m != nil {
		return m.CatalogVersion
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *CatalogItemCreateSpec) GetOwnerClusterUuid() []byte {
	if m != nil {
		return m.OwnerClusterUuid
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetSourceCatalogItemId() *CatalogItemId {
	if m != nil {
		return m.SourceCatalogItemId
	}
	return nil
}

func (m *CatalogItemCreateSpec) GetCategoriesUuidList() [][]byte {
	if m != nil {
		return m.CategoriesUuidList
	}
	return nil
}

type SourceGroupSpec struct {
	// List of source specs.
	SourceSpecList       []*SourceSpec `protobuf:"bytes,3,rep,name=source_spec_list,json=sourceSpecList" json:"source_spec_list,omitempty"`
	Uuid                 []byte        `protobuf:"bytes,4,opt,name=uuid" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SourceGroupSpec) Reset()         { *m = SourceGroupSpec{} }
func (m *SourceGroupSpec) String() string { return proto.CompactTextString(m) }
func (*SourceGroupSpec) ProtoMessage()    {}
func (*SourceGroupSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{8}
}

func (m *SourceGroupSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SourceGroupSpec.Unmarshal(m, b)
}
func (m *SourceGroupSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SourceGroupSpec.Marshal(b, m, deterministic)
}
func (m *SourceGroupSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceGroupSpec.Merge(m, src)
}
func (m *SourceGroupSpec) XXX_Size() int {
	return xxx_messageInfo_SourceGroupSpec.Size(m)
}
func (m *SourceGroupSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceGroupSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SourceGroupSpec proto.InternalMessageInfo

func (m *SourceGroupSpec) GetSourceSpecList() []*SourceSpec {
	if m != nil {
		return m.SourceSpecList
	}
	return nil
}

func (m *SourceGroupSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type SourceSpec struct {
	// Spec describing a file to import into the catalog.
	ImportSpec *FileImportSpec `protobuf:"bytes,1,opt,name=import_spec,json=importSpec" json:"import_spec,omitempty"`
	// Snapshot UUID.
	SnapshotUuid []byte `protobuf:"bytes,3,opt,name=snapshot_uuid,json=snapshotUuid" json:"snapshot_uuid,omitempty"`
	// A child catalog item UUID.
	CatalogItemUuid      []byte   `protobuf:"bytes,4,opt,name=catalog_item_uuid,json=catalogItemUuid" json:"catalog_item_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SourceSpec) Reset()         { *m = SourceSpec{} }
func (m *SourceSpec) String() string { return proto.CompactTextString(m) }
func (*SourceSpec) ProtoMessage()    {}
func (*SourceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{9}
}

func (m *SourceSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SourceSpec.Unmarshal(m, b)
}
func (m *SourceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SourceSpec.Marshal(b, m, deterministic)
}
func (m *SourceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceSpec.Merge(m, src)
}
func (m *SourceSpec) XXX_Size() int {
	return xxx_messageInfo_SourceSpec.Size(m)
}
func (m *SourceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SourceSpec proto.InternalMessageInfo

func (m *SourceSpec) GetImportSpec() *FileImportSpec {
	if m != nil {
		return m.ImportSpec
	}
	return nil
}

func (m *SourceSpec) GetSnapshotUuid() []byte {
	if m != nil {
		return m.SnapshotUuid
	}
	return nil
}

func (m *SourceSpec) GetCatalogItemUuid() []byte {
	if m != nil {
		return m.CatalogItemUuid
	}
	return nil
}

type CatalogItemId struct {
	// global catalog item UUIDs to lookup
	GlobalCatalogItemUuid []byte `protobuf:"bytes,1,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// version of the catalog item to lookup
	Version              *int64   `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemId) Reset()         { *m = CatalogItemId{} }
func (m *CatalogItemId) String() string { return proto.CompactTextString(m) }
func (*CatalogItemId) ProtoMessage()    {}
func (*CatalogItemId) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{10}
}

func (m *CatalogItemId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemId.Unmarshal(m, b)
}
func (m *CatalogItemId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemId.Marshal(b, m, deterministic)
}
func (m *CatalogItemId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemId.Merge(m, src)
}
func (m *CatalogItemId) XXX_Size() int {
	return xxx_messageInfo_CatalogItemId.Size(m)
}
func (m *CatalogItemId) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemId.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemId proto.InternalMessageInfo

func (m *CatalogItemId) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogItemId) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

type CatalogItemUpdateSpec struct {
	// Catalog item name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Annotation describing the catalog item.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Catalog item type.
	ItemType *CatalogItemUpdateSpec_CatalogItemType `protobuf:"varint,4,opt,name=item_type,json=itemType,enum=nutanix.catalog.CatalogItemUpdateSpec_CatalogItemType" json:"item_type,omitempty"`
	// Number of copies of the catalog item to maintain. Note that these copies
	// are spread across availability zones/clusters.
	NumberOfCopies *int32 `protobuf:"varint,5,opt,name=number_of_copies,json=numberOfCopies" json:"number_of_copies,omitempty"`
	// Opaque blob that can be used by the consuming service to deploy an entity
	// from a catalog item.
	Opaque []byte `protobuf:"bytes,6,opt,name=opaque" json:"opaque,omitempty"`
	// UUIDs of source groups to be removed from catalog item.
	RemoveSourceGroupUuidList [][]byte `protobuf:"bytes,7,rep,name=remove_source_group_uuid_list,json=removeSourceGroupUuidList" json:"remove_source_group_uuid_list,omitempty"`
	// List of source group specs.
	AddSourceGroupList []*SourceGroupSpec `protobuf:"bytes,8,rep,name=add_source_group_list,json=addSourceGroupList" json:"add_source_group_list,omitempty"`
	// Human readable version for CatalogItem.
	CatalogVersion *CatalogVersion `protobuf:"bytes,9,opt,name=catalog_version,json=catalogVersion" json:"catalog_version,omitempty"`
	// UUIDs of files to be removed from catalog item.
	RemoveFileUuidList [][]byte `protobuf:"bytes,10,rep,name=remove_file_uuid_list,json=removeFileUuidList" json:"remove_file_uuid_list,omitempty"`
	// Catalog item version.
	Version              *int64   `protobuf:"varint,11,opt,name=version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUpdateSpec) Reset()         { *m = CatalogItemUpdateSpec{} }
func (m *CatalogItemUpdateSpec) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUpdateSpec) ProtoMessage()    {}
func (*CatalogItemUpdateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{11}
}

func (m *CatalogItemUpdateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUpdateSpec.Unmarshal(m, b)
}
func (m *CatalogItemUpdateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUpdateSpec.Marshal(b, m, deterministic)
}
func (m *CatalogItemUpdateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUpdateSpec.Merge(m, src)
}
func (m *CatalogItemUpdateSpec) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUpdateSpec.Size(m)
}
func (m *CatalogItemUpdateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUpdateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUpdateSpec proto.InternalMessageInfo

func (m *CatalogItemUpdateSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogItemUpdateSpec) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *CatalogItemUpdateSpec) GetItemType() CatalogItemUpdateSpec_CatalogItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return CatalogItemUpdateSpec_kImage
}

func (m *CatalogItemUpdateSpec) GetNumberOfCopies() int32 {
	if m != nil && m.NumberOfCopies != nil {
		return *m.NumberOfCopies
	}
	return 0
}

func (m *CatalogItemUpdateSpec) GetOpaque() []byte {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *CatalogItemUpdateSpec) GetRemoveSourceGroupUuidList() [][]byte {
	if m != nil {
		return m.RemoveSourceGroupUuidList
	}
	return nil
}

func (m *CatalogItemUpdateSpec) GetAddSourceGroupList() []*SourceGroupSpec {
	if m != nil {
		return m.AddSourceGroupList
	}
	return nil
}

func (m *CatalogItemUpdateSpec) GetCatalogVersion() *CatalogVersion {
	if m != nil {
		return m.CatalogVersion
	}
	return nil
}

func (m *CatalogItemUpdateSpec) GetRemoveFileUuidList() [][]byte {
	if m != nil {
		return m.RemoveFileUuidList
	}
	return nil
}

func (m *CatalogItemUpdateSpec) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

type PayloadValue struct {
	// The offset of the value in the payload.
	Offset *uint64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	// The size of the value in the payload.
	Size                 *uint64  `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayloadValue) Reset()         { *m = PayloadValue{} }
func (m *PayloadValue) String() string { return proto.CompactTextString(m) }
func (*PayloadValue) ProtoMessage()    {}
func (*PayloadValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{12}
}

func (m *PayloadValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadValue.Unmarshal(m, b)
}
func (m *PayloadValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadValue.Marshal(b, m, deterministic)
}
func (m *PayloadValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadValue.Merge(m, src)
}
func (m *PayloadValue) XXX_Size() int {
	return xxx_messageInfo_PayloadValue.Size(m)
}
func (m *PayloadValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadValue.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadValue proto.InternalMessageInfo

func (m *PayloadValue) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *PayloadValue) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

type PayloadOrEmbeddedValue struct {
	// Instructions on how to find value in the payload.
	Payload *PayloadValue `protobuf:"bytes,1,opt,name=payload" json:"payload,omitempty"`
	// Embedded value.
	Embedded             []byte   `protobuf:"bytes,2,opt,name=embedded" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayloadOrEmbeddedValue) Reset()         { *m = PayloadOrEmbeddedValue{} }
func (m *PayloadOrEmbeddedValue) String() string { return proto.CompactTextString(m) }
func (*PayloadOrEmbeddedValue) ProtoMessage()    {}
func (*PayloadOrEmbeddedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{13}
}

func (m *PayloadOrEmbeddedValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Unmarshal(m, b)
}
func (m *PayloadOrEmbeddedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Marshal(b, m, deterministic)
}
func (m *PayloadOrEmbeddedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadOrEmbeddedValue.Merge(m, src)
}
func (m *PayloadOrEmbeddedValue) XXX_Size() int {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Size(m)
}
func (m *PayloadOrEmbeddedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadOrEmbeddedValue.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadOrEmbeddedValue proto.InternalMessageInfo

func (m *PayloadOrEmbeddedValue) GetPayload() *PayloadValue {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PayloadOrEmbeddedValue) GetEmbedded() []byte {
	if m != nil {
		return m.Embedded
	}
	return nil
}

type MetaRequest struct {
	// Method name.
	MethodName *string `protobuf:"bytes,1,opt,name=method_name,json=methodName" json:"method_name,omitempty"`
	// Serialized argument.
	Arg *PayloadOrEmbeddedValue `protobuf:"bytes,2,opt,name=arg" json:"arg,omitempty"`
	// Whether the RPC was forwarded from another Catalog instance.
	Forwarded            *bool    `protobuf:"varint,3,opt,name=forwarded" json:"forwarded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaRequest) Reset()         { *m = MetaRequest{} }
func (m *MetaRequest) String() string { return proto.CompactTextString(m) }
func (*MetaRequest) ProtoMessage()    {}
func (*MetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{14}
}

func (m *MetaRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaRequest.Unmarshal(m, b)
}
func (m *MetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaRequest.Marshal(b, m, deterministic)
}
func (m *MetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRequest.Merge(m, src)
}
func (m *MetaRequest) XXX_Size() int {
	return xxx_messageInfo_MetaRequest.Size(m)
}
func (m *MetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRequest proto.InternalMessageInfo

func (m *MetaRequest) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *MetaRequest) GetArg() *PayloadOrEmbeddedValue {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *MetaRequest) GetForwarded() bool {
	if m != nil && m.Forwarded != nil {
		return *m.Forwarded
	}
	return false
}

type MetaResponse struct {
	// An error code indicating whether the RPC was successful.
	ErrorCode *CatalogError_Type `protobuf:"varint,1,opt,name=error_code,json=errorCode,enum=nutanix.catalog.CatalogError_Type" json:"error_code,omitempty"`
	// An optional additional string describing the error, if the RPC was not
	// successful.
	ErrorDetail *string `protobuf:"bytes,2,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	// The serialized response, if any.
	Ret                  *PayloadOrEmbeddedValue `protobuf:"bytes,3,opt,name=ret" json:"ret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MetaResponse) Reset()         { *m = MetaResponse{} }
func (m *MetaResponse) String() string { return proto.CompactTextString(m) }
func (*MetaResponse) ProtoMessage()    {}
func (*MetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{15}
}

func (m *MetaResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaResponse.Unmarshal(m, b)
}
func (m *MetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaResponse.Marshal(b, m, deterministic)
}
func (m *MetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaResponse.Merge(m, src)
}
func (m *MetaResponse) XXX_Size() int {
	return xxx_messageInfo_MetaResponse.Size(m)
}
func (m *MetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MetaResponse proto.InternalMessageInfo

func (m *MetaResponse) GetErrorCode() CatalogError_Type {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return CatalogError_kNoError
}

func (m *MetaResponse) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

func (m *MetaResponse) GetRet() *PayloadOrEmbeddedValue {
	if m != nil {
		return m.Ret
	}
	return nil
}

type Task struct {
	// The task identifier.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The request that spawned the task.
	Request *MetaRequest `protobuf:"bytes,2,opt,name=request" json:"request,omitempty"`
	// The task completion information.
	Response *MetaResponse `protobuf:"bytes,3,opt,name=response" json:"response,omitempty"`
	// Creation time in microseconds from epoch.
	CreateTime *uint64 `protobuf:"fixed64,4,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Start time in microseconds from epoch.
	StartTime *uint64 `protobuf:"fixed64,5,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Completion time in microseconds from epoch. Unset for ongoing tasks.
	CompleteTime *uint64 `protobuf:"fixed64,6,opt,name=complete_time,json=completeTime" json:"complete_time,omitempty"`
	// Last time the task was updated from epoch.
	LastUpdatedTime *uint64             `protobuf:"fixed64,7,opt,name=last_updated_time,json=lastUpdatedTime" json:"last_updated_time,omitempty"`
	EntityList      []*Task_EntityId    `protobuf:"bytes,8,rep,name=entity_list,json=entityList" json:"entity_list,omitempty"`
	OperationType   *Task_OperationType `protobuf:"varint,9,opt,name=operation_type,json=operationType,enum=nutanix.catalog.Task_OperationType" json:"operation_type,omitempty"`
	// Message describing the task. It should attempt to be more specific about
	// the kind of entities involved with the task. (For e.g., in the
	// enter_maintenance_mode_task in Acropolis, "Migrate normal VM for
	// maintenance mode", "Acpi shutdown agent VM for maintenance mode")
	Message *string `protobuf:"bytes,10,opt,name=message" json:"message,omitempty"`
	// Percentage of task completed.
	PercentageComplete *int32       `protobuf:"varint,11,opt,name=percentage_complete,json=percentageComplete" json:"percentage_complete,omitempty"`
	ProgressStatus     *Task_Status `protobuf:"varint,12,opt,name=progress_status,json=progressStatus,enum=nutanix.catalog.Task_Status" json:"progress_status,omitempty"`
	// The parent task UUID. This is for internal use only, and should not be
	// exposed at the presentation layer.
	ParentTaskUuid []byte `protobuf:"bytes,13,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// A list of subtask UUIDs, ordered by creation time.
	SubtaskUuidList [][]byte `protobuf:"bytes,14,rep,name=subtask_uuid_list,json=subtaskUuidList" json:"subtask_uuid_list,omitempty"`
	// If this flag is set, then this is an internal task and is not meant
	// to be displayed in UI.
	InternalTask *bool `protobuf:"varint,15,opt,name=internal_task,json=internalTask,def=0" json:"internal_task,omitempty"`
	// If the canceled flag is set, then user has indicated the task to be
	// canceled. It is up to task executor whether to move the task to
	// kAborted or let it continue running until its completion.
	Canceled *bool `protobuf:"varint,16,opt,name=canceled,def=0" json:"canceled,omitempty"`
	// The task operation name to be displayed on UI. This allows the
	// task to optionally specify the name of its operation. In case it isn't
	// specified, Prism parses the name from the operation type.
	// (For e.g., "Catalog item create" for the kCatalogItemCreate.)
	DisplayName *string `protobuf:"bytes,17,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Only set when parent_task_uuid is set.  Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,18,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Whether UI should display failures from this task.
	DisplayFailures *bool `protobuf:"varint,19,opt,name=display_failures,json=displayFailures,def=1" json:"display_failures,omitempty"`
	// Set of capabilities of a task.
	Capabilities []Task_Capability `protobuf:"varint,20,rep,name=capabilities,enum=nutanix.catalog.Task_Capability" json:"capabilities,omitempty"`
	// Context about the request that spawned the task such as the
	// user name, client ip, etc.
	RequestContext *net.RpcRequestContext `protobuf:"bytes,21,opt,name=request_context,json=requestContext" json:"request_context,omitempty"`
	// Whether to use barrier updates for this task's completion.
	UseSyncBarrier *bool `protobuf:"varint,22,opt,name=use_sync_barrier,json=useSyncBarrier,def=0" json:"use_sync_barrier,omitempty"`
	// Disable auto progress update of tasks by Ergon.
	//
	// If set to True, progress of this task is *not* automatically updated
	// based on progress of subtasks.
	DisableAutoProgressUpdate *bool    `protobuf:"varint,23,opt,name=disable_auto_progress_update,json=disableAutoProgressUpdate,def=0" json:"disable_auto_progress_update,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{16}
}

func (m *Task) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Task.Unmarshal(m, b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Task.Marshal(b, m, deterministic)
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return xxx_messageInfo_Task.Size(m)
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

const Default_Task_InternalTask bool = false
const Default_Task_Canceled bool = false
const Default_Task_DisplayFailures bool = true
const Default_Task_UseSyncBarrier bool = false
const Default_Task_DisableAutoProgressUpdate bool = false

func (m *Task) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Task) GetRequest() *MetaRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Task) GetResponse() *MetaResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Task) GetCreateTime() uint64 {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return 0
}

func (m *Task) GetStartTime() uint64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *Task) GetCompleteTime() uint64 {
	if m != nil && m.CompleteTime != nil {
		return *m.CompleteTime
	}
	return 0
}

func (m *Task) GetLastUpdatedTime() uint64 {
	if m != nil && m.LastUpdatedTime != nil {
		return *m.LastUpdatedTime
	}
	return 0
}

func (m *Task) GetEntityList() []*Task_EntityId {
	if m != nil {
		return m.EntityList
	}
	return nil
}

func (m *Task) GetOperationType() Task_OperationType {
	if m != nil && m.OperationType != nil {
		return *m.OperationType
	}
	return Task_kCatalogItemCreate
}

func (m *Task) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *Task) GetPercentageComplete() int32 {
	if m != nil && m.PercentageComplete != nil {
		return *m.PercentageComplete
	}
	return 0
}

func (m *Task) GetProgressStatus() Task_Status {
	if m != nil && m.ProgressStatus != nil {
		return *m.ProgressStatus
	}
	return Task_kQueued
}

func (m *Task) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *Task) GetSubtaskUuidList() [][]byte {
	if m != nil {
		return m.SubtaskUuidList
	}
	return nil
}

func (m *Task) GetInternalTask() bool {
	if m != nil && m.InternalTask != nil {
		return *m.InternalTask
	}
	return Default_Task_InternalTask
}

func (m *Task) GetCanceled() bool {
	if m != nil && m.Canceled != nil {
		return *m.Canceled
	}
	return Default_Task_Canceled
}

func (m *Task) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *Task) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *Task) GetDisplayFailures() bool {
	if m != nil && m.DisplayFailures != nil {
		return *m.DisplayFailures
	}
	return Default_Task_DisplayFailures
}

func (m *Task) GetCapabilities() []Task_Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *Task) GetRequestContext() *net.RpcRequestContext {
	if m != nil {
		return m.RequestContext
	}
	return nil
}

func (m *Task) GetUseSyncBarrier() bool {
	if m != nil && m.UseSyncBarrier != nil {
		return *m.UseSyncBarrier
	}
	return Default_Task_UseSyncBarrier
}

func (m *Task) GetDisableAutoProgressUpdate() bool {
	if m != nil && m.DisableAutoProgressUpdate != nil {
		return *m.DisableAutoProgressUpdate
	}
	return Default_Task_DisableAutoProgressUpdate
}

type Task_EntityId struct {
	// UUID of the entity.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Entity type.
	EntityType *Task_Entity `protobuf:"varint,2,opt,name=entity_type,json=entityType,enum=nutanix.catalog.Task_Entity" json:"entity_type,omitempty"`
	// Entity name. This is not stored to the database, but resolved on demand.
	EntityName           *string  `protobuf:"bytes,3,opt,name=entity_name,json=entityName" json:"entity_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Task_EntityId) Reset()         { *m = Task_EntityId{} }
func (m *Task_EntityId) String() string { return proto.CompactTextString(m) }
func (*Task_EntityId) ProtoMessage()    {}
func (*Task_EntityId) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{16, 0}
}

func (m *Task_EntityId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Task_EntityId.Unmarshal(m, b)
}
func (m *Task_EntityId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Task_EntityId.Marshal(b, m, deterministic)
}
func (m *Task_EntityId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task_EntityId.Merge(m, src)
}
func (m *Task_EntityId) XXX_Size() int {
	return xxx_messageInfo_Task_EntityId.Size(m)
}
func (m *Task_EntityId) XXX_DiscardUnknown() {
	xxx_messageInfo_Task_EntityId.DiscardUnknown(m)
}

var xxx_messageInfo_Task_EntityId proto.InternalMessageInfo

func (m *Task_EntityId) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Task_EntityId) GetEntityType() Task_Entity {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return Task_kCatalogItem
}

func (m *Task_EntityId) GetEntityName() string {
	if m != nil && m.EntityName != nil {
		return *m.EntityName
	}
	return ""
}

type FileImportSpec struct {
	// Pass a UUID for idempotence.
	FileUuid []byte `protobuf:"bytes,1,opt,name=file_uuid,json=fileUuid" json:"file_uuid,omitempty"`
	// A list of specs describing a remote locations where the file can be
	// imported from.
	RemoteImportList []*RemoteImportSpec `protobuf:"bytes,2,rep,name=remote_import_list,json=remoteImportList" json:"remote_import_list,omitempty"`
	// A list of specs describing locations on Nutanix clusters where the file
	// can be imported from.
	LocalImportList []*LocalImportSpec `protobuf:"bytes,3,rep,name=local_import_list,json=localImportList" json:"local_import_list,omitempty"`
	// For files that are already existing but only need creation of a repo
	// entry
	ExistingFileSpec     *ExistingFileSpec `protobuf:"bytes,4,opt,name=existing_file_spec,json=existingFileSpec" json:"existing_file_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FileImportSpec) Reset()         { *m = FileImportSpec{} }
func (m *FileImportSpec) String() string { return proto.CompactTextString(m) }
func (*FileImportSpec) ProtoMessage()    {}
func (*FileImportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{17}
}

func (m *FileImportSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileImportSpec.Unmarshal(m, b)
}
func (m *FileImportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileImportSpec.Marshal(b, m, deterministic)
}
func (m *FileImportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileImportSpec.Merge(m, src)
}
func (m *FileImportSpec) XXX_Size() int {
	return xxx_messageInfo_FileImportSpec.Size(m)
}
func (m *FileImportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_FileImportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_FileImportSpec proto.InternalMessageInfo

func (m *FileImportSpec) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *FileImportSpec) GetRemoteImportList() []*RemoteImportSpec {
	if m != nil {
		return m.RemoteImportList
	}
	return nil
}

func (m *FileImportSpec) GetLocalImportList() []*LocalImportSpec {
	if m != nil {
		return m.LocalImportList
	}
	return nil
}

func (m *FileImportSpec) GetExistingFileSpec() *ExistingFileSpec {
	if m != nil {
		return m.ExistingFileSpec
	}
	return nil
}

type RemoteImportSpec struct {
	// A URL pointing at a file to import into the file repository.
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// A destination container where the source should be imported. If missing
	// the catalog will try to auto select a container.
	ContainerUuid []byte `protobuf:"bytes,2,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Authetication credentials
	AuthCred             *AuthenticationCredentials `protobuf:"bytes,3,opt,name=auth_cred,json=authCred" json:"auth_cred,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *RemoteImportSpec) Reset()         { *m = RemoteImportSpec{} }
func (m *RemoteImportSpec) String() string { return proto.CompactTextString(m) }
func (*RemoteImportSpec) ProtoMessage()    {}
func (*RemoteImportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{18}
}

func (m *RemoteImportSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteImportSpec.Unmarshal(m, b)
}
func (m *RemoteImportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteImportSpec.Marshal(b, m, deterministic)
}
func (m *RemoteImportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteImportSpec.Merge(m, src)
}
func (m *RemoteImportSpec) XXX_Size() int {
	return xxx_messageInfo_RemoteImportSpec.Size(m)
}
func (m *RemoteImportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteImportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteImportSpec proto.InternalMessageInfo

func (m *RemoteImportSpec) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *RemoteImportSpec) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *RemoteImportSpec) GetAuthCred() *AuthenticationCredentials {
	if m != nil {
		return m.AuthCred
	}
	return nil
}

type LocalImportSpec struct {
	// A cluster UUID where the ADSF path exists or file repository entry exists.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// A local ADSF path pointing at a file to import into the file repository.
	AdsfPath *string `protobuf:"bytes,2,opt,name=adsf_path,json=adsfPath" json:"adsf_path,omitempty"`
	// A pointer to a file repo entry on a cluster.
	FileUuid []byte `protobuf:"bytes,3,opt,name=file_uuid,json=fileUuid" json:"file_uuid,omitempty"`
	// An availability zone where the file repository entry exists.
	AvailabilityZoneLogicalId *string `protobuf:"bytes,4,opt,name=availability_zone_logical_id,json=availabilityZoneLogicalId" json:"availability_zone_logical_id,omitempty"`
	// Spec describing the information to track a file upload that is currently
	// in progress.
	UploadSpec *CatalogFileUploadSpec `protobuf:"bytes,5,opt,name=upload_spec,json=uploadSpec" json:"upload_spec,omitempty"`
	// Container UUID, for when adsf_path is relative.
	ContainerUuid        []byte   `protobuf:"bytes,6,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalImportSpec) Reset()         { *m = LocalImportSpec{} }
func (m *LocalImportSpec) String() string { return proto.CompactTextString(m) }
func (*LocalImportSpec) ProtoMessage()    {}
func (*LocalImportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{19}
}

func (m *LocalImportSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocalImportSpec.Unmarshal(m, b)
}
func (m *LocalImportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocalImportSpec.Marshal(b, m, deterministic)
}
func (m *LocalImportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalImportSpec.Merge(m, src)
}
func (m *LocalImportSpec) XXX_Size() int {
	return xxx_messageInfo_LocalImportSpec.Size(m)
}
func (m *LocalImportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalImportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_LocalImportSpec proto.InternalMessageInfo

func (m *LocalImportSpec) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *LocalImportSpec) GetAdsfPath() string {
	if m != nil && m.AdsfPath != nil {
		return *m.AdsfPath
	}
	return ""
}

func (m *LocalImportSpec) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *LocalImportSpec) GetAvailabilityZoneLogicalId() string {
	if m != nil && m.AvailabilityZoneLogicalId != nil {
		return *m.AvailabilityZoneLogicalId
	}
	return ""
}

func (m *LocalImportSpec) GetUploadSpec() *CatalogFileUploadSpec {
	if m != nil {
		return m.UploadSpec
	}
	return nil
}

func (m *LocalImportSpec) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

type ExistingFileSpec struct {
	// The container uuid where the file exists
	ContainerUuid        []byte   `protobuf:"bytes,1,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExistingFileSpec) Reset()         { *m = ExistingFileSpec{} }
func (m *ExistingFileSpec) String() string { return proto.CompactTextString(m) }
func (*ExistingFileSpec) ProtoMessage()    {}
func (*ExistingFileSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{20}
}

func (m *ExistingFileSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExistingFileSpec.Unmarshal(m, b)
}
func (m *ExistingFileSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExistingFileSpec.Marshal(b, m, deterministic)
}
func (m *ExistingFileSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistingFileSpec.Merge(m, src)
}
func (m *ExistingFileSpec) XXX_Size() int {
	return xxx_messageInfo_ExistingFileSpec.Size(m)
}
func (m *ExistingFileSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistingFileSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ExistingFileSpec proto.InternalMessageInfo

func (m *ExistingFileSpec) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

type AuthenticationCredentials struct {
	// Basic authentication credentials (username/password)
	BasicAuth *BasicAuth `protobuf:"bytes,1,opt,name=basic_auth,json=basicAuth" json:"basic_auth,omitempty"`
	// AWS authentication credentials
	AwsAuth              *AWSAuth `protobuf:"bytes,2,opt,name=aws_auth,json=awsAuth" json:"aws_auth,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticationCredentials) Reset()         { *m = AuthenticationCredentials{} }
func (m *AuthenticationCredentials) String() string { return proto.CompactTextString(m) }
func (*AuthenticationCredentials) ProtoMessage()    {}
func (*AuthenticationCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{21}
}

func (m *AuthenticationCredentials) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthenticationCredentials.Unmarshal(m, b)
}
func (m *AuthenticationCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthenticationCredentials.Marshal(b, m, deterministic)
}
func (m *AuthenticationCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationCredentials.Merge(m, src)
}
func (m *AuthenticationCredentials) XXX_Size() int {
	return xxx_messageInfo_AuthenticationCredentials.Size(m)
}
func (m *AuthenticationCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationCredentials proto.InternalMessageInfo

func (m *AuthenticationCredentials) GetBasicAuth() *BasicAuth {
	if m != nil {
		return m.BasicAuth
	}
	return nil
}

func (m *AuthenticationCredentials) GetAwsAuth() *AWSAuth {
	if m != nil {
		return m.AwsAuth
	}
	return nil
}

type BasicAuth struct {
	// Username
	Username *string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Password
	Password             *string  `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicAuth) Reset()         { *m = BasicAuth{} }
func (m *BasicAuth) String() string { return proto.CompactTextString(m) }
func (*BasicAuth) ProtoMessage()    {}
func (*BasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{22}
}

func (m *BasicAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BasicAuth.Unmarshal(m, b)
}
func (m *BasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BasicAuth.Marshal(b, m, deterministic)
}
func (m *BasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAuth.Merge(m, src)
}
func (m *BasicAuth) XXX_Size() int {
	return xxx_messageInfo_BasicAuth.Size(m)
}
func (m *BasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAuth proto.InternalMessageInfo

func (m *BasicAuth) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *BasicAuth) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

type AWSAuth struct {
	// Access Key
	AccessKey *string `protobuf:"bytes,1,opt,name=access_key,json=accessKey" json:"access_key,omitempty"`
	// Secret Key
	SecretKey            *string  `protobuf:"bytes,2,opt,name=secret_key,json=secretKey" json:"secret_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSAuth) Reset()         { *m = AWSAuth{} }
func (m *AWSAuth) String() string { return proto.CompactTextString(m) }
func (*AWSAuth) ProtoMessage()    {}
func (*AWSAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{23}
}

func (m *AWSAuth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AWSAuth.Unmarshal(m, b)
}
func (m *AWSAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AWSAuth.Marshal(b, m, deterministic)
}
func (m *AWSAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAuth.Merge(m, src)
}
func (m *AWSAuth) XXX_Size() int {
	return xxx_messageInfo_AWSAuth.Size(m)
}
func (m *AWSAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAuth.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAuth proto.InternalMessageInfo

func (m *AWSAuth) GetAccessKey() string {
	if m != nil && m.AccessKey != nil {
		return *m.AccessKey
	}
	return ""
}

func (m *AWSAuth) GetSecretKey() string {
	if m != nil && m.SecretKey != nil {
		return *m.SecretKey
	}
	return ""
}

type ImageRequest struct {
	// The image RPC method name.
	MethodName *string `protobuf:"bytes,1,opt,name=method_name,json=methodName" json:"method_name,omitempty"`
	// An image request can be either a create, update, or delete request, so one
	// of the following must be provided.
	ImageCreateArg       *acropolis.ImageCreateArg `protobuf:"bytes,2,opt,name=image_create_arg,json=imageCreateArg" json:"image_create_arg,omitempty"`
	ImageUpdateArg       *acropolis.ImageUpdateArg `protobuf:"bytes,3,opt,name=image_update_arg,json=imageUpdateArg" json:"image_update_arg,omitempty"`
	ImageDeleteArg       *acropolis.ImageDeleteArg `protobuf:"bytes,4,opt,name=image_delete_arg,json=imageDeleteArg" json:"image_delete_arg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ImageRequest) Reset()         { *m = ImageRequest{} }
func (m *ImageRequest) String() string { return proto.CompactTextString(m) }
func (*ImageRequest) ProtoMessage()    {}
func (*ImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{24}
}

func (m *ImageRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageRequest.Unmarshal(m, b)
}
func (m *ImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageRequest.Marshal(b, m, deterministic)
}
func (m *ImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageRequest.Merge(m, src)
}
func (m *ImageRequest) XXX_Size() int {
	return xxx_messageInfo_ImageRequest.Size(m)
}
func (m *ImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImageRequest proto.InternalMessageInfo

func (m *ImageRequest) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *ImageRequest) GetImageCreateArg() *acropolis.ImageCreateArg {
	if m != nil {
		return m.ImageCreateArg
	}
	return nil
}

func (m *ImageRequest) GetImageUpdateArg() *acropolis.ImageUpdateArg {
	if m != nil {
		return m.ImageUpdateArg
	}
	return nil
}

func (m *ImageRequest) GetImageDeleteArg() *acropolis.ImageDeleteArg {
	if m != nil {
		return m.ImageDeleteArg
	}
	return nil
}

type ImageResponse struct {
	// The image RPC method name.
	MethodName *string `protobuf:"bytes,1,opt,name=method_name,json=methodName" json:"method_name,omitempty"`
	// The image response, one of the following attributes should be specified.
	ImageCreateRet       *acropolis.ImageCreateTaskRet `protobuf:"bytes,2,opt,name=image_create_ret,json=imageCreateRet" json:"image_create_ret,omitempty"`
	ImageUpdateRet       *acropolis.ImageUpdateTaskRet `protobuf:"bytes,3,opt,name=image_update_ret,json=imageUpdateRet" json:"image_update_ret,omitempty"`
	ImageDeleteRet       *acropolis.ImageDeleteTaskRet `protobuf:"bytes,4,opt,name=image_delete_ret,json=imageDeleteRet" json:"image_delete_ret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ImageResponse) Reset()         { *m = ImageResponse{} }
func (m *ImageResponse) String() string { return proto.CompactTextString(m) }
func (*ImageResponse) ProtoMessage()    {}
func (*ImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{25}
}

func (m *ImageResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageResponse.Unmarshal(m, b)
}
func (m *ImageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageResponse.Marshal(b, m, deterministic)
}
func (m *ImageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageResponse.Merge(m, src)
}
func (m *ImageResponse) XXX_Size() int {
	return xxx_messageInfo_ImageResponse.Size(m)
}
func (m *ImageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImageResponse proto.InternalMessageInfo

func (m *ImageResponse) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *ImageResponse) GetImageCreateRet() *acropolis.ImageCreateTaskRet {
	if m != nil {
		return m.ImageCreateRet
	}
	return nil
}

func (m *ImageResponse) GetImageUpdateRet() *acropolis.ImageUpdateTaskRet {
	if m != nil {
		return m.ImageUpdateRet
	}
	return nil
}

func (m *ImageResponse) GetImageDeleteRet() *acropolis.ImageDeleteTaskRet {
	if m != nil {
		return m.ImageDeleteRet
	}
	return nil
}

type CatalogFileUploadSpec struct {
	// ADSF path where the uploaded file resides. Should only be provided when
	// uploading on PE.
	UploadAdsfPath *string `protobuf:"bytes,1,opt,name=upload_adsf_path,json=uploadAdsfPath" json:"upload_adsf_path,omitempty"`
	// Size of the upload. Should only be provided when uploading on PE.
	UploadImageSize *int64 `protobuf:"varint,2,opt,name=upload_image_size,json=uploadImageSize" json:"upload_image_size,omitempty"`
	// The task that is currently processing the file upload.
	UploadTask *EndpointTask `protobuf:"bytes,3,opt,name=upload_task,json=uploadTask" json:"upload_task,omitempty"`
	// UUID of catalog item for which file is being uploaded
	CatalogItemUuid      []byte   `protobuf:"bytes,4,opt,name=catalog_item_uuid,json=catalogItemUuid" json:"catalog_item_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogFileUploadSpec) Reset()         { *m = CatalogFileUploadSpec{} }
func (m *CatalogFileUploadSpec) String() string { return proto.CompactTextString(m) }
func (*CatalogFileUploadSpec) ProtoMessage()    {}
func (*CatalogFileUploadSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{26}
}

func (m *CatalogFileUploadSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogFileUploadSpec.Unmarshal(m, b)
}
func (m *CatalogFileUploadSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogFileUploadSpec.Marshal(b, m, deterministic)
}
func (m *CatalogFileUploadSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogFileUploadSpec.Merge(m, src)
}
func (m *CatalogFileUploadSpec) XXX_Size() int {
	return xxx_messageInfo_CatalogFileUploadSpec.Size(m)
}
func (m *CatalogFileUploadSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogFileUploadSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogFileUploadSpec proto.InternalMessageInfo

func (m *CatalogFileUploadSpec) GetUploadAdsfPath() string {
	if m != nil && m.UploadAdsfPath != nil {
		return *m.UploadAdsfPath
	}
	return ""
}

func (m *CatalogFileUploadSpec) GetUploadImageSize() int64 {
	if m != nil && m.UploadImageSize != nil {
		return *m.UploadImageSize
	}
	return 0
}

func (m *CatalogFileUploadSpec) GetUploadTask() *EndpointTask {
	if m != nil {
		return m.UploadTask
	}
	return nil
}

func (m *CatalogFileUploadSpec) GetCatalogItemUuid() []byte {
	if m != nil {
		return m.CatalogItemUuid
	}
	return nil
}

type EndpointTask struct {
	// The task UUID of the task currently processing the file upload.
	TaskUuid []byte `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// The cluster UUID where the file upload is being processed.
	ClusterUuid []byte `protobuf:"bytes,2,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// The availability zone logical ID where the file upload is being
	// processed.
	AvailabilityZoneLogicalId *string `protobuf:"bytes,3,opt,name=availability_zone_logical_id,json=availabilityZoneLogicalId" json:"availability_zone_logical_id,omitempty"`
	// The Catalog UUID involved in this task.
	GlobalCatalogItemUuid []byte   `protobuf:"bytes,4,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *EndpointTask) Reset()         { *m = EndpointTask{} }
func (m *EndpointTask) String() string { return proto.CompactTextString(m) }
func (*EndpointTask) ProtoMessage()    {}
func (*EndpointTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{27}
}

func (m *EndpointTask) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EndpointTask.Unmarshal(m, b)
}
func (m *EndpointTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EndpointTask.Marshal(b, m, deterministic)
}
func (m *EndpointTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndpointTask.Merge(m, src)
}
func (m *EndpointTask) XXX_Size() int {
	return xxx_messageInfo_EndpointTask.Size(m)
}
func (m *EndpointTask) XXX_DiscardUnknown() {
	xxx_messageInfo_EndpointTask.DiscardUnknown(m)
}

var xxx_messageInfo_EndpointTask proto.InternalMessageInfo

func (m *EndpointTask) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *EndpointTask) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *EndpointTask) GetAvailabilityZoneLogicalId() string {
	if m != nil && m.AvailabilityZoneLogicalId != nil {
		return *m.AvailabilityZoneLogicalId
	}
	return ""
}

func (m *EndpointTask) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

type RemoteSeedingCatalogInfo struct {
	// Catalog item info.
	CatalogInfo *CatalogItemInfo `protobuf:"bytes,1,opt,name=catalog_info,json=catalogInfo" json:"catalog_info,omitempty"`
	// Path for file backing the catalog item on remote PE.
	PeFilesList          []*RemoteSeedingCatalogInfo_PeFiles `protobuf:"bytes,2,rep,name=pe_files_list,json=peFilesList" json:"pe_files_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *RemoteSeedingCatalogInfo) Reset()         { *m = RemoteSeedingCatalogInfo{} }
func (m *RemoteSeedingCatalogInfo) String() string { return proto.CompactTextString(m) }
func (*RemoteSeedingCatalogInfo) ProtoMessage()    {}
func (*RemoteSeedingCatalogInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{28}
}

func (m *RemoteSeedingCatalogInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteSeedingCatalogInfo.Unmarshal(m, b)
}
func (m *RemoteSeedingCatalogInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteSeedingCatalogInfo.Marshal(b, m, deterministic)
}
func (m *RemoteSeedingCatalogInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteSeedingCatalogInfo.Merge(m, src)
}
func (m *RemoteSeedingCatalogInfo) XXX_Size() int {
	return xxx_messageInfo_RemoteSeedingCatalogInfo.Size(m)
}
func (m *RemoteSeedingCatalogInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteSeedingCatalogInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteSeedingCatalogInfo proto.InternalMessageInfo

func (m *RemoteSeedingCatalogInfo) GetCatalogInfo() *CatalogItemInfo {
	if m != nil {
		return m.CatalogInfo
	}
	return nil
}

func (m *RemoteSeedingCatalogInfo) GetPeFilesList() []*RemoteSeedingCatalogInfo_PeFiles {
	if m != nil {
		return m.PeFilesList
	}
	return nil
}

type RemoteSeedingCatalogInfo_PeFiles struct {
	// Remote PE cluster UUID on which backing file for catalog exists.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Path for file backing the catalog item on remote PE.
	FilePathList         []string `protobuf:"bytes,2,rep,name=file_path_list,json=filePathList" json:"file_path_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteSeedingCatalogInfo_PeFiles) Reset()         { *m = RemoteSeedingCatalogInfo_PeFiles{} }
func (m *RemoteSeedingCatalogInfo_PeFiles) String() string { return proto.CompactTextString(m) }
func (*RemoteSeedingCatalogInfo_PeFiles) ProtoMessage()    {}
func (*RemoteSeedingCatalogInfo_PeFiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{28, 0}
}

func (m *RemoteSeedingCatalogInfo_PeFiles) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoteSeedingCatalogInfo_PeFiles.Unmarshal(m, b)
}
func (m *RemoteSeedingCatalogInfo_PeFiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoteSeedingCatalogInfo_PeFiles.Marshal(b, m, deterministic)
}
func (m *RemoteSeedingCatalogInfo_PeFiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteSeedingCatalogInfo_PeFiles.Merge(m, src)
}
func (m *RemoteSeedingCatalogInfo_PeFiles) XXX_Size() int {
	return xxx_messageInfo_RemoteSeedingCatalogInfo_PeFiles.Size(m)
}
func (m *RemoteSeedingCatalogInfo_PeFiles) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteSeedingCatalogInfo_PeFiles.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteSeedingCatalogInfo_PeFiles proto.InternalMessageInfo

func (m *RemoteSeedingCatalogInfo_PeFiles) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *RemoteSeedingCatalogInfo_PeFiles) GetFilePathList() []string {
	if m != nil {
		return m.FilePathList
	}
	return nil
}

type ClusterIpMapping struct {
	// PE cluster UUID.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Values in fields 2 and 3 are co-related by index in the list.
	// List of external IPs of the PE.
	IpList []string `protobuf:"bytes,2,rep,name=ip_list,json=ipList" json:"ip_list,omitempty"`
	// List of external ports of the PE's cerebro service.
	PortList             []int64  `protobuf:"varint,3,rep,name=port_list,json=portList" json:"port_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterIpMapping) Reset()         { *m = ClusterIpMapping{} }
func (m *ClusterIpMapping) String() string { return proto.CompactTextString(m) }
func (*ClusterIpMapping) ProtoMessage()    {}
func (*ClusterIpMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{29}
}

func (m *ClusterIpMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterIpMapping.Unmarshal(m, b)
}
func (m *ClusterIpMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterIpMapping.Marshal(b, m, deterministic)
}
func (m *ClusterIpMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterIpMapping.Merge(m, src)
}
func (m *ClusterIpMapping) XXX_Size() int {
	return xxx_messageInfo_ClusterIpMapping.Size(m)
}
func (m *ClusterIpMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterIpMapping.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterIpMapping proto.InternalMessageInfo

func (m *ClusterIpMapping) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *ClusterIpMapping) GetIpList() []string {
	if m != nil {
		return m.IpList
	}
	return nil
}

func (m *ClusterIpMapping) GetPortList() []int64 {
	if m != nil {
		return m.PortList
	}
	return nil
}

type CatalogPlacementPolicyInfo struct {
	// Policy UUID
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Policy name
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Policy description
	Description *string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Policy placement type
	PlacementType *CatalogPlacementPolicyInfo_PlacementType `protobuf:"varint,4,opt,name=placement_type,json=placementType,enum=nutanix.catalog.CatalogPlacementPolicyInfo_PlacementType" json:"placement_type,omitempty"`
	// Filter object UUIDs for Catalog Item and Cluster
	CatalogFilterUuid []byte `protobuf:"bytes,5,opt,name=catalog_filter_uuid,json=catalogFilterUuid" json:"catalog_filter_uuid,omitempty"`
	ClusterFilterUuid []byte `protobuf:"bytes,6,opt,name=cluster_filter_uuid,json=clusterFilterUuid" json:"cluster_filter_uuid,omitempty"`
	// Catalog item type on which the policy is enforced.
	ItemType *CatalogItemInfo_CatalogItemType `protobuf:"varint,7,opt,name=item_type,json=itemType,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"item_type,omitempty"`
	// Logical timestamp
	LogicalTimestamp     *int64   `protobuf:"varint,8,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyInfo) Reset()         { *m = CatalogPlacementPolicyInfo{} }
func (m *CatalogPlacementPolicyInfo) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyInfo) ProtoMessage()    {}
func (*CatalogPlacementPolicyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{30}
}

func (m *CatalogPlacementPolicyInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyInfo.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyInfo.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyInfo.Merge(m, src)
}
func (m *CatalogPlacementPolicyInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyInfo.Size(m)
}
func (m *CatalogPlacementPolicyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyInfo proto.InternalMessageInfo

func (m *CatalogPlacementPolicyInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *CatalogPlacementPolicyInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogPlacementPolicyInfo) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *CatalogPlacementPolicyInfo) GetPlacementType() CatalogPlacementPolicyInfo_PlacementType {
	if m != nil && m.PlacementType != nil {
		return *m.PlacementType
	}
	return CatalogPlacementPolicyInfo_kAtLeast
}

func (m *CatalogPlacementPolicyInfo) GetCatalogFilterUuid() []byte {
	if m != nil {
		return m.CatalogFilterUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyInfo) GetClusterFilterUuid() []byte {
	if m != nil {
		return m.ClusterFilterUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyInfo) GetItemType() CatalogItemInfo_CatalogItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return CatalogItemInfo_kImage
}

func (m *CatalogPlacementPolicyInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

type CatalogPlacementPolicyCreateSpec struct {
	// Placement policy object UUID
	PolicyUuid []byte `protobuf:"bytes,1,opt,name=policy_uuid,json=policyUuid" json:"policy_uuid,omitempty"`
	// Policy name
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Policy Description
	Description *string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Image fileter categories
	CatalogFilter *CatalogPlacementPolicyCreateSpec_EntityFilter `protobuf:"bytes,4,opt,name=catalog_filter,json=catalogFilter" json:"catalog_filter,omitempty"`
	// Cluster fileter categories
	ClusterFilter *CatalogPlacementPolicyCreateSpec_EntityFilter `protobuf:"bytes,5,opt,name=cluster_filter,json=clusterFilter" json:"cluster_filter,omitempty"`
	// Catalog item type on which the policy is enforced.
	ItemType *CatalogItemInfo_CatalogItemType `protobuf:"varint,6,opt,name=item_type,json=itemType,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"item_type,omitempty"`
	// Placement policy semantic
	PlacementType        *CatalogPlacementPolicyInfo_PlacementType `protobuf:"varint,7,opt,name=placement_type,json=placementType,enum=nutanix.catalog.CatalogPlacementPolicyInfo_PlacementType" json:"placement_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *CatalogPlacementPolicyCreateSpec) Reset()         { *m = CatalogPlacementPolicyCreateSpec{} }
func (m *CatalogPlacementPolicyCreateSpec) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyCreateSpec) ProtoMessage()    {}
func (*CatalogPlacementPolicyCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{31}
}

func (m *CatalogPlacementPolicyCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyCreateSpec.Merge(m, src)
}
func (m *CatalogPlacementPolicyCreateSpec) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec.Size(m)
}
func (m *CatalogPlacementPolicyCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyCreateSpec proto.InternalMessageInfo

func (m *CatalogPlacementPolicyCreateSpec) GetPolicyUuid() []byte {
	if m != nil {
		return m.PolicyUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyCreateSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogPlacementPolicyCreateSpec) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *CatalogPlacementPolicyCreateSpec) GetCatalogFilter() *CatalogPlacementPolicyCreateSpec_EntityFilter {
	if m != nil {
		return m.CatalogFilter
	}
	return nil
}

func (m *CatalogPlacementPolicyCreateSpec) GetClusterFilter() *CatalogPlacementPolicyCreateSpec_EntityFilter {
	if m != nil {
		return m.ClusterFilter
	}
	return nil
}

func (m *CatalogPlacementPolicyCreateSpec) GetItemType() CatalogItemInfo_CatalogItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return CatalogItemInfo_kImage
}

func (m *CatalogPlacementPolicyCreateSpec) GetPlacementType() CatalogPlacementPolicyInfo_PlacementType {
	if m != nil && m.PlacementType != nil {
		return *m.PlacementType
	}
	return CatalogPlacementPolicyInfo_kAtLeast
}

type CatalogPlacementPolicyCreateSpec_CategoryKeyValue struct {
	// The category key
	CategoryKey *string `protobuf:"bytes,1,opt,name=category_key,json=categoryKey" json:"category_key,omitempty"`
	// List of category values for the given key
	CategoryValues       []string `protobuf:"bytes,2,rep,name=category_values,json=categoryValues" json:"category_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) Reset() {
	*m = CatalogPlacementPolicyCreateSpec_CategoryKeyValue{}
}
func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) String() string {
	return proto.CompactTextString(m)
}
func (*CatalogPlacementPolicyCreateSpec_CategoryKeyValue) ProtoMessage() {}
func (*CatalogPlacementPolicyCreateSpec_CategoryKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{31, 0}
}

func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec_CategoryKeyValue.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec_CategoryKeyValue.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyCreateSpec_CategoryKeyValue.Merge(m, src)
}
func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec_CategoryKeyValue.Size(m)
}
func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyCreateSpec_CategoryKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyCreateSpec_CategoryKeyValue proto.InternalMessageInfo

func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) GetCategoryKey() string {
	if m != nil && m.CategoryKey != nil {
		return *m.CategoryKey
	}
	return ""
}

func (m *CatalogPlacementPolicyCreateSpec_CategoryKeyValue) GetCategoryValues() []string {
	if m != nil {
		return m.CategoryValues
	}
	return nil
}

type CatalogPlacementPolicyCreateSpec_EntityFilter struct {
	// Entity kind
	EntityKind *string `protobuf:"bytes,1,opt,name=entity_kind,json=entityKind" json:"entity_kind,omitempty"`
	// Matching type
	MatchType *CatalogPlacementPolicyCreateSpec_CategoryMatchType `protobuf:"varint,2,opt,name=match_type,json=matchType,enum=nutanix.catalog.CatalogPlacementPolicyCreateSpec_CategoryMatchType" json:"match_type,omitempty"`
	// Categories
	Categories           []*CatalogPlacementPolicyCreateSpec_CategoryKeyValue `protobuf:"bytes,3,rep,name=categories" json:"categories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) Reset() {
	*m = CatalogPlacementPolicyCreateSpec_EntityFilter{}
}
func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) String() string {
	return proto.CompactTextString(m)
}
func (*CatalogPlacementPolicyCreateSpec_EntityFilter) ProtoMessage() {}
func (*CatalogPlacementPolicyCreateSpec_EntityFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{31, 1}
}

func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec_EntityFilter.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec_EntityFilter.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyCreateSpec_EntityFilter.Merge(m, src)
}
func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyCreateSpec_EntityFilter.Size(m)
}
func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyCreateSpec_EntityFilter.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyCreateSpec_EntityFilter proto.InternalMessageInfo

func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) GetEntityKind() string {
	if m != nil && m.EntityKind != nil {
		return *m.EntityKind
	}
	return ""
}

func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) GetMatchType() CatalogPlacementPolicyCreateSpec_CategoryMatchType {
	if m != nil && m.MatchType != nil {
		return *m.MatchType
	}
	return CatalogPlacementPolicyCreateSpec_kAll
}

func (m *CatalogPlacementPolicyCreateSpec_EntityFilter) GetCategories() []*CatalogPlacementPolicyCreateSpec_CategoryKeyValue {
	if m != nil {
		return m.Categories
	}
	return nil
}

type CatalogPlacementPolicyStatusInfo struct {
	// UUID of the policy status info entry
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Global catalog item UUID
	GlobalCatalogItemUuid []byte `protobuf:"bytes,2,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// List of applicable policies with their status
	PolicyStatusList []*CatalogPlacementPolicyStatusInfo_PerPolicyInfo `protobuf:"bytes,3,rep,name=policy_status_list,json=policyStatusList" json:"policy_status_list,omitempty"`
	// Placement policy status version
	LogicalTimestamp     *int64   `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyStatusInfo) Reset()         { *m = CatalogPlacementPolicyStatusInfo{} }
func (m *CatalogPlacementPolicyStatusInfo) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyStatusInfo) ProtoMessage()    {}
func (*CatalogPlacementPolicyStatusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{32}
}

func (m *CatalogPlacementPolicyStatusInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyStatusInfo.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyStatusInfo.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyStatusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyStatusInfo.Merge(m, src)
}
func (m *CatalogPlacementPolicyStatusInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyStatusInfo.Size(m)
}
func (m *CatalogPlacementPolicyStatusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyStatusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyStatusInfo proto.InternalMessageInfo

func (m *CatalogPlacementPolicyStatusInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *CatalogPlacementPolicyStatusInfo) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyStatusInfo) GetPolicyStatusList() []*CatalogPlacementPolicyStatusInfo_PerPolicyInfo {
	if m != nil {
		return m.PolicyStatusList
	}
	return nil
}

func (m *CatalogPlacementPolicyStatusInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

type CatalogPlacementPolicyStatusInfo_PerPolicyInfo struct {
	// Policy UUID
	PolicyUuid []byte `protobuf:"bytes,1,opt,name=policy_uuid,json=policyUuid" json:"policy_uuid,omitempty"`
	// Policy state
	State *CatalogPlacementPolicyStatusInfo_PolicyState `protobuf:"varint,2,opt,name=state,enum=nutanix.catalog.CatalogPlacementPolicyStatusInfo_PolicyState" json:"state,omitempty"`
	// Policy action
	Action *CatalogPlacementPolicyStatusInfo_PolicyAction `protobuf:"varint,3,opt,name=action,enum=nutanix.catalog.CatalogPlacementPolicyStatusInfo_PolicyAction" json:"action,omitempty"`
	// Conflicting policy UUID list
	ConflictingPolicyUuids [][]byte `protobuf:"bytes,4,rep,name=conflicting_policy_uuids,json=conflictingPolicyUuids" json:"conflicting_policy_uuids,omitempty"`
	// Eventual state of the policy
	EventualState *CatalogPlacementPolicyStatusInfo_PolicyState `protobuf:"varint,5,opt,name=eventual_state,json=eventualState,enum=nutanix.catalog.CatalogPlacementPolicyStatusInfo_PolicyState" json:"eventual_state,omitempty"`
	// List of clusters which are part of this policy and
	// list of clusters where catalog item exists which are
	// also part of this policy.
	// This is populated only in Get RPC response and not
	// stored in DB.
	ClusterList          [][]byte `protobuf:"bytes,6,rep,name=cluster_list,json=clusterList" json:"cluster_list,omitempty"`
	EnforcedClusterList  [][]byte `protobuf:"bytes,7,rep,name=enforced_cluster_list,json=enforcedClusterList" json:"enforced_cluster_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) Reset() {
	*m = CatalogPlacementPolicyStatusInfo_PerPolicyInfo{}
}
func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) String() string {
	return proto.CompactTextString(m)
}
func (*CatalogPlacementPolicyStatusInfo_PerPolicyInfo) ProtoMessage() {}
func (*CatalogPlacementPolicyStatusInfo_PerPolicyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{32, 0}
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyStatusInfo_PerPolicyInfo.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyStatusInfo_PerPolicyInfo.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyStatusInfo_PerPolicyInfo.Merge(m, src)
}
func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyStatusInfo_PerPolicyInfo.Size(m)
}
func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyStatusInfo_PerPolicyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyStatusInfo_PerPolicyInfo proto.InternalMessageInfo

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetPolicyUuid() []byte {
	if m != nil {
		return m.PolicyUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetState() CatalogPlacementPolicyStatusInfo_PolicyState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return CatalogPlacementPolicyStatusInfo_kCompliant
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetAction() CatalogPlacementPolicyStatusInfo_PolicyAction {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return CatalogPlacementPolicyStatusInfo_kEnforcing
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetConflictingPolicyUuids() [][]byte {
	if m != nil {
		return m.ConflictingPolicyUuids
	}
	return nil
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetEventualState() CatalogPlacementPolicyStatusInfo_PolicyState {
	if m != nil && m.EventualState != nil {
		return *m.EventualState
	}
	return CatalogPlacementPolicyStatusInfo_kCompliant
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetClusterList() [][]byte {
	if m != nil {
		return m.ClusterList
	}
	return nil
}

func (m *CatalogPlacementPolicyStatusInfo_PerPolicyInfo) GetEnforcedClusterList() [][]byte {
	if m != nil {
		return m.EnforcedClusterList
	}
	return nil
}

type CatalogRateLimitFilter struct {
	// Matching type
	MatchType *CatalogRateLimitFilter_CategoryMatchType `protobuf:"varint,2,opt,name=match_type,json=matchType,enum=nutanix.catalog.CatalogRateLimitFilter_CategoryMatchType" json:"match_type,omitempty"`
	// Categories
	Categories           []*CatalogRateLimitFilter_CategoryKeyValue `protobuf:"bytes,3,rep,name=categories" json:"categories,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *CatalogRateLimitFilter) Reset()         { *m = CatalogRateLimitFilter{} }
func (m *CatalogRateLimitFilter) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitFilter) ProtoMessage()    {}
func (*CatalogRateLimitFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{33}
}

func (m *CatalogRateLimitFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitFilter.Unmarshal(m, b)
}
func (m *CatalogRateLimitFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitFilter.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitFilter.Merge(m, src)
}
func (m *CatalogRateLimitFilter) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitFilter.Size(m)
}
func (m *CatalogRateLimitFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitFilter.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitFilter proto.InternalMessageInfo

func (m *CatalogRateLimitFilter) GetMatchType() CatalogRateLimitFilter_CategoryMatchType {
	if m != nil && m.MatchType != nil {
		return *m.MatchType
	}
	return CatalogRateLimitFilter_kAll
}

func (m *CatalogRateLimitFilter) GetCategories() []*CatalogRateLimitFilter_CategoryKeyValue {
	if m != nil {
		return m.Categories
	}
	return nil
}

type CatalogRateLimitFilter_CategoryKeyValue struct {
	// The category key
	CategoryKey *string `protobuf:"bytes,1,opt,name=category_key,json=categoryKey" json:"category_key,omitempty"`
	// List of category values for the given key
	CategoryValues       []string `protobuf:"bytes,2,rep,name=category_values,json=categoryValues" json:"category_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitFilter_CategoryKeyValue) Reset() {
	*m = CatalogRateLimitFilter_CategoryKeyValue{}
}
func (m *CatalogRateLimitFilter_CategoryKeyValue) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitFilter_CategoryKeyValue) ProtoMessage()    {}
func (*CatalogRateLimitFilter_CategoryKeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{33, 0}
}

func (m *CatalogRateLimitFilter_CategoryKeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitFilter_CategoryKeyValue.Unmarshal(m, b)
}
func (m *CatalogRateLimitFilter_CategoryKeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitFilter_CategoryKeyValue.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitFilter_CategoryKeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitFilter_CategoryKeyValue.Merge(m, src)
}
func (m *CatalogRateLimitFilter_CategoryKeyValue) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitFilter_CategoryKeyValue.Size(m)
}
func (m *CatalogRateLimitFilter_CategoryKeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitFilter_CategoryKeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitFilter_CategoryKeyValue proto.InternalMessageInfo

func (m *CatalogRateLimitFilter_CategoryKeyValue) GetCategoryKey() string {
	if m != nil && m.CategoryKey != nil {
		return *m.CategoryKey
	}
	return ""
}

func (m *CatalogRateLimitFilter_CategoryKeyValue) GetCategoryValues() []string {
	if m != nil {
		return m.CategoryValues
	}
	return nil
}

type CatalogRateLimitSpec struct {
	// Rate limit UUID for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Rate limit name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Rate limit description.
	Description *string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Rate limit enforced KBps.
	RateLimitKbps *uint64 `protobuf:"varint,4,opt,name=rate_limit_kbps,json=rateLimitKbps" json:"rate_limit_kbps,omitempty"`
	// Rate limit cluster filter.
	ClusterFilter        *CatalogRateLimitFilter `protobuf:"bytes,5,opt,name=cluster_filter,json=clusterFilter" json:"cluster_filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CatalogRateLimitSpec) Reset()         { *m = CatalogRateLimitSpec{} }
func (m *CatalogRateLimitSpec) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitSpec) ProtoMessage()    {}
func (*CatalogRateLimitSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{34}
}

func (m *CatalogRateLimitSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitSpec.Unmarshal(m, b)
}
func (m *CatalogRateLimitSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitSpec.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitSpec.Merge(m, src)
}
func (m *CatalogRateLimitSpec) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitSpec.Size(m)
}
func (m *CatalogRateLimitSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitSpec proto.InternalMessageInfo

func (m *CatalogRateLimitSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *CatalogRateLimitSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogRateLimitSpec) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *CatalogRateLimitSpec) GetRateLimitKbps() uint64 {
	if m != nil && m.RateLimitKbps != nil {
		return *m.RateLimitKbps
	}
	return 0
}

func (m *CatalogRateLimitSpec) GetClusterFilter() *CatalogRateLimitFilter {
	if m != nil {
		return m.ClusterFilter
	}
	return nil
}

type CatalogRateLimitInfo struct {
	// Entity UUID.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Entity name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Entity description.
	Description *string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Enforced rate limit in KBps.
	RateLimitKbps *uint64 `protobuf:"varint,4,opt,name=rate_limit_kbps,json=rateLimitKbps" json:"rate_limit_kbps,omitempty"`
	// Category based filter UUID.
	ClusterFilterUuid []byte `protobuf:"bytes,5,opt,name=cluster_filter_uuid,json=clusterFilterUuid" json:"cluster_filter_uuid,omitempty"`
	// Entity version.
	LogicalTimestamp     *int64                                           `protobuf:"varint,6,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	Status               *CatalogRateLimitInfo_CatalogRateLimitStatusInfo `protobuf:"bytes,7,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *CatalogRateLimitInfo) Reset()         { *m = CatalogRateLimitInfo{} }
func (m *CatalogRateLimitInfo) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitInfo) ProtoMessage()    {}
func (*CatalogRateLimitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{35}
}

func (m *CatalogRateLimitInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitInfo.Unmarshal(m, b)
}
func (m *CatalogRateLimitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitInfo.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitInfo.Merge(m, src)
}
func (m *CatalogRateLimitInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitInfo.Size(m)
}
func (m *CatalogRateLimitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitInfo proto.InternalMessageInfo

func (m *CatalogRateLimitInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *CatalogRateLimitInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogRateLimitInfo) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *CatalogRateLimitInfo) GetRateLimitKbps() uint64 {
	if m != nil && m.RateLimitKbps != nil {
		return *m.RateLimitKbps
	}
	return 0
}

func (m *CatalogRateLimitInfo) GetClusterFilterUuid() []byte {
	if m != nil {
		return m.ClusterFilterUuid
	}
	return nil
}

func (m *CatalogRateLimitInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *CatalogRateLimitInfo) GetStatus() *CatalogRateLimitInfo_CatalogRateLimitStatusInfo {
	if m != nil {
		return m.Status
	}
	return nil
}

type CatalogRateLimitInfo_CatalogRateLimitStatusInfo struct {
	// The current filter params of the rate limit entry.
	ClusterFilter *CatalogRateLimitFilter `protobuf:"bytes,1,opt,name=cluster_filter,json=clusterFilter" json:"cluster_filter,omitempty"`
	// Has an entry for each cluster to which this Rate Limit applies, even when
	// it is not the effective Rate Limit.
	ClusterStatusList []*CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo `protobuf:"bytes,2,rep,name=cluster_status_list,json=clusterStatusList" json:"cluster_status_list,omitempty"`
	// A list of cluster UUIDs for clusters that match the Rate Limit cluster
	// filter but that do not support rate limiting due to their version.
	UnsupportedClusterUuidList [][]byte `protobuf:"bytes,3,rep,name=unsupported_cluster_uuid_list,json=unsupportedClusterUuidList" json:"unsupported_cluster_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) Reset() {
	*m = CatalogRateLimitInfo_CatalogRateLimitStatusInfo{}
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) String() string {
	return proto.CompactTextString(m)
}
func (*CatalogRateLimitInfo_CatalogRateLimitStatusInfo) ProtoMessage() {}
func (*CatalogRateLimitInfo_CatalogRateLimitStatusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{35, 0}
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo.Unmarshal(m, b)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo.Merge(m, src)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo.Size(m)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo proto.InternalMessageInfo

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) GetClusterFilter() *CatalogRateLimitFilter {
	if m != nil {
		return m.ClusterFilter
	}
	return nil
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) GetClusterStatusList() []*CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo {
	if m != nil {
		return m.ClusterStatusList
	}
	return nil
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo) GetUnsupportedClusterUuidList() [][]byte {
	if m != nil {
		return m.UnsupportedClusterUuidList
	}
	return nil
}

type CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo struct {
	// UUID of a cluster affected by the Rate Limit.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// The effectively enforced Rate Limit for the cluster.
	EffectiveRateLimitKbps *uint64 `protobuf:"varint,2,opt,name=effective_rate_limit_kbps,json=effectiveRateLimitKbps" json:"effective_rate_limit_kbps,omitempty"`
	// The UUID of the effective Rate Limit applied to the cluster
	EffectiveRateLimitUuid []byte   `protobuf:"bytes,3,opt,name=effective_rate_limit_uuid,json=effectiveRateLimitUuid" json:"effective_rate_limit_uuid,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) Reset() {
	*m = CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo{}
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) String() string {
	return proto.CompactTextString(m)
}
func (*CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) ProtoMessage() {}
func (*CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{35, 0, 0}
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo.Unmarshal(m, b)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo.Merge(m, src)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo.Size(m)
}
func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo proto.InternalMessageInfo

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) GetEffectiveRateLimitKbps() uint64 {
	if m != nil && m.EffectiveRateLimitKbps != nil {
		return *m.EffectiveRateLimitKbps
	}
	return 0
}

func (m *CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo) GetEffectiveRateLimitUuid() []byte {
	if m != nil {
		return m.EffectiveRateLimitUuid
	}
	return nil
}

type CatalogComparisonChecksum struct {
	// Catalog Item Global UUID
	GlobalCatalogItemUuid []byte `protobuf:"bytes,1,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// Catalog item name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Annotation describing the catalog item.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Catalog item type.
	ItemType *CatalogItemInfo_CatalogItemType `protobuf:"varint,4,opt,name=item_type,json=itemType,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"item_type,omitempty"`
	// Catalog item version.
	Version *int64 `protobuf:"varint,5,opt,name=version" json:"version,omitempty"`
	// Number of source groups present in the given catalog item version
	SourceGroupCount *int64 `protobuf:"varint,6,opt,name=source_group_count,json=sourceGroupCount" json:"source_group_count,omitempty"`
	// UUID of the source groups
	SourceGroupUuidList  [][]byte `protobuf:"bytes,7,rep,name=source_group_uuid_list,json=sourceGroupUuidList" json:"source_group_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogComparisonChecksum) Reset()         { *m = CatalogComparisonChecksum{} }
func (m *CatalogComparisonChecksum) String() string { return proto.CompactTextString(m) }
func (*CatalogComparisonChecksum) ProtoMessage()    {}
func (*CatalogComparisonChecksum) Descriptor() ([]byte, []int) {
	return fileDescriptor_e979d748b5c2694e, []int{36}
}

func (m *CatalogComparisonChecksum) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogComparisonChecksum.Unmarshal(m, b)
}
func (m *CatalogComparisonChecksum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogComparisonChecksum.Marshal(b, m, deterministic)
}
func (m *CatalogComparisonChecksum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogComparisonChecksum.Merge(m, src)
}
func (m *CatalogComparisonChecksum) XXX_Size() int {
	return xxx_messageInfo_CatalogComparisonChecksum.Size(m)
}
func (m *CatalogComparisonChecksum) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogComparisonChecksum.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogComparisonChecksum proto.InternalMessageInfo

func (m *CatalogComparisonChecksum) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogComparisonChecksum) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *CatalogComparisonChecksum) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *CatalogComparisonChecksum) GetItemType() CatalogItemInfo_CatalogItemType {
	if m != nil && m.ItemType != nil {
		return *m.ItemType
	}
	return CatalogItemInfo_kImage
}

func (m *CatalogComparisonChecksum) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *CatalogComparisonChecksum) GetSourceGroupCount() int64 {
	if m != nil && m.SourceGroupCount != nil {
		return *m.SourceGroupCount
	}
	return 0
}

func (m *CatalogComparisonChecksum) GetSourceGroupUuidList() [][]byte {
	if m != nil {
		return m.SourceGroupUuidList
	}
	return nil
}

func init() {
	proto.RegisterEnum("nutanix.catalog.CatalogItemInfo_CatalogItemType", CatalogItemInfo_CatalogItemType_name, CatalogItemInfo_CatalogItemType_value)
	proto.RegisterEnum("nutanix.catalog.FileInfo_ChecksumType", FileInfo_ChecksumType_name, FileInfo_ChecksumType_value)
	proto.RegisterEnum("nutanix.catalog.CatalogItemUpdateSpec_CatalogItemType", CatalogItemUpdateSpec_CatalogItemType_name, CatalogItemUpdateSpec_CatalogItemType_value)
	proto.RegisterEnum("nutanix.catalog.Task_Entity", Task_Entity_name, Task_Entity_value)
	proto.RegisterEnum("nutanix.catalog.Task_OperationType", Task_OperationType_name, Task_OperationType_value)
	proto.RegisterEnum("nutanix.catalog.Task_Status", Task_Status_name, Task_Status_value)
	proto.RegisterEnum("nutanix.catalog.Task_Capability", Task_Capability_name, Task_Capability_value)
	proto.RegisterEnum("nutanix.catalog.CatalogPlacementPolicyInfo_PlacementType", CatalogPlacementPolicyInfo_PlacementType_name, CatalogPlacementPolicyInfo_PlacementType_value)
	proto.RegisterEnum("nutanix.catalog.CatalogPlacementPolicyCreateSpec_CategoryMatchType", CatalogPlacementPolicyCreateSpec_CategoryMatchType_name, CatalogPlacementPolicyCreateSpec_CategoryMatchType_value)
	proto.RegisterEnum("nutanix.catalog.CatalogPlacementPolicyStatusInfo_PolicyState", CatalogPlacementPolicyStatusInfo_PolicyState_name, CatalogPlacementPolicyStatusInfo_PolicyState_value)
	proto.RegisterEnum("nutanix.catalog.CatalogPlacementPolicyStatusInfo_PolicyAction", CatalogPlacementPolicyStatusInfo_PolicyAction_name, CatalogPlacementPolicyStatusInfo_PolicyAction_value)
	proto.RegisterEnum("nutanix.catalog.CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus", CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus_name, CatalogPlacementPolicyStatusInfo_CurrentPolicyStatus_value)
	proto.RegisterEnum("nutanix.catalog.CatalogRateLimitFilter_CategoryMatchType", CatalogRateLimitFilter_CategoryMatchType_name, CatalogRateLimitFilter_CategoryMatchType_value)
	proto.RegisterType((*VmTemplateVersionInfo)(nil), "nutanix.catalog.VmTemplateVersionInfo")
	proto.RegisterType((*CatalogItemInfo)(nil), "nutanix.catalog.CatalogItemInfo")
	proto.RegisterType((*CatalogItemInfo_CatalogItemLocation)(nil), "nutanix.catalog.CatalogItemInfo.CatalogItemLocation")
	proto.RegisterType((*CatalogVersion)(nil), "nutanix.catalog.CatalogVersion")
	proto.RegisterType((*SourceGroup)(nil), "nutanix.catalog.SourceGroup")
	proto.RegisterType((*Source)(nil), "nutanix.catalog.Source")
	proto.RegisterType((*FileInfo)(nil), "nutanix.catalog.FileInfo")
	proto.RegisterType((*FileLocation)(nil), "nutanix.catalog.FileLocation")
	proto.RegisterType((*CatalogItemCreateSpec)(nil), "nutanix.catalog.CatalogItemCreateSpec")
	proto.RegisterType((*SourceGroupSpec)(nil), "nutanix.catalog.SourceGroupSpec")
	proto.RegisterType((*SourceSpec)(nil), "nutanix.catalog.SourceSpec")
	proto.RegisterType((*CatalogItemId)(nil), "nutanix.catalog.CatalogItemId")
	proto.RegisterType((*CatalogItemUpdateSpec)(nil), "nutanix.catalog.CatalogItemUpdateSpec")
	proto.RegisterType((*PayloadValue)(nil), "nutanix.catalog.PayloadValue")
	proto.RegisterType((*PayloadOrEmbeddedValue)(nil), "nutanix.catalog.PayloadOrEmbeddedValue")
	proto.RegisterType((*MetaRequest)(nil), "nutanix.catalog.MetaRequest")
	proto.RegisterType((*MetaResponse)(nil), "nutanix.catalog.MetaResponse")
	proto.RegisterType((*Task)(nil), "nutanix.catalog.Task")
	proto.RegisterType((*Task_EntityId)(nil), "nutanix.catalog.Task.EntityId")
	proto.RegisterType((*FileImportSpec)(nil), "nutanix.catalog.FileImportSpec")
	proto.RegisterType((*RemoteImportSpec)(nil), "nutanix.catalog.RemoteImportSpec")
	proto.RegisterType((*LocalImportSpec)(nil), "nutanix.catalog.LocalImportSpec")
	proto.RegisterType((*ExistingFileSpec)(nil), "nutanix.catalog.ExistingFileSpec")
	proto.RegisterType((*AuthenticationCredentials)(nil), "nutanix.catalog.AuthenticationCredentials")
	proto.RegisterType((*BasicAuth)(nil), "nutanix.catalog.BasicAuth")
	proto.RegisterType((*AWSAuth)(nil), "nutanix.catalog.AWSAuth")
	proto.RegisterType((*ImageRequest)(nil), "nutanix.catalog.ImageRequest")
	proto.RegisterType((*ImageResponse)(nil), "nutanix.catalog.ImageResponse")
	proto.RegisterType((*CatalogFileUploadSpec)(nil), "nutanix.catalog.CatalogFileUploadSpec")
	proto.RegisterType((*EndpointTask)(nil), "nutanix.catalog.EndpointTask")
	proto.RegisterType((*RemoteSeedingCatalogInfo)(nil), "nutanix.catalog.RemoteSeedingCatalogInfo")
	proto.RegisterType((*RemoteSeedingCatalogInfo_PeFiles)(nil), "nutanix.catalog.RemoteSeedingCatalogInfo.PeFiles")
	proto.RegisterType((*ClusterIpMapping)(nil), "nutanix.catalog.ClusterIpMapping")
	proto.RegisterType((*CatalogPlacementPolicyInfo)(nil), "nutanix.catalog.CatalogPlacementPolicyInfo")
	proto.RegisterType((*CatalogPlacementPolicyCreateSpec)(nil), "nutanix.catalog.CatalogPlacementPolicyCreateSpec")
	proto.RegisterType((*CatalogPlacementPolicyCreateSpec_CategoryKeyValue)(nil), "nutanix.catalog.CatalogPlacementPolicyCreateSpec.CategoryKeyValue")
	proto.RegisterType((*CatalogPlacementPolicyCreateSpec_EntityFilter)(nil), "nutanix.catalog.CatalogPlacementPolicyCreateSpec.EntityFilter")
	proto.RegisterType((*CatalogPlacementPolicyStatusInfo)(nil), "nutanix.catalog.CatalogPlacementPolicyStatusInfo")
	proto.RegisterType((*CatalogPlacementPolicyStatusInfo_PerPolicyInfo)(nil), "nutanix.catalog.CatalogPlacementPolicyStatusInfo.PerPolicyInfo")
	proto.RegisterType((*CatalogRateLimitFilter)(nil), "nutanix.catalog.CatalogRateLimitFilter")
	proto.RegisterType((*CatalogRateLimitFilter_CategoryKeyValue)(nil), "nutanix.catalog.CatalogRateLimitFilter.CategoryKeyValue")
	proto.RegisterType((*CatalogRateLimitSpec)(nil), "nutanix.catalog.CatalogRateLimitSpec")
	proto.RegisterType((*CatalogRateLimitInfo)(nil), "nutanix.catalog.CatalogRateLimitInfo")
	proto.RegisterType((*CatalogRateLimitInfo_CatalogRateLimitStatusInfo)(nil), "nutanix.catalog.CatalogRateLimitInfo.CatalogRateLimitStatusInfo")
	proto.RegisterType((*CatalogRateLimitInfo_CatalogRateLimitStatusInfo_ClusterRateLimitStatusInfo)(nil), "nutanix.catalog.CatalogRateLimitInfo.CatalogRateLimitStatusInfo.ClusterRateLimitStatusInfo")
	proto.RegisterType((*CatalogComparisonChecksum)(nil), "nutanix.catalog.CatalogComparisonChecksum")
}

func init() { proto.RegisterFile("catalog/catalog_types.proto", fileDescriptor_e979d748b5c2694e) }

var fileDescriptor_e979d748b5c2694e = []byte{
	// 4080 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x3b, 0x5d, 0x6f, 0xdc, 0x48,
	0x72, 0x98, 0x0f, 0xcd, 0x47, 0xcd, 0x87, 0xa8, 0x96, 0x25, 0x8f, 0xe4, 0x2f, 0x99, 0xde, 0x5d,
	0x0b, 0xce, 0x42, 0xde, 0xf5, 0x25, 0xbb, 0xeb, 0x03, 0xee, 0x76, 0xe5, 0x59, 0xdb, 0xeb, 0xd8,
	0x5e, 0x2b, 0x94, 0xed, 0x6c, 0x2e, 0x41, 0x78, 0x14, 0xd9, 0x33, 0x26, 0x86, 0x43, 0xf2, 0xc8,
	0xa6, 0x6c, 0xed, 0x43, 0x80, 0x3c, 0x04, 0x01, 0x72, 0xc8, 0x5b, 0x10, 0x20, 0x40, 0x92, 0x7b,
	0xc8, 0x73, 0x10, 0x20, 0x40, 0x90, 0xbf, 0x90, 0xd7, 0x00, 0x17, 0x20, 0x79, 0xc9, 0xbf, 0x08,
	0x82, 0x20, 0x2f, 0x87, 0xae, 0x6e, 0x92, 0xcd, 0x19, 0xce, 0x48, 0xb2, 0xf7, 0x0e, 0xfb, 0xa4,
	0x61, 0x55, 0x75, 0xb1, 0xeb, 0xb3, 0xab, 0xaa, 0x29, 0xb8, 0x64, 0x5b, 0xcc, 0xf2, 0x82, 0xf1,
	0x6d, 0xf9, 0xd7, 0x64, 0x27, 0x21, 0x8d, 0xf7, 0xc2, 0x28, 0x60, 0x01, 0x59, 0xf5, 0x13, 0x66,
	0xf9, 0xee, 0x9b, 0x3d, 0x89, 0xdc, 0xbe, 0x66, 0xd9, 0x51, 0x10, 0x06, 0x9e, 0x1b, 0xdf, 0xce,
	0x7e, 0x99, 0x34, 0x8a, 0x82, 0x48, 0xac, 0xd8, 0xbe, 0x51, 0x46, 0xe0, 0xfa, 0x8c, 0x46, 0x23,
	0xcb, 0xa6, 0x92, 0x68, 0xee, 0x9d, 0x2a, 0x87, 0xed, 0x84, 0xb9, 0xde, 0xed, 0xd8, 0x33, 0x8f,
	0x92, 0x51, 0x7c, 0xdb, 0xa7, 0xec, 0x76, 0x14, 0xda, 0x02, 0xa7, 0xff, 0x14, 0x36, 0x5e, 0x4e,
	0x9f, 0xd3, 0x69, 0xe8, 0x59, 0x8c, 0xbe, 0xa4, 0x51, 0xec, 0x06, 0xfe, 0x23, 0x7f, 0x14, 0x90,
	0x3d, 0x58, 0x8f, 0xa8, 0x1d, 0x1c, 0xd3, 0xe8, 0xc4, 0x0c, 0x03, 0xd7, 0x67, 0x66, 0x92, 0xb8,
	0xce, 0xa0, 0xb2, 0x53, 0xd9, 0xed, 0x1a, 0x6b, 0x29, 0xea, 0x80, 0x63, 0x5e, 0x24, 0xae, 0x43,
	0x2e, 0x42, 0xf3, 0x78, 0x6a, 0xc6, 0x21, 0xb5, 0x07, 0xd5, 0x9d, 0xca, 0x6e, 0xdb, 0x68, 0x1c,
	0x4f, 0x0f, 0x43, 0x6a, 0xeb, 0x7f, 0xd6, 0x82, 0xd5, 0xa1, 0xd8, 0xd5, 0x23, 0x46, 0xa7, 0xc8,
	0x9c, 0x40, 0x5d, 0xe1, 0x86, 0xbf, 0x39, 0xcc, 0xb7, 0xa6, 0x54, 0xae, 0xc6, 0xdf, 0xe4, 0x2a,
	0x80, 0xe5, 0xfb, 0x01, 0xb3, 0x98, 0x1b, 0xf8, 0x83, 0x1a, 0x62, 0x14, 0x08, 0x79, 0x0a, 0x6d,
	0x97, 0xd1, 0x29, 0x6a, 0x78, 0x50, 0xdf, 0xa9, 0xec, 0xf6, 0xef, 0x7c, 0xb4, 0x37, 0xa3, 0xe1,
	0xbd, 0x99, 0x97, 0xab, 0xcf, 0xcf, 0x4f, 0x42, 0x6a, 0xb4, 0x5c, 0xf9, 0x8b, 0x0c, 0xa0, 0x79,
	0x2c, 0x54, 0x30, 0x58, 0xd9, 0xa9, 0xec, 0xd6, 0x8c, 0xf4, 0x91, 0xec, 0x82, 0xe6, 0x27, 0xd3,
	0x23, 0x1a, 0x99, 0xc1, 0xc8, 0xb4, 0x83, 0xd0, 0xa5, 0xf1, 0xa0, 0xb1, 0x53, 0xd9, 0x5d, 0x31,
	0xfa, 0x02, 0xfe, 0x6c, 0x34, 0x44, 0x28, 0xd9, 0x84, 0x46, 0x10, 0x5a, 0x3f, 0x4b, 0xe8, 0xa0,
	0x89, 0xc2, 0xc9, 0x27, 0xf2, 0x15, 0xac, 0xc5, 0x41, 0x12, 0xd9, 0xd4, 0x1c, 0x47, 0x41, 0x12,
	0x9a, 0x9e, 0x1b, 0xb3, 0x41, 0x6b, 0xa7, 0xb6, 0xdb, 0xb9, 0x73, 0x79, 0x6e, 0xcb, 0x87, 0x48,
	0xf9, 0x90, 0x13, 0x1a, 0xab, 0x71, 0xfe, 0xf0, 0xc4, 0x8d, 0x19, 0xf9, 0x14, 0x06, 0x63, 0x2f,
	0x38, 0xb2, 0x3c, 0x33, 0x35, 0x36, 0xea, 0x00, 0x15, 0xda, 0xc6, 0x77, 0x6e, 0x08, 0xbc, 0x22,
	0x28, 0x9a, 0xe8, 0x2b, 0x58, 0x4d, 0x57, 0xa4, 0x62, 0xc2, 0x4e, 0x65, 0xb7, 0x73, 0xe7, 0xda,
	0x22, 0x9d, 0x49, 0x87, 0x30, 0xfa, 0x76, 0xe1, 0x99, 0xfc, 0x01, 0xf4, 0xbc, 0xc0, 0x46, 0x1b,
	0x08, 0x41, 0x3a, 0x28, 0xc8, 0x6f, 0x9f, 0x47, 0xf7, 0x4f, 0x24, 0x03, 0xa3, 0x9b, 0xb2, 0x42,
	0xe9, 0x3e, 0x04, 0x12, 0xbc, 0xf6, 0x69, 0x64, 0xda, 0x5e, 0x12, 0x33, 0x1a, 0x09, 0xb9, 0xba,
	0x28, 0x97, 0x86, 0x98, 0xa1, 0x40, 0xa0, 0x48, 0x87, 0xb0, 0x29, 0xb5, 0x5a, 0xd0, 0x85, 0xeb,
	0x0c, 0x7a, 0x28, 0xd9, 0xd5, 0xa5, 0x3b, 0x72, 0x8c, 0x75, 0xb1, 0xba, 0x00, 0x24, 0x26, 0x0c,
	0x8e, 0xa7, 0x26, 0x93, 0x41, 0x91, 0xea, 0xca, 0x74, 0xfd, 0x51, 0x30, 0xe8, 0x23, 0xdb, 0x0f,
	0xe6, 0xd8, 0x96, 0x06, 0x91, 0xb1, 0x71, 0x5c, 0x06, 0xde, 0x3e, 0x81, 0xf5, 0x12, 0x45, 0x90,
	0xeb, 0xd0, 0x2d, 0x08, 0x2d, 0xa2, 0xa3, 0x63, 0x2b, 0xf2, 0x7e, 0x0e, 0x97, 0xad, 0x63, 0xcb,
	0xf5, 0xac, 0x23, 0xd7, 0x73, 0xd9, 0x89, 0xf9, 0x6d, 0xe0, 0x53, 0xd3, 0x0b, 0xc6, 0xae, 0x6d,
	0x79, 0x5c, 0x6a, 0x11, 0x3c, 0x5b, 0x2a, 0xcd, 0x4f, 0x02, 0x9f, 0x3e, 0x11, 0x14, 0x8f, 0x1c,
	0xfd, 0x4d, 0x21, 0x18, 0xd1, 0xeb, 0x01, 0x1a, 0x93, 0x47, 0x53, 0x6b, 0x4c, 0xb5, 0x0a, 0x19,
	0xc0, 0x85, 0xc9, 0x7e, 0x9a, 0x65, 0x5e, 0x4e, 0x0f, 0x7d, 0x2b, 0x8c, 0x5f, 0x05, 0x4c, 0xab,
	0x92, 0x55, 0xe8, 0x4c, 0x14, 0x40, 0x8d, 0xb4, 0x61, 0x65, 0xf2, 0xc0, 0xf5, 0xa8, 0x56, 0x27,
	0x2d, 0xa8, 0x4f, 0x9e, 0x0c, 0x9f, 0x6a, 0x2b, 0xf8, 0xeb, 0xd9, 0xcb, 0x7d, 0xad, 0x21, 0xe9,
	0x53, 0xe9, 0xb5, 0xa6, 0xfe, 0x47, 0xd0, 0x2f, 0x7a, 0x15, 0x97, 0x37, 0x8c, 0x02, 0x27, 0xb1,
	0x99, 0x89, 0x91, 0x5f, 0xc1, 0xcd, 0x77, 0x24, 0xec, 0x6b, 0x9e, 0x00, 0x6e, 0xc2, 0x6a, 0x4a,
	0x92, 0xba, 0xac, 0x10, 0xb1, 0x2f, 0xc1, 0x92, 0x97, 0xfe, 0xef, 0x15, 0xe8, 0x28, 0x51, 0x53,
	0x9a, 0x61, 0x6e, 0xc1, 0x9a, 0xaa, 0x5f, 0xe1, 0xb9, 0xd5, 0x9d, 0xda, 0x6e, 0xd7, 0x58, 0x55,
	0x94, 0x8c, 0x6e, 0xf8, 0x15, 0x5c, 0x5f, 0xa6, 0x68, 0xb1, 0xb6, 0xb6, 0x53, 0xdb, 0x6d, 0x1b,
	0x57, 0x16, 0x6a, 0x1b, 0x39, 0x7d, 0x06, 0x1d, 0xe9, 0xa2, 0xb8, 0xa6, 0x8e, 0x91, 0x72, 0x71,
	0x41, 0xc8, 0x1b, 0x20, 0x68, 0xf9, 0x4a, 0xfd, 0x18, 0x1a, 0x02, 0x8a, 0x3b, 0x9f, 0x8b, 0x75,
	0x21, 0x5a, 0x1a, 0xd2, 0x59, 0x94, 0x5f, 0x82, 0xf6, 0xc8, 0xf5, 0xa8, 0xa0, 0xa9, 0x22, 0x4d,
	0x8b, 0x03, 0x10, 0x79, 0x03, 0x7a, 0xb1, 0x34, 0xa1, 0x20, 0xa8, 0x21, 0x41, 0x37, 0x05, 0x72,
	0x22, 0xfd, 0x9f, 0x6b, 0xd0, 0xe2, 0x96, 0x5d, 0x98, 0xaa, 0xb7, 0xa1, 0x65, 0xbf, 0xa2, 0xf6,
	0x24, 0x4e, 0xa6, 0xe9, 0x1b, 0xd2, 0x67, 0xf2, 0x18, 0x7a, 0xe9, 0x6f, 0x91, 0x96, 0x6b, 0x98,
	0x96, 0xe7, 0x23, 0x26, 0x7d, 0xc3, 0xde, 0x50, 0x92, 0x63, 0x32, 0xee, 0xda, 0xca, 0x13, 0xb9,
	0x37, 0x9b, 0x67, 0x84, 0xf6, 0xae, 0x94, 0x32, 0x5b, 0x90, 0x50, 0x7e, 0x0b, 0xd6, 0x52, 0xbb,
	0x31, 0x77, 0x4a, 0x63, 0x66, 0x4d, 0x43, 0x99, 0xde, 0x35, 0x89, 0x78, 0x9e, 0xc2, 0x33, 0xe5,
	0xc5, 0xee, 0xb7, 0x14, 0x13, 0x7c, 0x4d, 0x28, 0xef, 0xd0, 0xfd, 0x96, 0x92, 0x2b, 0x20, 0xad,
	0x63, 0x26, 0x91, 0x87, 0xe9, 0xbd, 0x6d, 0xb4, 0x05, 0xe4, 0x45, 0xe4, 0x91, 0xe7, 0xa0, 0x49,
	0xb4, 0x95, 0xb0, 0x57, 0xa6, 0x1d, 0x51, 0x67, 0xd0, 0xc2, 0x74, 0x71, 0x6b, 0x6e, 0xbf, 0xfb,
	0x09, 0x7b, 0x45, 0x7d, 0xe6, 0x8a, 0x7d, 0x0e, 0x23, 0xea, 0xf0, 0x27, 0xcb, 0x8b, 0x8d, 0xbe,
	0xe0, 0xc1, 0x09, 0x38, 0x58, 0xff, 0x00, 0xba, 0xaa, 0x82, 0x30, 0xec, 0x0e, 0x5f, 0x59, 0x1f,
	0x6b, 0x15, 0xd2, 0x81, 0x26, 0xff, 0x79, 0xe7, 0x77, 0x3e, 0xd1, 0xaa, 0xfa, 0x3f, 0x56, 0xa1,
	0xab, 0x6a, 0xe1, 0x37, 0x91, 0x4d, 0xc8, 0xfb, 0xd0, 0xb7, 0x03, 0x9f, 0x59, 0xae, 0x9f, 0xbe,
	0x45, 0xf8, 0x53, 0x2f, 0x83, 0xe2, 0x7b, 0xb6, 0xa0, 0x95, 0x44, 0x5e, 0x6e, 0xc1, 0xb6, 0xd1,
	0x4c, 0x22, 0x0f, 0xad, 0x53, 0xf0, 0xd6, 0x95, 0x19, 0x6f, 0xfd, 0x10, 0x88, 0xe5, 0xc4, 0x23,
	0x33, 0xa2, 0x9e, 0xc5, 0xdc, 0x63, 0x6a, 0x86, 0x16, 0x7b, 0x85, 0x66, 0x69, 0x1b, 0x1a, 0xc7,
	0x18, 0x12, 0x71, 0x60, 0xb1, 0x57, 0x19, 0xb5, 0x75, 0x14, 0x07, 0x5e, 0xc2, 0x24, 0x75, 0x33,
	0xa7, 0xde, 0x97, 0x08, 0x4e, 0xad, 0xff, 0xcd, 0x0a, 0x6c, 0x28, 0x99, 0x70, 0x18, 0x51, 0x8b,
	0x51, 0x5e, 0xb0, 0x7c, 0x5f, 0x8b, 0x93, 0xb2, 0x12, 0x64, 0xe5, 0x94, 0x12, 0xa4, 0x51, 0x28,
	0x41, 0x5e, 0x64, 0x87, 0xa5, 0x28, 0x41, 0x78, 0xb1, 0x26, 0x8c, 0xd2, 0xc4, 0xb0, 0xda, 0x59,
	0x56, 0x87, 0x70, 0xd5, 0xa4, 0xc7, 0x65, 0x06, 0x38, 0xb5, 0x1e, 0x69, 0x9d, 0xb3, 0x1e, 0x69,
	0xbf, 0x5d, 0x3d, 0xa2, 0x14, 0x6e, 0x50, 0x2c, 0xdc, 0xca, 0xcb, 0x89, 0xce, 0xb9, 0xcb, 0x89,
	0xee, 0xdb, 0x97, 0x13, 0x1f, 0xc1, 0x05, 0xdb, 0x62, 0x74, 0x1c, 0x44, 0x2e, 0x8d, 0x95, 0x93,
	0xa7, 0x87, 0x27, 0x0f, 0xc9, 0x71, 0xe9, 0xe1, 0xa3, 0x7b, 0xb0, 0x3a, 0xa3, 0x79, 0x72, 0x3f,
	0x4b, 0x2e, 0xb9, 0xd5, 0x6a, 0x68, 0xb5, 0x4b, 0x0b, 0xac, 0x86, 0x06, 0x93, 0xd9, 0x24, 0xb3,
	0x55, 0xea, 0xdb, 0xf5, 0xdc, 0xb7, 0xf5, 0x5f, 0x54, 0x00, 0xf2, 0x25, 0xe4, 0x0b, 0xe8, 0xb8,
	0xd3, 0x30, 0x88, 0x98, 0x28, 0xe6, 0x2b, 0x0b, 0x2c, 0x82, 0xe9, 0x1b, 0xe9, 0xf0, 0x45, 0xe0,
	0x66, 0xbf, 0xcf, 0x74, 0xc8, 0x94, 0x1f, 0x69, 0xf5, 0xd2, 0x23, 0x4d, 0x3f, 0x82, 0x5e, 0x51,
	0xa5, 0xcb, 0x5c, 0xae, 0xb2, 0xcc, 0xe5, 0x14, 0x47, 0xa9, 0x16, 0x1c, 0x45, 0xff, 0xbf, 0x7a,
	0x21, 0x1f, 0xbc, 0x08, 0x1d, 0x25, 0x1f, 0x9c, 0x3b, 0xf6, 0x0f, 0xe7, 0x63, 0xff, 0x93, 0x65,
	0xbe, 0x93, 0xbf, 0xee, 0xd7, 0x9a, 0x01, 0xbe, 0x80, 0x2b, 0x11, 0x9d, 0x06, 0xc7, 0xd4, 0x2c,
	0x24, 0x82, 0xdc, 0x27, 0x9b, 0xe8, 0x93, 0x5b, 0x82, 0x48, 0xf1, 0xc1, 0xac, 0x2e, 0x3a, 0x84,
	0x0d, 0xcb, 0x71, 0xcc, 0x45, 0xad, 0xcc, 0xe9, 0x29, 0x84, 0x58, 0x8e, 0x73, 0x38, 0xd3, 0xd1,
	0x7c, 0x77, 0x89, 0xe0, 0x63, 0xd8, 0x90, 0x02, 0x66, 0xa7, 0x8a, 0xd8, 0x1e, 0x88, 0x60, 0x13,
	0xc8, 0x07, 0xf2, 0x80, 0xc1, 0x97, 0x2b, 0x2e, 0xd1, 0x29, 0xba, 0xc4, 0xf8, 0x37, 0x54, 0x2b,
	0xeb, 0x3f, 0x84, 0xee, 0x81, 0x75, 0xe2, 0x05, 0x96, 0xf3, 0xd2, 0xf2, 0x12, 0x8a, 0xe6, 0x1b,
	0x8d, 0x62, 0xca, 0xd0, 0x99, 0xeb, 0x86, 0x7c, 0xe2, 0x9e, 0x88, 0x85, 0x49, 0x15, 0xa1, 0xf8,
	0x5b, 0x9f, 0xc2, 0xa6, 0x5c, 0xfb, 0x2c, 0xba, 0x3f, 0x3d, 0xa2, 0x8e, 0x43, 0x25, 0x97, 0x4f,
	0xa1, 0x19, 0x0a, 0x8c, 0x0c, 0xe2, 0xf9, 0xb2, 0x49, 0x7d, 0xab, 0x91, 0x52, 0xf3, 0xf2, 0x8e,
	0x4a, 0x4e, 0x69, 0x79, 0x97, 0x3e, 0xeb, 0x7f, 0x5e, 0x81, 0xce, 0x53, 0xca, 0x2c, 0x83, 0xfe,
	0x2c, 0xa1, 0x31, 0x23, 0xd7, 0xa0, 0x33, 0xa5, 0xec, 0x55, 0xe0, 0xa8, 0x25, 0x3c, 0x08, 0x10,
	0x56, 0xf0, 0x77, 0xa1, 0x66, 0x45, 0x63, 0xe4, 0xd3, 0xb9, 0x73, 0x73, 0xd1, 0x0e, 0x66, 0xf6,
	0x6e, 0xf0, 0x35, 0xe4, 0x32, 0xb4, 0x47, 0x41, 0xf4, 0xda, 0x8a, 0xf8, 0x46, 0x78, 0x8c, 0xb5,
	0x8c, 0x1c, 0xa0, 0xff, 0x53, 0x05, 0xba, 0x62, 0x27, 0x71, 0x18, 0xf8, 0x31, 0x25, 0xfb, 0x00,
	0x38, 0xf5, 0x30, 0xed, 0xc0, 0x11, 0x3b, 0xe9, 0xdf, 0xd1, 0x17, 0x39, 0xd0, 0x7d, 0x9c, 0x8f,
	0x60, 0x80, 0xb5, 0x71, 0xd5, 0x30, 0x70, 0x28, 0xaf, 0x99, 0x04, 0x0b, 0x87, 0x32, 0xcb, 0xf5,
	0x64, 0xc8, 0x77, 0x10, 0xf6, 0x25, 0x82, 0xb8, 0x3c, 0x11, 0x65, 0xb8, 0x9d, 0xf3, 0xc8, 0x13,
	0x51, 0xa6, 0xff, 0xfd, 0x05, 0xa8, 0x3f, 0xb7, 0xe2, 0x49, 0x69, 0x85, 0xf1, 0x09, 0x34, 0x23,
	0xa1, 0x53, 0xa9, 0xab, 0xf9, 0xa9, 0x80, 0xa2, 0x77, 0x23, 0x25, 0x26, 0x77, 0xa1, 0x15, 0x49,
	0x0d, 0xc8, 0x4d, 0x5d, 0x59, 0xb0, 0x50, 0x10, 0x19, 0x19, 0x39, 0xb7, 0x9d, 0x8d, 0x65, 0x0f,
	0x16, 0xc6, 0x98, 0xa6, 0x1a, 0x06, 0x08, 0x10, 0x2f, 0x89, 0xb1, 0xe0, 0x65, 0x56, 0xc4, 0x04,
	0x7e, 0x05, 0xf1, 0x6d, 0x84, 0x20, 0xfa, 0x06, 0xf4, 0xec, 0x60, 0x1a, 0x7a, 0x34, 0xe5, 0xd0,
	0x40, 0x8a, 0x6e, 0x0a, 0x44, 0xa2, 0x5b, 0xb0, 0xe6, 0x59, 0x31, 0x33, 0x13, 0xcc, 0x70, 0x8e,
	0x20, 0x6c, 0x22, 0xe1, 0x2a, 0x47, 0x88, 0xcc, 0xe7, 0x20, 0xed, 0xe7, 0xd0, 0xe1, 0x65, 0x30,
	0x3b, 0x51, 0x53, 0xca, 0xfc, 0x99, 0xcb, 0x75, 0xb8, 0x77, 0x1f, 0x09, 0x1f, 0x39, 0x06, 0x88,
	0x25, 0x18, 0xcb, 0xbf, 0x0b, 0xfd, 0x20, 0xa4, 0x91, 0x68, 0x18, 0x30, 0xf7, 0xb6, 0xd1, 0x0d,
	0x6e, 0x94, 0xf3, 0x78, 0x96, 0xd2, 0xa2, 0x1f, 0xf4, 0x02, 0xf5, 0x91, 0xe7, 0x85, 0x29, 0x8d,
	0x63, 0x6b, 0x4c, 0xb1, 0xa6, 0x68, 0x1b, 0xe9, 0x23, 0xb9, 0x0d, 0xeb, 0x21, 0x8d, 0x6c, 0xea,
	0x33, 0x6b, 0x4c, 0xcd, 0x54, 0x5a, 0xcc, 0x1e, 0x2b, 0x06, 0xc9, 0x51, 0x43, 0x89, 0x21, 0xf7,
	0xb1, 0x8b, 0x1d, 0x47, 0x34, 0x8e, 0xcd, 0x98, 0x59, 0x2c, 0x89, 0xb1, 0x9e, 0xe8, 0x97, 0xd8,
	0x18, 0xf7, 0x75, 0x88, 0x34, 0xd8, 0xe3, 0xe2, 0x22, 0xf1, 0xcc, 0xf3, 0x7f, 0x68, 0x45, 0xd4,
	0x67, 0x26, 0xb3, 0xe2, 0x89, 0x38, 0xed, 0x7a, 0xe8, 0x42, 0x7d, 0x01, 0xe7, 0x8b, 0xd3, 0xc3,
	0x35, 0x4e, 0x8e, 0x32, 0x2a, 0xa1, 0xce, 0xbe, 0xe8, 0x74, 0x25, 0x22, 0xcb, 0x7f, 0xb7, 0xa0,
	0x87, 0xd3, 0x44, 0x9f, 0x37, 0x48, 0x56, 0x3c, 0x19, 0xac, 0xf2, 0x48, 0xfb, 0xe1, 0xca, 0xc8,
	0xf2, 0x62, 0x6a, 0x74, 0x53, 0x1c, 0x3a, 0xee, 0x75, 0x68, 0xd9, 0x96, 0x6f, 0x53, 0x8f, 0x3a,
	0x03, 0x4d, 0x25, 0xcb, 0xc0, 0x3c, 0x84, 0x1c, 0x37, 0x0e, 0x3d, 0xeb, 0x44, 0x64, 0x84, 0x35,
	0x11, 0x42, 0x12, 0x86, 0x29, 0x61, 0x0f, 0xd6, 0xd3, 0xdd, 0xc5, 0xdc, 0x8b, 0x7d, 0x9b, 0xf2,
	0x12, 0x8b, 0x60, 0x56, 0x4b, 0x37, 0x7e, 0x28, 0x31, 0x8f, 0x1c, 0x72, 0x1b, 0xb4, 0x94, 0xe5,
	0xc8, 0x72, 0xbd, 0x24, 0xa2, 0xf1, 0x60, 0x1d, 0xdf, 0x5e, 0x67, 0x51, 0x42, 0x8d, 0x55, 0x89,
	0x7d, 0x20, 0x91, 0xe4, 0x4b, 0xe8, 0xda, 0x56, 0x28, 0x3a, 0x16, 0x7e, 0x48, 0x5e, 0xd8, 0xa9,
	0xed, 0xf6, 0x4b, 0xce, 0x26, 0x54, 0xf6, 0x30, 0xa5, 0x3c, 0x31, 0x0a, 0xab, 0xc8, 0x43, 0x58,
	0x95, 0x41, 0x66, 0xf2, 0x76, 0x86, 0xbe, 0x61, 0x83, 0x8d, 0x99, 0x2a, 0xd0, 0xa7, 0x6c, 0xcf,
	0x08, 0x6d, 0x19, 0x94, 0x43, 0x41, 0x65, 0xf4, 0xa3, 0xc2, 0x33, 0xdf, 0x7f, 0x12, 0x53, 0x33,
	0x3e, 0xf1, 0x6d, 0xf3, 0xc8, 0x8a, 0x22, 0x97, 0x46, 0x83, 0x4d, 0x55, 0x7b, 0xfd, 0x24, 0xa6,
	0x87, 0x27, 0xbe, 0x7d, 0x4f, 0x20, 0xc9, 0x03, 0xb8, 0xec, 0xb8, 0xb1, 0x75, 0xe4, 0x61, 0x2b,
	0x19, 0x98, 0x99, 0xf3, 0x88, 0x20, 0x1a, 0x5c, 0x54, 0x17, 0x6f, 0x49, 0xd2, 0xfd, 0x84, 0x05,
	0x07, 0x92, 0x50, 0x04, 0xd5, 0xf6, 0x9f, 0x40, 0x2b, 0x0d, 0x93, 0xd2, 0x9c, 0xf3, 0xa3, 0x2c,
	0xde, 0x30, 0x56, 0xaa, 0xcb, 0x7c, 0x52, 0x30, 0x4a, 0xa3, 0x0d, 0x23, 0xe4, 0x5a, 0xb6, 0x1c,
	0x2d, 0x2d, 0xab, 0x20, 0x01, 0xe2, 0x86, 0xd6, 0xff, 0xb6, 0x02, 0x0d, 0xb1, 0x8e, 0x68, 0xd0,
	0x9d, 0x28, 0x87, 0xa9, 0x56, 0xc9, 0xcf, 0xc4, 0xaa, 0x72, 0xaa, 0xd6, 0x48, 0x17, 0x5a, 0x13,
	0x59, 0x92, 0x6b, 0x75, 0x72, 0x09, 0x2e, 0xa6, 0xcb, 0x0e, 0x3c, 0xcb, 0xa6, 0x53, 0xea, 0xb3,
	0x83, 0xc0, 0x73, 0xed, 0x13, 0x6d, 0x65, 0x76, 0xc4, 0xd4, 0x20, 0x9b, 0x40, 0x26, 0x73, 0x83,
	0x38, 0xad, 0x49, 0x36, 0x60, 0x2d, 0xe5, 0x62, 0x58, 0x8c, 0x3e, 0x71, 0xa7, 0x2e, 0xd3, 0x5a,
	0xfa, 0x5f, 0xb6, 0xa0, 0x57, 0x48, 0x01, 0xc8, 0x60, 0xae, 0x29, 0xd4, 0x2a, 0xb3, 0x70, 0xa1,
	0x5e, 0xad, 0x3a, 0x0b, 0xff, 0x92, 0xf2, 0x70, 0xd7, 0x6a, 0xb8, 0xb3, 0xbc, 0x40, 0xd6, 0xea,
	0xe4, 0x02, 0x68, 0x93, 0x07, 0xe2, 0xe8, 0x42, 0x41, 0x8d, 0xd0, 0xd6, 0x56, 0xc8, 0x1a, 0xf4,
	0x90, 0x0c, 0x1b, 0xfc, 0x20, 0x61, 0x5a, 0x03, 0xf5, 0x84, 0x14, 0x2f, 0x42, 0x7e, 0x8e, 0x68,
	0x4d, 0x2c, 0x33, 0xd4, 0x3d, 0xa5, 0xb4, 0xad, 0xf9, 0x5d, 0xe1, 0x8a, 0xb6, 0x2a, 0xee, 0x53,
	0x77, 0x1c, 0x59, 0x8c, 0x1e, 0xd8, 0x1a, 0x94, 0x81, 0xa9, 0xd6, 0xc9, 0xdf, 0x28, 0xa5, 0xed,
	0xe6, 0x10, 0x29, 0x4f, 0x4f, 0xdd, 0x15, 0x4a, 0xde, 0x17, 0x02, 0x89, 0x71, 0xc3, 0x64, 0xe8,
	0x51, 0xcb, 0x4f, 0x42, 0x6d, 0x95, 0x5c, 0x83, 0x4b, 0x99, 0xa2, 0xe9, 0x34, 0x60, 0xf4, 0x90,
	0x52, 0xc7, 0xf5, 0xc7, 0xa2, 0xe0, 0xd3, 0x34, 0xf2, 0x1e, 0xec, 0x94, 0x12, 0x7c, 0x49, 0x63,
	0xe6, 0xfa, 0x68, 0x08, 0x6d, 0x8d, 0xe8, 0x70, 0x35, 0xa5, 0x4a, 0x8b, 0x28, 0x83, 0x86, 0x9e,
	0xcb, 0x5b, 0x25, 0xfe, 0xd2, 0x58, 0x23, 0x64, 0x07, 0x2e, 0x97, 0x72, 0x4a, 0x37, 0xb3, 0x4e,
	0x2e, 0xc2, 0xfa, 0x44, 0xc8, 0x74, 0x40, 0x25, 0x89, 0xcb, 0xa8, 0x76, 0x81, 0x5c, 0x87, 0x2b,
	0x0b, 0x9c, 0x4a, 0xaa, 0x60, 0x63, 0x09, 0x89, 0xd4, 0xc0, 0xe6, 0x12, 0x12, 0xa9, 0xb6, 0x8b,
	0x64, 0x1b, 0x36, 0x0b, 0x06, 0xf2, 0xed, 0xd4, 0x78, 0x03, 0x42, 0xa0, 0x2f, 0xd5, 0x9e, 0xc2,
	0xb6, 0x54, 0x96, 0x69, 0x57, 0xea, 0x47, 0x74, 0xec, 0xc6, 0x4c, 0xf8, 0xa8, 0xb6, 0xad, 0x06,
	0x84, 0x60, 0x19, 0xd1, 0xb1, 0xdc, 0xd2, 0x25, 0x55, 0xfd, 0x72, 0xbd, 0xa1, 0xae, 0xbe, 0x4c,
	0xb6, 0x60, 0x43, 0x5d, 0x6d, 0x64, 0x6b, 0xaf, 0xa8, 0x8c, 0xb3, 0x18, 0x91, 0xea, 0xb8, 0x5a,
	0x8a, 0x94, 0x2b, 0xaf, 0x95, 0x22, 0xa5, 0x0a, 0x76, 0xc8, 0x15, 0xd8, 0x9a, 0x0f, 0xc9, 0x58,
	0xa2, 0xaf, 0x93, 0xab, 0xb0, 0x3d, 0x8f, 0x36, 0x0e, 0x24, 0x5e, 0x47, 0x9f, 0xcd, 0xf1, 0x12,
	0x7c, 0x63, 0x06, 0x2c, 0xb7, 0xf9, 0x1e, 0xca, 0x9f, 0x83, 0xf7, 0x7d, 0x47, 0x32, 0x94, 0x04,
	0xef, 0x93, 0xcb, 0x30, 0x98, 0x7f, 0x9d, 0xc4, 0x7e, 0xa0, 0x7f, 0x0d, 0x0d, 0x79, 0xd2, 0x76,
	0xa0, 0x39, 0xf9, 0xbd, 0x84, 0x26, 0xd4, 0xd1, 0x2a, 0x98, 0x91, 0x8c, 0xc4, 0xf7, 0x5d, 0x7f,
	0xac, 0x55, 0x49, 0x1f, 0x60, 0x72, 0x98, 0xd8, 0x36, 0xa5, 0x0e, 0x75, 0x64, 0xbe, 0xda, 0x3f,
	0x0a, 0x22, 0x46, 0x1d, 0xad, 0x8e, 0x0b, 0xf9, 0x31, 0x44, 0x1d, 0x6d, 0x45, 0xbf, 0x0d, 0x90,
	0x1f, 0x2e, 0x18, 0x43, 0x3c, 0x93, 0x1e, 0x26, 0x71, 0x48, 0x7d, 0xce, 0x98, 0x67, 0x09, 0x0e,
	0x19, 0xe2, 0xd9, 0xa9, 0x55, 0xf5, 0xbf, 0xab, 0x42, 0xbf, 0xd8, 0x57, 0x17, 0xe7, 0x63, 0x95,
	0x99, 0xf9, 0xd8, 0x33, 0xc0, 0x86, 0x86, 0x51, 0x53, 0x76, 0xec, 0xd9, 0x44, 0xbb, 0x73, 0xe7,
	0xfa, 0x5c, 0x1a, 0x17, 0x31, 0xa0, 0xf4, 0xec, 0x5a, 0xa4, 0x40, 0xb0, 0x16, 0x78, 0x02, 0x6b,
	0x5e, 0x80, 0xc3, 0x3f, 0x85, 0x5f, 0x6d, 0x41, 0x67, 0xf7, 0x84, 0x53, 0x2a, 0xec, 0x56, 0xbd,
	0x1c, 0x80, 0xdc, 0x9e, 0x01, 0xa1, 0x6f, 0x5c, 0x1e, 0xd8, 0x63, 0xd1, 0x8e, 0xe1, 0x40, 0xa1,
	0x8e, 0x67, 0xe8, 0xfc, 0xf6, 0xee, 0x4b, 0x52, 0xae, 0x00, 0xb1, 0x3d, 0x3a, 0x03, 0xd1, 0xff,
	0xaa, 0x02, 0xda, 0xac, 0x14, 0x44, 0x83, 0x5a, 0x12, 0x79, 0xb2, 0xf3, 0xe0, 0x3f, 0x4b, 0xa6,
	0x92, 0xd5, 0xb2, 0xa9, 0xe4, 0x43, 0x68, 0xe7, 0x83, 0xda, 0xda, 0xb9, 0x07, 0xb5, 0x2d, 0x2b,
	0x1d, 0xd1, 0xfe, 0xa2, 0x0a, 0xab, 0x33, 0xca, 0x38, 0xcb, 0xf4, 0xf5, 0x12, 0xb4, 0x71, 0x5e,
	0x89, 0x63, 0x4a, 0xd1, 0x69, 0xb4, 0x38, 0x00, 0x87, 0x99, 0x05, 0xbb, 0xd7, 0x66, 0xec, 0x7e,
	0xda, 0xdc, 0xb6, 0x7e, 0xda, 0xdc, 0xf6, 0x21, 0x74, 0x12, 0x3c, 0x2d, 0x84, 0x49, 0x56, 0x16,
	0x5c, 0x6a, 0xc9, 0xa8, 0xc6, 0x76, 0x19, 0xc9, 0xc5, 0xa8, 0x27, 0xc9, 0x7e, 0x97, 0xa8, 0xba,
	0x51, 0xa2, 0x6a, 0xfd, 0x2e, 0x68, 0xb3, 0xe6, 0x2d, 0x59, 0x5a, 0x29, 0x5b, 0xfa, 0xf3, 0x0a,
	0x6c, 0x2d, 0x34, 0x02, 0xb9, 0x0b, 0x70, 0x64, 0xc5, 0xae, 0x8d, 0x23, 0x77, 0xd9, 0xe6, 0x6e,
	0xcf, 0xc9, 0x71, 0x8f, 0x93, 0x70, 0x26, 0x46, 0xfb, 0x28, 0xfd, 0x49, 0x7e, 0x00, 0x2d, 0xeb,
	0x75, 0x2c, 0x16, 0x8a, 0x8e, 0x6b, 0x30, 0x6f, 0xfd, 0xdf, 0x3f, 0xc4, 0x65, 0x4d, 0xeb, 0x75,
	0xcc, 0x7f, 0xe8, 0x43, 0x68, 0x67, 0xcc, 0x78, 0x9f, 0x9c, 0xc4, 0xbc, 0x38, 0xce, 0x1a, 0xdf,
	0xec, 0x99, 0xe3, 0x42, 0x2b, 0x8e, 0x5f, 0x07, 0x51, 0x3a, 0x46, 0xcf, 0x9e, 0xf5, 0x87, 0xd0,
	0x94, 0x8c, 0x79, 0x87, 0x65, 0xd9, 0x36, 0x2f, 0xed, 0x26, 0xf4, 0x44, 0x32, 0x69, 0x0b, 0xc8,
	0x63, 0x7a, 0x82, 0x0d, 0x18, 0xb5, 0x23, 0xca, 0x10, 0x5d, 0x95, 0x37, 0x0e, 0x08, 0x79, 0x4c,
	0x4f, 0xf4, 0xbf, 0xae, 0x42, 0x57, 0x94, 0x13, 0x67, 0xed, 0xc6, 0x1f, 0x83, 0xe6, 0x4e, 0xb1,
	0x6b, 0x11, 0x8d, 0x5f, 0xde, 0x9a, 0xe7, 0x01, 0x99, 0x7d, 0x65, 0xb0, 0xa7, 0x94, 0x05, 0xfb,
	0xd1, 0xd8, 0xe8, 0xbb, 0x85, 0xe7, 0x9c, 0x99, 0x28, 0x4b, 0x91, 0x59, 0x6d, 0x39, 0x33, 0x71,
	0x68, 0xe4, 0xcc, 0xb2, 0xe7, 0x9c, 0x99, 0x83, 0x49, 0x1e, 0x99, 0xd5, 0x97, 0x33, 0x13, 0xc7,
	0x41, 0xce, 0x2c, 0x7b, 0xd6, 0xff, 0xa1, 0x0a, 0x3d, 0xa9, 0x98, 0xbc, 0xd7, 0x5d, 0xae, 0x99,
	0x67, 0x33, 0x9a, 0xe1, 0x4d, 0xbe, 0xd0, 0xcc, 0xfb, 0xcb, 0x35, 0xc3, 0x33, 0xb8, 0x41, 0x59,
	0x41, 0x3b, 0x06, 0x65, 0x39, 0x43, 0xa9, 0x9d, 0x7c, 0x6a, 0xf0, 0xfe, 0x72, 0xed, 0x14, 0x19,
	0x0a, 0x58, 0x81, 0xa1, 0xd4, 0x10, 0x67, 0x58, 0x5f, 0xce, 0x50, 0x68, 0xa4, 0xc8, 0x50, 0xc0,
	0x0c, 0xca, 0xf4, 0xff, 0xaa, 0x64, 0x23, 0xcf, 0x62, 0x88, 0xf3, 0x4e, 0x53, 0xe6, 0x87, 0x3c,
	0x43, 0x09, 0x95, 0xf5, 0x05, 0x7c, 0x3f, 0xcd, 0x53, 0xb7, 0x60, 0x4d, 0x52, 0x8a, 0xbd, 0x65,
	0xf3, 0xa9, 0x9a, 0xb1, 0x2a, 0x10, 0xb8, 0x11, 0xbc, 0x3f, 0xfb, 0x71, 0x96, 0x75, 0xb0, 0xcf,
	0x5c, 0x34, 0xad, 0xb8, 0xef, 0x3b, 0xf8, 0xc1, 0x09, 0x6e, 0x5b, 0x26, 0x1b, 0xec, 0x3e, 0xcf,
	0x33, 0x32, 0xfe, 0xb7, 0x0a, 0x74, 0x55, 0x46, 0x3c, 0xa1, 0xe6, 0x5d, 0xb3, 0x3c, 0x48, 0xd3,
	0x3e, 0x78, 0x2e, 0x5b, 0x57, 0xcf, 0x7f, 0x57, 0x56, 0x3b, 0x2d, 0xe7, 0x2e, 0x9b, 0x59, 0xd7,
	0x97, 0xcc, 0xac, 0xf5, 0xbf, 0xa8, 0xc2, 0xa0, 0x58, 0xe2, 0x4a, 0x02, 0x7f, 0x14, 0x90, 0x21,
	0x6f, 0x75, 0x25, 0x3b, 0x7f, 0x14, 0xc8, 0x14, 0xb8, 0x73, 0xda, 0x3d, 0x93, 0xd1, 0xb1, 0x15,
	0x26, 0x2f, 0xa0, 0x17, 0x8a, 0x89, 0x69, 0xac, 0x96, 0x10, 0x1f, 0x2f, 0x28, 0x21, 0xe6, 0xb7,
	0xb1, 0x77, 0x20, 0xea, 0x72, 0xa3, 0x13, 0x8a, 0x1f, 0xfc, 0xfc, 0xdf, 0x36, 0xa0, 0x29, 0xe1,
	0x67, 0x39, 0x0e, 0xdf, 0x83, 0x3e, 0x9e, 0x78, 0xdc, 0xd9, 0xf2, 0x5d, 0xb4, 0x8d, 0x2e, 0x87,
	0x72, 0x5f, 0xc3, 0xab, 0x91, 0x09, 0x68, 0xb2, 0xb4, 0x7d, 0x14, 0x3e, 0xb5, 0xc2, 0xd0, 0xf5,
	0xc7, 0x67, 0x61, 0x7e, 0x11, 0x9a, 0x6e, 0xa8, 0x72, 0x6d, 0xb8, 0x61, 0x7a, 0xff, 0x58, 0xac,
	0x74, 0x6a, 0x46, 0x2b, 0x2d, 0x60, 0xf4, 0xff, 0xae, 0xc1, 0x76, 0x79, 0x89, 0x7f, 0xae, 0xaf,
	0x98, 0x76, 0xa0, 0xe3, 0xd0, 0xd8, 0x8e, 0xdc, 0x50, 0xb9, 0x2d, 0x50, 0x41, 0xe4, 0xa7, 0xd0,
	0x0f, 0xd3, 0x17, 0xa8, 0x77, 0x06, 0x77, 0x17, 0xd9, 0xb1, 0x64, 0x3b, 0x7b, 0x19, 0x4c, 0x4c,
	0xb3, 0x42, 0xf5, 0x91, 0xec, 0xc1, 0x7a, 0xea, 0x27, 0x23, 0xd7, 0xcb, 0x54, 0x25, 0x6e, 0x5c,
	0xd3, 0xb0, 0x7a, 0x80, 0x18, 0x54, 0x18, 0xa7, 0x97, 0x3a, 0x55, 0xe9, 0x1b, 0x92, 0x5e, 0xa0,
	0x14, 0xfa, 0xc2, 0x65, 0x67, 0xf3, 0x9d, 0x2f, 0x3b, 0x4b, 0x2f, 0xed, 0x5b, 0xe5, 0x97, 0xf6,
	0xfa, 0x67, 0xd0, 0x2b, 0xc8, 0x2e, 0x6a, 0x72, 0xf6, 0x84, 0x5a, 0x31, 0x93, 0xd7, 0xe4, 0xfb,
	0xec, 0x69, 0x10, 0x33, 0xad, 0x8a, 0xa8, 0xfb, 0x6f, 0x2c, 0x9b, 0x79, 0x27, 0x5a, 0x4d, 0xff,
	0xff, 0x06, 0xec, 0x2c, 0xeb, 0x04, 0x31, 0x19, 0x5e, 0x83, 0x4e, 0x88, 0x30, 0xd5, 0xbb, 0x40,
	0x80, 0x5e, 0xbc, 0xbd, 0xcd, 0x29, 0xf4, 0x8b, 0x16, 0x91, 0xc9, 0xfc, 0xc7, 0x67, 0xb4, 0x79,
	0xbe, 0x43, 0x39, 0x9b, 0x11, 0xd6, 0x30, 0x7a, 0x05, 0x63, 0xe2, 0x6b, 0x0a, 0x86, 0x94, 0xd5,
	0xde, 0xbb, 0xbf, 0x46, 0xf5, 0x81, 0xa2, 0xfd, 0x1b, 0xef, 0x6c, 0xff, 0xf9, 0x80, 0x68, 0x7e,
	0xb7, 0x01, 0xb1, 0xfd, 0xc7, 0xa0, 0x0d, 0xc5, 0xcd, 0xeb, 0xc9, 0x63, 0x7a, 0x22, 0x6e, 0x4c,
	0xae, 0x63, 0x32, 0x45, 0x98, 0x52, 0x8f, 0x75, 0xec, 0x9c, 0x8e, 0xdc, 0xc4, 0xab, 0x2a, 0x41,
	0x72, 0xcc, 0x17, 0xc5, 0x32, 0xa1, 0xf4, 0x53, 0x30, 0xb2, 0x8a, 0xb7, 0xff, 0x17, 0x0f, 0xa0,
	0x5c, 0x61, 0xca, 0xb4, 0x6c, 0xe2, 0xfa, 0x4e, 0x5a, 0x81, 0x08, 0xd0, 0x63, 0xd7, 0x77, 0xc8,
	0x11, 0xc0, 0xd4, 0x62, 0xf6, 0x2b, 0x75, 0x18, 0x37, 0x3c, 0xbf, 0x95, 0x52, 0xa9, 0x9e, 0x72,
	0x5e, 0xe2, 0x82, 0x63, 0x9a, 0xfe, 0xe4, 0xef, 0xc8, 0xef, 0x9b, 0x65, 0x67, 0x77, 0xef, 0xed,
	0xdf, 0x91, 0x6a, 0xce, 0x50, 0xb8, 0xea, 0x37, 0x61, 0x6d, 0x6e, 0x0f, 0x78, 0xd9, 0xb5, 0xef,
	0x79, 0x5a, 0x45, 0xfc, 0xf2, 0x4f, 0xb4, 0xaa, 0xfe, 0xa7, 0xcd, 0x45, 0xd1, 0x27, 0xda, 0xf0,
	0x85, 0x49, 0x76, 0xd9, 0x51, 0x5a, 0x5d, 0x76, 0xfd, 0x3b, 0x05, 0x22, 0x43, 0x59, 0x8c, 0xe1,
	0xd5, 0x06, 0xf7, 0xf3, 0x33, 0xaa, 0x21, 0xdf, 0xdb, 0xde, 0x01, 0x8d, 0x72, 0x77, 0x33, 0xb4,
	0x50, 0xc1, 0x2f, 0xfe, 0xf4, 0xa8, 0x5e, 0x9e, 0xc5, 0xb6, 0x7f, 0x59, 0x83, 0x5e, 0x81, 0xe1,
	0xe9, 0x89, 0xe7, 0x10, 0x56, 0xb8, 0x1c, 0xa9, 0xb3, 0xfc, 0xe8, 0x2d, 0x24, 0xc8, 0x00, 0xd4,
	0x10, 0xbc, 0xc8, 0x4b, 0x68, 0x58, 0x76, 0x96, 0xb4, 0xfa, 0x67, 0x4e, 0x14, 0x73, 0x5c, 0xf7,
	0x91, 0x8b, 0x21, 0xb9, 0x91, 0xcf, 0x60, 0x60, 0x07, 0xfe, 0xc8, 0x73, 0x6d, 0x1c, 0x08, 0x28,
	0x92, 0xc5, 0xf8, 0x51, 0x50, 0xd7, 0xd8, 0x54, 0xf0, 0x07, 0x99, 0x94, 0x31, 0x71, 0xa0, 0x4f,
	0x8f, 0xa9, 0xcf, 0x12, 0xcb, 0x33, 0x85, 0xbc, 0x2b, 0xdf, 0x85, 0xbc, 0xbd, 0x94, 0x29, 0x3e,
	0xaa, 0x55, 0x04, 0x7a, 0x45, 0x03, 0xf7, 0x94, 0x56, 0x11, 0x68, 0xcf, 0x3b, 0xb0, 0x41, 0xfd,
	0x51, 0x10, 0xd9, 0xd4, 0x31, 0x0b, 0xb4, 0xe2, 0xda, 0x7c, 0x3d, 0x45, 0x0e, 0xf3, 0x35, 0xfa,
	0x47, 0xd0, 0x51, 0x5e, 0x8a, 0xe3, 0x23, 0xbc, 0x17, 0x72, 0x2d, 0x9f, 0x1f, 0x4e, 0x6b, 0xd0,
	0x9b, 0x7c, 0x1d, 0xf8, 0x39, 0xa8, 0xaa, 0x7f, 0x0a, 0x5d, 0x55, 0x81, 0xb8, 0xe4, 0x3e, 0x72,
	0x76, 0xfd, 0xb1, 0x56, 0xc1, 0xb9, 0xa6, 0x78, 0x16, 0xe9, 0x71, 0x24, 0xe6, 0x4d, 0x55, 0xfd,
	0x0e, 0xac, 0x0f, 0x93, 0x28, 0x9a, 0x91, 0x5b, 0x9c, 0x7f, 0x36, 0x73, 0x8f, 0xa9, 0x56, 0x91,
	0xe3, 0x2b, 0x9c, 0x40, 0xe1, 0x9a, 0xff, 0xa8, 0xc2, 0xe6, 0xec, 0xf0, 0x4e, 0x26, 0xac, 0x6f,
	0x4a, 0xf2, 0xd1, 0xc2, 0xfc, 0x3b, 0xb3, 0x78, 0x79, 0x16, 0xfa, 0xa6, 0x24, 0x0b, 0x7d, 0x76,
	0x5e, 0xce, 0x65, 0xb9, 0xe7, 0xd7, 0x9d, 0xd5, 0xcf, 0x9e, 0xdb, 0xfe, 0xb3, 0x02, 0x17, 0x66,
	0x05, 0x38, 0xd7, 0xd7, 0x65, 0xa7, 0x17, 0x10, 0x1f, 0xc0, 0x6a, 0xc4, 0x1b, 0x4b, 0x8f, 0xf3,
	0x36, 0x27, 0x47, 0x61, 0x8c, 0xb9, 0xa5, 0x6e, 0xf4, 0xa2, 0xf4, 0x8d, 0x8f, 0x8f, 0xc2, 0x98,
	0x7c, 0xbd, 0xa0, 0x02, 0xb8, 0x79, 0x46, 0x8d, 0xcf, 0x1c, 0xf5, 0xfa, 0xbf, 0x36, 0xe6, 0x45,
	0xfb, 0x8e, 0xeb, 0xe1, 0xb3, 0x8a, 0xb6, 0xa0, 0x4a, 0x5d, 0x59, 0x54, 0xa5, 0x96, 0x26, 0xe4,
	0xc6, 0x82, 0x6f, 0x41, 0xbf, 0x81, 0x86, 0xbc, 0xac, 0x6d, 0xa2, 0xbe, 0xbe, 0x38, 0x55, 0x5f,
	0x6a, 0x51, 0x93, 0x5b, 0x3d, 0xcb, 0x3e, 0x86, 0xe4, 0xb7, 0xfd, 0x3f, 0x79, 0x5f, 0x51, 0x42,
	0x56, 0x62, 0xb0, 0xca, 0xbb, 0x18, 0x8c, 0xfc, 0xbc, 0x92, 0xab, 0x49, 0x3d, 0xf7, 0x44, 0x97,
	0xf7, 0x87, 0xef, 0x2a, 0xd6, 0x5e, 0x7a, 0xd7, 0x50, 0x22, 0x71, 0x6a, 0x03, 0xe5, 0x50, 0xdc,
	0x87, 0x2b, 0x89, 0x1f, 0x27, 0x61, 0x88, 0x33, 0x73, 0x73, 0xfe, 0x8b, 0xec, 0x1a, 0x26, 0xd3,
	0x6d, 0x85, 0x68, 0x58, 0xfc, 0x38, 0x7b, 0xfb, 0x5f, 0x2a, 0xb0, 0xbd, 0xf8, 0xa5, 0x67, 0xe9,
	0x07, 0xef, 0xc2, 0x16, 0x1d, 0x8d, 0x28, 0x66, 0x45, 0x73, 0xd6, 0xd5, 0xc4, 0xe7, 0x35, 0x9b,
	0x19, 0x81, 0x51, 0xf0, 0xb9, 0x45, 0x4b, 0x95, 0x49, 0x6d, 0xc9, 0x52, 0xec, 0xe4, 0x7f, 0x59,
	0x85, 0xad, 0xf4, 0x7e, 0x26, 0x98, 0x86, 0x56, 0xe4, 0xc6, 0x81, 0x9f, 0x7e, 0xdd, 0xfb, 0xf6,
	0x1f, 0xb5, 0x7d, 0xaf, 0xff, 0x73, 0xe6, 0x43, 0x20, 0x85, 0x8f, 0xc5, 0xec, 0x20, 0xf1, 0x59,
	0x1a, 0x73, 0xca, 0xe7, 0xa4, 0x43, 0x0e, 0x27, 0x3f, 0x98, 0xf9, 0x44, 0x75, 0xf6, 0xcb, 0x34,
	0xf5, 0x03, 0xd4, 0xd4, 0x1d, 0xee, 0x5d, 0x85, 0x75, 0x3b, 0x98, 0xce, 0xee, 0xfe, 0x27, 0x4d,
	0xf9, 0xe3, 0x57, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x15, 0x48, 0xff, 0x91, 0x35, 0x00, 0x00,
}
