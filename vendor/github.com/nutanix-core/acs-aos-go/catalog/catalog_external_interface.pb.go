// Code generated by protoc-gen-go. DO NOT EDIT.
// source: catalog/catalog_external_interface.proto

package catalog

import (
	acropolis "github.com/nutanix-core/acs-aos-go/acropolis"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/base"
	_ "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/net"
	math "math"
)

import (
	"errors"
	util_net "github.com/nutanix-core/acs-aos-go/nutanix/util-go/net"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type CatalogItemCreateArg struct {
	// Catalog item spec used to create the catalog item.
	Spec *CatalogItemCreateSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,2,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,3,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,4,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Forces a catalog item update. This option ignores any mechanisms that
	// prevent updates in the catalog (i.e PE being registered).
	ForceUpdate          *bool    `protobuf:"varint,5,opt,name=force_update,json=forceUpdate,def=0" json:"force_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemCreateArg) Reset()         { *m = CatalogItemCreateArg{} }
func (m *CatalogItemCreateArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCreateArg) ProtoMessage()    {}
func (*CatalogItemCreateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{0}
}

func (m *CatalogItemCreateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCreateArg.Unmarshal(m, b)
}
func (m *CatalogItemCreateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCreateArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemCreateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCreateArg.Merge(m, src)
}
func (m *CatalogItemCreateArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCreateArg.Size(m)
}
func (m *CatalogItemCreateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCreateArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCreateArg proto.InternalMessageInfo

const Default_CatalogItemCreateArg_ForceUpdate bool = false

func (m *CatalogItemCreateArg) GetSpec() *CatalogItemCreateSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CatalogItemCreateArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemCreateArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogItemCreateArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *CatalogItemCreateArg) GetForceUpdate() bool {
	if m != nil && m.ForceUpdate != nil {
		return *m.ForceUpdate
	}
	return Default_CatalogItemCreateArg_ForceUpdate
}

type CatalogItemCreateRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemCreateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemCreateRet) Reset()         { *m = CatalogItemCreateRet{} }
func (m *CatalogItemCreateRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCreateRet) ProtoMessage()    {}
func (*CatalogItemCreateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{1}
}

func (m *CatalogItemCreateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCreateRet.Unmarshal(m, b)
}
func (m *CatalogItemCreateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCreateRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemCreateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCreateRet.Merge(m, src)
}
func (m *CatalogItemCreateRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCreateRet.Size(m)
}
func (m *CatalogItemCreateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCreateRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCreateRet proto.InternalMessageInfo

func (m *CatalogItemCreateRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemCreateTaskRet struct {
	// Newly created catalog item UUID.
	CatalogItemUuid []byte `protobuf:"bytes,1,opt,name=catalog_item_uuid,json=catalogItemUuid" json:"catalog_item_uuid,omitempty"`
	// Newly created catalog item global UUID.
	GlobalCatalogItemUuid []byte   `protobuf:"bytes,2,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *CatalogItemCreateTaskRet) Reset()         { *m = CatalogItemCreateTaskRet{} }
func (m *CatalogItemCreateTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCreateTaskRet) ProtoMessage()    {}
func (*CatalogItemCreateTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{2}
}

func (m *CatalogItemCreateTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCreateTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemCreateTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCreateTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemCreateTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCreateTaskRet.Merge(m, src)
}
func (m *CatalogItemCreateTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCreateTaskRet.Size(m)
}
func (m *CatalogItemCreateTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCreateTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCreateTaskRet proto.InternalMessageInfo

func (m *CatalogItemCreateTaskRet) GetCatalogItemUuid() []byte {
	if m != nil {
		return m.CatalogItemUuid
	}
	return nil
}

func (m *CatalogItemCreateTaskRet) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

type CatalogItemUpdateArg struct {
	// UUID of the catalog item to update.
	GlobalCatalogItemUuid []byte `protobuf:"bytes,1,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// Catalog item spec used to update the catalog item.
	Spec *CatalogItemUpdateSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	// Current version of the catalog item.
	Version *int64 `protobuf:"varint,3,opt,name=version,def=-1" json:"version,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,4,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,5,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,6,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Forces a catalog item update. This option ignores any mechanisms that
	// prevent updates in the catalog (i.e PE being registered).
	ForceUpdate          *bool    `protobuf:"varint,7,opt,name=force_update,json=forceUpdate,def=0" json:"force_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUpdateArg) Reset()         { *m = CatalogItemUpdateArg{} }
func (m *CatalogItemUpdateArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUpdateArg) ProtoMessage()    {}
func (*CatalogItemUpdateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{3}
}

func (m *CatalogItemUpdateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUpdateArg.Unmarshal(m, b)
}
func (m *CatalogItemUpdateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUpdateArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemUpdateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUpdateArg.Merge(m, src)
}
func (m *CatalogItemUpdateArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUpdateArg.Size(m)
}
func (m *CatalogItemUpdateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUpdateArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUpdateArg proto.InternalMessageInfo

const Default_CatalogItemUpdateArg_Version int64 = -1
const Default_CatalogItemUpdateArg_ForceUpdate bool = false

func (m *CatalogItemUpdateArg) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogItemUpdateArg) GetSpec() *CatalogItemUpdateSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CatalogItemUpdateArg) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_CatalogItemUpdateArg_Version
}

func (m *CatalogItemUpdateArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemUpdateArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogItemUpdateArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *CatalogItemUpdateArg) GetForceUpdate() bool {
	if m != nil && m.ForceUpdate != nil {
		return *m.ForceUpdate
	}
	return Default_CatalogItemUpdateArg_ForceUpdate
}

type CatalogItemUpdateRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemUpdateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUpdateRet) Reset()         { *m = CatalogItemUpdateRet{} }
func (m *CatalogItemUpdateRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUpdateRet) ProtoMessage()    {}
func (*CatalogItemUpdateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{4}
}

func (m *CatalogItemUpdateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUpdateRet.Unmarshal(m, b)
}
func (m *CatalogItemUpdateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUpdateRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUpdateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUpdateRet.Merge(m, src)
}
func (m *CatalogItemUpdateRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUpdateRet.Size(m)
}
func (m *CatalogItemUpdateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUpdateRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUpdateRet proto.InternalMessageInfo

func (m *CatalogItemUpdateRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemUpdateTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUpdateTaskRet) Reset()         { *m = CatalogItemUpdateTaskRet{} }
func (m *CatalogItemUpdateTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUpdateTaskRet) ProtoMessage()    {}
func (*CatalogItemUpdateTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{5}
}

func (m *CatalogItemUpdateTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUpdateTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemUpdateTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUpdateTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUpdateTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUpdateTaskRet.Merge(m, src)
}
func (m *CatalogItemUpdateTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUpdateTaskRet.Size(m)
}
func (m *CatalogItemUpdateTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUpdateTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUpdateTaskRet proto.InternalMessageInfo

type CatalogItemGetArg struct {
	// List of catalog item types to use as a filter.
	CatalogItemTypeList []CatalogItemInfo_CatalogItemType `protobuf:"varint,1,rep,name=catalog_item_type_list,json=catalogItemTypeList,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"catalog_item_type_list,omitempty"`
	// List of catalog item query details.
	CatalogItemIdList []*CatalogItemId `protobuf:"bytes,2,rep,name=catalog_item_id_list,json=catalogItemIdList" json:"catalog_item_id_list,omitempty"`
	// Get only latest version of the catalog item
	Latest               *bool    `protobuf:"varint,3,opt,name=latest,def=0" json:"latest,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemGetArg) Reset()         { *m = CatalogItemGetArg{} }
func (m *CatalogItemGetArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemGetArg) ProtoMessage()    {}
func (*CatalogItemGetArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{6}
}

func (m *CatalogItemGetArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemGetArg.Unmarshal(m, b)
}
func (m *CatalogItemGetArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemGetArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemGetArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemGetArg.Merge(m, src)
}
func (m *CatalogItemGetArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemGetArg.Size(m)
}
func (m *CatalogItemGetArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemGetArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemGetArg proto.InternalMessageInfo

const Default_CatalogItemGetArg_Latest bool = false

func (m *CatalogItemGetArg) GetCatalogItemTypeList() []CatalogItemInfo_CatalogItemType {
	if m != nil {
		return m.CatalogItemTypeList
	}
	return nil
}

func (m *CatalogItemGetArg) GetCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.CatalogItemIdList
	}
	return nil
}

func (m *CatalogItemGetArg) GetLatest() bool {
	if m != nil && m.Latest != nil {
		return *m.Latest
	}
	return Default_CatalogItemGetArg_Latest
}

type CatalogItemGetRet struct {
	// List of catalog item objects.
	CatalogItemList      []*CatalogItemInfo `protobuf:"bytes,1,rep,name=catalog_item_list,json=catalogItemList" json:"catalog_item_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CatalogItemGetRet) Reset()         { *m = CatalogItemGetRet{} }
func (m *CatalogItemGetRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemGetRet) ProtoMessage()    {}
func (*CatalogItemGetRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{7}
}

func (m *CatalogItemGetRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemGetRet.Unmarshal(m, b)
}
func (m *CatalogItemGetRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemGetRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemGetRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemGetRet.Merge(m, src)
}
func (m *CatalogItemGetRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemGetRet.Size(m)
}
func (m *CatalogItemGetRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemGetRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemGetRet proto.InternalMessageInfo

func (m *CatalogItemGetRet) GetCatalogItemList() []*CatalogItemInfo {
	if m != nil {
		return m.CatalogItemList
	}
	return nil
}

type CatalogClusterUnregistrationArg struct {
	// UUID of cluster being unregistered
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,2,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,3,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,4,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogClusterUnregistrationArg) Reset()         { *m = CatalogClusterUnregistrationArg{} }
func (m *CatalogClusterUnregistrationArg) String() string { return proto.CompactTextString(m) }
func (*CatalogClusterUnregistrationArg) ProtoMessage()    {}
func (*CatalogClusterUnregistrationArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{8}
}

func (m *CatalogClusterUnregistrationArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterUnregistrationArg.Unmarshal(m, b)
}
func (m *CatalogClusterUnregistrationArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterUnregistrationArg.Marshal(b, m, deterministic)
}
func (m *CatalogClusterUnregistrationArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterUnregistrationArg.Merge(m, src)
}
func (m *CatalogClusterUnregistrationArg) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterUnregistrationArg.Size(m)
}
func (m *CatalogClusterUnregistrationArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterUnregistrationArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterUnregistrationArg proto.InternalMessageInfo

func (m *CatalogClusterUnregistrationArg) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *CatalogClusterUnregistrationArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogClusterUnregistrationArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogClusterUnregistrationArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogClusterUnregistrationRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogClusterUnregistrationTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogClusterUnregistrationRet) Reset()         { *m = CatalogClusterUnregistrationRet{} }
func (m *CatalogClusterUnregistrationRet) String() string { return proto.CompactTextString(m) }
func (*CatalogClusterUnregistrationRet) ProtoMessage()    {}
func (*CatalogClusterUnregistrationRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{9}
}

func (m *CatalogClusterUnregistrationRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterUnregistrationRet.Unmarshal(m, b)
}
func (m *CatalogClusterUnregistrationRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterUnregistrationRet.Marshal(b, m, deterministic)
}
func (m *CatalogClusterUnregistrationRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterUnregistrationRet.Merge(m, src)
}
func (m *CatalogClusterUnregistrationRet) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterUnregistrationRet.Size(m)
}
func (m *CatalogClusterUnregistrationRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterUnregistrationRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterUnregistrationRet proto.InternalMessageInfo

func (m *CatalogClusterUnregistrationRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogClusterUnregistrationTaskRet struct {
	// List of catalog item updated
	SuccessfulCatalogItemIdList []*CatalogItemId `protobuf:"bytes,1,rep,name=successful_catalog_item_id_list,json=successfulCatalogItemIdList" json:"successful_catalog_item_id_list,omitempty"`
	// List of catalog item failed to be udpated
	FailedCatalogItemIdList []*CatalogItemId `protobuf:"bytes,2,rep,name=failed_catalog_item_id_list,json=failedCatalogItemIdList" json:"failed_catalog_item_id_list,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}         `json:"-"`
	XXX_unrecognized        []byte           `json:"-"`
	XXX_sizecache           int32            `json:"-"`
}

func (m *CatalogClusterUnregistrationTaskRet) Reset()         { *m = CatalogClusterUnregistrationTaskRet{} }
func (m *CatalogClusterUnregistrationTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogClusterUnregistrationTaskRet) ProtoMessage()    {}
func (*CatalogClusterUnregistrationTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{10}
}

func (m *CatalogClusterUnregistrationTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterUnregistrationTaskRet.Unmarshal(m, b)
}
func (m *CatalogClusterUnregistrationTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterUnregistrationTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogClusterUnregistrationTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterUnregistrationTaskRet.Merge(m, src)
}
func (m *CatalogClusterUnregistrationTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterUnregistrationTaskRet.Size(m)
}
func (m *CatalogClusterUnregistrationTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterUnregistrationTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterUnregistrationTaskRet proto.InternalMessageInfo

func (m *CatalogClusterUnregistrationTaskRet) GetSuccessfulCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.SuccessfulCatalogItemIdList
	}
	return nil
}

func (m *CatalogClusterUnregistrationTaskRet) GetFailedCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.FailedCatalogItemIdList
	}
	return nil
}

// Deprecated
type CatalogItemUnregCleanupArg struct {
	// Uuid for the cluster that is being unregistered
	ClusterUuid          []byte   `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUnregCleanupArg) Reset()         { *m = CatalogItemUnregCleanupArg{} }
func (m *CatalogItemUnregCleanupArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUnregCleanupArg) ProtoMessage()    {}
func (*CatalogItemUnregCleanupArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{11}
}

func (m *CatalogItemUnregCleanupArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUnregCleanupArg.Unmarshal(m, b)
}
func (m *CatalogItemUnregCleanupArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUnregCleanupArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemUnregCleanupArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUnregCleanupArg.Merge(m, src)
}
func (m *CatalogItemUnregCleanupArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUnregCleanupArg.Size(m)
}
func (m *CatalogItemUnregCleanupArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUnregCleanupArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUnregCleanupArg proto.InternalMessageInfo

func (m *CatalogItemUnregCleanupArg) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

type CatalogItemUnregCleanupRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUnregCleanupRet) Reset()         { *m = CatalogItemUnregCleanupRet{} }
func (m *CatalogItemUnregCleanupRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUnregCleanupRet) ProtoMessage()    {}
func (*CatalogItemUnregCleanupRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{12}
}

func (m *CatalogItemUnregCleanupRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUnregCleanupRet.Unmarshal(m, b)
}
func (m *CatalogItemUnregCleanupRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUnregCleanupRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUnregCleanupRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUnregCleanupRet.Merge(m, src)
}
func (m *CatalogItemUnregCleanupRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUnregCleanupRet.Size(m)
}
func (m *CatalogItemUnregCleanupRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUnregCleanupRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUnregCleanupRet proto.InternalMessageInfo

type CatalogClusterRegistrationArg struct {
	// UUID of cluster being unregistered
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,2,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,3,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,4,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogClusterRegistrationArg) Reset()         { *m = CatalogClusterRegistrationArg{} }
func (m *CatalogClusterRegistrationArg) String() string { return proto.CompactTextString(m) }
func (*CatalogClusterRegistrationArg) ProtoMessage()    {}
func (*CatalogClusterRegistrationArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{13}
}

func (m *CatalogClusterRegistrationArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterRegistrationArg.Unmarshal(m, b)
}
func (m *CatalogClusterRegistrationArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterRegistrationArg.Marshal(b, m, deterministic)
}
func (m *CatalogClusterRegistrationArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterRegistrationArg.Merge(m, src)
}
func (m *CatalogClusterRegistrationArg) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterRegistrationArg.Size(m)
}
func (m *CatalogClusterRegistrationArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterRegistrationArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterRegistrationArg proto.InternalMessageInfo

func (m *CatalogClusterRegistrationArg) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *CatalogClusterRegistrationArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogClusterRegistrationArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogClusterRegistrationArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogClusterRegistrationRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogClusterUnregistrationTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogClusterRegistrationRet) Reset()         { *m = CatalogClusterRegistrationRet{} }
func (m *CatalogClusterRegistrationRet) String() string { return proto.CompactTextString(m) }
func (*CatalogClusterRegistrationRet) ProtoMessage()    {}
func (*CatalogClusterRegistrationRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{14}
}

func (m *CatalogClusterRegistrationRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterRegistrationRet.Unmarshal(m, b)
}
func (m *CatalogClusterRegistrationRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterRegistrationRet.Marshal(b, m, deterministic)
}
func (m *CatalogClusterRegistrationRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterRegistrationRet.Merge(m, src)
}
func (m *CatalogClusterRegistrationRet) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterRegistrationRet.Size(m)
}
func (m *CatalogClusterRegistrationRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterRegistrationRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterRegistrationRet proto.InternalMessageInfo

func (m *CatalogClusterRegistrationRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogClusterRegistrationTaskRet struct {
	// List of catalog item updated
	SuccessfulCatalogItemIdList []*CatalogItemId `protobuf:"bytes,1,rep,name=successful_catalog_item_id_list,json=successfulCatalogItemIdList" json:"successful_catalog_item_id_list,omitempty"`
	// List of catalog item failed to be udpated
	FailedCatalogItemIdList []*CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo `protobuf:"bytes,2,rep,name=failed_catalog_item_id_list,json=failedCatalogItemIdList" json:"failed_catalog_item_id_list,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                                                       `json:"-"`
	XXX_unrecognized        []byte                                                         `json:"-"`
	XXX_sizecache           int32                                                          `json:"-"`
}

func (m *CatalogClusterRegistrationTaskRet) Reset()         { *m = CatalogClusterRegistrationTaskRet{} }
func (m *CatalogClusterRegistrationTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogClusterRegistrationTaskRet) ProtoMessage()    {}
func (*CatalogClusterRegistrationTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{15}
}

func (m *CatalogClusterRegistrationTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterRegistrationTaskRet.Unmarshal(m, b)
}
func (m *CatalogClusterRegistrationTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterRegistrationTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogClusterRegistrationTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterRegistrationTaskRet.Merge(m, src)
}
func (m *CatalogClusterRegistrationTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterRegistrationTaskRet.Size(m)
}
func (m *CatalogClusterRegistrationTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterRegistrationTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterRegistrationTaskRet proto.InternalMessageInfo

func (m *CatalogClusterRegistrationTaskRet) GetSuccessfulCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.SuccessfulCatalogItemIdList
	}
	return nil
}

func (m *CatalogClusterRegistrationTaskRet) GetFailedCatalogItemIdList() []*CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo {
	if m != nil {
		return m.FailedCatalogItemIdList
	}
	return nil
}

type CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo struct {
	CatalogItemId        *CatalogItemId `protobuf:"bytes,1,opt,name=catalog_item_id,json=catalogItemId" json:"catalog_item_id,omitempty"`
	ErrReason            *string        `protobuf:"bytes,2,opt,name=err_reason,json=errReason" json:"err_reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) Reset() {
	*m = CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo{}
}
func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) String() string {
	return proto.CompactTextString(m)
}
func (*CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) ProtoMessage() {}
func (*CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{15, 0}
}

func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo.Unmarshal(m, b)
}
func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo.Marshal(b, m, deterministic)
}
func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo.Merge(m, src)
}
func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) XXX_Size() int {
	return xxx_messageInfo_CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo.Size(m)
}
func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo proto.InternalMessageInfo

func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) GetCatalogItemId() *CatalogItemId {
	if m != nil {
		return m.CatalogItemId
	}
	return nil
}

func (m *CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo) GetErrReason() string {
	if m != nil && m.ErrReason != nil {
		return *m.ErrReason
	}
	return ""
}

type CatalogItemCheckoutArg struct {
	// ID of the catalog item to checkout.
	CatalogItemId *CatalogItemId `protobuf:"bytes,1,opt,name=catalog_item_id,json=catalogItemId" json:"catalog_item_id,omitempty"`
	// UUIDs of clusters where the catalog item should be checked out.
	ClusterUuidList [][]byte `protobuf:"bytes,2,rep,name=cluster_uuid_list,json=clusterUuidList" json:"cluster_uuid_list,omitempty"`
	// UUIDs of availability zones where the catalog item should be checked out.
	AvailabilityZoneUuidList [][]byte `protobuf:"bytes,3,rep,name=availability_zone_uuid_list,json=availabilityZoneUuidList" json:"availability_zone_uuid_list,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,4,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,5,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,6,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Boolean indicating if checkout is issued from policy engine or not
	IssuedFromEngine     *bool    `protobuf:"varint,7,opt,name=issued_from_engine,json=issuedFromEngine,def=0" json:"issued_from_engine,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemCheckoutArg) Reset()         { *m = CatalogItemCheckoutArg{} }
func (m *CatalogItemCheckoutArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCheckoutArg) ProtoMessage()    {}
func (*CatalogItemCheckoutArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{16}
}

func (m *CatalogItemCheckoutArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCheckoutArg.Unmarshal(m, b)
}
func (m *CatalogItemCheckoutArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCheckoutArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemCheckoutArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCheckoutArg.Merge(m, src)
}
func (m *CatalogItemCheckoutArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCheckoutArg.Size(m)
}
func (m *CatalogItemCheckoutArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCheckoutArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCheckoutArg proto.InternalMessageInfo

const Default_CatalogItemCheckoutArg_IssuedFromEngine bool = false

func (m *CatalogItemCheckoutArg) GetCatalogItemId() *CatalogItemId {
	if m != nil {
		return m.CatalogItemId
	}
	return nil
}

func (m *CatalogItemCheckoutArg) GetClusterUuidList() [][]byte {
	if m != nil {
		return m.ClusterUuidList
	}
	return nil
}

func (m *CatalogItemCheckoutArg) GetAvailabilityZoneUuidList() [][]byte {
	if m != nil {
		return m.AvailabilityZoneUuidList
	}
	return nil
}

func (m *CatalogItemCheckoutArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemCheckoutArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogItemCheckoutArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *CatalogItemCheckoutArg) GetIssuedFromEngine() bool {
	if m != nil && m.IssuedFromEngine != nil {
		return *m.IssuedFromEngine
	}
	return Default_CatalogItemCheckoutArg_IssuedFromEngine
}

type CatalogItemCheckoutRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemCheckoutTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemCheckoutRet) Reset()         { *m = CatalogItemCheckoutRet{} }
func (m *CatalogItemCheckoutRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCheckoutRet) ProtoMessage()    {}
func (*CatalogItemCheckoutRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{17}
}

func (m *CatalogItemCheckoutRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCheckoutRet.Unmarshal(m, b)
}
func (m *CatalogItemCheckoutRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCheckoutRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemCheckoutRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCheckoutRet.Merge(m, src)
}
func (m *CatalogItemCheckoutRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCheckoutRet.Size(m)
}
func (m *CatalogItemCheckoutRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCheckoutRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCheckoutRet proto.InternalMessageInfo

func (m *CatalogItemCheckoutRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemCheckoutTaskRet struct {
	// List of cluster UUIDs where checkout failed.
	FailedDstClusterUuidList [][]byte `protobuf:"bytes,1,rep,name=failed_dst_cluster_uuid_list,json=failedDstClusterUuidList" json:"failed_dst_cluster_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *CatalogItemCheckoutTaskRet) Reset()         { *m = CatalogItemCheckoutTaskRet{} }
func (m *CatalogItemCheckoutTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemCheckoutTaskRet) ProtoMessage()    {}
func (*CatalogItemCheckoutTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{18}
}

func (m *CatalogItemCheckoutTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemCheckoutTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemCheckoutTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemCheckoutTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemCheckoutTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemCheckoutTaskRet.Merge(m, src)
}
func (m *CatalogItemCheckoutTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemCheckoutTaskRet.Size(m)
}
func (m *CatalogItemCheckoutTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemCheckoutTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemCheckoutTaskRet proto.InternalMessageInfo

func (m *CatalogItemCheckoutTaskRet) GetFailedDstClusterUuidList() [][]byte {
	if m != nil {
		return m.FailedDstClusterUuidList
	}
	return nil
}

type CatalogItemUncheckoutArg struct {
	// ID of the catalog item to checkout.
	CatalogItemId *CatalogItemId `protobuf:"bytes,1,opt,name=catalog_item_id,json=catalogItemId" json:"catalog_item_id,omitempty"`
	// UUIDs of clusters where the catalog item should be unchecked out.
	ClusterUuidList [][]byte `protobuf:"bytes,2,rep,name=cluster_uuid_list,json=clusterUuidList" json:"cluster_uuid_list,omitempty"`
	// UUIDs of availability zones where the catalog item should be unchecked out.
	AvailabilityZoneUuidList [][]byte `protobuf:"bytes,3,rep,name=availability_zone_uuid_list,json=availabilityZoneUuidList" json:"availability_zone_uuid_list,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,4,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,5,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,6,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Boolean indicating if checkout is issued from policy engine or not
	IssuedFromEngine     *bool    `protobuf:"varint,7,opt,name=issued_from_engine,json=issuedFromEngine,def=0" json:"issued_from_engine,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUncheckoutArg) Reset()         { *m = CatalogItemUncheckoutArg{} }
func (m *CatalogItemUncheckoutArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUncheckoutArg) ProtoMessage()    {}
func (*CatalogItemUncheckoutArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{19}
}

func (m *CatalogItemUncheckoutArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUncheckoutArg.Unmarshal(m, b)
}
func (m *CatalogItemUncheckoutArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUncheckoutArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemUncheckoutArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUncheckoutArg.Merge(m, src)
}
func (m *CatalogItemUncheckoutArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUncheckoutArg.Size(m)
}
func (m *CatalogItemUncheckoutArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUncheckoutArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUncheckoutArg proto.InternalMessageInfo

const Default_CatalogItemUncheckoutArg_IssuedFromEngine bool = false

func (m *CatalogItemUncheckoutArg) GetCatalogItemId() *CatalogItemId {
	if m != nil {
		return m.CatalogItemId
	}
	return nil
}

func (m *CatalogItemUncheckoutArg) GetClusterUuidList() [][]byte {
	if m != nil {
		return m.ClusterUuidList
	}
	return nil
}

func (m *CatalogItemUncheckoutArg) GetAvailabilityZoneUuidList() [][]byte {
	if m != nil {
		return m.AvailabilityZoneUuidList
	}
	return nil
}

func (m *CatalogItemUncheckoutArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemUncheckoutArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogItemUncheckoutArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *CatalogItemUncheckoutArg) GetIssuedFromEngine() bool {
	if m != nil && m.IssuedFromEngine != nil {
		return *m.IssuedFromEngine
	}
	return Default_CatalogItemUncheckoutArg_IssuedFromEngine
}

type CatalogItemUncheckoutRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemUncheckoutTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUncheckoutRet) Reset()         { *m = CatalogItemUncheckoutRet{} }
func (m *CatalogItemUncheckoutRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUncheckoutRet) ProtoMessage()    {}
func (*CatalogItemUncheckoutRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{20}
}

func (m *CatalogItemUncheckoutRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUncheckoutRet.Unmarshal(m, b)
}
func (m *CatalogItemUncheckoutRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUncheckoutRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUncheckoutRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUncheckoutRet.Merge(m, src)
}
func (m *CatalogItemUncheckoutRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUncheckoutRet.Size(m)
}
func (m *CatalogItemUncheckoutRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUncheckoutRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUncheckoutRet proto.InternalMessageInfo

func (m *CatalogItemUncheckoutRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemUncheckoutTaskRet struct {
	// List of cluster UUIDs where uncheckout failed.
	FailedDstClusterUuidList [][]byte `protobuf:"bytes,1,rep,name=failed_dst_cluster_uuid_list,json=failedDstClusterUuidList" json:"failed_dst_cluster_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *CatalogItemUncheckoutTaskRet) Reset()         { *m = CatalogItemUncheckoutTaskRet{} }
func (m *CatalogItemUncheckoutTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUncheckoutTaskRet) ProtoMessage()    {}
func (*CatalogItemUncheckoutTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{21}
}

func (m *CatalogItemUncheckoutTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUncheckoutTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemUncheckoutTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUncheckoutTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUncheckoutTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUncheckoutTaskRet.Merge(m, src)
}
func (m *CatalogItemUncheckoutTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUncheckoutTaskRet.Size(m)
}
func (m *CatalogItemUncheckoutTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUncheckoutTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUncheckoutTaskRet proto.InternalMessageInfo

func (m *CatalogItemUncheckoutTaskRet) GetFailedDstClusterUuidList() [][]byte {
	if m != nil {
		return m.FailedDstClusterUuidList
	}
	return nil
}

type CatalogItemRemoveArg struct {
	// UUID of the catalog item to remove.
	CatalogItemUuid []byte `protobuf:"bytes,1,opt,name=catalog_item_uuid,json=catalogItemUuid" json:"catalog_item_uuid,omitempty"`
	// UUIDs of the clusters where the catalog item should no longer reside.
	ClusterUuidList [][]byte `protobuf:"bytes,2,rep,name=cluster_uuid_list,json=clusterUuidList" json:"cluster_uuid_list,omitempty"`
	// UUIDs of availability zones where the catalog item should no longer
	// reside.
	AvailabilityZoneUuidList [][]byte `protobuf:"bytes,3,rep,name=availability_zone_uuid_list,json=availabilityZoneUuidList" json:"availability_zone_uuid_list,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,4,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,5,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,6,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemRemoveArg) Reset()         { *m = CatalogItemRemoveArg{} }
func (m *CatalogItemRemoveArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemRemoveArg) ProtoMessage()    {}
func (*CatalogItemRemoveArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{22}
}

func (m *CatalogItemRemoveArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemRemoveArg.Unmarshal(m, b)
}
func (m *CatalogItemRemoveArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemRemoveArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemRemoveArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemRemoveArg.Merge(m, src)
}
func (m *CatalogItemRemoveArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemRemoveArg.Size(m)
}
func (m *CatalogItemRemoveArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemRemoveArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemRemoveArg proto.InternalMessageInfo

func (m *CatalogItemRemoveArg) GetCatalogItemUuid() []byte {
	if m != nil {
		return m.CatalogItemUuid
	}
	return nil
}

func (m *CatalogItemRemoveArg) GetClusterUuidList() [][]byte {
	if m != nil {
		return m.ClusterUuidList
	}
	return nil
}

func (m *CatalogItemRemoveArg) GetAvailabilityZoneUuidList() [][]byte {
	if m != nil {
		return m.AvailabilityZoneUuidList
	}
	return nil
}

func (m *CatalogItemRemoveArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemRemoveArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogItemRemoveArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogItemRemoveRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemRemoveTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemRemoveRet) Reset()         { *m = CatalogItemRemoveRet{} }
func (m *CatalogItemRemoveRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemRemoveRet) ProtoMessage()    {}
func (*CatalogItemRemoveRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{23}
}

func (m *CatalogItemRemoveRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemRemoveRet.Unmarshal(m, b)
}
func (m *CatalogItemRemoveRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemRemoveRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemRemoveRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemRemoveRet.Merge(m, src)
}
func (m *CatalogItemRemoveRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemRemoveRet.Size(m)
}
func (m *CatalogItemRemoveRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemRemoveRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemRemoveRet proto.InternalMessageInfo

func (m *CatalogItemRemoveRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemRemoveTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemRemoveTaskRet) Reset()         { *m = CatalogItemRemoveTaskRet{} }
func (m *CatalogItemRemoveTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemRemoveTaskRet) ProtoMessage()    {}
func (*CatalogItemRemoveTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{24}
}

func (m *CatalogItemRemoveTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemRemoveTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemRemoveTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemRemoveTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemRemoveTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemRemoveTaskRet.Merge(m, src)
}
func (m *CatalogItemRemoveTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemRemoveTaskRet.Size(m)
}
func (m *CatalogItemRemoveTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemRemoveTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemRemoveTaskRet proto.InternalMessageInfo

type CatalogItemDeleteArg struct {
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// List of catalog item query details.
	CatalogItemId *CatalogItemId `protobuf:"bytes,2,opt,name=catalog_item_id,json=catalogItemId" json:"catalog_item_id,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,3,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,4,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Forces a catalog item update. This option ignores any mechanisms that
	// prevent updates in the catalog (i.e PE being registered).
	ForceUpdate          *bool    `protobuf:"varint,5,opt,name=force_update,json=forceUpdate,def=0" json:"force_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemDeleteArg) Reset()         { *m = CatalogItemDeleteArg{} }
func (m *CatalogItemDeleteArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemDeleteArg) ProtoMessage()    {}
func (*CatalogItemDeleteArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{25}
}

func (m *CatalogItemDeleteArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemDeleteArg.Unmarshal(m, b)
}
func (m *CatalogItemDeleteArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemDeleteArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemDeleteArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemDeleteArg.Merge(m, src)
}
func (m *CatalogItemDeleteArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemDeleteArg.Size(m)
}
func (m *CatalogItemDeleteArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemDeleteArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemDeleteArg proto.InternalMessageInfo

const Default_CatalogItemDeleteArg_ForceUpdate bool = false

func (m *CatalogItemDeleteArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemDeleteArg) GetCatalogItemId() *CatalogItemId {
	if m != nil {
		return m.CatalogItemId
	}
	return nil
}

func (m *CatalogItemDeleteArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogItemDeleteArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *CatalogItemDeleteArg) GetForceUpdate() bool {
	if m != nil && m.ForceUpdate != nil {
		return *m.ForceUpdate
	}
	return Default_CatalogItemDeleteArg_ForceUpdate
}

type CatalogItemDeleteRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemDeleteTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemDeleteRet) Reset()         { *m = CatalogItemDeleteRet{} }
func (m *CatalogItemDeleteRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemDeleteRet) ProtoMessage()    {}
func (*CatalogItemDeleteRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{26}
}

func (m *CatalogItemDeleteRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemDeleteRet.Unmarshal(m, b)
}
func (m *CatalogItemDeleteRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemDeleteRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemDeleteRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemDeleteRet.Merge(m, src)
}
func (m *CatalogItemDeleteRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemDeleteRet.Size(m)
}
func (m *CatalogItemDeleteRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemDeleteRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemDeleteRet proto.InternalMessageInfo

func (m *CatalogItemDeleteRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemDeleteTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemDeleteTaskRet) Reset()         { *m = CatalogItemDeleteTaskRet{} }
func (m *CatalogItemDeleteTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemDeleteTaskRet) ProtoMessage()    {}
func (*CatalogItemDeleteTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{27}
}

func (m *CatalogItemDeleteTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemDeleteTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemDeleteTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemDeleteTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemDeleteTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemDeleteTaskRet.Merge(m, src)
}
func (m *CatalogItemDeleteTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemDeleteTaskRet.Size(m)
}
func (m *CatalogItemDeleteTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemDeleteTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemDeleteTaskRet proto.InternalMessageInfo

type CatalogItemUploadArg struct {
	// Catalog item global UUID.
	GlobalCatalogItemUuid []byte `protobuf:"bytes,1,opt,name=global_catalog_item_uuid,json=globalCatalogItemUuid" json:"global_catalog_item_uuid,omitempty"`
	// Upload spec that contains the details of the catalog item being uploaded.
	UploadSpec *CatalogFileUploadSpec `protobuf:"bytes,2,opt,name=upload_spec,json=uploadSpec" json:"upload_spec,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,3,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Catalog item version (logical timestamp).
	Version *int64 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	// Tenant UUID.
	TenantUuid []byte `protobuf:"bytes,5,opt,name=tenant_uuid,json=tenantUuid" json:"tenant_uuid,omitempty"`
	// User UUID.
	UserUuid             []byte   `protobuf:"bytes,6,opt,name=user_uuid,json=userUuid" json:"user_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUploadArg) Reset()         { *m = CatalogItemUploadArg{} }
func (m *CatalogItemUploadArg) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUploadArg) ProtoMessage()    {}
func (*CatalogItemUploadArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{28}
}

func (m *CatalogItemUploadArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUploadArg.Unmarshal(m, b)
}
func (m *CatalogItemUploadArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUploadArg.Marshal(b, m, deterministic)
}
func (m *CatalogItemUploadArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUploadArg.Merge(m, src)
}
func (m *CatalogItemUploadArg) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUploadArg.Size(m)
}
func (m *CatalogItemUploadArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUploadArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUploadArg proto.InternalMessageInfo

func (m *CatalogItemUploadArg) GetGlobalCatalogItemUuid() []byte {
	if m != nil {
		return m.GlobalCatalogItemUuid
	}
	return nil
}

func (m *CatalogItemUploadArg) GetUploadSpec() *CatalogFileUploadSpec {
	if m != nil {
		return m.UploadSpec
	}
	return nil
}

func (m *CatalogItemUploadArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogItemUploadArg) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *CatalogItemUploadArg) GetTenantUuid() []byte {
	if m != nil {
		return m.TenantUuid
	}
	return nil
}

func (m *CatalogItemUploadArg) GetUserUuid() []byte {
	if m != nil {
		return m.UserUuid
	}
	return nil
}

type CatalogItemUploadRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogItemUploadTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUploadRet) Reset()         { *m = CatalogItemUploadRet{} }
func (m *CatalogItemUploadRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUploadRet) ProtoMessage()    {}
func (*CatalogItemUploadRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{29}
}

func (m *CatalogItemUploadRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUploadRet.Unmarshal(m, b)
}
func (m *CatalogItemUploadRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUploadRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUploadRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUploadRet.Merge(m, src)
}
func (m *CatalogItemUploadRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUploadRet.Size(m)
}
func (m *CatalogItemUploadRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUploadRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUploadRet proto.InternalMessageInfo

func (m *CatalogItemUploadRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogItemUploadTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogItemUploadTaskRet) Reset()         { *m = CatalogItemUploadTaskRet{} }
func (m *CatalogItemUploadTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogItemUploadTaskRet) ProtoMessage()    {}
func (*CatalogItemUploadTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{30}
}

func (m *CatalogItemUploadTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogItemUploadTaskRet.Unmarshal(m, b)
}
func (m *CatalogItemUploadTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogItemUploadTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogItemUploadTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogItemUploadTaskRet.Merge(m, src)
}
func (m *CatalogItemUploadTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogItemUploadTaskRet.Size(m)
}
func (m *CatalogItemUploadTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogItemUploadTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogItemUploadTaskRet proto.InternalMessageInfo

type FileGetArg struct {
	// List of file uuids to query for.
	FileUuidList [][]byte `protobuf:"bytes,1,rep,name=file_uuid_list,json=fileUuidList" json:"file_uuid_list,omitempty"`
	// Whether to calculate the size of files
	IncludeSize *bool `protobuf:"varint,2,opt,name=include_size,json=includeSize,def=0" json:"include_size,omitempty"`
	// Whether to return absolute path of file location.
	IncludeAbsolutePath  *bool    `protobuf:"varint,3,opt,name=include_absolute_path,json=includeAbsolutePath,def=0" json:"include_absolute_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileGetArg) Reset()         { *m = FileGetArg{} }
func (m *FileGetArg) String() string { return proto.CompactTextString(m) }
func (*FileGetArg) ProtoMessage()    {}
func (*FileGetArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{31}
}

func (m *FileGetArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileGetArg.Unmarshal(m, b)
}
func (m *FileGetArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileGetArg.Marshal(b, m, deterministic)
}
func (m *FileGetArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileGetArg.Merge(m, src)
}
func (m *FileGetArg) XXX_Size() int {
	return xxx_messageInfo_FileGetArg.Size(m)
}
func (m *FileGetArg) XXX_DiscardUnknown() {
	xxx_messageInfo_FileGetArg.DiscardUnknown(m)
}

var xxx_messageInfo_FileGetArg proto.InternalMessageInfo

const Default_FileGetArg_IncludeSize bool = false
const Default_FileGetArg_IncludeAbsolutePath bool = false

func (m *FileGetArg) GetFileUuidList() [][]byte {
	if m != nil {
		return m.FileUuidList
	}
	return nil
}

func (m *FileGetArg) GetIncludeSize() bool {
	if m != nil && m.IncludeSize != nil {
		return *m.IncludeSize
	}
	return Default_FileGetArg_IncludeSize
}

func (m *FileGetArg) GetIncludeAbsolutePath() bool {
	if m != nil && m.IncludeAbsolutePath != nil {
		return *m.IncludeAbsolutePath
	}
	return Default_FileGetArg_IncludeAbsolutePath
}

type FileGetRet struct {
	// List of file info objects.
	FileInfoList         []*FileInfo `protobuf:"bytes,1,rep,name=file_info_list,json=fileInfoList" json:"file_info_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FileGetRet) Reset()         { *m = FileGetRet{} }
func (m *FileGetRet) String() string { return proto.CompactTextString(m) }
func (*FileGetRet) ProtoMessage()    {}
func (*FileGetRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{32}
}

func (m *FileGetRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileGetRet.Unmarshal(m, b)
}
func (m *FileGetRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileGetRet.Marshal(b, m, deterministic)
}
func (m *FileGetRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileGetRet.Merge(m, src)
}
func (m *FileGetRet) XXX_Size() int {
	return xxx_messageInfo_FileGetRet.Size(m)
}
func (m *FileGetRet) XXX_DiscardUnknown() {
	xxx_messageInfo_FileGetRet.DiscardUnknown(m)
}

var xxx_messageInfo_FileGetRet proto.InternalMessageInfo

func (m *FileGetRet) GetFileInfoList() []*FileInfo {
	if m != nil {
		return m.FileInfoList
	}
	return nil
}

type ImageUploadArg struct {
	// Image UUID.
	ImageUuid []byte `protobuf:"bytes,1,opt,name=image_uuid,json=imageUuid" json:"image_uuid,omitempty"`
	// Upload spec that contains the details of the image upload.
	UploadSpec *CatalogFileUploadSpec `protobuf:"bytes,2,opt,name=upload_spec,json=uploadSpec" json:"upload_spec,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,3,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Image version (logical timestamp).
	Version *int64 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	// Tenant UUID.
	TenantUuid []byte `protobuf:"bytes,5,opt,name=tenant_uuid,json=tenantUuid" json:"tenant_uuid,omitempty"`
	// User UUID.
	UserUuid []byte `protobuf:"bytes,6,opt,name=user_uuid,json=userUuid" json:"user_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,7,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,8,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageUploadArg) Reset()         { *m = ImageUploadArg{} }
func (m *ImageUploadArg) String() string { return proto.CompactTextString(m) }
func (*ImageUploadArg) ProtoMessage()    {}
func (*ImageUploadArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{33}
}

func (m *ImageUploadArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageUploadArg.Unmarshal(m, b)
}
func (m *ImageUploadArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageUploadArg.Marshal(b, m, deterministic)
}
func (m *ImageUploadArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageUploadArg.Merge(m, src)
}
func (m *ImageUploadArg) XXX_Size() int {
	return xxx_messageInfo_ImageUploadArg.Size(m)
}
func (m *ImageUploadArg) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageUploadArg.DiscardUnknown(m)
}

var xxx_messageInfo_ImageUploadArg proto.InternalMessageInfo

func (m *ImageUploadArg) GetImageUuid() []byte {
	if m != nil {
		return m.ImageUuid
	}
	return nil
}

func (m *ImageUploadArg) GetUploadSpec() *CatalogFileUploadSpec {
	if m != nil {
		return m.UploadSpec
	}
	return nil
}

func (m *ImageUploadArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *ImageUploadArg) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *ImageUploadArg) GetTenantUuid() []byte {
	if m != nil {
		return m.TenantUuid
	}
	return nil
}

func (m *ImageUploadArg) GetUserUuid() []byte {
	if m != nil {
		return m.UserUuid
	}
	return nil
}

func (m *ImageUploadArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *ImageUploadArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type ImageUploadRet struct {
	// A task to poll for completion. On success, the task will contain a
	// ImageUploadTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageUploadRet) Reset()         { *m = ImageUploadRet{} }
func (m *ImageUploadRet) String() string { return proto.CompactTextString(m) }
func (*ImageUploadRet) ProtoMessage()    {}
func (*ImageUploadRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{34}
}

func (m *ImageUploadRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageUploadRet.Unmarshal(m, b)
}
func (m *ImageUploadRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageUploadRet.Marshal(b, m, deterministic)
}
func (m *ImageUploadRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageUploadRet.Merge(m, src)
}
func (m *ImageUploadRet) XXX_Size() int {
	return xxx_messageInfo_ImageUploadRet.Size(m)
}
func (m *ImageUploadRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageUploadRet.DiscardUnknown(m)
}

var xxx_messageInfo_ImageUploadRet proto.InternalMessageInfo

func (m *ImageUploadRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type ImageUploadTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageUploadTaskRet) Reset()         { *m = ImageUploadTaskRet{} }
func (m *ImageUploadTaskRet) String() string { return proto.CompactTextString(m) }
func (*ImageUploadTaskRet) ProtoMessage()    {}
func (*ImageUploadTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{35}
}

func (m *ImageUploadTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageUploadTaskRet.Unmarshal(m, b)
}
func (m *ImageUploadTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageUploadTaskRet.Marshal(b, m, deterministic)
}
func (m *ImageUploadTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageUploadTaskRet.Merge(m, src)
}
func (m *ImageUploadTaskRet) XXX_Size() int {
	return xxx_messageInfo_ImageUploadTaskRet.Size(m)
}
func (m *ImageUploadTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageUploadTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_ImageUploadTaskRet proto.InternalMessageInfo

type CatalogMigratePcArg struct {
	// UUID of the PE cluster registered with PC
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	TaskUuid    []byte `protobuf:"bytes,2,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// List of catalog item types to use as a filter.
	CatalogItemTypeList []CatalogItemInfo_CatalogItemType `protobuf:"varint,3,rep,name=catalog_item_type_list,json=catalogItemTypeList,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"catalog_item_type_list,omitempty"`
	// ID list for catalog items to be migrated from PE cluster
	CatalogItemIdList    []*CatalogItemId `protobuf:"bytes,4,rep,name=catalog_item_id_list,json=catalogItemIdList" json:"catalog_item_id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CatalogMigratePcArg) Reset()         { *m = CatalogMigratePcArg{} }
func (m *CatalogMigratePcArg) String() string { return proto.CompactTextString(m) }
func (*CatalogMigratePcArg) ProtoMessage()    {}
func (*CatalogMigratePcArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{36}
}

func (m *CatalogMigratePcArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogMigratePcArg.Unmarshal(m, b)
}
func (m *CatalogMigratePcArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogMigratePcArg.Marshal(b, m, deterministic)
}
func (m *CatalogMigratePcArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogMigratePcArg.Merge(m, src)
}
func (m *CatalogMigratePcArg) XXX_Size() int {
	return xxx_messageInfo_CatalogMigratePcArg.Size(m)
}
func (m *CatalogMigratePcArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogMigratePcArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogMigratePcArg proto.InternalMessageInfo

func (m *CatalogMigratePcArg) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *CatalogMigratePcArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogMigratePcArg) GetCatalogItemTypeList() []CatalogItemInfo_CatalogItemType {
	if m != nil {
		return m.CatalogItemTypeList
	}
	return nil
}

func (m *CatalogMigratePcArg) GetCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.CatalogItemIdList
	}
	return nil
}

type CatalogMigratePcRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogMigratePcTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogMigratePcRet) Reset()         { *m = CatalogMigratePcRet{} }
func (m *CatalogMigratePcRet) String() string { return proto.CompactTextString(m) }
func (*CatalogMigratePcRet) ProtoMessage()    {}
func (*CatalogMigratePcRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{37}
}

func (m *CatalogMigratePcRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogMigratePcRet.Unmarshal(m, b)
}
func (m *CatalogMigratePcRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogMigratePcRet.Marshal(b, m, deterministic)
}
func (m *CatalogMigratePcRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogMigratePcRet.Merge(m, src)
}
func (m *CatalogMigratePcRet) XXX_Size() int {
	return xxx_messageInfo_CatalogMigratePcRet.Size(m)
}
func (m *CatalogMigratePcRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogMigratePcRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogMigratePcRet proto.InternalMessageInfo

func (m *CatalogMigratePcRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogMigratePcTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogMigratePcTaskRet) Reset()         { *m = CatalogMigratePcTaskRet{} }
func (m *CatalogMigratePcTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogMigratePcTaskRet) ProtoMessage()    {}
func (*CatalogMigratePcTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{38}
}

func (m *CatalogMigratePcTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogMigratePcTaskRet.Unmarshal(m, b)
}
func (m *CatalogMigratePcTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogMigratePcTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogMigratePcTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogMigratePcTaskRet.Merge(m, src)
}
func (m *CatalogMigratePcTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogMigratePcTaskRet.Size(m)
}
func (m *CatalogMigratePcTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogMigratePcTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogMigratePcTaskRet proto.InternalMessageInfo

type CatalogRemoteSeedingSourceArg struct {
	// Remote PC clsuter UUID.
	ClusterUuid []byte `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// UUIDs of the catalog item to be copied over to remote PC.
	CatalogItemIdList []*CatalogItemId `protobuf:"bytes,2,rep,name=catalog_item_id_list,json=catalogItemIdList" json:"catalog_item_id_list,omitempty"`
	// Type of catalog items to be migrated.
	CatalogItemTypeList  []CatalogItemInfo_CatalogItemType `protobuf:"varint,3,rep,name=catalog_item_type_list,json=catalogItemTypeList,enum=nutanix.catalog.CatalogItemInfo_CatalogItemType" json:"catalog_item_type_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *CatalogRemoteSeedingSourceArg) Reset()         { *m = CatalogRemoteSeedingSourceArg{} }
func (m *CatalogRemoteSeedingSourceArg) String() string { return proto.CompactTextString(m) }
func (*CatalogRemoteSeedingSourceArg) ProtoMessage()    {}
func (*CatalogRemoteSeedingSourceArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{39}
}

func (m *CatalogRemoteSeedingSourceArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRemoteSeedingSourceArg.Unmarshal(m, b)
}
func (m *CatalogRemoteSeedingSourceArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRemoteSeedingSourceArg.Marshal(b, m, deterministic)
}
func (m *CatalogRemoteSeedingSourceArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRemoteSeedingSourceArg.Merge(m, src)
}
func (m *CatalogRemoteSeedingSourceArg) XXX_Size() int {
	return xxx_messageInfo_CatalogRemoteSeedingSourceArg.Size(m)
}
func (m *CatalogRemoteSeedingSourceArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRemoteSeedingSourceArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRemoteSeedingSourceArg proto.InternalMessageInfo

func (m *CatalogRemoteSeedingSourceArg) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *CatalogRemoteSeedingSourceArg) GetCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.CatalogItemIdList
	}
	return nil
}

func (m *CatalogRemoteSeedingSourceArg) GetCatalogItemTypeList() []CatalogItemInfo_CatalogItemType {
	if m != nil {
		return m.CatalogItemTypeList
	}
	return nil
}

type CatalogRemoteSeedingSourceRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogRemoteSeedingSourceTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRemoteSeedingSourceRet) Reset()         { *m = CatalogRemoteSeedingSourceRet{} }
func (m *CatalogRemoteSeedingSourceRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRemoteSeedingSourceRet) ProtoMessage()    {}
func (*CatalogRemoteSeedingSourceRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{40}
}

func (m *CatalogRemoteSeedingSourceRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRemoteSeedingSourceRet.Unmarshal(m, b)
}
func (m *CatalogRemoteSeedingSourceRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRemoteSeedingSourceRet.Marshal(b, m, deterministic)
}
func (m *CatalogRemoteSeedingSourceRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRemoteSeedingSourceRet.Merge(m, src)
}
func (m *CatalogRemoteSeedingSourceRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRemoteSeedingSourceRet.Size(m)
}
func (m *CatalogRemoteSeedingSourceRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRemoteSeedingSourceRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRemoteSeedingSourceRet proto.InternalMessageInfo

func (m *CatalogRemoteSeedingSourceRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogRemoteSeedingSourceTaskRet struct {
	// List of catalog items that failed to be copied to remote PC.
	FailedCatalogItemIdList []*CatalogItemId `protobuf:"bytes,2,rep,name=failed_catalog_item_id_list,json=failedCatalogItemIdList" json:"failed_catalog_item_id_list,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}         `json:"-"`
	XXX_unrecognized        []byte           `json:"-"`
	XXX_sizecache           int32            `json:"-"`
}

func (m *CatalogRemoteSeedingSourceTaskRet) Reset()         { *m = CatalogRemoteSeedingSourceTaskRet{} }
func (m *CatalogRemoteSeedingSourceTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRemoteSeedingSourceTaskRet) ProtoMessage()    {}
func (*CatalogRemoteSeedingSourceTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{41}
}

func (m *CatalogRemoteSeedingSourceTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRemoteSeedingSourceTaskRet.Unmarshal(m, b)
}
func (m *CatalogRemoteSeedingSourceTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRemoteSeedingSourceTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogRemoteSeedingSourceTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRemoteSeedingSourceTaskRet.Merge(m, src)
}
func (m *CatalogRemoteSeedingSourceTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRemoteSeedingSourceTaskRet.Size(m)
}
func (m *CatalogRemoteSeedingSourceTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRemoteSeedingSourceTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRemoteSeedingSourceTaskRet proto.InternalMessageInfo

func (m *CatalogRemoteSeedingSourceTaskRet) GetFailedCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.FailedCatalogItemIdList
	}
	return nil
}

type CatalogPlacementPolicyCreateArg struct {
	// Catalog placement policy spec
	Spec *CatalogPlacementPolicyCreateSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,2,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,3,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,4,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyCreateArg) Reset()         { *m = CatalogPlacementPolicyCreateArg{} }
func (m *CatalogPlacementPolicyCreateArg) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyCreateArg) ProtoMessage()    {}
func (*CatalogPlacementPolicyCreateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{42}
}

func (m *CatalogPlacementPolicyCreateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyCreateArg.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyCreateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyCreateArg.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyCreateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyCreateArg.Merge(m, src)
}
func (m *CatalogPlacementPolicyCreateArg) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyCreateArg.Size(m)
}
func (m *CatalogPlacementPolicyCreateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyCreateArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyCreateArg proto.InternalMessageInfo

func (m *CatalogPlacementPolicyCreateArg) GetSpec() *CatalogPlacementPolicyCreateSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CatalogPlacementPolicyCreateArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyCreateArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyCreateArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogPlacementPolicyCreateRet struct {
	// A task to poll for completion. On success, the task will contain a
	// PlacementPolicyCreateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyCreateRet) Reset()         { *m = CatalogPlacementPolicyCreateRet{} }
func (m *CatalogPlacementPolicyCreateRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyCreateRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyCreateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{43}
}

func (m *CatalogPlacementPolicyCreateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyCreateRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyCreateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyCreateRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyCreateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyCreateRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyCreateRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyCreateRet.Size(m)
}
func (m *CatalogPlacementPolicyCreateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyCreateRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyCreateRet proto.InternalMessageInfo

func (m *CatalogPlacementPolicyCreateRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogPlacementPolicyCreateTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyCreateTaskRet) Reset()         { *m = CatalogPlacementPolicyCreateTaskRet{} }
func (m *CatalogPlacementPolicyCreateTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyCreateTaskRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyCreateTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{44}
}

func (m *CatalogPlacementPolicyCreateTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyCreateTaskRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyCreateTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyCreateTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyCreateTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyCreateTaskRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyCreateTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyCreateTaskRet.Size(m)
}
func (m *CatalogPlacementPolicyCreateTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyCreateTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyCreateTaskRet proto.InternalMessageInfo

type CatalogPlacementPolicyUpdateArg struct {
	// Catalog placement policy spec
	Spec *CatalogPlacementPolicyCreateSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// Logical timestamp to compare against while updating
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,3,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,4,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,5,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyUpdateArg) Reset()         { *m = CatalogPlacementPolicyUpdateArg{} }
func (m *CatalogPlacementPolicyUpdateArg) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyUpdateArg) ProtoMessage()    {}
func (*CatalogPlacementPolicyUpdateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{45}
}

func (m *CatalogPlacementPolicyUpdateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateArg.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyUpdateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateArg.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyUpdateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyUpdateArg.Merge(m, src)
}
func (m *CatalogPlacementPolicyUpdateArg) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateArg.Size(m)
}
func (m *CatalogPlacementPolicyUpdateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyUpdateArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyUpdateArg proto.InternalMessageInfo

const Default_CatalogPlacementPolicyUpdateArg_LogicalTimestamp int64 = -1

func (m *CatalogPlacementPolicyUpdateArg) GetSpec() *CatalogPlacementPolicyCreateSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CatalogPlacementPolicyUpdateArg) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_CatalogPlacementPolicyUpdateArg_LogicalTimestamp
}

func (m *CatalogPlacementPolicyUpdateArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyUpdateArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyUpdateArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogPlacementPolicyUpdateRet struct {
	// A task to poll for completion. On success, the task will contain a
	// PlacementPolicyUpdateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyUpdateRet) Reset()         { *m = CatalogPlacementPolicyUpdateRet{} }
func (m *CatalogPlacementPolicyUpdateRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyUpdateRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyUpdateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{46}
}

func (m *CatalogPlacementPolicyUpdateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyUpdateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyUpdateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyUpdateRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyUpdateRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateRet.Size(m)
}
func (m *CatalogPlacementPolicyUpdateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyUpdateRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyUpdateRet proto.InternalMessageInfo

func (m *CatalogPlacementPolicyUpdateRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogPlacementPolicyUpdateTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyUpdateTaskRet) Reset()         { *m = CatalogPlacementPolicyUpdateTaskRet{} }
func (m *CatalogPlacementPolicyUpdateTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyUpdateTaskRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyUpdateTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{47}
}

func (m *CatalogPlacementPolicyUpdateTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateTaskRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyUpdateTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyUpdateTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyUpdateTaskRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyUpdateTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyUpdateTaskRet.Size(m)
}
func (m *CatalogPlacementPolicyUpdateTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyUpdateTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyUpdateTaskRet proto.InternalMessageInfo

type CatalogPlacementPolicyDeleteArg struct {
	// Catalog placement policy uuid
	PolicyUuid []byte `protobuf:"bytes,1,opt,name=policy_uuid,json=policyUuid" json:"policy_uuid,omitempty"`
	// Logical timestamp to compare against while updating
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,3,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,4,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,5,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyDeleteArg) Reset()         { *m = CatalogPlacementPolicyDeleteArg{} }
func (m *CatalogPlacementPolicyDeleteArg) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyDeleteArg) ProtoMessage()    {}
func (*CatalogPlacementPolicyDeleteArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{48}
}

func (m *CatalogPlacementPolicyDeleteArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteArg.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyDeleteArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteArg.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyDeleteArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyDeleteArg.Merge(m, src)
}
func (m *CatalogPlacementPolicyDeleteArg) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteArg.Size(m)
}
func (m *CatalogPlacementPolicyDeleteArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyDeleteArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyDeleteArg proto.InternalMessageInfo

const Default_CatalogPlacementPolicyDeleteArg_LogicalTimestamp int64 = -1

func (m *CatalogPlacementPolicyDeleteArg) GetPolicyUuid() []byte {
	if m != nil {
		return m.PolicyUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyDeleteArg) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_CatalogPlacementPolicyDeleteArg_LogicalTimestamp
}

func (m *CatalogPlacementPolicyDeleteArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyDeleteArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogPlacementPolicyDeleteArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogPlacementPolicyDeleteRet struct {
	// A task to poll for completion. On success, the task will contain a
	// PlacementPolicyUpdateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyDeleteRet) Reset()         { *m = CatalogPlacementPolicyDeleteRet{} }
func (m *CatalogPlacementPolicyDeleteRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyDeleteRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyDeleteRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{49}
}

func (m *CatalogPlacementPolicyDeleteRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyDeleteRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyDeleteRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyDeleteRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyDeleteRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteRet.Size(m)
}
func (m *CatalogPlacementPolicyDeleteRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyDeleteRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyDeleteRet proto.InternalMessageInfo

func (m *CatalogPlacementPolicyDeleteRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogPlacementPolicyDeleteTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyDeleteTaskRet) Reset()         { *m = CatalogPlacementPolicyDeleteTaskRet{} }
func (m *CatalogPlacementPolicyDeleteTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyDeleteTaskRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyDeleteTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{50}
}

func (m *CatalogPlacementPolicyDeleteTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteTaskRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyDeleteTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyDeleteTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyDeleteTaskRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyDeleteTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyDeleteTaskRet.Size(m)
}
func (m *CatalogPlacementPolicyDeleteTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyDeleteTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyDeleteTaskRet proto.InternalMessageInfo

type CatalogPlacementPolicyGetArg struct {
	// Placement policy UUID
	PolicyUuidList       [][]byte `protobuf:"bytes,1,rep,name=policy_uuid_list,json=policyUuidList" json:"policy_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogPlacementPolicyGetArg) Reset()         { *m = CatalogPlacementPolicyGetArg{} }
func (m *CatalogPlacementPolicyGetArg) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyGetArg) ProtoMessage()    {}
func (*CatalogPlacementPolicyGetArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{51}
}

func (m *CatalogPlacementPolicyGetArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyGetArg.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyGetArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyGetArg.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyGetArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyGetArg.Merge(m, src)
}
func (m *CatalogPlacementPolicyGetArg) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyGetArg.Size(m)
}
func (m *CatalogPlacementPolicyGetArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyGetArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyGetArg proto.InternalMessageInfo

func (m *CatalogPlacementPolicyGetArg) GetPolicyUuidList() [][]byte {
	if m != nil {
		return m.PolicyUuidList
	}
	return nil
}

type CatalogPlacementPolicyGetRet struct {
	// List of catalog item objects.
	PlacementPolicyInfoList []*CatalogPlacementPolicyInfo `protobuf:"bytes,1,rep,name=placement_policy_info_list,json=placementPolicyInfoList" json:"placement_policy_info_list,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                      `json:"-"`
	XXX_unrecognized        []byte                        `json:"-"`
	XXX_sizecache           int32                         `json:"-"`
}

func (m *CatalogPlacementPolicyGetRet) Reset()         { *m = CatalogPlacementPolicyGetRet{} }
func (m *CatalogPlacementPolicyGetRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyGetRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyGetRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{52}
}

func (m *CatalogPlacementPolicyGetRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyGetRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyGetRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyGetRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyGetRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyGetRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyGetRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyGetRet.Size(m)
}
func (m *CatalogPlacementPolicyGetRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyGetRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyGetRet proto.InternalMessageInfo

func (m *CatalogPlacementPolicyGetRet) GetPlacementPolicyInfoList() []*CatalogPlacementPolicyInfo {
	if m != nil {
		return m.PlacementPolicyInfoList
	}
	return nil
}

type CatalogPlacementPolicyStatusGetArg struct {
	// Catalog item ID list
	CatalogItemIdList    []*CatalogItemId `protobuf:"bytes,1,rep,name=catalog_item_id_list,json=catalogItemIdList" json:"catalog_item_id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CatalogPlacementPolicyStatusGetArg) Reset()         { *m = CatalogPlacementPolicyStatusGetArg{} }
func (m *CatalogPlacementPolicyStatusGetArg) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyStatusGetArg) ProtoMessage()    {}
func (*CatalogPlacementPolicyStatusGetArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{53}
}

func (m *CatalogPlacementPolicyStatusGetArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyStatusGetArg.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyStatusGetArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyStatusGetArg.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyStatusGetArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyStatusGetArg.Merge(m, src)
}
func (m *CatalogPlacementPolicyStatusGetArg) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyStatusGetArg.Size(m)
}
func (m *CatalogPlacementPolicyStatusGetArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyStatusGetArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyStatusGetArg proto.InternalMessageInfo

func (m *CatalogPlacementPolicyStatusGetArg) GetCatalogItemIdList() []*CatalogItemId {
	if m != nil {
		return m.CatalogItemIdList
	}
	return nil
}

type CatalogPlacementPolicyStatusGetRet struct {
	// List of placement status info
	PolicyStatusInfoList []*CatalogPlacementPolicyStatusInfo `protobuf:"bytes,1,rep,name=policy_status_info_list,json=policyStatusInfoList" json:"policy_status_info_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *CatalogPlacementPolicyStatusGetRet) Reset()         { *m = CatalogPlacementPolicyStatusGetRet{} }
func (m *CatalogPlacementPolicyStatusGetRet) String() string { return proto.CompactTextString(m) }
func (*CatalogPlacementPolicyStatusGetRet) ProtoMessage()    {}
func (*CatalogPlacementPolicyStatusGetRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{54}
}

func (m *CatalogPlacementPolicyStatusGetRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogPlacementPolicyStatusGetRet.Unmarshal(m, b)
}
func (m *CatalogPlacementPolicyStatusGetRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogPlacementPolicyStatusGetRet.Marshal(b, m, deterministic)
}
func (m *CatalogPlacementPolicyStatusGetRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogPlacementPolicyStatusGetRet.Merge(m, src)
}
func (m *CatalogPlacementPolicyStatusGetRet) XXX_Size() int {
	return xxx_messageInfo_CatalogPlacementPolicyStatusGetRet.Size(m)
}
func (m *CatalogPlacementPolicyStatusGetRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogPlacementPolicyStatusGetRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogPlacementPolicyStatusGetRet proto.InternalMessageInfo

func (m *CatalogPlacementPolicyStatusGetRet) GetPolicyStatusInfoList() []*CatalogPlacementPolicyStatusInfo {
	if m != nil {
		return m.PolicyStatusInfoList
	}
	return nil
}

type ImageCheckoutArg struct {
	// ID of the catalog item to checkout.
	ImageUuid []byte `protobuf:"bytes,1,opt,name=image_uuid,json=imageUuid" json:"image_uuid,omitempty"`
	// UUIDs of clusters where the catalog item should be checked out.
	ClusterUuidList [][]byte `protobuf:"bytes,2,rep,name=cluster_uuid_list,json=clusterUuidList" json:"cluster_uuid_list,omitempty"`
	// UUIDs of availability zones where the catalog item should be checked out.
	AvailabilityZoneUuidList [][]byte `protobuf:"bytes,3,rep,name=availability_zone_uuid_list,json=availabilityZoneUuidList" json:"availability_zone_uuid_list,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,4,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,5,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,6,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Boolean indicating if checkout is issued from policy engine or not
	IssuedFromEngine     *bool    `protobuf:"varint,7,opt,name=issued_from_engine,json=issuedFromEngine,def=0" json:"issued_from_engine,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCheckoutArg) Reset()         { *m = ImageCheckoutArg{} }
func (m *ImageCheckoutArg) String() string { return proto.CompactTextString(m) }
func (*ImageCheckoutArg) ProtoMessage()    {}
func (*ImageCheckoutArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{55}
}

func (m *ImageCheckoutArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCheckoutArg.Unmarshal(m, b)
}
func (m *ImageCheckoutArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCheckoutArg.Marshal(b, m, deterministic)
}
func (m *ImageCheckoutArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCheckoutArg.Merge(m, src)
}
func (m *ImageCheckoutArg) XXX_Size() int {
	return xxx_messageInfo_ImageCheckoutArg.Size(m)
}
func (m *ImageCheckoutArg) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCheckoutArg.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCheckoutArg proto.InternalMessageInfo

const Default_ImageCheckoutArg_IssuedFromEngine bool = false

func (m *ImageCheckoutArg) GetImageUuid() []byte {
	if m != nil {
		return m.ImageUuid
	}
	return nil
}

func (m *ImageCheckoutArg) GetClusterUuidList() [][]byte {
	if m != nil {
		return m.ClusterUuidList
	}
	return nil
}

func (m *ImageCheckoutArg) GetAvailabilityZoneUuidList() [][]byte {
	if m != nil {
		return m.AvailabilityZoneUuidList
	}
	return nil
}

func (m *ImageCheckoutArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *ImageCheckoutArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *ImageCheckoutArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *ImageCheckoutArg) GetIssuedFromEngine() bool {
	if m != nil && m.IssuedFromEngine != nil {
		return *m.IssuedFromEngine
	}
	return Default_ImageCheckoutArg_IssuedFromEngine
}

type ImageCheckoutRet struct {
	// A task to poll for completion. On success, the task will contain a
	// ImageCheckoutTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCheckoutRet) Reset()         { *m = ImageCheckoutRet{} }
func (m *ImageCheckoutRet) String() string { return proto.CompactTextString(m) }
func (*ImageCheckoutRet) ProtoMessage()    {}
func (*ImageCheckoutRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{56}
}

func (m *ImageCheckoutRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCheckoutRet.Unmarshal(m, b)
}
func (m *ImageCheckoutRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCheckoutRet.Marshal(b, m, deterministic)
}
func (m *ImageCheckoutRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCheckoutRet.Merge(m, src)
}
func (m *ImageCheckoutRet) XXX_Size() int {
	return xxx_messageInfo_ImageCheckoutRet.Size(m)
}
func (m *ImageCheckoutRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCheckoutRet.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCheckoutRet proto.InternalMessageInfo

func (m *ImageCheckoutRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type ImageCheckoutTaskRet struct {
	// List of cluster UUIDs where checkout failed.
	FailedDstClusterUuidList [][]byte `protobuf:"bytes,1,rep,name=failed_dst_cluster_uuid_list,json=failedDstClusterUuidList" json:"failed_dst_cluster_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *ImageCheckoutTaskRet) Reset()         { *m = ImageCheckoutTaskRet{} }
func (m *ImageCheckoutTaskRet) String() string { return proto.CompactTextString(m) }
func (*ImageCheckoutTaskRet) ProtoMessage()    {}
func (*ImageCheckoutTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{57}
}

func (m *ImageCheckoutTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCheckoutTaskRet.Unmarshal(m, b)
}
func (m *ImageCheckoutTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCheckoutTaskRet.Marshal(b, m, deterministic)
}
func (m *ImageCheckoutTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCheckoutTaskRet.Merge(m, src)
}
func (m *ImageCheckoutTaskRet) XXX_Size() int {
	return xxx_messageInfo_ImageCheckoutTaskRet.Size(m)
}
func (m *ImageCheckoutTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCheckoutTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCheckoutTaskRet proto.InternalMessageInfo

func (m *ImageCheckoutTaskRet) GetFailedDstClusterUuidList() [][]byte {
	if m != nil {
		return m.FailedDstClusterUuidList
	}
	return nil
}

type CatalogRateLimitCreateArg struct {
	// Catalog rate limit spec
	Spec *CatalogRateLimitSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,2,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,3,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,4,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitCreateArg) Reset()         { *m = CatalogRateLimitCreateArg{} }
func (m *CatalogRateLimitCreateArg) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitCreateArg) ProtoMessage()    {}
func (*CatalogRateLimitCreateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{58}
}

func (m *CatalogRateLimitCreateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitCreateArg.Unmarshal(m, b)
}
func (m *CatalogRateLimitCreateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitCreateArg.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitCreateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitCreateArg.Merge(m, src)
}
func (m *CatalogRateLimitCreateArg) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitCreateArg.Size(m)
}
func (m *CatalogRateLimitCreateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitCreateArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitCreateArg proto.InternalMessageInfo

func (m *CatalogRateLimitCreateArg) GetSpec() *CatalogRateLimitSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CatalogRateLimitCreateArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogRateLimitCreateArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogRateLimitCreateArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogRateLimitCreateRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogRateLimitCreateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitCreateRet) Reset()         { *m = CatalogRateLimitCreateRet{} }
func (m *CatalogRateLimitCreateRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitCreateRet) ProtoMessage()    {}
func (*CatalogRateLimitCreateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{59}
}

func (m *CatalogRateLimitCreateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitCreateRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitCreateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitCreateRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitCreateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitCreateRet.Merge(m, src)
}
func (m *CatalogRateLimitCreateRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitCreateRet.Size(m)
}
func (m *CatalogRateLimitCreateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitCreateRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitCreateRet proto.InternalMessageInfo

func (m *CatalogRateLimitCreateRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogRateLimitCreateTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitCreateTaskRet) Reset()         { *m = CatalogRateLimitCreateTaskRet{} }
func (m *CatalogRateLimitCreateTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitCreateTaskRet) ProtoMessage()    {}
func (*CatalogRateLimitCreateTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{60}
}

func (m *CatalogRateLimitCreateTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitCreateTaskRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitCreateTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitCreateTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitCreateTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitCreateTaskRet.Merge(m, src)
}
func (m *CatalogRateLimitCreateTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitCreateTaskRet.Size(m)
}
func (m *CatalogRateLimitCreateTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitCreateTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitCreateTaskRet proto.InternalMessageInfo

type CatalogRateLimitGetArg struct {
	// List of Rate Limit UUIDs.
	RateLimitUuidList [][]byte `protobuf:"bytes,1,rep,name=rate_limit_uuid_list,json=rateLimitUuidList" json:"rate_limit_uuid_list,omitempty"`
	// Whether to include the status of each Rate Limit in the response or not.
	IncludeStatus        *bool    `protobuf:"varint,2,opt,name=include_status,json=includeStatus,def=1" json:"include_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitGetArg) Reset()         { *m = CatalogRateLimitGetArg{} }
func (m *CatalogRateLimitGetArg) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitGetArg) ProtoMessage()    {}
func (*CatalogRateLimitGetArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{61}
}

func (m *CatalogRateLimitGetArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitGetArg.Unmarshal(m, b)
}
func (m *CatalogRateLimitGetArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitGetArg.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitGetArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitGetArg.Merge(m, src)
}
func (m *CatalogRateLimitGetArg) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitGetArg.Size(m)
}
func (m *CatalogRateLimitGetArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitGetArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitGetArg proto.InternalMessageInfo

const Default_CatalogRateLimitGetArg_IncludeStatus bool = true

func (m *CatalogRateLimitGetArg) GetRateLimitUuidList() [][]byte {
	if m != nil {
		return m.RateLimitUuidList
	}
	return nil
}

func (m *CatalogRateLimitGetArg) GetIncludeStatus() bool {
	if m != nil && m.IncludeStatus != nil {
		return *m.IncludeStatus
	}
	return Default_CatalogRateLimitGetArg_IncludeStatus
}

type CatalogRateLimitGetRet struct {
	// List of rate limit objects.
	RateLimitInfoList    []*CatalogRateLimitInfo `protobuf:"bytes,1,rep,name=rate_limit_info_list,json=rateLimitInfoList" json:"rate_limit_info_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CatalogRateLimitGetRet) Reset()         { *m = CatalogRateLimitGetRet{} }
func (m *CatalogRateLimitGetRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitGetRet) ProtoMessage()    {}
func (*CatalogRateLimitGetRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{62}
}

func (m *CatalogRateLimitGetRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitGetRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitGetRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitGetRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitGetRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitGetRet.Merge(m, src)
}
func (m *CatalogRateLimitGetRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitGetRet.Size(m)
}
func (m *CatalogRateLimitGetRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitGetRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitGetRet proto.InternalMessageInfo

func (m *CatalogRateLimitGetRet) GetRateLimitInfoList() []*CatalogRateLimitInfo {
	if m != nil {
		return m.RateLimitInfoList
	}
	return nil
}

type CatalogRateLimitUpdateArg struct {
	// Catalog rate limit spec
	Spec *CatalogRateLimitSpec `protobuf:"bytes,1,opt,name=spec" json:"spec,omitempty"`
	// Logical timestamp to compare against while updating
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,3,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,4,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,5,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitUpdateArg) Reset()         { *m = CatalogRateLimitUpdateArg{} }
func (m *CatalogRateLimitUpdateArg) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitUpdateArg) ProtoMessage()    {}
func (*CatalogRateLimitUpdateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{63}
}

func (m *CatalogRateLimitUpdateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitUpdateArg.Unmarshal(m, b)
}
func (m *CatalogRateLimitUpdateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitUpdateArg.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitUpdateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitUpdateArg.Merge(m, src)
}
func (m *CatalogRateLimitUpdateArg) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitUpdateArg.Size(m)
}
func (m *CatalogRateLimitUpdateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitUpdateArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitUpdateArg proto.InternalMessageInfo

const Default_CatalogRateLimitUpdateArg_LogicalTimestamp int64 = -1

func (m *CatalogRateLimitUpdateArg) GetSpec() *CatalogRateLimitSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CatalogRateLimitUpdateArg) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_CatalogRateLimitUpdateArg_LogicalTimestamp
}

func (m *CatalogRateLimitUpdateArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogRateLimitUpdateArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogRateLimitUpdateArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogRateLimitUpdateRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogRateLimitUpdateTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitUpdateRet) Reset()         { *m = CatalogRateLimitUpdateRet{} }
func (m *CatalogRateLimitUpdateRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitUpdateRet) ProtoMessage()    {}
func (*CatalogRateLimitUpdateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{64}
}

func (m *CatalogRateLimitUpdateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitUpdateRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitUpdateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitUpdateRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitUpdateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitUpdateRet.Merge(m, src)
}
func (m *CatalogRateLimitUpdateRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitUpdateRet.Size(m)
}
func (m *CatalogRateLimitUpdateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitUpdateRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitUpdateRet proto.InternalMessageInfo

func (m *CatalogRateLimitUpdateRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogRateLimitUpdateTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitUpdateTaskRet) Reset()         { *m = CatalogRateLimitUpdateTaskRet{} }
func (m *CatalogRateLimitUpdateTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitUpdateTaskRet) ProtoMessage()    {}
func (*CatalogRateLimitUpdateTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{65}
}

func (m *CatalogRateLimitUpdateTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitUpdateTaskRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitUpdateTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitUpdateTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitUpdateTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitUpdateTaskRet.Merge(m, src)
}
func (m *CatalogRateLimitUpdateTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitUpdateTaskRet.Size(m)
}
func (m *CatalogRateLimitUpdateTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitUpdateTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitUpdateTaskRet proto.InternalMessageInfo

type CatalogRateLimitDeleteArg struct {
	// Catalog rate limit uuid
	RateLimitUuid []byte `protobuf:"bytes,1,opt,name=rate_limit_uuid,json=rateLimitUuid" json:"rate_limit_uuid,omitempty"`
	// Logical timestamp to compare against while updating
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Task UUID. This is used as an idempotence token.
	TaskUuid []byte `protobuf:"bytes,3,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	// Parent task.
	ParentTaskUuid []byte `protobuf:"bytes,4,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// Only set when parent_task_uuid is set. Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId    *uint64  `protobuf:"varint,5,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitDeleteArg) Reset()         { *m = CatalogRateLimitDeleteArg{} }
func (m *CatalogRateLimitDeleteArg) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitDeleteArg) ProtoMessage()    {}
func (*CatalogRateLimitDeleteArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{66}
}

func (m *CatalogRateLimitDeleteArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitDeleteArg.Unmarshal(m, b)
}
func (m *CatalogRateLimitDeleteArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitDeleteArg.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitDeleteArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitDeleteArg.Merge(m, src)
}
func (m *CatalogRateLimitDeleteArg) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitDeleteArg.Size(m)
}
func (m *CatalogRateLimitDeleteArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitDeleteArg.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitDeleteArg proto.InternalMessageInfo

const Default_CatalogRateLimitDeleteArg_LogicalTimestamp int64 = -1

func (m *CatalogRateLimitDeleteArg) GetRateLimitUuid() []byte {
	if m != nil {
		return m.RateLimitUuid
	}
	return nil
}

func (m *CatalogRateLimitDeleteArg) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_CatalogRateLimitDeleteArg_LogicalTimestamp
}

func (m *CatalogRateLimitDeleteArg) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

func (m *CatalogRateLimitDeleteArg) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *CatalogRateLimitDeleteArg) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

type CatalogRateLimitDeleteRet struct {
	// A task to poll for completion. On success, the task will contain a
	// CatalogRateLimitDeleteTaskRet.
	TaskUuid             []byte   `protobuf:"bytes,1,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitDeleteRet) Reset()         { *m = CatalogRateLimitDeleteRet{} }
func (m *CatalogRateLimitDeleteRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitDeleteRet) ProtoMessage()    {}
func (*CatalogRateLimitDeleteRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{67}
}

func (m *CatalogRateLimitDeleteRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitDeleteRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitDeleteRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitDeleteRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitDeleteRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitDeleteRet.Merge(m, src)
}
func (m *CatalogRateLimitDeleteRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitDeleteRet.Size(m)
}
func (m *CatalogRateLimitDeleteRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitDeleteRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitDeleteRet proto.InternalMessageInfo

func (m *CatalogRateLimitDeleteRet) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type CatalogRateLimitDeleteTaskRet struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CatalogRateLimitDeleteTaskRet) Reset()         { *m = CatalogRateLimitDeleteTaskRet{} }
func (m *CatalogRateLimitDeleteTaskRet) String() string { return proto.CompactTextString(m) }
func (*CatalogRateLimitDeleteTaskRet) ProtoMessage()    {}
func (*CatalogRateLimitDeleteTaskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f5c93ebf4f527ba, []int{68}
}

func (m *CatalogRateLimitDeleteTaskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CatalogRateLimitDeleteTaskRet.Unmarshal(m, b)
}
func (m *CatalogRateLimitDeleteTaskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CatalogRateLimitDeleteTaskRet.Marshal(b, m, deterministic)
}
func (m *CatalogRateLimitDeleteTaskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CatalogRateLimitDeleteTaskRet.Merge(m, src)
}
func (m *CatalogRateLimitDeleteTaskRet) XXX_Size() int {
	return xxx_messageInfo_CatalogRateLimitDeleteTaskRet.Size(m)
}
func (m *CatalogRateLimitDeleteTaskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CatalogRateLimitDeleteTaskRet.DiscardUnknown(m)
}

var xxx_messageInfo_CatalogRateLimitDeleteTaskRet proto.InternalMessageInfo

func init() {
	proto.RegisterType((*CatalogItemCreateArg)(nil), "nutanix.catalog.CatalogItemCreateArg")
	proto.RegisterType((*CatalogItemCreateRet)(nil), "nutanix.catalog.CatalogItemCreateRet")
	proto.RegisterType((*CatalogItemCreateTaskRet)(nil), "nutanix.catalog.CatalogItemCreateTaskRet")
	proto.RegisterType((*CatalogItemUpdateArg)(nil), "nutanix.catalog.CatalogItemUpdateArg")
	proto.RegisterType((*CatalogItemUpdateRet)(nil), "nutanix.catalog.CatalogItemUpdateRet")
	proto.RegisterType((*CatalogItemUpdateTaskRet)(nil), "nutanix.catalog.CatalogItemUpdateTaskRet")
	proto.RegisterType((*CatalogItemGetArg)(nil), "nutanix.catalog.CatalogItemGetArg")
	proto.RegisterType((*CatalogItemGetRet)(nil), "nutanix.catalog.CatalogItemGetRet")
	proto.RegisterType((*CatalogClusterUnregistrationArg)(nil), "nutanix.catalog.CatalogClusterUnregistrationArg")
	proto.RegisterType((*CatalogClusterUnregistrationRet)(nil), "nutanix.catalog.CatalogClusterUnregistrationRet")
	proto.RegisterType((*CatalogClusterUnregistrationTaskRet)(nil), "nutanix.catalog.CatalogClusterUnregistrationTaskRet")
	proto.RegisterType((*CatalogItemUnregCleanupArg)(nil), "nutanix.catalog.CatalogItemUnregCleanupArg")
	proto.RegisterType((*CatalogItemUnregCleanupRet)(nil), "nutanix.catalog.CatalogItemUnregCleanupRet")
	proto.RegisterType((*CatalogClusterRegistrationArg)(nil), "nutanix.catalog.CatalogClusterRegistrationArg")
	proto.RegisterType((*CatalogClusterRegistrationRet)(nil), "nutanix.catalog.CatalogClusterRegistrationRet")
	proto.RegisterType((*CatalogClusterRegistrationTaskRet)(nil), "nutanix.catalog.CatalogClusterRegistrationTaskRet")
	proto.RegisterType((*CatalogClusterRegistrationTaskRet_CatalogItemRegFailureInfo)(nil), "nutanix.catalog.CatalogClusterRegistrationTaskRet.CatalogItemRegFailureInfo")
	proto.RegisterType((*CatalogItemCheckoutArg)(nil), "nutanix.catalog.CatalogItemCheckoutArg")
	proto.RegisterType((*CatalogItemCheckoutRet)(nil), "nutanix.catalog.CatalogItemCheckoutRet")
	proto.RegisterType((*CatalogItemCheckoutTaskRet)(nil), "nutanix.catalog.CatalogItemCheckoutTaskRet")
	proto.RegisterType((*CatalogItemUncheckoutArg)(nil), "nutanix.catalog.CatalogItemUncheckoutArg")
	proto.RegisterType((*CatalogItemUncheckoutRet)(nil), "nutanix.catalog.CatalogItemUncheckoutRet")
	proto.RegisterType((*CatalogItemUncheckoutTaskRet)(nil), "nutanix.catalog.CatalogItemUncheckoutTaskRet")
	proto.RegisterType((*CatalogItemRemoveArg)(nil), "nutanix.catalog.CatalogItemRemoveArg")
	proto.RegisterType((*CatalogItemRemoveRet)(nil), "nutanix.catalog.CatalogItemRemoveRet")
	proto.RegisterType((*CatalogItemRemoveTaskRet)(nil), "nutanix.catalog.CatalogItemRemoveTaskRet")
	proto.RegisterType((*CatalogItemDeleteArg)(nil), "nutanix.catalog.CatalogItemDeleteArg")
	proto.RegisterType((*CatalogItemDeleteRet)(nil), "nutanix.catalog.CatalogItemDeleteRet")
	proto.RegisterType((*CatalogItemDeleteTaskRet)(nil), "nutanix.catalog.CatalogItemDeleteTaskRet")
	proto.RegisterType((*CatalogItemUploadArg)(nil), "nutanix.catalog.CatalogItemUploadArg")
	proto.RegisterType((*CatalogItemUploadRet)(nil), "nutanix.catalog.CatalogItemUploadRet")
	proto.RegisterType((*CatalogItemUploadTaskRet)(nil), "nutanix.catalog.CatalogItemUploadTaskRet")
	proto.RegisterType((*FileGetArg)(nil), "nutanix.catalog.FileGetArg")
	proto.RegisterType((*FileGetRet)(nil), "nutanix.catalog.FileGetRet")
	proto.RegisterType((*ImageUploadArg)(nil), "nutanix.catalog.ImageUploadArg")
	proto.RegisterType((*ImageUploadRet)(nil), "nutanix.catalog.ImageUploadRet")
	proto.RegisterType((*ImageUploadTaskRet)(nil), "nutanix.catalog.ImageUploadTaskRet")
	proto.RegisterType((*CatalogMigratePcArg)(nil), "nutanix.catalog.CatalogMigratePcArg")
	proto.RegisterType((*CatalogMigratePcRet)(nil), "nutanix.catalog.CatalogMigratePcRet")
	proto.RegisterType((*CatalogMigratePcTaskRet)(nil), "nutanix.catalog.CatalogMigratePcTaskRet")
	proto.RegisterType((*CatalogRemoteSeedingSourceArg)(nil), "nutanix.catalog.CatalogRemoteSeedingSourceArg")
	proto.RegisterType((*CatalogRemoteSeedingSourceRet)(nil), "nutanix.catalog.CatalogRemoteSeedingSourceRet")
	proto.RegisterType((*CatalogRemoteSeedingSourceTaskRet)(nil), "nutanix.catalog.CatalogRemoteSeedingSourceTaskRet")
	proto.RegisterType((*CatalogPlacementPolicyCreateArg)(nil), "nutanix.catalog.CatalogPlacementPolicyCreateArg")
	proto.RegisterType((*CatalogPlacementPolicyCreateRet)(nil), "nutanix.catalog.CatalogPlacementPolicyCreateRet")
	proto.RegisterType((*CatalogPlacementPolicyCreateTaskRet)(nil), "nutanix.catalog.CatalogPlacementPolicyCreateTaskRet")
	proto.RegisterType((*CatalogPlacementPolicyUpdateArg)(nil), "nutanix.catalog.CatalogPlacementPolicyUpdateArg")
	proto.RegisterType((*CatalogPlacementPolicyUpdateRet)(nil), "nutanix.catalog.CatalogPlacementPolicyUpdateRet")
	proto.RegisterType((*CatalogPlacementPolicyUpdateTaskRet)(nil), "nutanix.catalog.CatalogPlacementPolicyUpdateTaskRet")
	proto.RegisterType((*CatalogPlacementPolicyDeleteArg)(nil), "nutanix.catalog.CatalogPlacementPolicyDeleteArg")
	proto.RegisterType((*CatalogPlacementPolicyDeleteRet)(nil), "nutanix.catalog.CatalogPlacementPolicyDeleteRet")
	proto.RegisterType((*CatalogPlacementPolicyDeleteTaskRet)(nil), "nutanix.catalog.CatalogPlacementPolicyDeleteTaskRet")
	proto.RegisterType((*CatalogPlacementPolicyGetArg)(nil), "nutanix.catalog.CatalogPlacementPolicyGetArg")
	proto.RegisterType((*CatalogPlacementPolicyGetRet)(nil), "nutanix.catalog.CatalogPlacementPolicyGetRet")
	proto.RegisterType((*CatalogPlacementPolicyStatusGetArg)(nil), "nutanix.catalog.CatalogPlacementPolicyStatusGetArg")
	proto.RegisterType((*CatalogPlacementPolicyStatusGetRet)(nil), "nutanix.catalog.CatalogPlacementPolicyStatusGetRet")
	proto.RegisterType((*ImageCheckoutArg)(nil), "nutanix.catalog.ImageCheckoutArg")
	proto.RegisterType((*ImageCheckoutRet)(nil), "nutanix.catalog.ImageCheckoutRet")
	proto.RegisterType((*ImageCheckoutTaskRet)(nil), "nutanix.catalog.ImageCheckoutTaskRet")
	proto.RegisterType((*CatalogRateLimitCreateArg)(nil), "nutanix.catalog.CatalogRateLimitCreateArg")
	proto.RegisterType((*CatalogRateLimitCreateRet)(nil), "nutanix.catalog.CatalogRateLimitCreateRet")
	proto.RegisterType((*CatalogRateLimitCreateTaskRet)(nil), "nutanix.catalog.CatalogRateLimitCreateTaskRet")
	proto.RegisterType((*CatalogRateLimitGetArg)(nil), "nutanix.catalog.CatalogRateLimitGetArg")
	proto.RegisterType((*CatalogRateLimitGetRet)(nil), "nutanix.catalog.CatalogRateLimitGetRet")
	proto.RegisterType((*CatalogRateLimitUpdateArg)(nil), "nutanix.catalog.CatalogRateLimitUpdateArg")
	proto.RegisterType((*CatalogRateLimitUpdateRet)(nil), "nutanix.catalog.CatalogRateLimitUpdateRet")
	proto.RegisterType((*CatalogRateLimitUpdateTaskRet)(nil), "nutanix.catalog.CatalogRateLimitUpdateTaskRet")
	proto.RegisterType((*CatalogRateLimitDeleteArg)(nil), "nutanix.catalog.CatalogRateLimitDeleteArg")
	proto.RegisterType((*CatalogRateLimitDeleteRet)(nil), "nutanix.catalog.CatalogRateLimitDeleteRet")
	proto.RegisterType((*CatalogRateLimitDeleteTaskRet)(nil), "nutanix.catalog.CatalogRateLimitDeleteTaskRet")
}

func init() {
	proto.RegisterFile("catalog/catalog_external_interface.proto", fileDescriptor_4f5c93ebf4f527ba)
}

var fileDescriptor_4f5c93ebf4f527ba = []byte{
	// 2416 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcb, 0x6f, 0xdc, 0xc6,
	0x19, 0x07, 0x57, 0xb2, 0x65, 0x8f, 0x64, 0x59, 0xa2, 0xe4, 0x78, 0x4d, 0xc9, 0x96, 0xcc, 0xc4,
	0xb1, 0x62, 0xd7, 0xda, 0x44, 0x46, 0x91, 0xc4, 0x68, 0x13, 0xb8, 0xeb, 0x47, 0x55, 0x38, 0x88,
	0xb1, 0x92, 0x8d, 0xc2, 0x08, 0x42, 0x8c, 0xb8, 0xb3, 0xab, 0x41, 0xb8, 0x24, 0x4b, 0x0e, 0x05,
	0xcb, 0x28, 0xda, 0xd4, 0xe8, 0xc1, 0x68, 0xd1, 0xc2, 0xb7, 0x1c, 0x7a, 0xed, 0xbf, 0xe0, 0x43,
	0xd1, 0x3f, 0xa0, 0x45, 0x81, 0xfe, 0x0d, 0xbd, 0xf6, 0x71, 0xec, 0xa1, 0x68, 0x81, 0x3e, 0x30,
	0x0f, 0x3e, 0x86, 0xe4, 0x90, 0x5c, 0x5b, 0xb5, 0xab, 0xc2, 0x27, 0xad, 0x66, 0x7e, 0xdf, 0x63,
	0xbe, 0xc7, 0xf0, 0xfb, 0x3e, 0x12, 0xac, 0xd9, 0x90, 0x40, 0xc7, 0x1b, 0x76, 0xc4, 0x5f, 0x0b,
	0x3d, 0x24, 0x28, 0x70, 0xa1, 0x63, 0x61, 0x97, 0xa0, 0x60, 0x00, 0x6d, 0xb4, 0xee, 0x07, 0x1e,
	0xf1, 0xf4, 0x93, 0x6e, 0x44, 0xa0, 0x8b, 0x1f, 0xae, 0x0b, 0xa4, 0xf1, 0x26, 0xb4, 0x03, 0xcf,
	0xf7, 0x1c, 0x1c, 0x76, 0x92, 0x5f, 0x79, 0x2a, 0x63, 0x29, 0xcf, 0x9f, 0xec, 0xfb, 0x28, 0x14,
	0x9b, 0xab, 0xf1, 0xe6, 0xde, 0xc8, 0x22, 0x68, 0xe4, 0x3b, 0x90, 0xa0, 0x50, 0x42, 0xac, 0x44,
	0x04, 0x3b, 0x9d, 0xd0, 0xb1, 0x76, 0xa2, 0x41, 0xd8, 0xd9, 0x81, 0x21, 0xea, 0x84, 0x28, 0xd8,
	0xc3, 0x09, 0x7f, 0x43, 0x02, 0xb8, 0x88, 0x74, 0x02, 0xdf, 0xe6, 0x7b, 0xe6, 0x5f, 0x35, 0xb0,
	0xd8, 0xe5, 0x12, 0x36, 0x09, 0x1a, 0x75, 0x03, 0x04, 0x09, 0xba, 0x1e, 0x0c, 0xf5, 0x6b, 0x60,
	0x32, 0xf4, 0x91, 0xdd, 0xd6, 0x56, 0xb5, 0xb5, 0xe9, 0x8d, 0xb7, 0xd7, 0x73, 0x27, 0x5b, 0x2f,
	0x10, 0x6d, 0xf9, 0xc8, 0xee, 0x31, 0x1a, 0x7d, 0x09, 0x1c, 0x27, 0x30, 0xfc, 0xc2, 0x8a, 0x22,
	0xdc, 0x6f, 0xb7, 0x56, 0xb5, 0xb5, 0x99, 0xde, 0x31, 0xba, 0x70, 0x2f, 0xc2, 0x7d, 0x7d, 0x0d,
	0xcc, 0xf9, 0x30, 0x40, 0x2e, 0xb1, 0x52, 0xcc, 0x04, 0xc3, 0xcc, 0xf2, 0xf5, 0xed, 0x18, 0xb9,
	0x0e, 0x16, 0xc2, 0x68, 0x87, 0xa1, 0x42, 0xf4, 0xbd, 0x08, 0xb9, 0x36, 0xb2, 0x70, 0xbf, 0x3d,
	0xb9, 0xaa, 0xad, 0x4d, 0xf6, 0xe6, 0xc5, 0xd6, 0x96, 0xd8, 0xd9, 0xa4, 0x9c, 0x67, 0x06, 0x5e,
	0x60, 0x23, 0x2b, 0xf2, 0xfb, 0x90, 0xa0, 0xf6, 0x91, 0x55, 0x6d, 0xed, 0xd8, 0xb5, 0x23, 0x03,
	0xe8, 0x84, 0xa8, 0x37, 0xcd, 0xb6, 0xee, 0xb1, 0x1d, 0xf3, 0x6a, 0xc9, 0xa1, 0x7b, 0x88, 0xc8,
	0x8a, 0x6b, 0xb2, 0xe2, 0xe6, 0x0f, 0x41, 0xbb, 0x40, 0x44, 0x75, 0xa5, 0x84, 0x97, 0xc0, 0x7c,
	0xec, 0x3c, 0x4c, 0xd0, 0x28, 0xcb, 0xe0, 0xa4, 0x9d, 0x12, 0xb1, 0x63, 0xbd, 0x0f, 0xda, 0x43,
	0xc7, 0xdb, 0x81, 0x8e, 0x55, 0x24, 0xe1, 0xc6, 0x3a, 0xc5, 0xf7, 0xbb, 0x32, 0xa1, 0xf9, 0xbb,
	0x96, 0xa4, 0x36, 0x3f, 0x0b, 0xf5, 0x55, 0x15, 0x47, 0xad, 0x82, 0x63, 0xe2, 0xe4, 0x56, 0xbd,
	0x93, 0xb9, 0xb4, 0x8c, 0x93, 0x97, 0xc1, 0xd4, 0x1e, 0x0a, 0x42, 0xec, 0xb9, 0xcc, 0x7d, 0x13,
	0xd7, 0x5a, 0x57, 0xde, 0xeb, 0xc5, 0x4b, 0xb2, 0x25, 0x27, 0x1b, 0x84, 0xc0, 0x91, 0x71, 0x42,
	0xe0, 0x68, 0xd3, 0x10, 0x98, 0x6a, 0x18, 0x02, 0x7c, 0xb1, 0x36, 0x04, 0x0c, 0x29, 0x04, 0x38,
	0x91, 0x08, 0x01, 0xf3, 0xcf, 0x1a, 0x98, 0xcf, 0x6c, 0xde, 0x46, 0x84, 0xba, 0x06, 0x81, 0x37,
	0x24, 0x9f, 0xd0, 0xc4, 0xb5, 0x1c, 0x1c, 0x92, 0xb6, 0xb6, 0x3a, 0xb1, 0x36, 0xbb, 0xf1, 0x6e,
	0x95, 0xcd, 0x37, 0xdd, 0x81, 0x97, 0xfd, 0x7f, 0x7b, 0xdf, 0x47, 0xbd, 0x05, 0x5b, 0x5e, 0xb8,
	0x83, 0x43, 0xa2, 0x7f, 0x0a, 0x16, 0x25, 0x31, 0xb8, 0xcf, 0x85, 0xb4, 0x56, 0x27, 0xd6, 0xa6,
	0x37, 0xce, 0x55, 0x0a, 0xe9, 0xf7, 0xe6, 0xed, 0xec, 0xbf, 0x8c, 0xe1, 0x59, 0x70, 0x94, 0xdd,
	0x34, 0x84, 0x39, 0x37, 0x31, 0xa1, 0x58, 0x34, 0x61, 0xfe, 0xac, 0xd4, 0x74, 0x77, 0x72, 0x49,
	0x90, 0x1c, 0x73, 0x7a, 0x63, 0xb5, 0xee, 0x98, 0x52, 0x9a, 0x50, 0x0d, 0xcc, 0x5f, 0x6b, 0x60,
	0x45, 0x80, 0xba, 0x4e, 0x14, 0x12, 0x14, 0xdc, 0x73, 0x03, 0x34, 0xc4, 0x21, 0x09, 0x20, 0xc1,
	0x9e, 0x4b, 0xad, 0x7b, 0x1e, 0xcc, 0xd8, 0x7c, 0x2f, 0xeb, 0xaf, 0x69, 0xb1, 0xc6, 0x22, 0xe8,
	0xd5, 0xdc, 0x45, 0xe6, 0x47, 0xd5, 0xca, 0xd7, 0x46, 0xda, 0x9f, 0x34, 0xf0, 0x66, 0x15, 0x83,
	0xf8, 0xe2, 0xe9, 0x83, 0x95, 0x30, 0xb2, 0x6d, 0x14, 0x86, 0x83, 0x28, 0x97, 0xfe, 0x71, 0x0c,
	0x68, 0x8d, 0x62, 0x60, 0x29, 0x65, 0xd3, 0x2d, 0x44, 0xc3, 0x67, 0x60, 0x69, 0x00, 0xb1, 0x83,
	0xfa, 0xd6, 0x0b, 0x44, 0xd9, 0x69, 0xce, 0xa2, 0xc0, 0xdd, 0xfc, 0x18, 0x18, 0xd9, 0xac, 0xa2,
	0xe7, 0xec, 0x3a, 0x08, 0xba, 0x91, 0xdf, 0xcc, 0xc7, 0xe6, 0xb2, 0x92, 0x01, 0x4d, 0xcc, 0x5f,
	0x69, 0xe0, 0xac, 0x6c, 0xca, 0xde, 0xa1, 0x09, 0xa3, 0x6f, 0x54, 0xa9, 0x5e, 0x1b, 0x44, 0xbf,
	0x98, 0x00, 0xe7, 0xd5, 0xe4, 0x2f, 0x37, 0x84, 0x7e, 0xa2, 0x35, 0x89, 0xa1, 0x3b, 0x2a, 0x11,
	0x6a, 0xfd, 0xb3, 0x4a, 0xf4, 0xd0, 0xf0, 0x16, 0xc4, 0x4e, 0x14, 0x20, 0x76, 0xa7, 0xa8, 0x22,
	0xce, 0x78, 0xac, 0x81, 0x33, 0x4a, 0x32, 0xfd, 0x16, 0x38, 0x99, 0x53, 0x51, 0x54, 0x41, 0x75,
	0x06, 0x38, 0x21, 0xdd, 0xa3, 0xfa, 0x59, 0x00, 0x50, 0x10, 0x58, 0x01, 0x82, 0xa1, 0xe7, 0xb2,
	0xa0, 0x39, 0xde, 0x3b, 0x8e, 0x82, 0xa0, 0xc7, 0x16, 0xcc, 0xbf, 0xb5, 0xc0, 0x1b, 0xd9, 0x82,
	0x62, 0x17, 0xd9, 0x5f, 0x78, 0x11, 0x7b, 0x6a, 0x1c, 0x94, 0x06, 0xb4, 0x2c, 0xc9, 0x04, 0x76,
	0x6a, 0x69, 0x5a, 0x96, 0xa4, 0xd1, 0xcd, 0x1c, 0xf4, 0x4d, 0xb0, 0x04, 0xf7, 0x20, 0x76, 0xe0,
	0x0e, 0x76, 0x30, 0xd9, 0xb7, 0x1e, 0x79, 0x2e, 0xca, 0x50, 0x4d, 0x30, 0xaa, 0x76, 0x16, 0xf2,
	0xc0, 0x73, 0x51, 0x42, 0xfe, 0x8a, 0x1e, 0xf8, 0x57, 0x81, 0x8e, 0xc3, 0x30, 0x42, 0x7d, 0x6b,
	0x10, 0x78, 0x23, 0x0b, 0xb9, 0x43, 0xec, 0xe6, 0x1e, 0xfb, 0x73, 0x1c, 0x70, 0x2b, 0xf0, 0x46,
	0x37, 0xd9, 0xb6, 0xf9, 0xf5, 0x52, 0xc3, 0xd7, 0xa6, 0xd3, 0x67, 0xd2, 0x35, 0x13, 0x93, 0xc5,
	0x69, 0xf4, 0x11, 0x58, 0x16, 0xf1, 0xdd, 0x0f, 0x89, 0x55, 0x34, 0xbb, 0xc6, 0x0d, 0xc8, 0x31,
	0x37, 0x42, 0xd2, 0x95, 0xed, 0x6f, 0xfe, 0xbd, 0x25, 0x17, 0x17, 0xae, 0xfd, 0x3a, 0x20, 0x5e,
	0x56, 0x40, 0xbc, 0xaf, 0x30, 0x7d, 0x6d, 0x48, 0x7c, 0x0e, 0x96, 0x4b, 0x09, 0x0f, 0x2a, 0x28,
	0x7e, 0x29, 0x97, 0xfc, 0x3d, 0x34, 0xf2, 0xf6, 0x58, 0xc9, 0x3f, 0x4e, 0xc3, 0xf1, 0x7f, 0xef,
	0xf4, 0x5c, 0x31, 0xcf, 0xad, 0x34, 0x66, 0x31, 0xcf, 0x89, 0xe2, 0x62, 0xfe, 0xdf, 0x72, 0x5b,
	0x7c, 0x03, 0x39, 0x88, 0xb7, 0x5a, 0x55, 0x1c, 0xcb, 0xb2, 0xb4, 0xf5, 0x3c, 0x59, 0xfa, 0xbf,
	0xd7, 0x22, 0x73, 0x03, 0x8c, 0x69, 0x52, 0x4e, 0x14, 0x9b, 0xf4, 0x67, 0xf9, 0xee, 0xd5, 0xf1,
	0x60, 0xff, 0x85, 0xba, 0xd7, 0xdb, 0x60, 0x3a, 0x62, 0x5c, 0xac, 0x26, 0x4d, 0xec, 0x2d, 0xec,
	0x20, 0x2e, 0x94, 0x35, 0xb1, 0x20, 0x4a, 0x7e, 0xcb, 0x67, 0x9a, 0xc8, 0x39, 0xb5, 0x9d, 0xf6,
	0xb9, 0xd4, 0xac, 0x13, 0x69, 0x8f, 0xbb, 0x02, 0xa6, 0x09, 0x72, 0xa1, 0x4b, 0xb2, 0xa1, 0x0c,
	0xf8, 0x52, 0x5c, 0x34, 0x46, 0x61, 0x5c, 0x54, 0x1e, 0xe5, 0x7c, 0xe9, 0x02, 0xb3, 0xd5, 0xd5,
	0x12, 0x73, 0x8c, 0xdd, 0x80, 0x52, 0xa2, 0xd8, 0xc0, 0x5f, 0x69, 0x00, 0xd0, 0x43, 0x8a, 0xce,
	0xf3, 0x2d, 0x30, 0x3b, 0xc0, 0x0e, 0x2a, 0x5c, 0x36, 0x33, 0x74, 0x35, 0x49, 0xd8, 0x35, 0x30,
	0x83, 0x5d, 0xdb, 0x89, 0xfa, 0xc8, 0x0a, 0xf1, 0x23, 0xc4, 0x8c, 0x98, 0x06, 0x84, 0xd8, 0xda,
	0xc2, 0x8f, 0x90, 0xfe, 0x21, 0x38, 0x15, 0x23, 0xe1, 0x4e, 0xe8, 0x39, 0x11, 0x41, 0x96, 0x0f,
	0xc9, 0xae, 0xdc, 0x20, 0x2e, 0x08, 0xcc, 0x75, 0x01, 0xb9, 0x0b, 0xc9, 0xae, 0xf9, 0x49, 0xa2,
	0x18, 0x3d, 0xe0, 0xc7, 0x42, 0x31, 0xec, 0x0e, 0xbc, 0x6c, 0x79, 0x79, 0xa6, 0xe0, 0x39, 0x4a,
	0xc4, 0x0a, 0x39, 0xa6, 0x33, 0xfd, 0xc5, 0x2e, 0xc5, 0xdf, 0xb4, 0xc0, 0xec, 0xe6, 0x08, 0x0e,
	0x51, 0x1a, 0x43, 0x67, 0x01, 0xc0, 0x74, 0x25, 0x6b, 0xb5, 0xe3, 0x6c, 0xe5, 0xf0, 0x47, 0x4a,
	0xe9, 0x75, 0x30, 0x35, 0xce, 0x75, 0x70, 0x4c, 0x75, 0x6f, 0x5e, 0x91, 0x0c, 0x59, 0x1b, 0x7d,
	0x8b, 0x40, 0xcf, 0xc0, 0x33, 0x89, 0xbd, 0x20, 0x2c, 0xf7, 0x09, 0x1e, 0x06, 0x90, 0xa0, 0xbb,
	0xf6, 0x41, 0x74, 0x55, 0xea, 0xd1, 0xc9, 0xc4, 0xcb, 0x18, 0x9d, 0x4c, 0x3e, 0xe7, 0xe8, 0xc4,
	0xdc, 0x28, 0x9a, 0xa3, 0xd6, 0xb2, 0x67, 0xc0, 0xe9, 0x3c, 0x4d, 0x6c, 0xde, 0x7f, 0xa4, 0xed,
	0x2b, 0x7d, 0x46, 0x11, 0xb4, 0x85, 0x50, 0x1f, 0xbb, 0xc3, 0x2d, 0x2f, 0x0a, 0x6c, 0xd4, 0xd0,
	0xd0, 0x07, 0x3e, 0x1f, 0x7a, 0x39, 0xce, 0xc9, 0xf4, 0xbf, 0x25, 0x67, 0xaf, 0xb5, 0xea, 0x8f,
	0xb4, 0xa4, 0xff, 0x2d, 0x21, 0x8f, 0x6b, 0xb4, 0xff, 0xee, 0x70, 0xe3, 0x0f, 0xe9, 0x18, 0xeb,
	0xae, 0x03, 0x6d, 0x34, 0x42, 0x2e, 0xb9, 0xeb, 0x39, 0xd8, 0xde, 0x4f, 0x67, 0xed, 0x37, 0xa5,
	0x59, 0xfb, 0x7b, 0x2a, 0x51, 0xa5, 0xf4, 0xaf, 0x7c, 0xec, 0x9e, 0x19, 0x75, 0x95, 0x2a, 0x58,
	0xeb, 0xa5, 0x0b, 0xc9, 0xa4, 0xab, 0x94, 0x3e, 0xce, 0x83, 0xa7, 0x2d, 0x95, 0x9c, 0x74, 0x10,
	0x7e, 0x40, 0x86, 0xec, 0x80, 0x79, 0xc7, 0x1b, 0x62, 0x1b, 0x3a, 0x16, 0xc1, 0x23, 0x14, 0x12,
	0x38, 0xf2, 0x99, 0x41, 0xf9, 0x90, 0x7b, 0x4e, 0x6c, 0x6e, 0xc7, 0x7b, 0xd5, 0x8f, 0x85, 0x32,
	0xcb, 0x4f, 0x8e, 0x63, 0xf9, 0x23, 0x63, 0x5b, 0xbe, 0xe1, 0x38, 0x5b, 0x69, 0xf9, 0xc2, 0x64,
	0x5b, 0x21, 0x27, 0xad, 0x8b, 0x57, 0xc0, 0xb4, 0xcf, 0x96, 0xb2, 0x92, 0x00, 0x5f, 0x62, 0x67,
	0x3b, 0xf4, 0x36, 0x6d, 0x58, 0x02, 0x2b, 0x6d, 0x2a, 0x57, 0xc3, 0xdf, 0x4e, 0x1a, 0xc7, 0x1c,
	0x4c, 0x54, 0x6f, 0xf4, 0x80, 0xa9, 0x3d, 0xb3, 0xf5, 0xdb, 0x6c, 0x6a, 0x54, 0x76, 0xc1, 0x3c,
	0xd1, 0x2a, 0x58, 0x51, 0x75, 0x77, 0x81, 0xe1, 0xc7, 0x1b, 0x96, 0x60, 0x9a, 0xaf, 0xbd, 0x2e,
	0x37, 0x4c, 0x15, 0x3e, 0x56, 0xf3, 0x8b, 0x8b, 0x4c, 0x95, 0x08, 0x98, 0xe5, 0x64, 0x5b, 0x04,
	0x92, 0x28, 0x14, 0x47, 0x53, 0x3d, 0x8b, 0xb4, 0xe7, 0x7d, 0xe0, 0xfe, 0x5c, 0xab, 0x95, 0xcb,
	0xed, 0x70, 0x5a, 0x9c, 0x3e, 0x64, 0xcb, 0x05, 0x23, 0x34, 0xbd, 0x2f, 0x38, 0x57, 0x66, 0x8a,
	0x45, 0x3f, 0xb7, 0xc2, 0x14, 0xfa, 0x6d, 0x0b, 0xcc, 0xb1, 0x42, 0x29, 0x3b, 0xd3, 0xab, 0x29,
	0x51, 0x5f, 0x4f, 0x66, 0x4a, 0x27, 0x33, 0x9d, 0x9c, 0x25, 0x6b, 0xf3, 0xef, 0x3e, 0x58, 0x94,
	0x08, 0x0e, 0x6a, 0x12, 0xf3, 0xfb, 0x74, 0x64, 0xdc, 0x83, 0x04, 0xdd, 0xc1, 0x23, 0x4c, 0xd2,
	0x27, 0xf8, 0x87, 0xd2, 0x83, 0xe7, 0x82, 0x2a, 0x90, 0x12, 0xca, 0x57, 0xff, 0xd4, 0xfe, 0x40,
	0x75, 0x9c, 0x5a, 0x0b, 0xaf, 0xa4, 0x35, 0x99, 0x4c, 0x19, 0xdf, 0x6d, 0x7b, 0xc9, 0x78, 0x35,
	0x01, 0x88, 0xd4, 0xef, 0x80, 0x45, 0x5a, 0xdc, 0x5a, 0x0e, 0x5d, 0x2b, 0x18, 0x7f, 0x3e, 0x88,
	0xe1, 0x49, 0xa8, 0x5e, 0x06, 0xb3, 0x49, 0x7b, 0xca, 0x72, 0x4c, 0x34, 0xa8, 0x93, 0x24, 0x88,
	0x50, 0xef, 0x44, 0xdc, 0x9f, 0xb2, 0x2d, 0xd3, 0x2f, 0x95, 0x4b, 0xcf, 0x73, 0x5f, 0x92, 0x9b,
	0xcf, 0xfb, 0x7a, 0x77, 0xb1, 0x5c, 0x4f, 0xd5, 0x4b, 0x12, 0xfd, 0x5f, 0x25, 0x41, 0x91, 0x56,
	0x23, 0x2f, 0x10, 0x14, 0x87, 0xe5, 0x69, 0xf9, 0x81, 0xea, 0xfc, 0xcf, 0x13, 0x45, 0x72, 0xd5,
	0xf1, 0x97, 0x12, 0xdb, 0xa6, 0xf5, 0xc6, 0xdb, 0xe0, 0x64, 0x2e, 0x92, 0x84, 0x84, 0x13, 0x52,
	0x10, 0x1d, 0x66, 0x43, 0x36, 0x2c, 0x38, 0x4a, 0x0c, 0x29, 0x95, 0x1a, 0x1b, 0xff, 0x3c, 0x9f,
	0xf0, 0xbe, 0x29, 0x3e, 0x5c, 0xea, 0xf9, 0xf6, 0x16, 0xff, 0x44, 0x48, 0x97, 0xdf, 0xe4, 0xf3,
	0x44, 0xd6, 0x2f, 0xd4, 0x7f, 0xee, 0x73, 0x3d, 0x18, 0x1a, 0x0d, 0x60, 0x54, 0x7d, 0x59, 0x04,
	0xf7, 0x72, 0xb5, 0x88, 0x24, 0x87, 0x8c, 0x06, 0x30, 0x2a, 0xe2, 0xbb, 0x60, 0x56, 0xfe, 0x1e,
	0x41, 0x37, 0xab, 0x08, 0xf9, 0x75, 0x64, 0xd4, 0x61, 0x28, 0xe7, 0x61, 0xd2, 0xcd, 0x67, 0x5f,
	0xfa, 0xe8, 0x17, 0x2b, 0x8f, 0x9e, 0x3e, 0xf6, 0x8d, 0x46, 0x40, 0x2a, 0x68, 0x04, 0x4e, 0x95,
	0xbe, 0x4a, 0xd0, 0xdf, 0xa9, 0x34, 0x41, 0xf6, 0x35, 0x91, 0xd1, 0x10, 0x5a, 0xe6, 0x14, 0xc7,
	0x83, 0xfd, 0x3a, 0xa7, 0x88, 0x69, 0x9b, 0xd1, 0x00, 0x46, 0x45, 0x7c, 0x0e, 0xe6, 0xf2, 0x43,
	0x0d, 0xfd, 0x2d, 0x15, 0x69, 0x76, 0x74, 0x64, 0xd4, 0xa3, 0x28, 0xff, 0xef, 0x27, 0xef, 0xe3,
	0x4a, 0xba, 0x7b, 0x7d, 0x5d, 0x79, 0xdf, 0x96, 0x4e, 0x51, 0x8c, 0x71, 0xf0, 0x45, 0x03, 0xf2,
	0xd7, 0x07, 0xd5, 0x06, 0x4c, 0xde, 0xde, 0x18, 0x0d, 0x60, 0x45, 0x11, 0x3c, 0xab, 0xab, 0x45,
	0x24, 0x17, 0xa4, 0xd1, 0x00, 0x46, 0x45, 0x3c, 0x4e, 0xbb, 0x87, 0xd2, 0xef, 0x4c, 0xf4, 0x77,
	0x6b, 0xde, 0xc8, 0x17, 0x3e, 0xca, 0x31, 0xc6, 0xa3, 0x90, 0x1d, 0x59, 0xf2, 0x9a, 0x5f, 0xed,
	0xc8, 0xf2, 0xaf, 0x39, 0x8c, 0x71, 0xf0, 0x54, 0x7a, 0x98, 0xcc, 0xde, 0xf2, 0x5f, 0x8f, 0xe8,
	0x97, 0xab, 0xf3, 0x49, 0xfa, 0x50, 0xc5, 0x68, 0x0c, 0xa6, 0x42, 0xbb, 0x60, 0x4a, 0x8c, 0xc4,
	0xf5, 0xa5, 0xd2, 0xb9, 0xb7, 0xb8, 0xa2, 0x94, 0x9b, 0x94, 0xc9, 0x16, 0x98, 0xe6, 0xb5, 0x2e,
	0xbf, 0xb5, 0xcf, 0x27, 0xd8, 0xe4, 0x5b, 0xd3, 0xf5, 0xcc, 0x3e, 0x65, 0x57, 0x03, 0xa1, 0x4c,
	0xbf, 0x03, 0x8e, 0xb1, 0x15, 0xaa, 0xda, 0x39, 0x15, 0x5c, 0x68, 0x57, 0xb5, 0x9f, 0x55, 0x50,
	0xdc, 0xf9, 0x4a, 0xe9, 0xe9, 0x7d, 0x5f, 0x03, 0xc9, 0x32, 0x15, 0xf9, 0xa0, 0xa4, 0x48, 0x73,
	0xa1, 0x06, 0x42, 0x99, 0x7e, 0x9a, 0x68, 0xca, 0x2e, 0xc2, 0x95, 0x82, 0xd9, 0xe5, 0x17, 0x0e,
	0x46, 0x25, 0x20, 0x97, 0x58, 0xa5, 0xe3, 0x26, 0x75, 0x62, 0xa9, 0xc6, 0x84, 0xc6, 0x78, 0x14,
	0xd5, 0x4a, 0x08, 0x8f, 0x34, 0x65, 0x99, 0x3a, 0x68, 0x3c, 0x8a, 0x6a, 0x25, 0x84, 0x07, 0x9b,
	0xb2, 0x4c, 0x1d, 0x3a, 0x1e, 0x05, 0x55, 0x62, 0x3f, 0xa9, 0x81, 0x8a, 0x43, 0x12, 0xfd, 0x4a,
	0x43, 0x76, 0x22, 0xea, 0xc7, 0x80, 0x53, 0xd1, 0x3f, 0x55, 0x8e, 0xcf, 0x92, 0xf1, 0x84, 0x7e,
	0x75, 0xac, 0xd1, 0x83, 0xd0, 0x63, 0x6c, 0x22, 0xaa, 0xcd, 0x3d, 0x70, 0x42, 0xea, 0x8f, 0x33,
	0xf9, 0x23, 0x45, 0x72, 0xb6, 0x86, 0xa9, 0x81, 0x50, 0xb6, 0x0f, 0xc0, 0xdc, 0xfd, 0xd1, 0xb6,
	0xf8, 0x3e, 0x5d, 0x44, 0x78, 0xb1, 0xbc, 0x92, 0x01, 0xe5, 0x25, 0x98, 0x8c, 0xa1, 0xbc, 0x3d,
	0x70, 0x3a, 0xe5, 0x7d, 0x9f, 0xbf, 0x52, 0x13, 0x22, 0xde, 0x51, 0x92, 0x4b, 0xb8, 0xf2, 0xda,
	0xa8, 0x14, 0x4a, 0x05, 0x3e, 0x04, 0x46, 0x2a, 0xf0, 0xba, 0xdb, 0x97, 0x65, 0x7e, 0x4d, 0xc9,
	0x28, 0x0f, 0xa5, 0x62, 0x9b, 0xa3, 0xa9, 0xe4, 0x6d, 0x30, 0x9b, 0x4a, 0x66, 0x91, 0xb1, 0xaa,
	0xa4, 0x8f, 0xc3, 0xa0, 0x1a, 0x41, 0xb9, 0x62, 0x70, 0xaa, 0x60, 0x40, 0xc6, 0xfc, 0x62, 0x9d,
	0x4d, 0x62, 0x19, 0x8d, 0x80, 0x85, 0x38, 0xb8, 0x81, 0x7c, 0xc7, 0xdb, 0xaf, 0x88, 0x03, 0x0e,
	0xa8, 0x8e, 0x03, 0x8e, 0xa1, 0xbc, 0x7f, 0xac, 0x81, 0x73, 0x29, 0xf3, 0x4d, 0x17, 0x13, 0x0c,
	0x09, 0xba, 0x1d, 0xa1, 0x90, 0x74, 0x77, 0xa1, 0x3b, 0x44, 0x61, 0xc9, 0x55, 0x52, 0x05, 0x2f,
	0xbf, 0x4a, 0xaa, 0x28, 0x8a, 0x6a, 0x74, 0xbd, 0x91, 0x4f, 0x2f, 0x99, 0x86, 0x6a, 0x94, 0xc1,
	0xab, 0xd5, 0x28, 0xa3, 0xa0, 0x6a, 0xfc, 0x00, 0x2c, 0x67, 0xb4, 0x80, 0xae, 0x8d, 0x1c, 0x49,
	0x87, 0x75, 0x35, 0xc7, 0x02, 0xb8, 0xbc, 0x6c, 0x52, 0xe3, 0x4b, 0x3c, 0xcd, 0x6e, 0xf2, 0x2a,
	0x2f, 0xc6, 0x77, 0x77, 0x1d, 0x86, 0xf2, 0x0e, 0x40, 0xbb, 0x18, 0xb0, 0x42, 0xc6, 0xa5, 0xda,
	0x50, 0x4c, 0x65, 0x35, 0xc5, 0x52, 0x99, 0x25, 0xd3, 0x23, 0x91, 0xf0, 0x97, 0x6a, 0x27, 0x37,
	0x69, 0xba, 0x37, 0xc5, 0xca, 0xad, 0x65, 0x76, 0x5e, 0xa5, 0x6e, 0x2d, 0x73, 0xd3, 0x34, 0xa3,
	0x11, 0x50, 0x71, 0x34, 0xf1, 0xfc, 0xaf, 0x57, 0x37, 0x7d, 0xf2, 0x37, 0xc5, 0x2a, 0x24, 0x2a,
	0xdd, 0xa7, 0x1c, 0xf2, 0x18, 0x4d, 0xb1, 0x3d, 0x44, 0x8c, 0xf6, 0x97, 0xcf, 0xda, 0x7f, 0x9c,
	0x7a, 0xf2, 0xac, 0xdd, 0x7a, 0xfa, 0xac, 0xad, 0x3d, 0xfe, 0xca, 0x9c, 0x12, 0x34, 0xdf, 0xba,
	0x08, 0x16, 0x6c, 0x6f, 0x94, 0x67, 0xf5, 0x20, 0xde, 0xff, 0x52, 0xd3, 0x9e, 0x68, 0xda, 0x53,
	0x4d, 0xfb, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x86, 0xc9, 0x60, 0xbd, 0xe8, 0x35, 0x00, 0x00,
}

//Generated by ntnx_rpc plugin

// Service CatalogExternalRpcService
type ICatalogExternalRpcService interface {
	BeforeRpcCall(rpc *util_net.ProtobufRpc, arg interface{}, ret interface{}) error
	AfterRpcCall(rpc *util_net.ProtobufRpc, arg interface{}, ret interface{}, err error) error

	CatalogItemCreate(*CatalogItemCreateArg, *CatalogItemCreateRet) error
	CatalogItemUpdate(*CatalogItemUpdateArg, *CatalogItemUpdateRet) error
	CatalogItemGet(*CatalogItemGetArg, *CatalogItemGetRet) error
	CatalogItemCheckout(*CatalogItemCheckoutArg, *CatalogItemCheckoutRet) error
	CatalogItemUncheckout(*CatalogItemUncheckoutArg, *CatalogItemUncheckoutRet) error
	CatalogItemUpload(*CatalogItemUploadArg, *CatalogItemUploadRet) error
	CatalogMigratePc(*CatalogMigratePcArg, *CatalogMigratePcRet) error
	CatalogRemoteSeedingSource(*CatalogRemoteSeedingSourceArg, *CatalogRemoteSeedingSourceRet) error
	CatalogItemRemove(*CatalogItemRemoveArg, *CatalogItemRemoveRet) error
	CatalogItemDelete(*CatalogItemDeleteArg, *CatalogItemDeleteRet) error
	CatalogClusterUnregistration(*CatalogClusterUnregistrationArg, *CatalogClusterUnregistrationRet) error
	CatalogClusterRegistration(*CatalogClusterRegistrationArg, *CatalogClusterRegistrationRet) error
	CatalogItemUnregCleanup(*CatalogItemUnregCleanupArg, *CatalogItemUnregCleanupRet) error
	FileGet(*FileGetArg, *FileGetRet) error
	ImageCreate(*acropolis.ImageCreateArg, *acropolis.ImageCreateRet) error
	ImageGet(*acropolis.ImageGetArg, *acropolis.ImageGetRet) error
	ImageUpdate(*acropolis.ImageUpdateArg, *acropolis.ImageUpdateRet) error
	ImageDelete(*acropolis.ImageDeleteArg, *acropolis.ImageDeleteRet) error
	ImageUpload(*ImageUploadArg, *ImageUploadRet) error
	CatalogPlacementPolicyCreate(*CatalogPlacementPolicyCreateArg, *CatalogPlacementPolicyCreateRet) error
	CatalogPlacementPolicyUpdate(*CatalogPlacementPolicyUpdateArg, *CatalogPlacementPolicyUpdateRet) error
	CatalogPlacementPolicyDelete(*CatalogPlacementPolicyDeleteArg, *CatalogPlacementPolicyDeleteRet) error
	CatalogPlacementPolicyGet(*CatalogPlacementPolicyGetArg, *CatalogPlacementPolicyGetRet) error
	CatalogPlacementPolicyStatusGet(*CatalogPlacementPolicyStatusGetArg, *CatalogPlacementPolicyStatusGetRet) error
	ImageCheckout(*ImageCheckoutArg, *ImageCheckoutRet) error
	VmTemplateCreate(*TemplateCreateArg, *TemplateCreateRet) error
	VmTemplateVersionCreate(*TemplateVersionCreateArg, *TemplateVersionCreateRet) error
	VmTemplateAndVersionCreate(*TemplateAndVersionCreateArg, *TemplateAndVersionCreateRet) error
	VmTemplatesGet(*TemplatesGetArg, *TemplatesGetRet) error
	VmTemplateVersionsGet(*TemplateVersionsGetArg, *TemplateVersionsGetRet) error
	VmTemplateDeploy(*TemplateDeployArg, *TemplateDeployRet) error
	VmTemplateInitiateGuestChanges(*TemplateInitiateGuestChangesArg, *TemplateInitiateGuestChangesRet) error
	VmTemplateCompleteGuestChanges(*TemplateCompleteGuestChangesArg, *TemplateCompleteGuestChangesRet) error
	VmTemplateCancelGuestChanges(*TemplateCancelGuestChangesArg, *TemplateCancelGuestChangesRet) error
	VmTemplateDelete(*TemplateDeleteArg, *TemplateDeleteRet) error
	VmTemplateVersionsDelete(*TemplateVersionsDeleteArg, *TemplateVersionsDeleteRet) error
	CatalogRateLimitCreate(*CatalogRateLimitCreateArg, *CatalogRateLimitCreateRet) error
	CatalogRateLimitGet(*CatalogRateLimitGetArg, *CatalogRateLimitGetRet) error
	CatalogRateLimitUpdate(*CatalogRateLimitUpdateArg, *CatalogRateLimitUpdateRet) error
	CatalogRateLimitDelete(*CatalogRateLimitDeleteArg, *CatalogRateLimitDeleteRet) error
}

func _CatalogExternalRpcService_CatalogItemCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemUpdate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemUpdateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemUpdateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemUpdate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemCheckout_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemCheckoutArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemCheckoutRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemCheckout(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemUncheckout_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemUncheckoutArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemUncheckoutRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemUncheckout(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemUpload_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemUploadArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemUploadRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemUpload(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogMigratePc_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogMigratePcArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogMigratePcRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogMigratePc(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogRemoteSeedingSource_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogRemoteSeedingSourceArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogRemoteSeedingSourceRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogRemoteSeedingSource(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemRemove_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemRemoveArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemRemoveRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemRemove(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemDelete_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemDeleteArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemDeleteRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemDelete(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogClusterUnregistration_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogClusterUnregistrationArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogClusterUnregistrationRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogClusterUnregistration(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogClusterRegistration_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogClusterRegistrationArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogClusterRegistrationRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogClusterRegistration(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogItemUnregCleanup_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogItemUnregCleanupArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogItemUnregCleanupRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogItemUnregCleanup(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_FileGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(FileGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &FileGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.FileGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_ImageCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(acropolis.ImageCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &acropolis.ImageCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ImageCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_ImageGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(acropolis.ImageGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &acropolis.ImageGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ImageGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_ImageUpdate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(acropolis.ImageUpdateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &acropolis.ImageUpdateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ImageUpdate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_ImageDelete_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(acropolis.ImageDeleteArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &acropolis.ImageDeleteRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ImageDelete(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_ImageUpload_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(ImageUploadArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &ImageUploadRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ImageUpload(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogPlacementPolicyCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogPlacementPolicyCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogPlacementPolicyCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogPlacementPolicyCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogPlacementPolicyUpdate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogPlacementPolicyUpdateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogPlacementPolicyUpdateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogPlacementPolicyUpdate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogPlacementPolicyDelete_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogPlacementPolicyDeleteArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogPlacementPolicyDeleteRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogPlacementPolicyDelete(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogPlacementPolicyGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogPlacementPolicyGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogPlacementPolicyGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogPlacementPolicyGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogPlacementPolicyStatusGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogPlacementPolicyStatusGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogPlacementPolicyStatusGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogPlacementPolicyStatusGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_ImageCheckout_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(ImageCheckoutArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &ImageCheckoutRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ImageCheckout(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateVersionCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateVersionCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateVersionCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateVersionCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateAndVersionCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateAndVersionCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateAndVersionCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateAndVersionCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplatesGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplatesGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplatesGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplatesGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateVersionsGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateVersionsGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateVersionsGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateVersionsGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateDeploy_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateDeployArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateDeployRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateDeploy(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateInitiateGuestChanges_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateInitiateGuestChangesArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateInitiateGuestChangesRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateInitiateGuestChanges(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateCompleteGuestChanges_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateCompleteGuestChangesArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateCompleteGuestChangesRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateCompleteGuestChanges(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateCancelGuestChanges_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateCancelGuestChangesArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateCancelGuestChangesRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateCancelGuestChanges(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateDelete_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateDeleteArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateDeleteRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateDelete(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_VmTemplateVersionsDelete_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(TemplateVersionsDeleteArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &TemplateVersionsDeleteRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.VmTemplateVersionsDelete(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogRateLimitCreate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogRateLimitCreateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogRateLimitCreateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogRateLimitCreate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogRateLimitGet_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogRateLimitGetArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogRateLimitGetRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogRateLimitGet(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogRateLimitUpdate_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogRateLimitUpdateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogRateLimitUpdateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogRateLimitUpdate(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _CatalogExternalRpcService_CatalogRateLimitDelete_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(ICatalogExternalRpcService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CatalogRateLimitDeleteArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CatalogRateLimitDeleteRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CatalogRateLimitDelete(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

var _CatalogExternalRpcServiceDesc = util_net.ServiceDesc{
	Name: "nutanix.catalog.CatalogExternalRpcService",
	Methods: map[string]util_net.ServiceMethodFn{
		"CatalogItemCreate":               _CatalogExternalRpcService_CatalogItemCreate_Handler,
		"CatalogItemUpdate":               _CatalogExternalRpcService_CatalogItemUpdate_Handler,
		"CatalogItemGet":                  _CatalogExternalRpcService_CatalogItemGet_Handler,
		"CatalogItemCheckout":             _CatalogExternalRpcService_CatalogItemCheckout_Handler,
		"CatalogItemUncheckout":           _CatalogExternalRpcService_CatalogItemUncheckout_Handler,
		"CatalogItemUpload":               _CatalogExternalRpcService_CatalogItemUpload_Handler,
		"CatalogMigratePc":                _CatalogExternalRpcService_CatalogMigratePc_Handler,
		"CatalogRemoteSeedingSource":      _CatalogExternalRpcService_CatalogRemoteSeedingSource_Handler,
		"CatalogItemRemove":               _CatalogExternalRpcService_CatalogItemRemove_Handler,
		"CatalogItemDelete":               _CatalogExternalRpcService_CatalogItemDelete_Handler,
		"CatalogClusterUnregistration":    _CatalogExternalRpcService_CatalogClusterUnregistration_Handler,
		"CatalogClusterRegistration":      _CatalogExternalRpcService_CatalogClusterRegistration_Handler,
		"CatalogItemUnregCleanup":         _CatalogExternalRpcService_CatalogItemUnregCleanup_Handler,
		"FileGet":                         _CatalogExternalRpcService_FileGet_Handler,
		"ImageCreate":                     _CatalogExternalRpcService_ImageCreate_Handler,
		"ImageGet":                        _CatalogExternalRpcService_ImageGet_Handler,
		"ImageUpdate":                     _CatalogExternalRpcService_ImageUpdate_Handler,
		"ImageDelete":                     _CatalogExternalRpcService_ImageDelete_Handler,
		"ImageUpload":                     _CatalogExternalRpcService_ImageUpload_Handler,
		"CatalogPlacementPolicyCreate":    _CatalogExternalRpcService_CatalogPlacementPolicyCreate_Handler,
		"CatalogPlacementPolicyUpdate":    _CatalogExternalRpcService_CatalogPlacementPolicyUpdate_Handler,
		"CatalogPlacementPolicyDelete":    _CatalogExternalRpcService_CatalogPlacementPolicyDelete_Handler,
		"CatalogPlacementPolicyGet":       _CatalogExternalRpcService_CatalogPlacementPolicyGet_Handler,
		"CatalogPlacementPolicyStatusGet": _CatalogExternalRpcService_CatalogPlacementPolicyStatusGet_Handler,
		"ImageCheckout":                   _CatalogExternalRpcService_ImageCheckout_Handler,
		"VmTemplateCreate":                _CatalogExternalRpcService_VmTemplateCreate_Handler,
		"VmTemplateVersionCreate":         _CatalogExternalRpcService_VmTemplateVersionCreate_Handler,
		"VmTemplateAndVersionCreate":      _CatalogExternalRpcService_VmTemplateAndVersionCreate_Handler,
		"VmTemplatesGet":                  _CatalogExternalRpcService_VmTemplatesGet_Handler,
		"VmTemplateVersionsGet":           _CatalogExternalRpcService_VmTemplateVersionsGet_Handler,
		"VmTemplateDeploy":                _CatalogExternalRpcService_VmTemplateDeploy_Handler,
		"VmTemplateInitiateGuestChanges":  _CatalogExternalRpcService_VmTemplateInitiateGuestChanges_Handler,
		"VmTemplateCompleteGuestChanges":  _CatalogExternalRpcService_VmTemplateCompleteGuestChanges_Handler,
		"VmTemplateCancelGuestChanges":    _CatalogExternalRpcService_VmTemplateCancelGuestChanges_Handler,
		"VmTemplateDelete":                _CatalogExternalRpcService_VmTemplateDelete_Handler,
		"VmTemplateVersionsDelete":        _CatalogExternalRpcService_VmTemplateVersionsDelete_Handler,
		"CatalogRateLimitCreate":          _CatalogExternalRpcService_CatalogRateLimitCreate_Handler,
		"CatalogRateLimitGet":             _CatalogExternalRpcService_CatalogRateLimitGet_Handler,
		"CatalogRateLimitUpdate":          _CatalogExternalRpcService_CatalogRateLimitUpdate_Handler,
		"CatalogRateLimitDelete":          _CatalogExternalRpcService_CatalogRateLimitDelete_Handler,
	},
}

func NewCatalogExternalRpcService(impl ICatalogExternalRpcService) *util_net.Service {
	return &util_net.Service{
		Desc: &_CatalogExternalRpcServiceDesc,
		Impl: impl,
	}
}

type ICatalogExternalRpcClient interface {
	CatalogItemCreate(*CatalogItemCreateArg) (*CatalogItemCreateRet, error)
	CatalogItemUpdate(*CatalogItemUpdateArg) (*CatalogItemUpdateRet, error)
	CatalogItemGet(*CatalogItemGetArg) (*CatalogItemGetRet, error)
	CatalogItemCheckout(*CatalogItemCheckoutArg) (*CatalogItemCheckoutRet, error)
	CatalogItemUncheckout(*CatalogItemUncheckoutArg) (*CatalogItemUncheckoutRet, error)
	CatalogItemUpload(*CatalogItemUploadArg) (*CatalogItemUploadRet, error)
	CatalogMigratePc(*CatalogMigratePcArg) (*CatalogMigratePcRet, error)
	CatalogRemoteSeedingSource(*CatalogRemoteSeedingSourceArg) (*CatalogRemoteSeedingSourceRet, error)
	CatalogItemRemove(*CatalogItemRemoveArg) (*CatalogItemRemoveRet, error)
	CatalogItemDelete(*CatalogItemDeleteArg) (*CatalogItemDeleteRet, error)
	CatalogClusterUnregistration(*CatalogClusterUnregistrationArg) (*CatalogClusterUnregistrationRet, error)
	CatalogClusterRegistration(*CatalogClusterRegistrationArg) (*CatalogClusterRegistrationRet, error)
	CatalogItemUnregCleanup(*CatalogItemUnregCleanupArg) (*CatalogItemUnregCleanupRet, error)
	FileGet(*FileGetArg) (*FileGetRet, error)
	ImageCreate(*acropolis.ImageCreateArg) (*acropolis.ImageCreateRet, error)
	ImageGet(*acropolis.ImageGetArg) (*acropolis.ImageGetRet, error)
	ImageUpdate(*acropolis.ImageUpdateArg) (*acropolis.ImageUpdateRet, error)
	ImageDelete(*acropolis.ImageDeleteArg) (*acropolis.ImageDeleteRet, error)
	ImageUpload(*ImageUploadArg) (*ImageUploadRet, error)
	CatalogPlacementPolicyCreate(*CatalogPlacementPolicyCreateArg) (*CatalogPlacementPolicyCreateRet, error)
	CatalogPlacementPolicyUpdate(*CatalogPlacementPolicyUpdateArg) (*CatalogPlacementPolicyUpdateRet, error)
	CatalogPlacementPolicyDelete(*CatalogPlacementPolicyDeleteArg) (*CatalogPlacementPolicyDeleteRet, error)
	CatalogPlacementPolicyGet(*CatalogPlacementPolicyGetArg) (*CatalogPlacementPolicyGetRet, error)
	CatalogPlacementPolicyStatusGet(*CatalogPlacementPolicyStatusGetArg) (*CatalogPlacementPolicyStatusGetRet, error)
	ImageCheckout(*ImageCheckoutArg) (*ImageCheckoutRet, error)
	VmTemplateCreate(*TemplateCreateArg) (*TemplateCreateRet, error)
	VmTemplateVersionCreate(*TemplateVersionCreateArg) (*TemplateVersionCreateRet, error)
	VmTemplateAndVersionCreate(*TemplateAndVersionCreateArg) (*TemplateAndVersionCreateRet, error)
	VmTemplatesGet(*TemplatesGetArg) (*TemplatesGetRet, error)
	VmTemplateVersionsGet(*TemplateVersionsGetArg) (*TemplateVersionsGetRet, error)
	VmTemplateDeploy(*TemplateDeployArg) (*TemplateDeployRet, error)
	VmTemplateInitiateGuestChanges(*TemplateInitiateGuestChangesArg) (*TemplateInitiateGuestChangesRet, error)
	VmTemplateCompleteGuestChanges(*TemplateCompleteGuestChangesArg) (*TemplateCompleteGuestChangesRet, error)
	VmTemplateCancelGuestChanges(*TemplateCancelGuestChangesArg) (*TemplateCancelGuestChangesRet, error)
	VmTemplateDelete(*TemplateDeleteArg) (*TemplateDeleteRet, error)
	VmTemplateVersionsDelete(*TemplateVersionsDeleteArg) (*TemplateVersionsDeleteRet, error)
	CatalogRateLimitCreate(*CatalogRateLimitCreateArg) (*CatalogRateLimitCreateRet, error)
	CatalogRateLimitGet(*CatalogRateLimitGetArg) (*CatalogRateLimitGetRet, error)
	CatalogRateLimitUpdate(*CatalogRateLimitUpdateArg) (*CatalogRateLimitUpdateRet, error)
	CatalogRateLimitDelete(*CatalogRateLimitDeleteArg) (*CatalogRateLimitDeleteRet, error)
}

type CatalogExternalRpcClient struct {
	Impl util_net.ProtobufRPCClientIfc
}

func NewCatalogExternalRpcClient(impl util_net.ProtobufRPCClientIfc) ICatalogExternalRpcClient {
	return &CatalogExternalRpcClient{
		Impl: impl,
	}
}

func (client *CatalogExternalRpcClient) CatalogItemCreate(
	arg *CatalogItemCreateArg) (
	*CatalogItemCreateRet, error) {

	ret := &CatalogItemCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemUpdate(
	arg *CatalogItemUpdateArg) (
	*CatalogItemUpdateRet, error) {

	ret := &CatalogItemUpdateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemUpdate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemGet(
	arg *CatalogItemGetArg) (
	*CatalogItemGetRet, error) {

	ret := &CatalogItemGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemCheckout(
	arg *CatalogItemCheckoutArg) (
	*CatalogItemCheckoutRet, error) {

	ret := &CatalogItemCheckoutRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemCheckout", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemUncheckout(
	arg *CatalogItemUncheckoutArg) (
	*CatalogItemUncheckoutRet, error) {

	ret := &CatalogItemUncheckoutRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemUncheckout", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemUpload(
	arg *CatalogItemUploadArg) (
	*CatalogItemUploadRet, error) {

	ret := &CatalogItemUploadRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemUpload", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogMigratePc(
	arg *CatalogMigratePcArg) (
	*CatalogMigratePcRet, error) {

	ret := &CatalogMigratePcRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogMigratePc", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogRemoteSeedingSource(
	arg *CatalogRemoteSeedingSourceArg) (
	*CatalogRemoteSeedingSourceRet, error) {

	ret := &CatalogRemoteSeedingSourceRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogRemoteSeedingSource", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemRemove(
	arg *CatalogItemRemoveArg) (
	*CatalogItemRemoveRet, error) {

	ret := &CatalogItemRemoveRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemRemove", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemDelete(
	arg *CatalogItemDeleteArg) (
	*CatalogItemDeleteRet, error) {

	ret := &CatalogItemDeleteRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemDelete", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogClusterUnregistration(
	arg *CatalogClusterUnregistrationArg) (
	*CatalogClusterUnregistrationRet, error) {

	ret := &CatalogClusterUnregistrationRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogClusterUnregistration", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogClusterRegistration(
	arg *CatalogClusterRegistrationArg) (
	*CatalogClusterRegistrationRet, error) {

	ret := &CatalogClusterRegistrationRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogClusterRegistration", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogItemUnregCleanup(
	arg *CatalogItemUnregCleanupArg) (
	*CatalogItemUnregCleanupRet, error) {

	ret := &CatalogItemUnregCleanupRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogItemUnregCleanup", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) FileGet(
	arg *FileGetArg) (
	*FileGetRet, error) {

	ret := &FileGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "FileGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) ImageCreate(
	arg *acropolis.ImageCreateArg) (
	*acropolis.ImageCreateRet, error) {

	ret := &acropolis.ImageCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "ImageCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) ImageGet(
	arg *acropolis.ImageGetArg) (
	*acropolis.ImageGetRet, error) {

	ret := &acropolis.ImageGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "ImageGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) ImageUpdate(
	arg *acropolis.ImageUpdateArg) (
	*acropolis.ImageUpdateRet, error) {

	ret := &acropolis.ImageUpdateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "ImageUpdate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) ImageDelete(
	arg *acropolis.ImageDeleteArg) (
	*acropolis.ImageDeleteRet, error) {

	ret := &acropolis.ImageDeleteRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "ImageDelete", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) ImageUpload(
	arg *ImageUploadArg) (
	*ImageUploadRet, error) {

	ret := &ImageUploadRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "ImageUpload", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogPlacementPolicyCreate(
	arg *CatalogPlacementPolicyCreateArg) (
	*CatalogPlacementPolicyCreateRet, error) {

	ret := &CatalogPlacementPolicyCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogPlacementPolicyCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogPlacementPolicyUpdate(
	arg *CatalogPlacementPolicyUpdateArg) (
	*CatalogPlacementPolicyUpdateRet, error) {

	ret := &CatalogPlacementPolicyUpdateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogPlacementPolicyUpdate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogPlacementPolicyDelete(
	arg *CatalogPlacementPolicyDeleteArg) (
	*CatalogPlacementPolicyDeleteRet, error) {

	ret := &CatalogPlacementPolicyDeleteRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogPlacementPolicyDelete", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogPlacementPolicyGet(
	arg *CatalogPlacementPolicyGetArg) (
	*CatalogPlacementPolicyGetRet, error) {

	ret := &CatalogPlacementPolicyGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogPlacementPolicyGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogPlacementPolicyStatusGet(
	arg *CatalogPlacementPolicyStatusGetArg) (
	*CatalogPlacementPolicyStatusGetRet, error) {

	ret := &CatalogPlacementPolicyStatusGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogPlacementPolicyStatusGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) ImageCheckout(
	arg *ImageCheckoutArg) (
	*ImageCheckoutRet, error) {

	ret := &ImageCheckoutRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "ImageCheckout", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateCreate(
	arg *TemplateCreateArg) (
	*TemplateCreateRet, error) {

	ret := &TemplateCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateVersionCreate(
	arg *TemplateVersionCreateArg) (
	*TemplateVersionCreateRet, error) {

	ret := &TemplateVersionCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateVersionCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateAndVersionCreate(
	arg *TemplateAndVersionCreateArg) (
	*TemplateAndVersionCreateRet, error) {

	ret := &TemplateAndVersionCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateAndVersionCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplatesGet(
	arg *TemplatesGetArg) (
	*TemplatesGetRet, error) {

	ret := &TemplatesGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplatesGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateVersionsGet(
	arg *TemplateVersionsGetArg) (
	*TemplateVersionsGetRet, error) {

	ret := &TemplateVersionsGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateVersionsGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateDeploy(
	arg *TemplateDeployArg) (
	*TemplateDeployRet, error) {

	ret := &TemplateDeployRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateDeploy", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateInitiateGuestChanges(
	arg *TemplateInitiateGuestChangesArg) (
	*TemplateInitiateGuestChangesRet, error) {

	ret := &TemplateInitiateGuestChangesRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateInitiateGuestChanges", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateCompleteGuestChanges(
	arg *TemplateCompleteGuestChangesArg) (
	*TemplateCompleteGuestChangesRet, error) {

	ret := &TemplateCompleteGuestChangesRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateCompleteGuestChanges", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateCancelGuestChanges(
	arg *TemplateCancelGuestChangesArg) (
	*TemplateCancelGuestChangesRet, error) {

	ret := &TemplateCancelGuestChangesRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateCancelGuestChanges", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateDelete(
	arg *TemplateDeleteArg) (
	*TemplateDeleteRet, error) {

	ret := &TemplateDeleteRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateDelete", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) VmTemplateVersionsDelete(
	arg *TemplateVersionsDeleteArg) (
	*TemplateVersionsDeleteRet, error) {

	ret := &TemplateVersionsDeleteRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "VmTemplateVersionsDelete", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogRateLimitCreate(
	arg *CatalogRateLimitCreateArg) (
	*CatalogRateLimitCreateRet, error) {

	ret := &CatalogRateLimitCreateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogRateLimitCreate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogRateLimitGet(
	arg *CatalogRateLimitGetArg) (
	*CatalogRateLimitGetRet, error) {

	ret := &CatalogRateLimitGetRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogRateLimitGet", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogRateLimitUpdate(
	arg *CatalogRateLimitUpdateArg) (
	*CatalogRateLimitUpdateRet, error) {

	ret := &CatalogRateLimitUpdateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogRateLimitUpdate", arg, ret, 0)
	return ret, err
}

func (client *CatalogExternalRpcClient) CatalogRateLimitDelete(
	arg *CatalogRateLimitDeleteArg) (
	*CatalogRateLimitDeleteRet, error) {

	ret := &CatalogRateLimitDeleteRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.catalog.CatalogExternalRpcService", "CatalogRateLimitDelete", arg, ret, 0)
	return ret, err
}
