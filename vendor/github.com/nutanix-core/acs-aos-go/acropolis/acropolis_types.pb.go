// Code generated by protoc-gen-go. DO NOT EDIT.
// source: acropolis/acropolis_types.proto

package acropolis

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	net "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/net"
	math "math"
	microseg "github.com/nutanix-core/acs-aos-go/microseg"
	pithos "github.com/nutanix-core/acs-aos-go/pithos"
	stretch_params "github.com/nutanix-core/acs-aos-go/pithos/stretch_params"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type VmChildEntityType int32

const (
	VmChildEntityType_kVirtualDisk VmChildEntityType = 1
	VmChildEntityType_kVirtualNic  VmChildEntityType = 2
	VmChildEntityType_kVirtualGpu  VmChildEntityType = 3
)

var VmChildEntityType_name = map[int32]string{
	1: "kVirtualDisk",
	2: "kVirtualNic",
	3: "kVirtualGpu",
}

var VmChildEntityType_value = map[string]int32{
	"kVirtualDisk": 1,
	"kVirtualNic":  2,
	"kVirtualGpu":  3,
}

func (x VmChildEntityType) Enum() *VmChildEntityType {
	p := new(VmChildEntityType)
	*p = x
	return p
}

func (x VmChildEntityType) String() string {
	return proto.EnumName(VmChildEntityType_name, int32(x))
}

func (x *VmChildEntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmChildEntityType_value, data, "VmChildEntityType")
	if err != nil {
		return err
	}
	*x = VmChildEntityType(value)
	return nil
}

func (VmChildEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{0}
}

//-----------------------------------------------------------------------------
// Type of VM.
type VmType int32

const (
	VmType_kGuestVM VmType = 1
	VmType_kCVM     VmType = 2
	VmType_kAFSVM   VmType = 3
	VmType_kPCVM    VmType = 4
	VmType_kVPNVM   VmType = 5
	VmType_kMSPVM   VmType = 6
)

var VmType_name = map[int32]string{
	1: "kGuestVM",
	2: "kCVM",
	3: "kAFSVM",
	4: "kPCVM",
	5: "kVPNVM",
	6: "kMSPVM",
}

var VmType_value = map[string]int32{
	"kGuestVM": 1,
	"kCVM":     2,
	"kAFSVM":   3,
	"kPCVM":    4,
	"kVPNVM":   5,
	"kMSPVM":   6,
}

func (x VmType) Enum() *VmType {
	p := new(VmType)
	*p = x
	return p
}

func (x VmType) String() string {
	return proto.EnumName(VmType_name, int32(x))
}

func (x *VmType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmType_value, data, "VmType")
	if err != nil {
		return err
	}
	*x = VmType(value)
	return nil
}

func (VmType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{1}
}

//-----------------------------------------------------------------------------
type VmNicVlanType int32

const (
	VmNicVlanType_kAccess  VmNicVlanType = 1
	VmNicVlanType_kTrunked VmNicVlanType = 2
)

var VmNicVlanType_name = map[int32]string{
	1: "kAccess",
	2: "kTrunked",
}

var VmNicVlanType_value = map[string]int32{
	"kAccess":  1,
	"kTrunked": 2,
}

func (x VmNicVlanType) Enum() *VmNicVlanType {
	p := new(VmNicVlanType)
	*p = x
	return p
}

func (x VmNicVlanType) String() string {
	return proto.EnumName(VmNicVlanType_name, int32(x))
}

func (x *VmNicVlanType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicVlanType_value, data, "VmNicVlanType")
	if err != nil {
		return err
	}
	*x = VmNicVlanType(value)
	return nil
}

func (VmNicVlanType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{2}
}

type VmNicType int32

const (
	// kNormal NIC's are used for user VM's and will be plugged in to the local
	// bridge in a bridge chain. Traffic from kNormal NIC's will go through
	// security groups and packet processing flows.
	VmNicType_kNormalNic VmNicType = 1
	// kNetworkFunctionNic NIC's are used for Network Function VM's. These NIC's
	// do not belong to any network, and ports are created in trunk-all mode. They
	// will be plugged in to the network function bridge, and will send/receive
	// packets as defined in a service chain.
	VmNicType_kNetworkFunctionNic VmNicType = 2
	// kDirectNic's are used for user VM's that are plugged in to directly to the
	// uplink bridges. Normal-type NIC's plugged in to the local bridge does not
	// suppport dynamic MAC address (needed by nested hypervisors, for example).
	// Packets from Direct NIC's will not go through microseg and network function
	// bridges.
	VmNicType_kDirectNic VmNicType = 3
)

var VmNicType_name = map[int32]string{
	1: "kNormalNic",
	2: "kNetworkFunctionNic",
	3: "kDirectNic",
}

var VmNicType_value = map[string]int32{
	"kNormalNic":          1,
	"kNetworkFunctionNic": 2,
	"kDirectNic":          3,
}

func (x VmNicType) Enum() *VmNicType {
	p := new(VmNicType)
	*p = x
	return p
}

func (x VmNicType) String() string {
	return proto.EnumName(VmNicType_name, int32(x))
}

func (x *VmNicType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicType_value, data, "VmNicType")
	if err != nil {
		return err
	}
	*x = VmNicType(value)
	return nil
}

func (VmNicType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{3}
}

type NetworkFunctionNicType int32

const (
	// Network packets flowing in the uplink direction (UVM->physical network)
	// through a network function chain, will enter the appliance through the
	// ingress nic and exit through the egress nic. Packets flowing in the
	// opposite direction will enter through egress nic and exit through ingress
	// nic. Tap nics on the appliance will receive a copy of all packets flowing
	// through the network function chain.
	NetworkFunctionNicType_kIngress NetworkFunctionNicType = 1
	NetworkFunctionNicType_kEgress  NetworkFunctionNicType = 2
	NetworkFunctionNicType_kTap     NetworkFunctionNicType = 3
)

var NetworkFunctionNicType_name = map[int32]string{
	1: "kIngress",
	2: "kEgress",
	3: "kTap",
}

var NetworkFunctionNicType_value = map[string]int32{
	"kIngress": 1,
	"kEgress":  2,
	"kTap":     3,
}

func (x NetworkFunctionNicType) Enum() *NetworkFunctionNicType {
	p := new(NetworkFunctionNicType)
	*p = x
	return p
}

func (x NetworkFunctionNicType) String() string {
	return proto.EnumName(NetworkFunctionNicType_name, int32(x))
}

func (x *NetworkFunctionNicType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkFunctionNicType_value, data, "NetworkFunctionNicType")
	if err != nil {
		return err
	}
	*x = NetworkFunctionNicType(value)
	return nil
}

func (NetworkFunctionNicType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{4}
}

type GPUType int32

const (
	// GPU in graphics mode.
	GPUType_kPassthroughGraphics GPUType = 1
	// GPU in compute mode.
	GPUType_kPassthroughCompute GPUType = 2
	// Virtual GPU.
	GPUType_kVirtual GPUType = 3
)

var GPUType_name = map[int32]string{
	1: "kPassthroughGraphics",
	2: "kPassthroughCompute",
	3: "kVirtual",
}

var GPUType_value = map[string]int32{
	"kPassthroughGraphics": 1,
	"kPassthroughCompute":  2,
	"kVirtual":             3,
}

func (x GPUType) Enum() *GPUType {
	p := new(GPUType)
	*p = x
	return p
}

func (x GPUType) String() string {
	return proto.EnumName(GPUType_name, int32(x))
}

func (x *GPUType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GPUType_value, data, "GPUType")
	if err != nil {
		return err
	}
	*x = GPUType(value)
	return nil
}

func (GPUType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{5}
}

type GPUVendor int32

const (
	// Nvidia GPU vendor.
	GPUVendor_kNvidia GPUVendor = 1
	// Intel GPU vendor.
	GPUVendor_kIntel GPUVendor = 2
	// AMD GPU Vendor.
	GPUVendor_kAmd GPUVendor = 3
)

var GPUVendor_name = map[int32]string{
	1: "kNvidia",
	2: "kIntel",
	3: "kAmd",
}

var GPUVendor_value = map[string]int32{
	"kNvidia": 1,
	"kIntel":  2,
	"kAmd":    3,
}

func (x GPUVendor) Enum() *GPUVendor {
	p := new(GPUVendor)
	*p = x
	return p
}

func (x GPUVendor) String() string {
	return proto.EnumName(GPUVendor_name, int32(x))
}

func (x *GPUVendor) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GPUVendor_value, data, "GPUVendor")
	if err != nil {
		return err
	}
	*x = GPUVendor(value)
	return nil
}

func (GPUVendor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{6}
}

type GPUMode int32

const (
	// GPU is not being used.
	GPUMode_kUnused GPUMode = 1
	// GPU is being used for passthrough.
	GPUMode_kUsedForPassthrough GPUMode = 2
	// GPU is being used by virtual GPU resources.
	GPUMode_kUsedForVirtual GPUMode = 3
)

var GPUMode_name = map[int32]string{
	1: "kUnused",
	2: "kUsedForPassthrough",
	3: "kUsedForVirtual",
}

var GPUMode_value = map[string]int32{
	"kUnused":             1,
	"kUsedForPassthrough": 2,
	"kUsedForVirtual":     3,
}

func (x GPUMode) Enum() *GPUMode {
	p := new(GPUMode)
	*p = x
	return p
}

func (x GPUMode) String() string {
	return proto.EnumName(GPUMode_name, int32(x))
}

func (x *GPUMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GPUMode_value, data, "GPUMode")
	if err != nil {
		return err
	}
	*x = GPUMode(value)
	return nil
}

func (GPUMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{7}
}

// Multiplication factor for memory that needs to be added to mem_assigned_bytes
// on the destination node for VM's segment assignment.
type AssignedMemoryUpdateType int32

const (
	AssignedMemoryUpdateType_kNoChange AssignedMemoryUpdateType = 0
	AssignedMemoryUpdateType_kAdd      AssignedMemoryUpdateType = 1
	AssignedMemoryUpdateType_kSubtract AssignedMemoryUpdateType = -1
)

var AssignedMemoryUpdateType_name = map[int32]string{
	0:  "kNoChange",
	1:  "kAdd",
	-1: "kSubtract",
}

var AssignedMemoryUpdateType_value = map[string]int32{
	"kNoChange": 0,
	"kAdd":      1,
	"kSubtract": -1,
}

func (x AssignedMemoryUpdateType) Enum() *AssignedMemoryUpdateType {
	p := new(AssignedMemoryUpdateType)
	*p = x
	return p
}

func (x AssignedMemoryUpdateType) String() string {
	return proto.EnumName(AssignedMemoryUpdateType_name, int32(x))
}

func (x *AssignedMemoryUpdateType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AssignedMemoryUpdateType_value, data, "AssignedMemoryUpdateType")
	if err != nil {
		return err
	}
	*x = AssignedMemoryUpdateType(value)
	return nil
}

func (AssignedMemoryUpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{8}
}

type MicrosegConfigOperation int32

const (
	// Config noop.
	MicrosegConfigOperation_kMicrosegOpInvalid MicrosegConfigOperation = 1
	// Rule add.
	MicrosegConfigOperation_kMicrosegOpRuleAdd MicrosegConfigOperation = 2
	// Rule delete.
	MicrosegConfigOperation_kMicrosegOpRuleDelete MicrosegConfigOperation = 3
)

var MicrosegConfigOperation_name = map[int32]string{
	1: "kMicrosegOpInvalid",
	2: "kMicrosegOpRuleAdd",
	3: "kMicrosegOpRuleDelete",
}

var MicrosegConfigOperation_value = map[string]int32{
	"kMicrosegOpInvalid":    1,
	"kMicrosegOpRuleAdd":    2,
	"kMicrosegOpRuleDelete": 3,
}

func (x MicrosegConfigOperation) Enum() *MicrosegConfigOperation {
	p := new(MicrosegConfigOperation)
	*p = x
	return p
}

func (x MicrosegConfigOperation) String() string {
	return proto.EnumName(MicrosegConfigOperation_name, int32(x))
}

func (x *MicrosegConfigOperation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MicrosegConfigOperation_value, data, "MicrosegConfigOperation")
	if err != nil {
		return err
	}
	*x = MicrosegConfigOperation(value)
	return nil
}

func (MicrosegConfigOperation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{9}
}

type MicrosegConfigReason int32

const (
	// Reason noop.
	MicrosegConfigReason_kMicrosegReasonInvalid MicrosegConfigReason = 1
	// Rule add.
	MicrosegConfigReason_kMicrosegRuleAdd MicrosegConfigReason = 2
	// Rule delete.
	MicrosegConfigReason_kMicrosegRuleDelete MicrosegConfigReason = 3
	// Rule update.
	MicrosegConfigReason_kMicrosegRuleUpdate MicrosegConfigReason = 4
	// VM category update.
	MicrosegConfigReason_kMicrosegCategoryUpdate MicrosegConfigReason = 5
	// VM add IP due to NIC add or Category attach.
	MicrosegConfigReason_kMicrosegVmAddIp MicrosegConfigReason = 6
	// VM delete IP due to NIC delete or Category detach.
	MicrosegConfigReason_kMicrosegVmDeleteIp MicrosegConfigReason = 7
	// VM migrate.
	MicrosegConfigReason_kMicrosegVmMigrate MicrosegConfigReason = 8
	// Virtual nic delete.
	MicrosegConfigReason_kMicrosegVmDeleteVirtualNic MicrosegConfigReason = 9
	// Virtual nic add.
	MicrosegConfigReason_kMicrosegVmAddVirtualNic MicrosegConfigReason = 10
	// Virtual nic update.
	MicrosegConfigReason_kMicrosegVmUpdateVirtualNic MicrosegConfigReason = 11
)

var MicrosegConfigReason_name = map[int32]string{
	1:  "kMicrosegReasonInvalid",
	2:  "kMicrosegRuleAdd",
	3:  "kMicrosegRuleDelete",
	4:  "kMicrosegRuleUpdate",
	5:  "kMicrosegCategoryUpdate",
	6:  "kMicrosegVmAddIp",
	7:  "kMicrosegVmDeleteIp",
	8:  "kMicrosegVmMigrate",
	9:  "kMicrosegVmDeleteVirtualNic",
	10: "kMicrosegVmAddVirtualNic",
	11: "kMicrosegVmUpdateVirtualNic",
}

var MicrosegConfigReason_value = map[string]int32{
	"kMicrosegReasonInvalid":      1,
	"kMicrosegRuleAdd":            2,
	"kMicrosegRuleDelete":         3,
	"kMicrosegRuleUpdate":         4,
	"kMicrosegCategoryUpdate":     5,
	"kMicrosegVmAddIp":            6,
	"kMicrosegVmDeleteIp":         7,
	"kMicrosegVmMigrate":          8,
	"kMicrosegVmDeleteVirtualNic": 9,
	"kMicrosegVmAddVirtualNic":    10,
	"kMicrosegVmUpdateVirtualNic": 11,
}

func (x MicrosegConfigReason) Enum() *MicrosegConfigReason {
	p := new(MicrosegConfigReason)
	*p = x
	return p
}

func (x MicrosegConfigReason) String() string {
	return proto.EnumName(MicrosegConfigReason_name, int32(x))
}

func (x *MicrosegConfigReason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MicrosegConfigReason_value, data, "MicrosegConfigReason")
	if err != nil {
		return err
	}
	*x = MicrosegConfigReason(value)
	return nil
}

func (MicrosegConfigReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{10}
}

type MicrosegConfigCommand int32

const (
	// Command noop.
	MicrosegConfigCommand_kNetworkSecurityRuleInvalid MicrosegConfigCommand = 1
	// Create rule.
	MicrosegConfigCommand_kNetworkSecurityRuleCreate MicrosegConfigCommand = 2
	// Delete rule.
	MicrosegConfigCommand_kNetworkSecurityRuleDelete MicrosegConfigCommand = 3
	// Update rule to add IP.
	MicrosegConfigCommand_kNetworkSecurityRuleAddIp MicrosegConfigCommand = 4
	// Update rule to delete IP.
	MicrosegConfigCommand_kNetworkSecurityRuleDeleteIp MicrosegConfigCommand = 5
	// Cleanup rules based on generation number.
	MicrosegConfigCommand_kNetworkSecurityRuleCleanup MicrosegConfigCommand = 6
	// Disable network security rule.
	MicrosegConfigCommand_kNetworkSecurityRuleDisable MicrosegConfigCommand = 7
	// Change Flow mode of operation.
	MicrosegConfigCommand_kFlowModeChange MicrosegConfigCommand = 8
	// Initialize hosts for flow features
	MicrosegConfigCommand_kFlowInit MicrosegConfigCommand = 9
	// Create default rules on VM upon policy attach
	MicrosegConfigCommand_kNetworkSecurityRuleDefaultCreate MicrosegConfigCommand = 10
	// Delete default rules on VM upon policy removal
	MicrosegConfigCommand_kNetworkSecurityRuleDefaultDelete MicrosegConfigCommand = 11
	// Used for sending Batch Commands from PE to ahv.
	// Batched commands include kNetworkSecurityRuleAddIp,
	// kNetworkSecurityRuleDeleteIp
	// NOTE: don't use it for PC-PE. not implemented
	MicrosegConfigCommand_kNetworkSecurityRuleMultiOpIp MicrosegConfigCommand = 12
	// Enable network security rule.
	MicrosegConfigCommand_kNetworkSecurityRuleEnable MicrosegConfigCommand = 13
)

var MicrosegConfigCommand_name = map[int32]string{
	1:  "kNetworkSecurityRuleInvalid",
	2:  "kNetworkSecurityRuleCreate",
	3:  "kNetworkSecurityRuleDelete",
	4:  "kNetworkSecurityRuleAddIp",
	5:  "kNetworkSecurityRuleDeleteIp",
	6:  "kNetworkSecurityRuleCleanup",
	7:  "kNetworkSecurityRuleDisable",
	8:  "kFlowModeChange",
	9:  "kFlowInit",
	10: "kNetworkSecurityRuleDefaultCreate",
	11: "kNetworkSecurityRuleDefaultDelete",
	12: "kNetworkSecurityRuleMultiOpIp",
	13: "kNetworkSecurityRuleEnable",
}

var MicrosegConfigCommand_value = map[string]int32{
	"kNetworkSecurityRuleInvalid":       1,
	"kNetworkSecurityRuleCreate":        2,
	"kNetworkSecurityRuleDelete":        3,
	"kNetworkSecurityRuleAddIp":         4,
	"kNetworkSecurityRuleDeleteIp":      5,
	"kNetworkSecurityRuleCleanup":       6,
	"kNetworkSecurityRuleDisable":       7,
	"kFlowModeChange":                   8,
	"kFlowInit":                         9,
	"kNetworkSecurityRuleDefaultCreate": 10,
	"kNetworkSecurityRuleDefaultDelete": 11,
	"kNetworkSecurityRuleMultiOpIp":     12,
	"kNetworkSecurityRuleEnable":        13,
}

func (x MicrosegConfigCommand) Enum() *MicrosegConfigCommand {
	p := new(MicrosegConfigCommand)
	*p = x
	return p
}

func (x MicrosegConfigCommand) String() string {
	return proto.EnumName(MicrosegConfigCommand_name, int32(x))
}

func (x *MicrosegConfigCommand) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MicrosegConfigCommand_value, data, "MicrosegConfigCommand")
	if err != nil {
		return err
	}
	*x = MicrosegConfigCommand(value)
	return nil
}

func (MicrosegConfigCommand) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{11}
}

// Type of the update request.
type MicrosegUpdateRequestType int32

const (
	MicrosegUpdateRequestType_kRuleUpdate      MicrosegUpdateRequestType = 1
	MicrosegUpdateRequestType_kReconcileUpdate MicrosegUpdateRequestType = 2
)

var MicrosegUpdateRequestType_name = map[int32]string{
	1: "kRuleUpdate",
	2: "kReconcileUpdate",
}

var MicrosegUpdateRequestType_value = map[string]int32{
	"kRuleUpdate":      1,
	"kReconcileUpdate": 2,
}

func (x MicrosegUpdateRequestType) Enum() *MicrosegUpdateRequestType {
	p := new(MicrosegUpdateRequestType)
	*p = x
	return p
}

func (x MicrosegUpdateRequestType) String() string {
	return proto.EnumName(MicrosegUpdateRequestType_name, int32(x))
}

func (x *MicrosegUpdateRequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MicrosegUpdateRequestType_value, data, "MicrosegUpdateRequestType")
	if err != nil {
		return err
	}
	*x = MicrosegUpdateRequestType(value)
	return nil
}

func (MicrosegUpdateRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{12}
}

// The version with respect to Volumes Capabilities.
type VolumesVersion int32

const (
	VolumesVersion_kInitialVersion                  VolumesVersion = 0
	VolumesVersion_kVolumesPCApiVersion             VolumesVersion = 1
	VolumesVersion_kVolumesStorageManagementVersion VolumesVersion = 2
)

var VolumesVersion_name = map[int32]string{
	0: "kInitialVersion",
	1: "kVolumesPCApiVersion",
	2: "kVolumesStorageManagementVersion",
}

var VolumesVersion_value = map[string]int32{
	"kInitialVersion":                  0,
	"kVolumesPCApiVersion":             1,
	"kVolumesStorageManagementVersion": 2,
}

func (x VolumesVersion) Enum() *VolumesVersion {
	p := new(VolumesVersion)
	*p = x
	return p
}

func (x VolumesVersion) String() string {
	return proto.EnumName(VolumesVersion_name, int32(x))
}

func (x *VolumesVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VolumesVersion_value, data, "VolumesVersion")
	if err != nil {
		return err
	}
	*x = VolumesVersion(value)
	return nil
}

func (VolumesVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13}
}

// Type of the power state mechanism.
type PowerStateMechanism int32

const (
	PowerStateMechanism_kHard  PowerStateMechanism = 1
	PowerStateMechanism_kAcpi  PowerStateMechanism = 2
	PowerStateMechanism_kGuest PowerStateMechanism = 3
)

var PowerStateMechanism_name = map[int32]string{
	1: "kHard",
	2: "kAcpi",
	3: "kGuest",
}

var PowerStateMechanism_value = map[string]int32{
	"kHard":  1,
	"kAcpi":  2,
	"kGuest": 3,
}

func (x PowerStateMechanism) Enum() *PowerStateMechanism {
	p := new(PowerStateMechanism)
	*p = x
	return p
}

func (x PowerStateMechanism) String() string {
	return proto.EnumName(PowerStateMechanism_name, int32(x))
}

func (x *PowerStateMechanism) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PowerStateMechanism_value, data, "PowerStateMechanism")
	if err != nil {
		return err
	}
	*x = PowerStateMechanism(value)
	return nil
}

func (PowerStateMechanism) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{14}
}

type HypervisorType_Type int32

const (
	HypervisorType_kKvm    HypervisorType_Type = 1
	HypervisorType_kHyperV HypervisorType_Type = 2
	HypervisorType_kEsx    HypervisorType_Type = 3
	HypervisorType_kXen    HypervisorType_Type = 4
)

var HypervisorType_Type_name = map[int32]string{
	1: "kKvm",
	2: "kHyperV",
	3: "kEsx",
	4: "kXen",
}

var HypervisorType_Type_value = map[string]int32{
	"kKvm":    1,
	"kHyperV": 2,
	"kEsx":    3,
	"kXen":    4,
}

func (x HypervisorType_Type) Enum() *HypervisorType_Type {
	p := new(HypervisorType_Type)
	*p = x
	return p
}

func (x HypervisorType_Type) String() string {
	return proto.EnumName(HypervisorType_Type_name, int32(x))
}

func (x *HypervisorType_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HypervisorType_Type_value, data, "HypervisorType_Type")
	if err != nil {
		return err
	}
	*x = HypervisorType_Type(value)
	return nil
}

func (HypervisorType_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{4, 0}
}

type HostType_Type int32

const (
	HostType_kHyperConverged   HostType_Type = 1
	HostType_kComputeOnly      HostType_Type = 2
	HostType_kNeverSchedulable HostType_Type = 3
)

var HostType_Type_name = map[int32]string{
	1: "kHyperConverged",
	2: "kComputeOnly",
	3: "kNeverSchedulable",
}

var HostType_Type_value = map[string]int32{
	"kHyperConverged":   1,
	"kComputeOnly":      2,
	"kNeverSchedulable": 3,
}

func (x HostType_Type) Enum() *HostType_Type {
	p := new(HostType_Type)
	*p = x
	return p
}

func (x HostType_Type) String() string {
	return proto.EnumName(HostType_Type_name, int32(x))
}

func (x *HostType_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HostType_Type_value, data, "HostType_Type")
	if err != nil {
		return err
	}
	*x = HostType_Type(value)
	return nil
}

func (HostType_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{5, 0}
}

// Entities associated with the task.
type Task_Entity int32

const (
	Task_kNode           Task_Entity = 1
	Task_kVM             Task_Entity = 2
	Task_kSnapshot       Task_Entity = 3
	Task_kImage          Task_Entity = 4
	Task_kVolumeGroup    Task_Entity = 5
	Task_kVirtualNetwork Task_Entity = 6
	Task_kVmGroup        Task_Entity = 7
	Task_kMicrosegRule   Task_Entity = 8
	Task_kCluster        Task_Entity = 9
	Task_kClusterVswitch Task_Entity = 10
	Task_kVirtualSwitch  Task_Entity = 11
	Task_kVirtualDisk    Task_Entity = 12
	Task_kIscsiClient    Task_Entity = 13
)

var Task_Entity_name = map[int32]string{
	1:  "kNode",
	2:  "kVM",
	3:  "kSnapshot",
	4:  "kImage",
	5:  "kVolumeGroup",
	6:  "kVirtualNetwork",
	7:  "kVmGroup",
	8:  "kMicrosegRule",
	9:  "kCluster",
	10: "kClusterVswitch",
	11: "kVirtualSwitch",
	12: "kVirtualDisk",
	13: "kIscsiClient",
}

var Task_Entity_value = map[string]int32{
	"kNode":           1,
	"kVM":             2,
	"kSnapshot":       3,
	"kImage":          4,
	"kVolumeGroup":    5,
	"kVirtualNetwork": 6,
	"kVmGroup":        7,
	"kMicrosegRule":   8,
	"kCluster":        9,
	"kClusterVswitch": 10,
	"kVirtualSwitch":  11,
	"kVirtualDisk":    12,
	"kIscsiClient":    13,
}

func (x Task_Entity) Enum() *Task_Entity {
	p := new(Task_Entity)
	*p = x
	return p
}

func (x Task_Entity) String() string {
	return proto.EnumName(Task_Entity_name, int32(x))
}

func (x *Task_Entity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_Entity_value, data, "Task_Entity")
	if err != nil {
		return err
	}
	*x = Task_Entity(value)
	return nil
}

func (Task_Entity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13, 0}
}

// Type of operation
type Task_OperationType int32

const (
	Task_kSnapshotCreate           Task_OperationType = 1
	Task_kVmCreate                 Task_OperationType = 2
	Task_kVmClone                  Task_OperationType = 3
	Task_kVmMigrate                Task_OperationType = 4
	Task_kVmRestore                Task_OperationType = 5
	Task_kVmUpdate                 Task_OperationType = 6
	Task_kVmSetPowerState          Task_OperationType = 7
	Task_kVmDelete                 Task_OperationType = 8
	Task_kVmDiskCreate             Task_OperationType = 9
	Task_kVmDiskUpdate             Task_OperationType = 10
	Task_kVmDiskDelete             Task_OperationType = 11
	Task_kVmNicCreate              Task_OperationType = 12
	Task_kVmNicUpdate              Task_OperationType = 13
	Task_kVmNicDelete              Task_OperationType = 14
	Task_kEnterMaintenanceMode     Task_OperationType = 15
	Task_kExitMaintenanceMode      Task_OperationType = 16
	Task_kVmRegister               Task_OperationType = 17
	Task_kVmForcePowerOff          Task_OperationType = 18
	Task_kSnapshotDelete           Task_OperationType = 19
	Task_kImageCreate              Task_OperationType = 20
	Task_kImageDelete              Task_OperationType = 21
	Task_kHostRestartAllVms        Task_OperationType = 22
	Task_kHaUpdate                 Task_OperationType = 23
	Task_kStartHAFailover          Task_OperationType = 24
	Task_kRestartVmGroup           Task_OperationType = 25
	Task_kVmForceCompleteMigration Task_OperationType = 26
	Task_kVolumeGroupCreate        Task_OperationType = 27
	Task_kVolumeGroupUpdate        Task_OperationType = 28
	Task_kVolumeGroupDelete        Task_OperationType = 29
	Task_kVolumeDiskCreate         Task_OperationType = 30
	Task_kVolumeDiskDelete         Task_OperationType = 31
	Task_kImageUpdate              Task_OperationType = 32
	Task_kVolumeGroupAttachVm      Task_OperationType = 33
	Task_kVmAttachVg               Task_OperationType = 34
	Task_kVolumeGroupRegister      Task_OperationType = 35
	Task_kHaFailover               Task_OperationType = 36
	Task_kHostRestoreVmLocality    Task_OperationType = 37
	Task_kVolumeDiskUpdate         Task_OperationType = 38
	Task_kVolumeGroupClone         Task_OperationType = 39
	Task_kStretchConfigure         Task_OperationType = 40
	Task_kStretchRecover           Task_OperationType = 41
	Task_kVmGroupCreate            Task_OperationType = 42
	Task_kVmGroupDelete            Task_OperationType = 43
	Task_kVmGroupUpdate            Task_OperationType = 44
	Task_kParcelsCreate            Task_OperationType = 45
	Task_kParcelDelete             Task_OperationType = 46
	Task_kNetworkCreate            Task_OperationType = 47
	Task_kNetworkUpdate            Task_OperationType = 48
	Task_kNetworkDelete            Task_OperationType = 49
	Task_kAffinityRuleUpdate       Task_OperationType = 50
	Task_kVmAffinityUpdate         Task_OperationType = 51
	Task_kLazanParcelUpdate        Task_OperationType = 52
	// Deprecated. kLazanGetVMsOnHost = 53;
	Task_kLazanNotifyPowerTransition  Task_OperationType = 54
	Task_kLazanCompleteMigrateVm      Task_OperationType = 55
	Task_kLazanSetHostFailures        Task_OperationType = 56
	Task_kLazanNotifyFailoverComplete Task_OperationType = 57
	// Deprecated. kLazanIsTaskPending = 58;
	Task_kLazanAssignSegments Task_OperationType = 59
	// Deprecated. kLazanGetEntityParcels = 60;
	Task_kLazanAffinityHAComplianceCheck Task_OperationType = 61
	// Deprecated. kLazanRecalculateReservations = 62;
	// Deprecated. kLazanCheckCurrentNodeFailures = 63;
	// Deprecated. kLazanIsFailoverInProgress = 64;
	Task_kLazanScheduleVm Task_OperationType = 65
	// Deprecated. Use MaybeUpdateAffinityTask and ScheduleVmTask instead.
	// kLazanMaybeScheduleVm = 66;
	// Deprecated. kLazanGetSegmentAssignment = 67;
	// Deprecated. kLazanGetHighPriorityHosts = 68;
	Task_kMicrosegUpdate           Task_OperationType = 69
	Task_kMicrosegDelete           Task_OperationType = 70
	Task_kLazanMaybeUpdateAffinity Task_OperationType = 71
	Task_kReservePerHostMemory     Task_OperationType = 72
	Task_kClusterVswitchCreate     Task_OperationType = 73
	Task_kClusterVswitchUpdate     Task_OperationType = 74
	Task_kClusterVswitchDelete     Task_OperationType = 75
	Task_kUpdateVmDbState          Task_OperationType = 76
	Task_kVmSyncRepEnable          Task_OperationType = 78
	// Deprecated. kVmSyncRepPromote = 79;
	Task_kVmSyncRepUpdate                         Task_OperationType = 80
	Task_kVmSyncRepUpdateDormantVm                Task_OperationType = 81
	Task_kDormantVmDiskDelete                     Task_OperationType = 83
	Task_kVmSyncRepReplicate                      Task_OperationType = 84
	Task_kVmSyncRepMigrate                        Task_OperationType = 85
	Task_kCrossClusterPrepareVmLiveMigrate        Task_OperationType = 86
	Task_kVmCrossClusterLiveMigrate               Task_OperationType = 87
	Task_kVmDisableUpdate                         Task_OperationType = 88
	Task_kPrechecksCrossClusterLiveMigrate        Task_OperationType = 89
	Task_kCleanupCrossClusterPrepareVmLiveMigrate Task_OperationType = 90
	Task_kVmChangeDiskContainerUpdate             Task_OperationType = 91
	Task_kDormantVmStateGet                       Task_OperationType = 92
	Task_kDistributedVswitchCreate                Task_OperationType = 93
	Task_kDistributedVswitchUpdate                Task_OperationType = 94
	Task_kDistributedVswitchDelete                Task_OperationType = 95
	Task_kMigrateBridgeToDistributedVswitch       Task_OperationType = 96
	Task_kHostSwapAttach                          Task_OperationType = 97
	Task_kHostSwapDetach                          Task_OperationType = 98
	Task_kVmSyncRepConfigUpdate                   Task_OperationType = 99
	Task_kVolumeGroupAttachIscsiClient            Task_OperationType = 100
	Task_kVmRemoteForcePowerOff                   Task_OperationType = 101
	Task_kIscsiClientUpdateAsync                  Task_OperationType = 102
	Task_kCleanupCrossClusterLiveMigrateSource    Task_OperationType = 103
	Task_kMicrosegBatchUpdate                     Task_OperationType = 104
	Task_kVmUpdateIncarnationIds                  Task_OperationType = 105
	Task_kMicrosegUpdateGenNum                    Task_OperationType = 106
)

var Task_OperationType_name = map[int32]string{
	1:   "kSnapshotCreate",
	2:   "kVmCreate",
	3:   "kVmClone",
	4:   "kVmMigrate",
	5:   "kVmRestore",
	6:   "kVmUpdate",
	7:   "kVmSetPowerState",
	8:   "kVmDelete",
	9:   "kVmDiskCreate",
	10:  "kVmDiskUpdate",
	11:  "kVmDiskDelete",
	12:  "kVmNicCreate",
	13:  "kVmNicUpdate",
	14:  "kVmNicDelete",
	15:  "kEnterMaintenanceMode",
	16:  "kExitMaintenanceMode",
	17:  "kVmRegister",
	18:  "kVmForcePowerOff",
	19:  "kSnapshotDelete",
	20:  "kImageCreate",
	21:  "kImageDelete",
	22:  "kHostRestartAllVms",
	23:  "kHaUpdate",
	24:  "kStartHAFailover",
	25:  "kRestartVmGroup",
	26:  "kVmForceCompleteMigration",
	27:  "kVolumeGroupCreate",
	28:  "kVolumeGroupUpdate",
	29:  "kVolumeGroupDelete",
	30:  "kVolumeDiskCreate",
	31:  "kVolumeDiskDelete",
	32:  "kImageUpdate",
	33:  "kVolumeGroupAttachVm",
	34:  "kVmAttachVg",
	35:  "kVolumeGroupRegister",
	36:  "kHaFailover",
	37:  "kHostRestoreVmLocality",
	38:  "kVolumeDiskUpdate",
	39:  "kVolumeGroupClone",
	40:  "kStretchConfigure",
	41:  "kStretchRecover",
	42:  "kVmGroupCreate",
	43:  "kVmGroupDelete",
	44:  "kVmGroupUpdate",
	45:  "kParcelsCreate",
	46:  "kParcelDelete",
	47:  "kNetworkCreate",
	48:  "kNetworkUpdate",
	49:  "kNetworkDelete",
	50:  "kAffinityRuleUpdate",
	51:  "kVmAffinityUpdate",
	52:  "kLazanParcelUpdate",
	54:  "kLazanNotifyPowerTransition",
	55:  "kLazanCompleteMigrateVm",
	56:  "kLazanSetHostFailures",
	57:  "kLazanNotifyFailoverComplete",
	59:  "kLazanAssignSegments",
	61:  "kLazanAffinityHAComplianceCheck",
	65:  "kLazanScheduleVm",
	69:  "kMicrosegUpdate",
	70:  "kMicrosegDelete",
	71:  "kLazanMaybeUpdateAffinity",
	72:  "kReservePerHostMemory",
	73:  "kClusterVswitchCreate",
	74:  "kClusterVswitchUpdate",
	75:  "kClusterVswitchDelete",
	76:  "kUpdateVmDbState",
	78:  "kVmSyncRepEnable",
	80:  "kVmSyncRepUpdate",
	81:  "kVmSyncRepUpdateDormantVm",
	83:  "kDormantVmDiskDelete",
	84:  "kVmSyncRepReplicate",
	85:  "kVmSyncRepMigrate",
	86:  "kCrossClusterPrepareVmLiveMigrate",
	87:  "kVmCrossClusterLiveMigrate",
	88:  "kVmDisableUpdate",
	89:  "kPrechecksCrossClusterLiveMigrate",
	90:  "kCleanupCrossClusterPrepareVmLiveMigrate",
	91:  "kVmChangeDiskContainerUpdate",
	92:  "kDormantVmStateGet",
	93:  "kDistributedVswitchCreate",
	94:  "kDistributedVswitchUpdate",
	95:  "kDistributedVswitchDelete",
	96:  "kMigrateBridgeToDistributedVswitch",
	97:  "kHostSwapAttach",
	98:  "kHostSwapDetach",
	99:  "kVmSyncRepConfigUpdate",
	100: "kVolumeGroupAttachIscsiClient",
	101: "kVmRemoteForcePowerOff",
	102: "kIscsiClientUpdateAsync",
	103: "kCleanupCrossClusterLiveMigrateSource",
	104: "kMicrosegBatchUpdate",
	105: "kVmUpdateIncarnationIds",
	106: "kMicrosegUpdateGenNum",
}

var Task_OperationType_value = map[string]int32{
	"kSnapshotCreate":                          1,
	"kVmCreate":                                2,
	"kVmClone":                                 3,
	"kVmMigrate":                               4,
	"kVmRestore":                               5,
	"kVmUpdate":                                6,
	"kVmSetPowerState":                         7,
	"kVmDelete":                                8,
	"kVmDiskCreate":                            9,
	"kVmDiskUpdate":                            10,
	"kVmDiskDelete":                            11,
	"kVmNicCreate":                             12,
	"kVmNicUpdate":                             13,
	"kVmNicDelete":                             14,
	"kEnterMaintenanceMode":                    15,
	"kExitMaintenanceMode":                     16,
	"kVmRegister":                              17,
	"kVmForcePowerOff":                         18,
	"kSnapshotDelete":                          19,
	"kImageCreate":                             20,
	"kImageDelete":                             21,
	"kHostRestartAllVms":                       22,
	"kHaUpdate":                                23,
	"kStartHAFailover":                         24,
	"kRestartVmGroup":                          25,
	"kVmForceCompleteMigration":                26,
	"kVolumeGroupCreate":                       27,
	"kVolumeGroupUpdate":                       28,
	"kVolumeGroupDelete":                       29,
	"kVolumeDiskCreate":                        30,
	"kVolumeDiskDelete":                        31,
	"kImageUpdate":                             32,
	"kVolumeGroupAttachVm":                     33,
	"kVmAttachVg":                              34,
	"kVolumeGroupRegister":                     35,
	"kHaFailover":                              36,
	"kHostRestoreVmLocality":                   37,
	"kVolumeDiskUpdate":                        38,
	"kVolumeGroupClone":                        39,
	"kStretchConfigure":                        40,
	"kStretchRecover":                          41,
	"kVmGroupCreate":                           42,
	"kVmGroupDelete":                           43,
	"kVmGroupUpdate":                           44,
	"kParcelsCreate":                           45,
	"kParcelDelete":                            46,
	"kNetworkCreate":                           47,
	"kNetworkUpdate":                           48,
	"kNetworkDelete":                           49,
	"kAffinityRuleUpdate":                      50,
	"kVmAffinityUpdate":                        51,
	"kLazanParcelUpdate":                       52,
	"kLazanNotifyPowerTransition":              54,
	"kLazanCompleteMigrateVm":                  55,
	"kLazanSetHostFailures":                    56,
	"kLazanNotifyFailoverComplete":             57,
	"kLazanAssignSegments":                     59,
	"kLazanAffinityHAComplianceCheck":          61,
	"kLazanScheduleVm":                         65,
	"kMicrosegUpdate":                          69,
	"kMicrosegDelete":                          70,
	"kLazanMaybeUpdateAffinity":                71,
	"kReservePerHostMemory":                    72,
	"kClusterVswitchCreate":                    73,
	"kClusterVswitchUpdate":                    74,
	"kClusterVswitchDelete":                    75,
	"kUpdateVmDbState":                         76,
	"kVmSyncRepEnable":                         78,
	"kVmSyncRepUpdate":                         80,
	"kVmSyncRepUpdateDormantVm":                81,
	"kDormantVmDiskDelete":                     83,
	"kVmSyncRepReplicate":                      84,
	"kVmSyncRepMigrate":                        85,
	"kCrossClusterPrepareVmLiveMigrate":        86,
	"kVmCrossClusterLiveMigrate":               87,
	"kVmDisableUpdate":                         88,
	"kPrechecksCrossClusterLiveMigrate":        89,
	"kCleanupCrossClusterPrepareVmLiveMigrate": 90,
	"kVmChangeDiskContainerUpdate":             91,
	"kDormantVmStateGet":                       92,
	"kDistributedVswitchCreate":                93,
	"kDistributedVswitchUpdate":                94,
	"kDistributedVswitchDelete":                95,
	"kMigrateBridgeToDistributedVswitch":       96,
	"kHostSwapAttach":                          97,
	"kHostSwapDetach":                          98,
	"kVmSyncRepConfigUpdate":                   99,
	"kVolumeGroupAttachIscsiClient":            100,
	"kVmRemoteForcePowerOff":                   101,
	"kIscsiClientUpdateAsync":                  102,
	"kCleanupCrossClusterLiveMigrateSource":    103,
	"kMicrosegBatchUpdate":                     104,
	"kVmUpdateIncarnationIds":                  105,
	"kMicrosegUpdateGenNum":                    106,
}

func (x Task_OperationType) Enum() *Task_OperationType {
	p := new(Task_OperationType)
	*p = x
	return p
}

func (x Task_OperationType) String() string {
	return proto.EnumName(Task_OperationType_name, int32(x))
}

func (x *Task_OperationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_OperationType_value, data, "Task_OperationType")
	if err != nil {
		return err
	}
	*x = Task_OperationType(value)
	return nil
}

func (Task_OperationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13, 1}
}

// Current status of this task.
type Task_Status int32

const (
	Task_kQueued    Task_Status = 1
	Task_kRunning   Task_Status = 2
	Task_kSucceeded Task_Status = 3
	Task_kAborted   Task_Status = 4
	Task_kFailed    Task_Status = 5
	Task_kSuspended Task_Status = 6
)

var Task_Status_name = map[int32]string{
	1: "kQueued",
	2: "kRunning",
	3: "kSucceeded",
	4: "kAborted",
	5: "kFailed",
	6: "kSuspended",
}

var Task_Status_value = map[string]int32{
	"kQueued":    1,
	"kRunning":   2,
	"kSucceeded": 3,
	"kAborted":   4,
	"kFailed":    5,
	"kSuspended": 6,
}

func (x Task_Status) Enum() *Task_Status {
	p := new(Task_Status)
	*p = x
	return p
}

func (x Task_Status) String() string {
	return proto.EnumName(Task_Status_name, int32(x))
}

func (x *Task_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_Status_value, data, "Task_Status")
	if err != nil {
		return err
	}
	*x = Task_Status(value)
	return nil
}

func (Task_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13, 2}
}

type Task_Capability int32

const (
	// This task can be suspended and then subsequently resumed.
	Task_kTaskSuspend Task_Capability = 1
	// This task can be canceled/aborted.
	Task_kTaskCancel Task_Capability = 2
)

var Task_Capability_name = map[int32]string{
	1: "kTaskSuspend",
	2: "kTaskCancel",
}

var Task_Capability_value = map[string]int32{
	"kTaskSuspend": 1,
	"kTaskCancel":  2,
}

func (x Task_Capability) Enum() *Task_Capability {
	p := new(Task_Capability)
	*p = x
	return p
}

func (x Task_Capability) String() string {
	return proto.EnumName(Task_Capability_name, int32(x))
}

func (x *Task_Capability) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Task_Capability_value, data, "Task_Capability")
	if err != nil {
		return err
	}
	*x = Task_Capability(value)
	return nil
}

func (Task_Capability) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13, 3}
}

// Indicates the action to take for the VMs.
type EnterMaintenanceModeTypes_VmNonMigratableOption int32

const (
	// Fail the operation if:
	// 1. There are non-migratable VMs present (since those would not be
	//    HA protected as well). Agent VMs are not considered for the check
	//    since user has asked to power them off in case of EMM.
	// 2. VMs are live migratable but not HA protected and there are not enough
	//    resources to start them elsewhere.
	EnterMaintenanceModeTypes_kBlock EnterMaintenanceModeTypes_VmNonMigratableOption = 1
	// Power off (via ACPI shutdown if possible) VMs which are not migratable or
	// cannot be HA protected due to lack of resources.
	EnterMaintenanceModeTypes_kAcpiShutdownAndPowerOff EnterMaintenanceModeTypes_VmNonMigratableOption = 2
)

var EnterMaintenanceModeTypes_VmNonMigratableOption_name = map[int32]string{
	1: "kBlock",
	2: "kAcpiShutdownAndPowerOff",
}

var EnterMaintenanceModeTypes_VmNonMigratableOption_value = map[string]int32{
	"kBlock":                   1,
	"kAcpiShutdownAndPowerOff": 2,
}

func (x EnterMaintenanceModeTypes_VmNonMigratableOption) Enum() *EnterMaintenanceModeTypes_VmNonMigratableOption {
	p := new(EnterMaintenanceModeTypes_VmNonMigratableOption)
	*p = x
	return p
}

func (x EnterMaintenanceModeTypes_VmNonMigratableOption) String() string {
	return proto.EnumName(EnterMaintenanceModeTypes_VmNonMigratableOption_name, int32(x))
}

func (x *EnterMaintenanceModeTypes_VmNonMigratableOption) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EnterMaintenanceModeTypes_VmNonMigratableOption_value, data, "EnterMaintenanceModeTypes_VmNonMigratableOption")
	if err != nil {
		return err
	}
	*x = EnterMaintenanceModeTypes_VmNonMigratableOption(value)
	return nil
}

func (EnterMaintenanceModeTypes_VmNonMigratableOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{14, 0}
}

type VmBootDeviceType_Type int32

const (
	VmBootDeviceType_kCdrom   VmBootDeviceType_Type = 1
	VmBootDeviceType_kDisk    VmBootDeviceType_Type = 2
	VmBootDeviceType_kNetwork VmBootDeviceType_Type = 3
)

var VmBootDeviceType_Type_name = map[int32]string{
	1: "kCdrom",
	2: "kDisk",
	3: "kNetwork",
}

var VmBootDeviceType_Type_value = map[string]int32{
	"kCdrom":   1,
	"kDisk":    2,
	"kNetwork": 3,
}

func (x VmBootDeviceType_Type) Enum() *VmBootDeviceType_Type {
	p := new(VmBootDeviceType_Type)
	*p = x
	return p
}

func (x VmBootDeviceType_Type) String() string {
	return proto.EnumName(VmBootDeviceType_Type_name, int32(x))
}

func (x *VmBootDeviceType_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmBootDeviceType_Type_value, data, "VmBootDeviceType_Type")
	if err != nil {
		return err
	}
	*x = VmBootDeviceType_Type(value)
	return nil
}

func (VmBootDeviceType_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{15, 0}
}

// The type of the network that this NIC is attached to.
type VmNicConfig_NetworkType int32

const (
	// A native network is a network that has an AcropolisNetwork database
	// entity in Pithos, which is natively managed by the Acropolis service.
	// The network_uuid, if set, refers to such an AcropolisNetwork entity.
	VmNicConfig_kNativeNetwork VmNicConfig_NetworkType = 1
	// An Atlas network has no AcropolisNetwork database entity, and is instead
	// managed by the Atlas service. In this case, the network_uuid is required
	// to be set, and refers to an Atlas subnet.
	VmNicConfig_kAtlasNetwork VmNicConfig_NetworkType = 2
)

var VmNicConfig_NetworkType_name = map[int32]string{
	1: "kNativeNetwork",
	2: "kAtlasNetwork",
}

var VmNicConfig_NetworkType_value = map[string]int32{
	"kNativeNetwork": 1,
	"kAtlasNetwork":  2,
}

func (x VmNicConfig_NetworkType) Enum() *VmNicConfig_NetworkType {
	p := new(VmNicConfig_NetworkType)
	*p = x
	return p
}

func (x VmNicConfig_NetworkType) String() string {
	return proto.EnumName(VmNicConfig_NetworkType_name, int32(x))
}

func (x *VmNicConfig_NetworkType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicConfig_NetworkType_value, data, "VmNicConfig_NetworkType")
	if err != nil {
		return err
	}
	*x = VmNicConfig_NetworkType(value)
	return nil
}

func (VmNicConfig_NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{31, 0}
}

// The backing type for this serial port.
type VmSerialPortConfig_Type int32

const (
	// The serial device is present, but has no backing.
	VmSerialPortConfig_kNull VmSerialPortConfig_Type = 1
	// The serial device is accessible through Prism via a websocket.
	VmSerialPortConfig_kServer VmSerialPortConfig_Type = 2
)

var VmSerialPortConfig_Type_name = map[int32]string{
	1: "kNull",
	2: "kServer",
}

var VmSerialPortConfig_Type_value = map[string]int32{
	"kNull":   1,
	"kServer": 2,
}

func (x VmSerialPortConfig_Type) Enum() *VmSerialPortConfig_Type {
	p := new(VmSerialPortConfig_Type)
	*p = x
	return p
}

func (x VmSerialPortConfig_Type) String() string {
	return proto.EnumName(VmSerialPortConfig_Type_name, int32(x))
}

func (x *VmSerialPortConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmSerialPortConfig_Type_value, data, "VmSerialPortConfig_Type")
	if err != nil {
		return err
	}
	*x = VmSerialPortConfig_Type(value)
	return nil
}

func (VmSerialPortConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{34, 0}
}

// Supported states are marked below. All others are currently unsupported.
type VmState_State int32

const (
	// Supported.
	VmState_kUnknown VmState_State = 1
	// Supported.
	VmState_kOff        VmState_State = 2
	VmState_kPoweringOn VmState_State = 3
	// Supported.
	VmState_kOn           VmState_State = 4
	VmState_kShuttingDown VmState_State = 5
	VmState_kPoweringOff  VmState_State = 6
	VmState_kPausing      VmState_State = 7
	// Supported.
	VmState_kPaused     VmState_State = 8
	VmState_kSuspending VmState_State = 9
	VmState_kSuspended  VmState_State = 10
	VmState_kResuming   VmState_State = 11
	VmState_kResetting  VmState_State = 12
	VmState_kMigrating  VmState_State = 13
)

var VmState_State_name = map[int32]string{
	1:  "kUnknown",
	2:  "kOff",
	3:  "kPoweringOn",
	4:  "kOn",
	5:  "kShuttingDown",
	6:  "kPoweringOff",
	7:  "kPausing",
	8:  "kPaused",
	9:  "kSuspending",
	10: "kSuspended",
	11: "kResuming",
	12: "kResetting",
	13: "kMigrating",
}

var VmState_State_value = map[string]int32{
	"kUnknown":      1,
	"kOff":          2,
	"kPoweringOn":   3,
	"kOn":           4,
	"kShuttingDown": 5,
	"kPoweringOff":  6,
	"kPausing":      7,
	"kPaused":       8,
	"kSuspending":   9,
	"kSuspended":    10,
	"kResuming":     11,
	"kResetting":    12,
	"kMigrating":    13,
}

func (x VmState_State) Enum() *VmState_State {
	p := new(VmState_State)
	*p = x
	return p
}

func (x VmState_State) String() string {
	return proto.EnumName(VmState_State_name, int32(x))
}

func (x *VmState_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmState_State_value, data, "VmState_State")
	if err != nil {
		return err
	}
	*x = VmState_State(value)
	return nil
}

func (VmState_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{41, 0}
}

type VmStateTransition_Transition int32

const (
	VmStateTransition_kPowerOn       VmStateTransition_Transition = 1
	VmStateTransition_kPowerOff      VmStateTransition_Transition = 2
	VmStateTransition_kPowerCycle    VmStateTransition_Transition = 3
	VmStateTransition_kReset         VmStateTransition_Transition = 4
	VmStateTransition_kPause         VmStateTransition_Transition = 5
	VmStateTransition_kSuspend       VmStateTransition_Transition = 6
	VmStateTransition_kResume        VmStateTransition_Transition = 7
	VmStateTransition_kAcpiShutdown  VmStateTransition_Transition = 8
	VmStateTransition_kAcpiReboot    VmStateTransition_Transition = 9
	VmStateTransition_kGuestShutdown VmStateTransition_Transition = 10
	VmStateTransition_kGuestReboot   VmStateTransition_Transition = 11
)

var VmStateTransition_Transition_name = map[int32]string{
	1:  "kPowerOn",
	2:  "kPowerOff",
	3:  "kPowerCycle",
	4:  "kReset",
	5:  "kPause",
	6:  "kSuspend",
	7:  "kResume",
	8:  "kAcpiShutdown",
	9:  "kAcpiReboot",
	10: "kGuestShutdown",
	11: "kGuestReboot",
}

var VmStateTransition_Transition_value = map[string]int32{
	"kPowerOn":       1,
	"kPowerOff":      2,
	"kPowerCycle":    3,
	"kReset":         4,
	"kPause":         5,
	"kSuspend":       6,
	"kResume":        7,
	"kAcpiShutdown":  8,
	"kAcpiReboot":    9,
	"kGuestShutdown": 10,
	"kGuestReboot":   11,
}

func (x VmStateTransition_Transition) Enum() *VmStateTransition_Transition {
	p := new(VmStateTransition_Transition)
	*p = x
	return p
}

func (x VmStateTransition_Transition) String() string {
	return proto.EnumName(VmStateTransition_Transition_name, int32(x))
}

func (x *VmStateTransition_Transition) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmStateTransition_Transition_value, data, "VmStateTransition_Transition")
	if err != nil {
		return err
	}
	*x = VmStateTransition_Transition(value)
	return nil
}

func (VmStateTransition_Transition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{42, 0}
}

// Type of the network.
type NetworkConfig_Type int32

const (
	// A VLAN-backed network. The identifier field is the VLAN tag associated
	// with the virtual switch port. The port inserts this VLAN tag for
	// untagged packets ingressed from VMs to the bridge, and strips this VLAN
	// tag from packets egressed from the bridge to the VM.
	NetworkConfig_kBridged NetworkConfig_Type = 1
	// An overlay network. The identifier field is the VNI. Currently unused.
	NetworkConfig_kOverlay NetworkConfig_Type = 2
	// An externally managed network. This indicates that acropolis is not
	// responsible for network management; it is only responsible for plugging
	// ports into the bridge, and associating these ports with an port
	// identifier that is known to the external network controller.
	//
	// Networks of this type do not have an identifier.
	NetworkConfig_kExternal NetworkConfig_Type = 3
)

var NetworkConfig_Type_name = map[int32]string{
	1: "kBridged",
	2: "kOverlay",
	3: "kExternal",
}

var NetworkConfig_Type_value = map[string]int32{
	"kBridged":  1,
	"kOverlay":  2,
	"kExternal": 3,
}

func (x NetworkConfig_Type) Enum() *NetworkConfig_Type {
	p := new(NetworkConfig_Type)
	*p = x
	return p
}

func (x NetworkConfig_Type) String() string {
	return proto.EnumName(NetworkConfig_Type_name, int32(x))
}

func (x *NetworkConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkConfig_Type_value, data, "NetworkConfig_Type")
	if err != nil {
		return err
	}
	*x = NetworkConfig_Type(value)
	return nil
}

func (NetworkConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{45, 0}
}

// Type of assignment
type AddressAssignment_AssignmentType int32

const (
	// Address assigned to VM, requires mac_address, entity_uuid is vm_uuid.
	AddressAssignment_kVm AddressAssignment_AssignmentType = 1
	// IP address reserved and excluded from allocation, requires ip_address.
	AddressAssignment_kReservation AddressAssignment_AssignmentType = 2
	// IP address for internal components, requires ip_address.
	AddressAssignment_kInfrastructure AddressAssignment_AssignmentType = 3
)

var AddressAssignment_AssignmentType_name = map[int32]string{
	1: "kVm",
	2: "kReservation",
	3: "kInfrastructure",
}

var AddressAssignment_AssignmentType_value = map[string]int32{
	"kVm":             1,
	"kReservation":    2,
	"kInfrastructure": 3,
}

func (x AddressAssignment_AssignmentType) Enum() *AddressAssignment_AssignmentType {
	p := new(AddressAssignment_AssignmentType)
	*p = x
	return p
}

func (x AddressAssignment_AssignmentType) String() string {
	return proto.EnumName(AddressAssignment_AssignmentType_name, int32(x))
}

func (x *AddressAssignment_AssignmentType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AddressAssignment_AssignmentType_value, data, "AddressAssignment_AssignmentType")
	if err != nil {
		return err
	}
	*x = AddressAssignment_AssignmentType(value)
	return nil
}

func (AddressAssignment_AssignmentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{46, 0}
}

type ImageInfo_ImageType int32

const (
	// Image has no type. This is a special type only used to unset the image
	// type.
	ImageInfo_kNoType ImageInfo_ImageType = 0
	// Image is a flat disk.
	ImageInfo_kDiskImage ImageInfo_ImageType = 1
	// Image is an ISO that can only be attached as a CDROM.
	ImageInfo_kIsoImage ImageInfo_ImageType = 2
)

var ImageInfo_ImageType_name = map[int32]string{
	0: "kNoType",
	1: "kDiskImage",
	2: "kIsoImage",
}

var ImageInfo_ImageType_value = map[string]int32{
	"kNoType":    0,
	"kDiskImage": 1,
	"kIsoImage":  2,
}

func (x ImageInfo_ImageType) Enum() *ImageInfo_ImageType {
	p := new(ImageInfo_ImageType)
	*p = x
	return p
}

func (x ImageInfo_ImageType) String() string {
	return proto.EnumName(ImageInfo_ImageType_name, int32(x))
}

func (x *ImageInfo_ImageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ImageInfo_ImageType_value, data, "ImageInfo_ImageType")
	if err != nil {
		return err
	}
	*x = ImageInfo_ImageType(value)
	return nil
}

func (ImageInfo_ImageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{49, 0}
}

type ImageInfo_ChecksumType int32

const (
	ImageInfo_kSha256 ImageInfo_ChecksumType = 1
	ImageInfo_kSha1   ImageInfo_ChecksumType = 2
)

var ImageInfo_ChecksumType_name = map[int32]string{
	1: "kSha256",
	2: "kSha1",
}

var ImageInfo_ChecksumType_value = map[string]int32{
	"kSha256": 1,
	"kSha1":   2,
}

func (x ImageInfo_ChecksumType) Enum() *ImageInfo_ChecksumType {
	p := new(ImageInfo_ChecksumType)
	*p = x
	return p
}

func (x ImageInfo_ChecksumType) String() string {
	return proto.EnumName(ImageInfo_ChecksumType_name, int32(x))
}

func (x *ImageInfo_ChecksumType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ImageInfo_ChecksumType_value, data, "ImageInfo_ChecksumType")
	if err != nil {
		return err
	}
	*x = ImageInfo_ChecksumType(value)
	return nil
}

func (ImageInfo_ChecksumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{49, 1}
}

type ImageInfo_ImageState int32

const (
	ImageInfo_kActive   ImageInfo_ImageState = 1
	ImageInfo_kInactive ImageInfo_ImageState = 2
)

var ImageInfo_ImageState_name = map[int32]string{
	1: "kActive",
	2: "kInactive",
}

var ImageInfo_ImageState_value = map[string]int32{
	"kActive":   1,
	"kInactive": 2,
}

func (x ImageInfo_ImageState) Enum() *ImageInfo_ImageState {
	p := new(ImageInfo_ImageState)
	*p = x
	return p
}

func (x ImageInfo_ImageState) String() string {
	return proto.EnumName(ImageInfo_ImageState_name, int32(x))
}

func (x *ImageInfo_ImageState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ImageInfo_ImageState_value, data, "ImageInfo_ImageState")
	if err != nil {
		return err
	}
	*x = ImageInfo_ImageState(value)
	return nil
}

func (ImageInfo_ImageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{49, 2}
}

type ImageInfo_ImageArchitecture int32

const (
	// x86_64.
	ImageInfo_kX86_64 ImageInfo_ImageArchitecture = 0
	// Power PC big endian.
	ImageInfo_kPPC64 ImageInfo_ImageArchitecture = 1
	// Power PC little endian.
	ImageInfo_kPPC64LE ImageInfo_ImageArchitecture = 2
)

var ImageInfo_ImageArchitecture_name = map[int32]string{
	0: "kX86_64",
	1: "kPPC64",
	2: "kPPC64LE",
}

var ImageInfo_ImageArchitecture_value = map[string]int32{
	"kX86_64":  0,
	"kPPC64":   1,
	"kPPC64LE": 2,
}

func (x ImageInfo_ImageArchitecture) Enum() *ImageInfo_ImageArchitecture {
	p := new(ImageInfo_ImageArchitecture)
	*p = x
	return p
}

func (x ImageInfo_ImageArchitecture) String() string {
	return proto.EnumName(ImageInfo_ImageArchitecture_name, int32(x))
}

func (x *ImageInfo_ImageArchitecture) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ImageInfo_ImageArchitecture_value, data, "ImageInfo_ImageArchitecture")
	if err != nil {
		return err
	}
	*x = ImageInfo_ImageArchitecture(value)
	return nil
}

func (ImageInfo_ImageArchitecture) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{49, 3}
}

// This field indicates what file system to use for volume group.
// This is supported for container volumes for now.
type VolumeGroupCreateSpec_FileSystemType int32

const (
	VolumeGroupCreateSpec_kUnknown VolumeGroupCreateSpec_FileSystemType = 0
	VolumeGroupCreateSpec_kExt4    VolumeGroupCreateSpec_FileSystemType = 1
)

var VolumeGroupCreateSpec_FileSystemType_name = map[int32]string{
	0: "kUnknown",
	1: "kExt4",
}

var VolumeGroupCreateSpec_FileSystemType_value = map[string]int32{
	"kUnknown": 0,
	"kExt4":    1,
}

func (x VolumeGroupCreateSpec_FileSystemType) Enum() *VolumeGroupCreateSpec_FileSystemType {
	p := new(VolumeGroupCreateSpec_FileSystemType)
	*p = x
	return p
}

func (x VolumeGroupCreateSpec_FileSystemType) String() string {
	return proto.EnumName(VolumeGroupCreateSpec_FileSystemType_name, int32(x))
}

func (x *VolumeGroupCreateSpec_FileSystemType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VolumeGroupCreateSpec_FileSystemType_value, data, "VolumeGroupCreateSpec_FileSystemType")
	if err != nil {
		return err
	}
	*x = VolumeGroupCreateSpec_FileSystemType(value)
	return nil
}

func (VolumeGroupCreateSpec_FileSystemType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{56, 0}
}

type SchedulerPolicy_Qualifier int32

const (
	// Filter out nodes based on affinity rules.
	SchedulerPolicy_kFitsAffinity SchedulerPolicy_Qualifier = 1
)

var SchedulerPolicy_Qualifier_name = map[int32]string{
	1: "kFitsAffinity",
}

var SchedulerPolicy_Qualifier_value = map[string]int32{
	"kFitsAffinity": 1,
}

func (x SchedulerPolicy_Qualifier) Enum() *SchedulerPolicy_Qualifier {
	p := new(SchedulerPolicy_Qualifier)
	*p = x
	return p
}

func (x SchedulerPolicy_Qualifier) String() string {
	return proto.EnumName(SchedulerPolicy_Qualifier_name, int32(x))
}

func (x *SchedulerPolicy_Qualifier) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulerPolicy_Qualifier_value, data, "SchedulerPolicy_Qualifier")
	if err != nil {
		return err
	}
	*x = SchedulerPolicy_Qualifier(value)
	return nil
}

func (SchedulerPolicy_Qualifier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{78, 0}
}

type SchedulerPolicy_Priority int32

const (
	// Favor nodes that have least CPU and memory utilization.
	SchedulerPolicy_kFavorLeastLoadedNode SchedulerPolicy_Priority = 1
	// Favor nodes that meet affinity requirement.
	SchedulerPolicy_kFavorAffinity SchedulerPolicy_Priority = 2
	// Favor hybrid nodes in a cluster with fewer all-flash nodes than
	// replication factor.
	SchedulerPolicy_kFavorHybridNode SchedulerPolicy_Priority = 3
	// Favor the node with highest utilized vGPU resources.
	SchedulerPolicy_kFavorHighestvGPUUtilizedNode SchedulerPolicy_Priority = 4
)

var SchedulerPolicy_Priority_name = map[int32]string{
	1: "kFavorLeastLoadedNode",
	2: "kFavorAffinity",
	3: "kFavorHybridNode",
	4: "kFavorHighestvGPUUtilizedNode",
}

var SchedulerPolicy_Priority_value = map[string]int32{
	"kFavorLeastLoadedNode":         1,
	"kFavorAffinity":                2,
	"kFavorHybridNode":              3,
	"kFavorHighestvGPUUtilizedNode": 4,
}

func (x SchedulerPolicy_Priority) Enum() *SchedulerPolicy_Priority {
	p := new(SchedulerPolicy_Priority)
	*p = x
	return p
}

func (x SchedulerPolicy_Priority) String() string {
	return proto.EnumName(SchedulerPolicy_Priority_name, int32(x))
}

func (x *SchedulerPolicy_Priority) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SchedulerPolicy_Priority_value, data, "SchedulerPolicy_Priority")
	if err != nil {
		return err
	}
	*x = SchedulerPolicy_Priority(value)
	return nil
}

func (SchedulerPolicy_Priority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{78, 1}
}

// Entity types that can be associated with the Parcel.
type ParcelConfig_EntityType int32

const (
	ParcelConfig_kVM   ParcelConfig_EntityType = 1
	ParcelConfig_kLast ParcelConfig_EntityType = 2
)

var ParcelConfig_EntityType_name = map[int32]string{
	1: "kVM",
	2: "kLast",
}

var ParcelConfig_EntityType_value = map[string]int32{
	"kVM":   1,
	"kLast": 2,
}

func (x ParcelConfig_EntityType) Enum() *ParcelConfig_EntityType {
	p := new(ParcelConfig_EntityType)
	*p = x
	return p
}

func (x ParcelConfig_EntityType) String() string {
	return proto.EnumName(ParcelConfig_EntityType_name, int32(x))
}

func (x *ParcelConfig_EntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ParcelConfig_EntityType_value, data, "ParcelConfig_EntityType")
	if err != nil {
		return err
	}
	*x = ParcelConfig_EntityType(value)
	return nil
}

func (ParcelConfig_EntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{79, 0}
}

type Affinity_Policy int32

const (
	Affinity_kAffinity     Affinity_Policy = 1
	Affinity_kAntiAffinity Affinity_Policy = 2
)

var Affinity_Policy_name = map[int32]string{
	1: "kAffinity",
	2: "kAntiAffinity",
}

var Affinity_Policy_value = map[string]int32{
	"kAffinity":     1,
	"kAntiAffinity": 2,
}

func (x Affinity_Policy) Enum() *Affinity_Policy {
	p := new(Affinity_Policy)
	*p = x
	return p
}

func (x Affinity_Policy) String() string {
	return proto.EnumName(Affinity_Policy_name, int32(x))
}

func (x *Affinity_Policy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Affinity_Policy_value, data, "Affinity_Policy")
	if err != nil {
		return err
	}
	*x = Affinity_Policy(value)
	return nil
}

func (Affinity_Policy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{80, 0}
}

type Affinity_Constraint int32

const (
	Affinity_kMust   Affinity_Constraint = 1
	Affinity_kShould Affinity_Constraint = 2
)

var Affinity_Constraint_name = map[int32]string{
	1: "kMust",
	2: "kShould",
}

var Affinity_Constraint_value = map[string]int32{
	"kMust":   1,
	"kShould": 2,
}

func (x Affinity_Constraint) Enum() *Affinity_Constraint {
	p := new(Affinity_Constraint)
	*p = x
	return p
}

func (x Affinity_Constraint) String() string {
	return proto.EnumName(Affinity_Constraint_name, int32(x))
}

func (x *Affinity_Constraint) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Affinity_Constraint_value, data, "Affinity_Constraint")
	if err != nil {
		return err
	}
	*x = Affinity_Constraint(value)
	return nil
}

func (Affinity_Constraint) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{80, 1}
}

// Type of the network function.
// Inline - the function lies between the VM and the host, and can modify or
// redirect packets.
// Tap - the function can only inspect packets between VM and the host.
type NetworkFunctionConfig_Type int32

const (
	NetworkFunctionConfig_kInline NetworkFunctionConfig_Type = 1
	NetworkFunctionConfig_kTap    NetworkFunctionConfig_Type = 2
)

var NetworkFunctionConfig_Type_name = map[int32]string{
	1: "kInline",
	2: "kTap",
}

var NetworkFunctionConfig_Type_value = map[string]int32{
	"kInline": 1,
	"kTap":    2,
}

func (x NetworkFunctionConfig_Type) Enum() *NetworkFunctionConfig_Type {
	p := new(NetworkFunctionConfig_Type)
	*p = x
	return p
}

func (x NetworkFunctionConfig_Type) String() string {
	return proto.EnumName(NetworkFunctionConfig_Type_name, int32(x))
}

func (x *NetworkFunctionConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkFunctionConfig_Type_value, data, "NetworkFunctionConfig_Type")
	if err != nil {
		return err
	}
	*x = NetworkFunctionConfig_Type(value)
	return nil
}

func (NetworkFunctionConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{91, 0}
}

type ClusterVswitchConfig_NicTeamPolicy int32

const (
	ClusterVswitchConfig_kActiveBackup ClusterVswitchConfig_NicTeamPolicy = 1
	ClusterVswitchConfig_kBalanceSlb   ClusterVswitchConfig_NicTeamPolicy = 2
	ClusterVswitchConfig_kBalanceTcp   ClusterVswitchConfig_NicTeamPolicy = 3
)

var ClusterVswitchConfig_NicTeamPolicy_name = map[int32]string{
	1: "kActiveBackup",
	2: "kBalanceSlb",
	3: "kBalanceTcp",
}

var ClusterVswitchConfig_NicTeamPolicy_value = map[string]int32{
	"kActiveBackup": 1,
	"kBalanceSlb":   2,
	"kBalanceTcp":   3,
}

func (x ClusterVswitchConfig_NicTeamPolicy) Enum() *ClusterVswitchConfig_NicTeamPolicy {
	p := new(ClusterVswitchConfig_NicTeamPolicy)
	*p = x
	return p
}

func (x ClusterVswitchConfig_NicTeamPolicy) String() string {
	return proto.EnumName(ClusterVswitchConfig_NicTeamPolicy_name, int32(x))
}

func (x *ClusterVswitchConfig_NicTeamPolicy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ClusterVswitchConfig_NicTeamPolicy_value, data, "ClusterVswitchConfig_NicTeamPolicy")
	if err != nil {
		return err
	}
	*x = ClusterVswitchConfig_NicTeamPolicy(value)
	return nil
}

func (ClusterVswitchConfig_NicTeamPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{104, 0}
}

// Default grouping of uplink interfaces for this bond.
// Can be overridden on a per-host basis.
type ClusterVswitchConfig_UplinkGroupingType int32

const (
	ClusterVswitchConfig_kNone    ClusterVswitchConfig_UplinkGroupingType = 1
	ClusterVswitchConfig_kAll     ClusterVswitchConfig_UplinkGroupingType = 2
	ClusterVswitchConfig_kAll1G   ClusterVswitchConfig_UplinkGroupingType = 3
	ClusterVswitchConfig_kAll10G  ClusterVswitchConfig_UplinkGroupingType = 4
	ClusterVswitchConfig_kAll25G  ClusterVswitchConfig_UplinkGroupingType = 5
	ClusterVswitchConfig_kAll40G  ClusterVswitchConfig_UplinkGroupingType = 6
	ClusterVswitchConfig_kAll100G ClusterVswitchConfig_UplinkGroupingType = 7
)

var ClusterVswitchConfig_UplinkGroupingType_name = map[int32]string{
	1: "kNone",
	2: "kAll",
	3: "kAll1G",
	4: "kAll10G",
	5: "kAll25G",
	6: "kAll40G",
	7: "kAll100G",
}

var ClusterVswitchConfig_UplinkGroupingType_value = map[string]int32{
	"kNone":    1,
	"kAll":     2,
	"kAll1G":   3,
	"kAll10G":  4,
	"kAll25G":  5,
	"kAll40G":  6,
	"kAll100G": 7,
}

func (x ClusterVswitchConfig_UplinkGroupingType) Enum() *ClusterVswitchConfig_UplinkGroupingType {
	p := new(ClusterVswitchConfig_UplinkGroupingType)
	*p = x
	return p
}

func (x ClusterVswitchConfig_UplinkGroupingType) String() string {
	return proto.EnumName(ClusterVswitchConfig_UplinkGroupingType_name, int32(x))
}

func (x *ClusterVswitchConfig_UplinkGroupingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ClusterVswitchConfig_UplinkGroupingType_value, data, "ClusterVswitchConfig_UplinkGroupingType")
	if err != nil {
		return err
	}
	*x = ClusterVswitchConfig_UplinkGroupingType(value)
	return nil
}

func (ClusterVswitchConfig_UplinkGroupingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{104, 1}
}

type ClusterVswitchConfig_LacpConfig_LacpTimeout int32

const (
	ClusterVswitchConfig_LacpConfig_kFast ClusterVswitchConfig_LacpConfig_LacpTimeout = 1
	ClusterVswitchConfig_LacpConfig_kSlow ClusterVswitchConfig_LacpConfig_LacpTimeout = 2
)

var ClusterVswitchConfig_LacpConfig_LacpTimeout_name = map[int32]string{
	1: "kFast",
	2: "kSlow",
}

var ClusterVswitchConfig_LacpConfig_LacpTimeout_value = map[string]int32{
	"kFast": 1,
	"kSlow": 2,
}

func (x ClusterVswitchConfig_LacpConfig_LacpTimeout) Enum() *ClusterVswitchConfig_LacpConfig_LacpTimeout {
	p := new(ClusterVswitchConfig_LacpConfig_LacpTimeout)
	*p = x
	return p
}

func (x ClusterVswitchConfig_LacpConfig_LacpTimeout) String() string {
	return proto.EnumName(ClusterVswitchConfig_LacpConfig_LacpTimeout_name, int32(x))
}

func (x *ClusterVswitchConfig_LacpConfig_LacpTimeout) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ClusterVswitchConfig_LacpConfig_LacpTimeout_value, data, "ClusterVswitchConfig_LacpConfig_LacpTimeout")
	if err != nil {
		return err
	}
	*x = ClusterVswitchConfig_LacpConfig_LacpTimeout(value)
	return nil
}

func (ClusterVswitchConfig_LacpConfig_LacpTimeout) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{104, 0, 0}
}

// All possible precheck status.
type CrossClusterLiveMigratePrecheckResult_PrecheckStatus int32

const (
	CrossClusterLiveMigratePrecheckResult_kOk CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 1
	// The VM is in powered off state on source cluster.
	CrossClusterLiveMigratePrecheckResult_kVmPoweredOffError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 2
	// Failed to apply network mapping to VM's NIC(s) on destination cluster.
	CrossClusterLiveMigratePrecheckResult_kNetworkMappingError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 3
	// Failed to get dormant VM or parse the dormant VM spec.
	CrossClusterLiveMigratePrecheckResult_kDormantVmSpecError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 4
	// The VM is not live migratable.
	CrossClusterLiveMigratePrecheckResult_kVmNotLiveMigratableError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 5
	// The VM has vNUMA configured.
	CrossClusterLiveMigratePrecheckResult_kHasvNumaNodeError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 6
	// The VM is not in synced state.
	CrossClusterLiveMigratePrecheckResult_kVmNotInSyncStateError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 7
	// MAC address of a VM NIC is in use by a VM on the destination cluster.
	CrossClusterLiveMigratePrecheckResult_kMacAddressAlreadyInUseError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 8
	// The CPU feature set on source is different from that at destination.
	CrossClusterLiveMigratePrecheckResult_kCpuFeatureSetError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 9
	// Failed to collect VM CPU feature set on source cluster.
	CrossClusterLiveMigratePrecheckResult_kSourceVmCpuFeatureSetError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 10
	// Failed to get host CPU feature set on destination cluster.
	CrossClusterLiveMigratePrecheckResult_kDestinationHostCpuFeatureSetError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 11
	// The AHV version on source differs from that of destination cluster.
	CrossClusterLiveMigratePrecheckResult_kSourceDestinationAhvVersionMismatchError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 12
	// Failed to get AHV version on source cluster.
	CrossClusterLiveMigratePrecheckResult_kSourceAhvVersionError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 13
	// Failed to get host AHV version on destination cluster.
	CrossClusterLiveMigratePrecheckResult_kDestinationAhvVersionError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 14
	// Hosts on destination cluster are not running with the same AHV version.
	CrossClusterLiveMigratePrecheckResult_kDestinationMultipleAhvVersionsError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 15
	// The source cluster is in the process of being upgraded.
	CrossClusterLiveMigratePrecheckResult_kSourceUpgradeInProgressError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 16
	// The destination cluster is in the process of being upgraded.
	CrossClusterLiveMigratePrecheckResult_kDestinationUpgradeInProgressError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 17
	// A host is not meeting the minimum AHV version requirement.
	CrossClusterLiveMigratePrecheckResult_kMinimumAhvVersionError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 18
	// Host affinity is configured for the VM.
	CrossClusterLiveMigratePrecheckResult_kHostAffinityError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 19
	// The VM has microsegmentation configured.
	CrossClusterLiveMigratePrecheckResult_kVmMicrosegmentationError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 20
	// Failed to connect to libvirtd on secondary cluster using certificates.
	CrossClusterLiveMigratePrecheckResult_kConnectHostUsingCertificateError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 21
	// AOS version on secondary cluster is not supported.
	CrossClusterLiveMigratePrecheckResult_kDestinationAosVersionError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 22
	// If source cluster is configured with reserved host HA.
	CrossClusterLiveMigratePrecheckResult_kSourceHAConfigError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 23
	// If destination cluster is configured with reserved host HA.
	CrossClusterLiveMigratePrecheckResult_kDestinationHAConfigError CrossClusterLiveMigratePrecheckResult_PrecheckStatus = 24
)

var CrossClusterLiveMigratePrecheckResult_PrecheckStatus_name = map[int32]string{
	1:  "kOk",
	2:  "kVmPoweredOffError",
	3:  "kNetworkMappingError",
	4:  "kDormantVmSpecError",
	5:  "kVmNotLiveMigratableError",
	6:  "kHasvNumaNodeError",
	7:  "kVmNotInSyncStateError",
	8:  "kMacAddressAlreadyInUseError",
	9:  "kCpuFeatureSetError",
	10: "kSourceVmCpuFeatureSetError",
	11: "kDestinationHostCpuFeatureSetError",
	12: "kSourceDestinationAhvVersionMismatchError",
	13: "kSourceAhvVersionError",
	14: "kDestinationAhvVersionError",
	15: "kDestinationMultipleAhvVersionsError",
	16: "kSourceUpgradeInProgressError",
	17: "kDestinationUpgradeInProgressError",
	18: "kMinimumAhvVersionError",
	19: "kHostAffinityError",
	20: "kVmMicrosegmentationError",
	21: "kConnectHostUsingCertificateError",
	22: "kDestinationAosVersionError",
	23: "kSourceHAConfigError",
	24: "kDestinationHAConfigError",
}

var CrossClusterLiveMigratePrecheckResult_PrecheckStatus_value = map[string]int32{
	"kOk":                                       1,
	"kVmPoweredOffError":                        2,
	"kNetworkMappingError":                      3,
	"kDormantVmSpecError":                       4,
	"kVmNotLiveMigratableError":                 5,
	"kHasvNumaNodeError":                        6,
	"kVmNotInSyncStateError":                    7,
	"kMacAddressAlreadyInUseError":              8,
	"kCpuFeatureSetError":                       9,
	"kSourceVmCpuFeatureSetError":               10,
	"kDestinationHostCpuFeatureSetError":        11,
	"kSourceDestinationAhvVersionMismatchError": 12,
	"kSourceAhvVersionError":                    13,
	"kDestinationAhvVersionError":               14,
	"kDestinationMultipleAhvVersionsError":      15,
	"kSourceUpgradeInProgressError":             16,
	"kDestinationUpgradeInProgressError":        17,
	"kMinimumAhvVersionError":                   18,
	"kHostAffinityError":                        19,
	"kVmMicrosegmentationError":                 20,
	"kConnectHostUsingCertificateError":         21,
	"kDestinationAosVersionError":               22,
	"kSourceHAConfigError":                      23,
	"kDestinationHAConfigError":                 24,
}

func (x CrossClusterLiveMigratePrecheckResult_PrecheckStatus) Enum() *CrossClusterLiveMigratePrecheckResult_PrecheckStatus {
	p := new(CrossClusterLiveMigratePrecheckResult_PrecheckStatus)
	*p = x
	return p
}

func (x CrossClusterLiveMigratePrecheckResult_PrecheckStatus) String() string {
	return proto.EnumName(CrossClusterLiveMigratePrecheckResult_PrecheckStatus_name, int32(x))
}

func (x *CrossClusterLiveMigratePrecheckResult_PrecheckStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CrossClusterLiveMigratePrecheckResult_PrecheckStatus_value, data, "CrossClusterLiveMigratePrecheckResult_PrecheckStatus")
	if err != nil {
		return err
	}
	*x = CrossClusterLiveMigratePrecheckResult_PrecheckStatus(value)
	return nil
}

func (CrossClusterLiveMigratePrecheckResult_PrecheckStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{107, 0}
}

type DistributedVirtualSwitch_NicTeamPolicy int32

const (
	DistributedVirtualSwitch_kNoBond       DistributedVirtualSwitch_NicTeamPolicy = 0
	DistributedVirtualSwitch_kActiveBackup DistributedVirtualSwitch_NicTeamPolicy = 1
	DistributedVirtualSwitch_kBalanceSlb   DistributedVirtualSwitch_NicTeamPolicy = 2
	DistributedVirtualSwitch_kBalanceTcp   DistributedVirtualSwitch_NicTeamPolicy = 3
)

var DistributedVirtualSwitch_NicTeamPolicy_name = map[int32]string{
	0: "kNoBond",
	1: "kActiveBackup",
	2: "kBalanceSlb",
	3: "kBalanceTcp",
}

var DistributedVirtualSwitch_NicTeamPolicy_value = map[string]int32{
	"kNoBond":       0,
	"kActiveBackup": 1,
	"kBalanceSlb":   2,
	"kBalanceTcp":   3,
}

func (x DistributedVirtualSwitch_NicTeamPolicy) Enum() *DistributedVirtualSwitch_NicTeamPolicy {
	p := new(DistributedVirtualSwitch_NicTeamPolicy)
	*p = x
	return p
}

func (x DistributedVirtualSwitch_NicTeamPolicy) String() string {
	return proto.EnumName(DistributedVirtualSwitch_NicTeamPolicy_name, int32(x))
}

func (x *DistributedVirtualSwitch_NicTeamPolicy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DistributedVirtualSwitch_NicTeamPolicy_value, data, "DistributedVirtualSwitch_NicTeamPolicy")
	if err != nil {
		return err
	}
	*x = DistributedVirtualSwitch_NicTeamPolicy(value)
	return nil
}

func (DistributedVirtualSwitch_NicTeamPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109, 0}
}

type DistributedVirtualSwitch_LacpConfig_LacpTimeout int32

const (
	DistributedVirtualSwitch_LacpConfig_kFast DistributedVirtualSwitch_LacpConfig_LacpTimeout = 1
	DistributedVirtualSwitch_LacpConfig_kSlow DistributedVirtualSwitch_LacpConfig_LacpTimeout = 2
)

var DistributedVirtualSwitch_LacpConfig_LacpTimeout_name = map[int32]string{
	1: "kFast",
	2: "kSlow",
}

var DistributedVirtualSwitch_LacpConfig_LacpTimeout_value = map[string]int32{
	"kFast": 1,
	"kSlow": 2,
}

func (x DistributedVirtualSwitch_LacpConfig_LacpTimeout) Enum() *DistributedVirtualSwitch_LacpConfig_LacpTimeout {
	p := new(DistributedVirtualSwitch_LacpConfig_LacpTimeout)
	*p = x
	return p
}

func (x DistributedVirtualSwitch_LacpConfig_LacpTimeout) String() string {
	return proto.EnumName(DistributedVirtualSwitch_LacpConfig_LacpTimeout_name, int32(x))
}

func (x *DistributedVirtualSwitch_LacpConfig_LacpTimeout) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DistributedVirtualSwitch_LacpConfig_LacpTimeout_value, data, "DistributedVirtualSwitch_LacpConfig_LacpTimeout")
	if err != nil {
		return err
	}
	*x = DistributedVirtualSwitch_LacpConfig_LacpTimeout(value)
	return nil
}

func (DistributedVirtualSwitch_LacpConfig_LacpTimeout) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109, 0, 0}
}

// Grouping of uplink interfaces for this bond.
// Backward compatible to support ClusterVswitchConfig
type DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType int32

const (
	DistributedVirtualSwitch_ClusterConfig_kMixed   DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 0
	DistributedVirtualSwitch_ClusterConfig_kNone    DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 1
	DistributedVirtualSwitch_ClusterConfig_kAll     DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 2
	DistributedVirtualSwitch_ClusterConfig_kAll1G   DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 3
	DistributedVirtualSwitch_ClusterConfig_kAll10G  DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 4
	DistributedVirtualSwitch_ClusterConfig_kAll25G  DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 5
	DistributedVirtualSwitch_ClusterConfig_kAll40G  DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 6
	DistributedVirtualSwitch_ClusterConfig_kAll100G DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType = 7
)

var DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType_name = map[int32]string{
	0: "kMixed",
	1: "kNone",
	2: "kAll",
	3: "kAll1G",
	4: "kAll10G",
	5: "kAll25G",
	6: "kAll40G",
	7: "kAll100G",
}

var DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType_value = map[string]int32{
	"kMixed":   0,
	"kNone":    1,
	"kAll":     2,
	"kAll1G":   3,
	"kAll10G":  4,
	"kAll25G":  5,
	"kAll40G":  6,
	"kAll100G": 7,
}

func (x DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType) Enum() *DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType {
	p := new(DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType)
	*p = x
	return p
}

func (x DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType) String() string {
	return proto.EnumName(DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType_name, int32(x))
}

func (x *DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType_value, data, "DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType")
	if err != nil {
		return err
	}
	*x = DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType(value)
	return nil
}

func (DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109, 1, 0}
}

// A header template for generic DB objects.
type GenericDbObjectHeader struct {
	// UUID for this object.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this object has been deleted.
	Deleted *bool `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	// Logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,3,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// Name of the object.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Description of the object
	Description          *string  `protobuf:"bytes,5,opt,name=description" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenericDbObjectHeader) Reset()         { *m = GenericDbObjectHeader{} }
func (m *GenericDbObjectHeader) String() string { return proto.CompactTextString(m) }
func (*GenericDbObjectHeader) ProtoMessage()    {}
func (*GenericDbObjectHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{0}
}

func (m *GenericDbObjectHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericDbObjectHeader.Unmarshal(m, b)
}
func (m *GenericDbObjectHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericDbObjectHeader.Marshal(b, m, deterministic)
}
func (m *GenericDbObjectHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericDbObjectHeader.Merge(m, src)
}
func (m *GenericDbObjectHeader) XXX_Size() int {
	return xxx_messageInfo_GenericDbObjectHeader.Size(m)
}
func (m *GenericDbObjectHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericDbObjectHeader.DiscardUnknown(m)
}

var xxx_messageInfo_GenericDbObjectHeader proto.InternalMessageInfo

func (m *GenericDbObjectHeader) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *GenericDbObjectHeader) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *GenericDbObjectHeader) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *GenericDbObjectHeader) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *GenericDbObjectHeader) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

type TestDbObject struct {
	Header               *GenericDbObjectHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Num                  *int32                 `protobuf:"varint,2,opt,name=num" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TestDbObject) Reset()         { *m = TestDbObject{} }
func (m *TestDbObject) String() string { return proto.CompactTextString(m) }
func (*TestDbObject) ProtoMessage()    {}
func (*TestDbObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{1}
}

func (m *TestDbObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestDbObject.Unmarshal(m, b)
}
func (m *TestDbObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestDbObject.Marshal(b, m, deterministic)
}
func (m *TestDbObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestDbObject.Merge(m, src)
}
func (m *TestDbObject) XXX_Size() int {
	return xxx_messageInfo_TestDbObject.Size(m)
}
func (m *TestDbObject) XXX_DiscardUnknown() {
	xxx_messageInfo_TestDbObject.DiscardUnknown(m)
}

var xxx_messageInfo_TestDbObject proto.InternalMessageInfo

func (m *TestDbObject) GetHeader() *GenericDbObjectHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *TestDbObject) GetNum() int32 {
	if m != nil && m.Num != nil {
		return *m.Num
	}
	return 0
}

type GenericQueryRequest struct {
	// FIQL filtering criteria.
	FilterCriteria *string `protobuf:"bytes,1,opt,name=filter_criteria,json=filterCriteria" json:"filter_criteria,omitempty"`
	// FIQL sorting criteria.
	SortCriteria *string `protobuf:"bytes,2,opt,name=sort_criteria,json=sortCriteria" json:"sort_criteria,omitempty"`
	// Maximum number of entries to be returned. This is a hint, and there may be
	// fewer entries than requested even though there are more entries available.
	Limit *uint64 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
	// The index of the entry at which to start. This should field should be used
	// to resume a query.
	Cursor               []byte   `protobuf:"bytes,4,opt,name=cursor" json:"cursor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenericQueryRequest) Reset()         { *m = GenericQueryRequest{} }
func (m *GenericQueryRequest) String() string { return proto.CompactTextString(m) }
func (*GenericQueryRequest) ProtoMessage()    {}
func (*GenericQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{2}
}

func (m *GenericQueryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericQueryRequest.Unmarshal(m, b)
}
func (m *GenericQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericQueryRequest.Marshal(b, m, deterministic)
}
func (m *GenericQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericQueryRequest.Merge(m, src)
}
func (m *GenericQueryRequest) XXX_Size() int {
	return xxx_messageInfo_GenericQueryRequest.Size(m)
}
func (m *GenericQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenericQueryRequest proto.InternalMessageInfo

func (m *GenericQueryRequest) GetFilterCriteria() string {
	if m != nil && m.FilterCriteria != nil {
		return *m.FilterCriteria
	}
	return ""
}

func (m *GenericQueryRequest) GetSortCriteria() string {
	if m != nil && m.SortCriteria != nil {
		return *m.SortCriteria
	}
	return ""
}

func (m *GenericQueryRequest) GetLimit() uint64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

func (m *GenericQueryRequest) GetCursor() []byte {
	if m != nil {
		return m.Cursor
	}
	return nil
}

type GenericQueryResponse struct {
	// The current cursor position. If unset, the cursor has reached the end of
	// the list.
	Cursor []byte `protobuf:"bytes,1,opt,name=cursor" json:"cursor,omitempty"`
	// The total number of objects matching the query.
	Total                *uint64  `protobuf:"varint,2,opt,name=total" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenericQueryResponse) Reset()         { *m = GenericQueryResponse{} }
func (m *GenericQueryResponse) String() string { return proto.CompactTextString(m) }
func (*GenericQueryResponse) ProtoMessage()    {}
func (*GenericQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{3}
}

func (m *GenericQueryResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericQueryResponse.Unmarshal(m, b)
}
func (m *GenericQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericQueryResponse.Marshal(b, m, deterministic)
}
func (m *GenericQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericQueryResponse.Merge(m, src)
}
func (m *GenericQueryResponse) XXX_Size() int {
	return xxx_messageInfo_GenericQueryResponse.Size(m)
}
func (m *GenericQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenericQueryResponse proto.InternalMessageInfo

func (m *GenericQueryResponse) GetCursor() []byte {
	if m != nil {
		return m.Cursor
	}
	return nil
}

func (m *GenericQueryResponse) GetTotal() uint64 {
	if m != nil && m.Total != nil {
		return *m.Total
	}
	return 0
}

type HypervisorType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HypervisorType) Reset()         { *m = HypervisorType{} }
func (m *HypervisorType) String() string { return proto.CompactTextString(m) }
func (*HypervisorType) ProtoMessage()    {}
func (*HypervisorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{4}
}

func (m *HypervisorType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HypervisorType.Unmarshal(m, b)
}
func (m *HypervisorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HypervisorType.Marshal(b, m, deterministic)
}
func (m *HypervisorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HypervisorType.Merge(m, src)
}
func (m *HypervisorType) XXX_Size() int {
	return xxx_messageInfo_HypervisorType.Size(m)
}
func (m *HypervisorType) XXX_DiscardUnknown() {
	xxx_messageInfo_HypervisorType.DiscardUnknown(m)
}

var xxx_messageInfo_HypervisorType proto.InternalMessageInfo

type HostType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostType) Reset()         { *m = HostType{} }
func (m *HostType) String() string { return proto.CompactTextString(m) }
func (*HostType) ProtoMessage()    {}
func (*HostType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{5}
}

func (m *HostType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostType.Unmarshal(m, b)
}
func (m *HostType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostType.Marshal(b, m, deterministic)
}
func (m *HostType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostType.Merge(m, src)
}
func (m *HostType) XXX_Size() int {
	return xxx_messageInfo_HostType.Size(m)
}
func (m *HostType) XXX_DiscardUnknown() {
	xxx_messageInfo_HostType.DiscardUnknown(m)
}

var xxx_messageInfo_HostType proto.InternalMessageInfo

//-----------------------------------------------------------------------------
type GenericKeyValuePair struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenericKeyValuePair) Reset()         { *m = GenericKeyValuePair{} }
func (m *GenericKeyValuePair) String() string { return proto.CompactTextString(m) }
func (*GenericKeyValuePair) ProtoMessage()    {}
func (*GenericKeyValuePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{6}
}

func (m *GenericKeyValuePair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericKeyValuePair.Unmarshal(m, b)
}
func (m *GenericKeyValuePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericKeyValuePair.Marshal(b, m, deterministic)
}
func (m *GenericKeyValuePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericKeyValuePair.Merge(m, src)
}
func (m *GenericKeyValuePair) XXX_Size() int {
	return xxx_messageInfo_GenericKeyValuePair.Size(m)
}
func (m *GenericKeyValuePair) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericKeyValuePair.DiscardUnknown(m)
}

var xxx_messageInfo_GenericKeyValuePair proto.InternalMessageInfo

func (m *GenericKeyValuePair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *GenericKeyValuePair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type MetaRequest struct {
	// Method name.
	MethodName *string `protobuf:"bytes,1,opt,name=method_name,json=methodName" json:"method_name,omitempty"`
	// Serialized argument.
	Arg *PayloadOrEmbeddedValue `protobuf:"bytes,2,opt,name=arg" json:"arg,omitempty"`
	// Whether the RPC was forwarded from another Acropolis instance.
	Forwarded *bool `protobuf:"varint,3,opt,name=forwarded" json:"forwarded,omitempty"`
	// Context about the request that spawned the task such as the
	// user name, client ip, etc.
	RequestContext       *net.RpcRequestContext `protobuf:"bytes,4,opt,name=request_context,json=requestContext" json:"request_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *MetaRequest) Reset()         { *m = MetaRequest{} }
func (m *MetaRequest) String() string { return proto.CompactTextString(m) }
func (*MetaRequest) ProtoMessage()    {}
func (*MetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{7}
}

func (m *MetaRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaRequest.Unmarshal(m, b)
}
func (m *MetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaRequest.Marshal(b, m, deterministic)
}
func (m *MetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRequest.Merge(m, src)
}
func (m *MetaRequest) XXX_Size() int {
	return xxx_messageInfo_MetaRequest.Size(m)
}
func (m *MetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRequest proto.InternalMessageInfo

func (m *MetaRequest) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *MetaRequest) GetArg() *PayloadOrEmbeddedValue {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *MetaRequest) GetForwarded() bool {
	if m != nil && m.Forwarded != nil {
		return *m.Forwarded
	}
	return false
}

func (m *MetaRequest) GetRequestContext() *net.RpcRequestContext {
	if m != nil {
		return m.RequestContext
	}
	return nil
}

type MetaResponse struct {
	// An error code indicating whether the RPC was successful.
	ErrorCode *AcropolisError_Type `protobuf:"varint,1,opt,name=error_code,json=errorCode,enum=nutanix.acropolis.AcropolisError_Type" json:"error_code,omitempty"`
	// An optional additional string describing the error, if the RPC was not
	// successful.
	ErrorDetail *string `protobuf:"bytes,2,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	// The serialized response, if any.
	Ret                  *PayloadOrEmbeddedValue `protobuf:"bytes,3,opt,name=ret" json:"ret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MetaResponse) Reset()         { *m = MetaResponse{} }
func (m *MetaResponse) String() string { return proto.CompactTextString(m) }
func (*MetaResponse) ProtoMessage()    {}
func (*MetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{8}
}

func (m *MetaResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaResponse.Unmarshal(m, b)
}
func (m *MetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaResponse.Marshal(b, m, deterministic)
}
func (m *MetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaResponse.Merge(m, src)
}
func (m *MetaResponse) XXX_Size() int {
	return xxx_messageInfo_MetaResponse.Size(m)
}
func (m *MetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MetaResponse proto.InternalMessageInfo

func (m *MetaResponse) GetErrorCode() AcropolisError_Type {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return AcropolisError_kNoError
}

func (m *MetaResponse) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

func (m *MetaResponse) GetRet() *PayloadOrEmbeddedValue {
	if m != nil {
		return m.Ret
	}
	return nil
}

type PayloadValue struct {
	// The offset of the value in the payload.
	Offset *uint64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	// The size of the value in the payload.
	Size                 *uint64  `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayloadValue) Reset()         { *m = PayloadValue{} }
func (m *PayloadValue) String() string { return proto.CompactTextString(m) }
func (*PayloadValue) ProtoMessage()    {}
func (*PayloadValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{9}
}

func (m *PayloadValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadValue.Unmarshal(m, b)
}
func (m *PayloadValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadValue.Marshal(b, m, deterministic)
}
func (m *PayloadValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadValue.Merge(m, src)
}
func (m *PayloadValue) XXX_Size() int {
	return xxx_messageInfo_PayloadValue.Size(m)
}
func (m *PayloadValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadValue.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadValue proto.InternalMessageInfo

func (m *PayloadValue) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *PayloadValue) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

type PayloadOrEmbeddedValue struct {
	// Instructions on how to find value in the payload.
	Payload *PayloadValue `protobuf:"bytes,1,opt,name=payload" json:"payload,omitempty"`
	// Embedded value.
	Embedded             []byte   `protobuf:"bytes,2,opt,name=embedded" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayloadOrEmbeddedValue) Reset()         { *m = PayloadOrEmbeddedValue{} }
func (m *PayloadOrEmbeddedValue) String() string { return proto.CompactTextString(m) }
func (*PayloadOrEmbeddedValue) ProtoMessage()    {}
func (*PayloadOrEmbeddedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{10}
}

func (m *PayloadOrEmbeddedValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Unmarshal(m, b)
}
func (m *PayloadOrEmbeddedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Marshal(b, m, deterministic)
}
func (m *PayloadOrEmbeddedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadOrEmbeddedValue.Merge(m, src)
}
func (m *PayloadOrEmbeddedValue) XXX_Size() int {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Size(m)
}
func (m *PayloadOrEmbeddedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadOrEmbeddedValue.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadOrEmbeddedValue proto.InternalMessageInfo

func (m *PayloadOrEmbeddedValue) GetPayload() *PayloadValue {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PayloadOrEmbeddedValue) GetEmbedded() []byte {
	if m != nil {
		return m.Embedded
	}
	return nil
}

type SnapshotInfo struct {
	// The snapshot identifier.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Whether the snapshot has been deleted.
	Deleted *bool `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	// The snapshot's logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// The epoch time in microseconds when this snapshot was created.
	CreateTimeUsecs *int64 `protobuf:"varint,5,opt,name=create_time_usecs,json=createTimeUsecs" json:"create_time_usecs,omitempty"`
	// The consistency group identifier for this snapshot.
	GroupUuid []byte `protobuf:"bytes,7,opt,name=group_uuid,json=groupUuid" json:"group_uuid,omitempty"`
	// The VM identifier.
	VmUuid []byte `protobuf:"bytes,9,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// A specification for creating VMs from this snapshot.
	VmSpec *VmCreateSpec `protobuf:"bytes,10,opt,name=vm_spec,json=vmSpec" json:"vm_spec,omitempty"`
	// The snapshot name.
	Name *string `protobuf:"bytes,11,opt,name=name" json:"name,omitempty"`
	// VmGroup information.
	VmGroup              *VmGroup `protobuf:"bytes,12,opt,name=vm_group,json=vmGroup" json:"vm_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotInfo) Reset()         { *m = SnapshotInfo{} }
func (m *SnapshotInfo) String() string { return proto.CompactTextString(m) }
func (*SnapshotInfo) ProtoMessage()    {}
func (*SnapshotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{11}
}

func (m *SnapshotInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotInfo.Unmarshal(m, b)
}
func (m *SnapshotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotInfo.Marshal(b, m, deterministic)
}
func (m *SnapshotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotInfo.Merge(m, src)
}
func (m *SnapshotInfo) XXX_Size() int {
	return xxx_messageInfo_SnapshotInfo.Size(m)
}
func (m *SnapshotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotInfo proto.InternalMessageInfo

const Default_SnapshotInfo_LogicalTimestamp int64 = -1

func (m *SnapshotInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SnapshotInfo) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *SnapshotInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_SnapshotInfo_LogicalTimestamp
}

func (m *SnapshotInfo) GetCreateTimeUsecs() int64 {
	if m != nil && m.CreateTimeUsecs != nil {
		return *m.CreateTimeUsecs
	}
	return 0
}

func (m *SnapshotInfo) GetGroupUuid() []byte {
	if m != nil {
		return m.GroupUuid
	}
	return nil
}

func (m *SnapshotInfo) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *SnapshotInfo) GetVmSpec() *VmCreateSpec {
	if m != nil {
		return m.VmSpec
	}
	return nil
}

func (m *SnapshotInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SnapshotInfo) GetVmGroup() *VmGroup {
	if m != nil {
		return m.VmGroup
	}
	return nil
}

type SnapshotSpec struct {
	// A version 4 UUID that the client may specify for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The VM identifier.
	// This is a required field for SnapshotCreate.
	VmUuid []byte `protobuf:"bytes,2,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// The VM logical timestamp.
	VmLogicalTimestamp *int64 `protobuf:"varint,3,opt,name=vm_logical_timestamp,json=vmLogicalTimestamp,def=-1" json:"vm_logical_timestamp,omitempty"`
	// The optional snapshot name.
	Name                 *string  `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotSpec) Reset()         { *m = SnapshotSpec{} }
func (m *SnapshotSpec) String() string { return proto.CompactTextString(m) }
func (*SnapshotSpec) ProtoMessage()    {}
func (*SnapshotSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{12}
}

func (m *SnapshotSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotSpec.Unmarshal(m, b)
}
func (m *SnapshotSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotSpec.Marshal(b, m, deterministic)
}
func (m *SnapshotSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotSpec.Merge(m, src)
}
func (m *SnapshotSpec) XXX_Size() int {
	return xxx_messageInfo_SnapshotSpec.Size(m)
}
func (m *SnapshotSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotSpec proto.InternalMessageInfo

const Default_SnapshotSpec_VmLogicalTimestamp int64 = -1

func (m *SnapshotSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SnapshotSpec) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *SnapshotSpec) GetVmLogicalTimestamp() int64 {
	if m != nil && m.VmLogicalTimestamp != nil {
		return *m.VmLogicalTimestamp
	}
	return Default_SnapshotSpec_VmLogicalTimestamp
}

func (m *SnapshotSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type Task struct {
	// The task identifier.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The request that spawned the task.
	Request *MetaRequest `protobuf:"bytes,2,opt,name=request" json:"request,omitempty"`
	// The task completion information.
	Response *MetaResponse `protobuf:"bytes,3,opt,name=response" json:"response,omitempty"`
	// Creation time in microseconds from epoch.
	CreateTime *uint64 `protobuf:"fixed64,4,opt,name=create_time,json=createTime" json:"create_time,omitempty"`
	// Start time in microseconds from epoch.
	StartTime *uint64 `protobuf:"fixed64,5,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Completion time in microseconds from epoch. Unset for ongoing tasks.
	CompleteTime *uint64 `protobuf:"fixed64,6,opt,name=complete_time,json=completeTime" json:"complete_time,omitempty"`
	// Last time the task was updated from epoch.
	LastUpdatedTime *uint64             `protobuf:"fixed64,7,opt,name=last_updated_time,json=lastUpdatedTime" json:"last_updated_time,omitempty"`
	EntityList      []*Task_EntityId    `protobuf:"bytes,8,rep,name=entity_list,json=entityList" json:"entity_list,omitempty"`
	OperationType   *Task_OperationType `protobuf:"varint,9,opt,name=operation_type,json=operationType,enum=nutanix.acropolis.Task_OperationType" json:"operation_type,omitempty"`
	// Message describing the task. It should attempt to be more specific
	// about the kind of entities involved with the task. (For e.g. in the
	// enter_maintenance_mode_task, some message examples could be "Migrate
	// normal VM for maintenance mode", "Acpi shutdown agent VM for maintenance
	// mode")
	Message *string `protobuf:"bytes,10,opt,name=message" json:"message,omitempty"`
	// Percentage of task completed.
	PercentageComplete *int32       `protobuf:"varint,11,opt,name=percentage_complete,json=percentageComplete" json:"percentage_complete,omitempty"`
	ProgressStatus     *Task_Status `protobuf:"varint,12,opt,name=progress_status,json=progressStatus,enum=nutanix.acropolis.Task_Status" json:"progress_status,omitempty"`
	// The parent task UUID. This is for internal use only, and should not be
	// exposed at the presentation layer.
	ParentTaskUuid []byte `protobuf:"bytes,13,opt,name=parent_task_uuid,json=parentTaskUuid" json:"parent_task_uuid,omitempty"`
	// A list of subtask UUIDs, ordered by creation time.
	SubtaskUuidList [][]byte `protobuf:"bytes,14,rep,name=subtask_uuid_list,json=subtaskUuidList" json:"subtask_uuid_list,omitempty"`
	// If this flag is set, then this is an internal task and is not meant to be
	// displayed in UI.
	InternalTask *bool `protobuf:"varint,15,opt,name=internal_task,json=internalTask,def=0" json:"internal_task,omitempty"`
	// If the canceled flag is set, then user has indicated the task to be
	// canceled. It is up to task executor whether to move the task to
	// kAborted or let it continue running until its completion.
	Canceled *bool `protobuf:"varint,16,opt,name=canceled,def=0" json:"canceled,omitempty"`
	// The name of the task operation to be displayed on UI. This allows the
	// task to optionally specify the name of its operation. In case it isn't
	// specified, Prism parses the name from the operation type.
	// (For e.g., "kVmCreate becomes Create VM", "kSnapshotDelete becomes
	// Delete Snapshot")
	DisplayName *string `protobuf:"bytes,17,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// Only set when parent_task_uuid is set.  Sequence ID of this child
	// among all the children of the parent task.
	SubtaskSequenceId *uint64 `protobuf:"varint,18,opt,name=subtask_sequence_id,json=subtaskSequenceId" json:"subtask_sequence_id,omitempty"`
	// Whether UI should display failures from this task.
	DisplayFailures *bool `protobuf:"varint,19,opt,name=display_failures,json=displayFailures,def=1" json:"display_failures,omitempty"`
	// Set of capabilities of a task.
	Capabilities []Task_Capability `protobuf:"varint,20,rep,name=capabilities,enum=nutanix.acropolis.Task_Capability" json:"capabilities,omitempty"`
	// Context about the request that spawned the task such as the
	// user name, client ip, etc.
	RequestContext *net.RpcRequestContext `protobuf:"bytes,21,opt,name=request_context,json=requestContext" json:"request_context,omitempty"`
	// Whether to use barrier updates for this task's completion.
	UseSyncBarrier       *bool    `protobuf:"varint,22,opt,name=use_sync_barrier,json=useSyncBarrier,def=0" json:"use_sync_barrier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Task) Reset()         { *m = Task{} }
func (m *Task) String() string { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()    {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13}
}

func (m *Task) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Task.Unmarshal(m, b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Task.Marshal(b, m, deterministic)
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return xxx_messageInfo_Task.Size(m)
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

const Default_Task_InternalTask bool = false
const Default_Task_Canceled bool = false
const Default_Task_DisplayFailures bool = true
const Default_Task_UseSyncBarrier bool = false

func (m *Task) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Task) GetRequest() *MetaRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Task) GetResponse() *MetaResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Task) GetCreateTime() uint64 {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return 0
}

func (m *Task) GetStartTime() uint64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *Task) GetCompleteTime() uint64 {
	if m != nil && m.CompleteTime != nil {
		return *m.CompleteTime
	}
	return 0
}

func (m *Task) GetLastUpdatedTime() uint64 {
	if m != nil && m.LastUpdatedTime != nil {
		return *m.LastUpdatedTime
	}
	return 0
}

func (m *Task) GetEntityList() []*Task_EntityId {
	if m != nil {
		return m.EntityList
	}
	return nil
}

func (m *Task) GetOperationType() Task_OperationType {
	if m != nil && m.OperationType != nil {
		return *m.OperationType
	}
	return Task_kSnapshotCreate
}

func (m *Task) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *Task) GetPercentageComplete() int32 {
	if m != nil && m.PercentageComplete != nil {
		return *m.PercentageComplete
	}
	return 0
}

func (m *Task) GetProgressStatus() Task_Status {
	if m != nil && m.ProgressStatus != nil {
		return *m.ProgressStatus
	}
	return Task_kQueued
}

func (m *Task) GetParentTaskUuid() []byte {
	if m != nil {
		return m.ParentTaskUuid
	}
	return nil
}

func (m *Task) GetSubtaskUuidList() [][]byte {
	if m != nil {
		return m.SubtaskUuidList
	}
	return nil
}

func (m *Task) GetInternalTask() bool {
	if m != nil && m.InternalTask != nil {
		return *m.InternalTask
	}
	return Default_Task_InternalTask
}

func (m *Task) GetCanceled() bool {
	if m != nil && m.Canceled != nil {
		return *m.Canceled
	}
	return Default_Task_Canceled
}

func (m *Task) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *Task) GetSubtaskSequenceId() uint64 {
	if m != nil && m.SubtaskSequenceId != nil {
		return *m.SubtaskSequenceId
	}
	return 0
}

func (m *Task) GetDisplayFailures() bool {
	if m != nil && m.DisplayFailures != nil {
		return *m.DisplayFailures
	}
	return Default_Task_DisplayFailures
}

func (m *Task) GetCapabilities() []Task_Capability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *Task) GetRequestContext() *net.RpcRequestContext {
	if m != nil {
		return m.RequestContext
	}
	return nil
}

func (m *Task) GetUseSyncBarrier() bool {
	if m != nil && m.UseSyncBarrier != nil {
		return *m.UseSyncBarrier
	}
	return Default_Task_UseSyncBarrier
}

type Task_EntityId struct {
	// UUID of the entity.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Entity type.
	EntityType *Task_Entity `protobuf:"varint,2,opt,name=entity_type,json=entityType,enum=nutanix.acropolis.Task_Entity" json:"entity_type,omitempty"`
	// Entity name. This is not stored to the database, but resolved on demand.
	EntityName *string `protobuf:"bytes,3,opt,name=entity_name,json=entityName" json:"entity_name,omitempty"`
	// Logical timestamp of the entity.
	LogicalTimestamp     *int64   `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Task_EntityId) Reset()         { *m = Task_EntityId{} }
func (m *Task_EntityId) String() string { return proto.CompactTextString(m) }
func (*Task_EntityId) ProtoMessage()    {}
func (*Task_EntityId) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{13, 0}
}

func (m *Task_EntityId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Task_EntityId.Unmarshal(m, b)
}
func (m *Task_EntityId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Task_EntityId.Marshal(b, m, deterministic)
}
func (m *Task_EntityId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task_EntityId.Merge(m, src)
}
func (m *Task_EntityId) XXX_Size() int {
	return xxx_messageInfo_Task_EntityId.Size(m)
}
func (m *Task_EntityId) XXX_DiscardUnknown() {
	xxx_messageInfo_Task_EntityId.DiscardUnknown(m)
}

var xxx_messageInfo_Task_EntityId proto.InternalMessageInfo

func (m *Task_EntityId) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *Task_EntityId) GetEntityType() Task_Entity {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return Task_kNode
}

func (m *Task_EntityId) GetEntityName() string {
	if m != nil && m.EntityName != nil {
		return *m.EntityName
	}
	return ""
}

func (m *Task_EntityId) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

type EnterMaintenanceModeTypes struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnterMaintenanceModeTypes) Reset()         { *m = EnterMaintenanceModeTypes{} }
func (m *EnterMaintenanceModeTypes) String() string { return proto.CompactTextString(m) }
func (*EnterMaintenanceModeTypes) ProtoMessage()    {}
func (*EnterMaintenanceModeTypes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{14}
}

func (m *EnterMaintenanceModeTypes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnterMaintenanceModeTypes.Unmarshal(m, b)
}
func (m *EnterMaintenanceModeTypes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnterMaintenanceModeTypes.Marshal(b, m, deterministic)
}
func (m *EnterMaintenanceModeTypes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnterMaintenanceModeTypes.Merge(m, src)
}
func (m *EnterMaintenanceModeTypes) XXX_Size() int {
	return xxx_messageInfo_EnterMaintenanceModeTypes.Size(m)
}
func (m *EnterMaintenanceModeTypes) XXX_DiscardUnknown() {
	xxx_messageInfo_EnterMaintenanceModeTypes.DiscardUnknown(m)
}

var xxx_messageInfo_EnterMaintenanceModeTypes proto.InternalMessageInfo

type VmBootDeviceType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmBootDeviceType) Reset()         { *m = VmBootDeviceType{} }
func (m *VmBootDeviceType) String() string { return proto.CompactTextString(m) }
func (*VmBootDeviceType) ProtoMessage()    {}
func (*VmBootDeviceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{15}
}

func (m *VmBootDeviceType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootDeviceType.Unmarshal(m, b)
}
func (m *VmBootDeviceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootDeviceType.Marshal(b, m, deterministic)
}
func (m *VmBootDeviceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootDeviceType.Merge(m, src)
}
func (m *VmBootDeviceType) XXX_Size() int {
	return xxx_messageInfo_VmBootDeviceType.Size(m)
}
func (m *VmBootDeviceType) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootDeviceType.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootDeviceType proto.InternalMessageInfo

type VmBootConfig struct {
	// The device from which to boot. This must refer to a valid device
	// configured on the VM. When a boot device is removed from the VM, this
	// field is cleared as a side effect. If boot device and boot device order
	// is not configured, the VM will have the following boot preference:
	// hard disk, CD-ROM, NIC.
	// This field takes preference over boot_device_order.
	Device *VmBootConfig_VmBootDevice `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	// UEFI or legacy boot.
	UefiBoot *bool `protobuf:"varint,2,opt,name=uefi_boot,json=uefiBoot,def=0" json:"uefi_boot,omitempty"`
	// Boot device order.
	// This field provides the preferred order of devices to attempt
	// booting from. Any device of the given class will do as long as the classes
	// are tried in specified order. If this field is provided in addition to
	// device field, then VM will first attempt to boot from that device, and in
	// case booting from that device fails VM will attempt to boot from devices
	// in the specified order in this field.
	// Note: Boot device order works correctly only when there is at most one
	// device of each type.
	BootDeviceOrder []VmBootDeviceType_Type `protobuf:"varint,3,rep,name=boot_device_order,json=bootDeviceOrder,enum=nutanix.acropolis.VmBootDeviceType_Type" json:"boot_device_order,omitempty"`
	// The firmware config for UEFI or legacy boot. If UEFI boot, the NVRAM disk
	// config is populated here.
	FirmwareConfig *VmBootConfig_VmFirmwareConfig `protobuf:"bytes,4,opt,name=firmware_config,json=firmwareConfig" json:"firmware_config,omitempty"`
	// User VM secure boot.
	SecureBoot *bool `protobuf:"varint,5,opt,name=secure_boot,json=secureBoot,def=0" json:"secure_boot,omitempty"`
	// Expose hardware virtualization support to guest.
	HardwareVirtualization *bool `protobuf:"varint,6,opt,name=hardware_virtualization,json=hardwareVirtualization,def=0" json:"hardware_virtualization,omitempty"`
	// Windows vm credential guard.
	WindowsCredentialGuard *bool    `protobuf:"varint,7,opt,name=windows_credential_guard,json=windowsCredentialGuard,def=0" json:"windows_credential_guard,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *VmBootConfig) Reset()         { *m = VmBootConfig{} }
func (m *VmBootConfig) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig) ProtoMessage()    {}
func (*VmBootConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{16}
}

func (m *VmBootConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig.Unmarshal(m, b)
}
func (m *VmBootConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig.Marshal(b, m, deterministic)
}
func (m *VmBootConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig.Merge(m, src)
}
func (m *VmBootConfig) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig.Size(m)
}
func (m *VmBootConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig proto.InternalMessageInfo

const Default_VmBootConfig_UefiBoot bool = false
const Default_VmBootConfig_SecureBoot bool = false
const Default_VmBootConfig_HardwareVirtualization bool = false
const Default_VmBootConfig_WindowsCredentialGuard bool = false

func (m *VmBootConfig) GetDevice() *VmBootConfig_VmBootDevice {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *VmBootConfig) GetUefiBoot() bool {
	if m != nil && m.UefiBoot != nil {
		return *m.UefiBoot
	}
	return Default_VmBootConfig_UefiBoot
}

func (m *VmBootConfig) GetBootDeviceOrder() []VmBootDeviceType_Type {
	if m != nil {
		return m.BootDeviceOrder
	}
	return nil
}

func (m *VmBootConfig) GetFirmwareConfig() *VmBootConfig_VmFirmwareConfig {
	if m != nil {
		return m.FirmwareConfig
	}
	return nil
}

func (m *VmBootConfig) GetSecureBoot() bool {
	if m != nil && m.SecureBoot != nil {
		return *m.SecureBoot
	}
	return Default_VmBootConfig_SecureBoot
}

func (m *VmBootConfig) GetHardwareVirtualization() bool {
	if m != nil && m.HardwareVirtualization != nil {
		return *m.HardwareVirtualization
	}
	return Default_VmBootConfig_HardwareVirtualization
}

func (m *VmBootConfig) GetWindowsCredentialGuard() bool {
	if m != nil && m.WindowsCredentialGuard != nil {
		return *m.WindowsCredentialGuard
	}
	return Default_VmBootConfig_WindowsCredentialGuard
}

type VmBootConfig_VmBootDevice struct {
	// Exactly one of the following must be set.
	DiskAddr             *VmDiskAddr `protobuf:"bytes,1,opt,name=disk_addr,json=diskAddr" json:"disk_addr,omitempty"`
	MacAddr              []byte      `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VmBootConfig_VmBootDevice) Reset()         { *m = VmBootConfig_VmBootDevice{} }
func (m *VmBootConfig_VmBootDevice) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig_VmBootDevice) ProtoMessage()    {}
func (*VmBootConfig_VmBootDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{16, 0}
}

func (m *VmBootConfig_VmBootDevice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig_VmBootDevice.Unmarshal(m, b)
}
func (m *VmBootConfig_VmBootDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig_VmBootDevice.Marshal(b, m, deterministic)
}
func (m *VmBootConfig_VmBootDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig_VmBootDevice.Merge(m, src)
}
func (m *VmBootConfig_VmBootDevice) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig_VmBootDevice.Size(m)
}
func (m *VmBootConfig_VmBootDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig_VmBootDevice.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig_VmBootDevice proto.InternalMessageInfo

func (m *VmBootConfig_VmBootDevice) GetDiskAddr() *VmDiskAddr {
	if m != nil {
		return m.DiskAddr
	}
	return nil
}

func (m *VmBootConfig_VmBootDevice) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

type VmBootConfig_VmFirmwareConfig struct {
	// Disk spec for NVRAM disk.
	// optional VmDiskConfig nvram_disk = 1; [deprecated]
	// The uuid of the NVRAM disk backed by stargate, to support EFI guests.
	NvramDiskUuid []byte `protobuf:"bytes,2,opt,name=nvram_disk_uuid,json=nvramDiskUuid" json:"nvram_disk_uuid,omitempty"`
	// The uuid of the container of NVRAM disk backed by stargate,
	// to support EFI guests.
	// optional bytes nvram_container_uuid = 3; [deprecated]
	// Disk create Spec for NVRAM disk.
	NvramDiskSpec        *VmDiskSpec `protobuf:"bytes,4,opt,name=nvram_disk_spec,json=nvramDiskSpec" json:"nvram_disk_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VmBootConfig_VmFirmwareConfig) Reset()         { *m = VmBootConfig_VmFirmwareConfig{} }
func (m *VmBootConfig_VmFirmwareConfig) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig_VmFirmwareConfig) ProtoMessage()    {}
func (*VmBootConfig_VmFirmwareConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{16, 1}
}

func (m *VmBootConfig_VmFirmwareConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Unmarshal(m, b)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Marshal(b, m, deterministic)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Merge(m, src)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Size(m)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig_VmFirmwareConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig_VmFirmwareConfig proto.InternalMessageInfo

func (m *VmBootConfig_VmFirmwareConfig) GetNvramDiskUuid() []byte {
	if m != nil {
		return m.NvramDiskUuid
	}
	return nil
}

func (m *VmBootConfig_VmFirmwareConfig) GetNvramDiskSpec() *VmDiskSpec {
	if m != nil {
		return m.NvramDiskSpec
	}
	return nil
}

type VmBootConfigSpec struct {
	// The device from which to boot. This must refer to a valid device
	// configured on the VM. When a boot device is removed from the VM, this
	// field is cleared as a side effect. If no boot device is configured, the VM
	// will have the following boot preference: hard disk, CD-ROM, NIC.
	Device *VmBootConfigSpec_VmBootDeviceSpec `protobuf:"bytes,1,opt,name=device" json:"device,omitempty"`
	// UEFI or legacy boot.
	UefiBoot *bool `protobuf:"varint,2,opt,name=uefi_boot,json=uefiBoot,def=0" json:"uefi_boot,omitempty"`
	// Boot device order.
	BootDeviceOrder []VmBootDeviceType_Type `protobuf:"varint,3,rep,name=boot_device_order,json=bootDeviceOrder,enum=nutanix.acropolis.VmBootDeviceType_Type" json:"boot_device_order,omitempty"`
	// The firmware config for UEFI or legacy boot. If UEFI boot, the NVRAM disk
	// spec (create/clone) is given within this firmware config.
	FirmwareConfig *VmBootConfigSpec_VmFirmwareConfigSpec `protobuf:"bytes,4,opt,name=firmware_config,json=firmwareConfig" json:"firmware_config,omitempty"`
	// User VM secure boot.
	SecureBoot *bool `protobuf:"varint,5,opt,name=secure_boot,json=secureBoot,def=0" json:"secure_boot,omitempty"`
	// Expose hardware virtualization support to guest.
	HardwareVirtualization *bool `protobuf:"varint,6,opt,name=hardware_virtualization,json=hardwareVirtualization,def=0" json:"hardware_virtualization,omitempty"`
	// Windows vm credential guard.
	WindowsCredentialGuard *bool    `protobuf:"varint,7,opt,name=windows_credential_guard,json=windowsCredentialGuard,def=0" json:"windows_credential_guard,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *VmBootConfigSpec) Reset()         { *m = VmBootConfigSpec{} }
func (m *VmBootConfigSpec) String() string { return proto.CompactTextString(m) }
func (*VmBootConfigSpec) ProtoMessage()    {}
func (*VmBootConfigSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{17}
}

func (m *VmBootConfigSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfigSpec.Unmarshal(m, b)
}
func (m *VmBootConfigSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfigSpec.Marshal(b, m, deterministic)
}
func (m *VmBootConfigSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfigSpec.Merge(m, src)
}
func (m *VmBootConfigSpec) XXX_Size() int {
	return xxx_messageInfo_VmBootConfigSpec.Size(m)
}
func (m *VmBootConfigSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfigSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfigSpec proto.InternalMessageInfo

const Default_VmBootConfigSpec_UefiBoot bool = false
const Default_VmBootConfigSpec_SecureBoot bool = false
const Default_VmBootConfigSpec_HardwareVirtualization bool = false
const Default_VmBootConfigSpec_WindowsCredentialGuard bool = false

func (m *VmBootConfigSpec) GetDevice() *VmBootConfigSpec_VmBootDeviceSpec {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *VmBootConfigSpec) GetUefiBoot() bool {
	if m != nil && m.UefiBoot != nil {
		return *m.UefiBoot
	}
	return Default_VmBootConfigSpec_UefiBoot
}

func (m *VmBootConfigSpec) GetBootDeviceOrder() []VmBootDeviceType_Type {
	if m != nil {
		return m.BootDeviceOrder
	}
	return nil
}

func (m *VmBootConfigSpec) GetFirmwareConfig() *VmBootConfigSpec_VmFirmwareConfigSpec {
	if m != nil {
		return m.FirmwareConfig
	}
	return nil
}

func (m *VmBootConfigSpec) GetSecureBoot() bool {
	if m != nil && m.SecureBoot != nil {
		return *m.SecureBoot
	}
	return Default_VmBootConfigSpec_SecureBoot
}

func (m *VmBootConfigSpec) GetHardwareVirtualization() bool {
	if m != nil && m.HardwareVirtualization != nil {
		return *m.HardwareVirtualization
	}
	return Default_VmBootConfigSpec_HardwareVirtualization
}

func (m *VmBootConfigSpec) GetWindowsCredentialGuard() bool {
	if m != nil && m.WindowsCredentialGuard != nil {
		return *m.WindowsCredentialGuard
	}
	return Default_VmBootConfigSpec_WindowsCredentialGuard
}

type VmBootConfigSpec_VmBootDeviceSpec struct {
	// Exactly one of the following must be set.
	DiskAddr *VmDiskAddr `protobuf:"bytes,1,opt,name=disk_addr,json=diskAddr" json:"disk_addr,omitempty"`
	MacAddr  []byte      `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// The index of the boot nic in the spec's nic list
	NicIndex             *uint64  `protobuf:"varint,3,opt,name=nic_index,json=nicIndex" json:"nic_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmBootConfigSpec_VmBootDeviceSpec) Reset()         { *m = VmBootConfigSpec_VmBootDeviceSpec{} }
func (m *VmBootConfigSpec_VmBootDeviceSpec) String() string { return proto.CompactTextString(m) }
func (*VmBootConfigSpec_VmBootDeviceSpec) ProtoMessage()    {}
func (*VmBootConfigSpec_VmBootDeviceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{17, 0}
}

func (m *VmBootConfigSpec_VmBootDeviceSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfigSpec_VmBootDeviceSpec.Unmarshal(m, b)
}
func (m *VmBootConfigSpec_VmBootDeviceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfigSpec_VmBootDeviceSpec.Marshal(b, m, deterministic)
}
func (m *VmBootConfigSpec_VmBootDeviceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfigSpec_VmBootDeviceSpec.Merge(m, src)
}
func (m *VmBootConfigSpec_VmBootDeviceSpec) XXX_Size() int {
	return xxx_messageInfo_VmBootConfigSpec_VmBootDeviceSpec.Size(m)
}
func (m *VmBootConfigSpec_VmBootDeviceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfigSpec_VmBootDeviceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfigSpec_VmBootDeviceSpec proto.InternalMessageInfo

func (m *VmBootConfigSpec_VmBootDeviceSpec) GetDiskAddr() *VmDiskAddr {
	if m != nil {
		return m.DiskAddr
	}
	return nil
}

func (m *VmBootConfigSpec_VmBootDeviceSpec) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *VmBootConfigSpec_VmBootDeviceSpec) GetNicIndex() uint64 {
	if m != nil && m.NicIndex != nil {
		return *m.NicIndex
	}
	return 0
}

type VmBootConfigSpec_VmFirmwareConfigSpec struct {
	// Disk spec for NVRAM disk.
	NvramDiskSpec *VmDiskSpec `protobuf:"bytes,1,opt,name=nvram_disk_spec,json=nvramDiskSpec" json:"nvram_disk_spec,omitempty"`
	// The uuid of the NVRAM disk backed by stargate, to support EFI guests.
	NvramDiskUuid        []byte   `protobuf:"bytes,2,opt,name=nvram_disk_uuid,json=nvramDiskUuid" json:"nvram_disk_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmBootConfigSpec_VmFirmwareConfigSpec) Reset()         { *m = VmBootConfigSpec_VmFirmwareConfigSpec{} }
func (m *VmBootConfigSpec_VmFirmwareConfigSpec) String() string { return proto.CompactTextString(m) }
func (*VmBootConfigSpec_VmFirmwareConfigSpec) ProtoMessage()    {}
func (*VmBootConfigSpec_VmFirmwareConfigSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{17, 1}
}

func (m *VmBootConfigSpec_VmFirmwareConfigSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfigSpec_VmFirmwareConfigSpec.Unmarshal(m, b)
}
func (m *VmBootConfigSpec_VmFirmwareConfigSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfigSpec_VmFirmwareConfigSpec.Marshal(b, m, deterministic)
}
func (m *VmBootConfigSpec_VmFirmwareConfigSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfigSpec_VmFirmwareConfigSpec.Merge(m, src)
}
func (m *VmBootConfigSpec_VmFirmwareConfigSpec) XXX_Size() int {
	return xxx_messageInfo_VmBootConfigSpec_VmFirmwareConfigSpec.Size(m)
}
func (m *VmBootConfigSpec_VmFirmwareConfigSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfigSpec_VmFirmwareConfigSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfigSpec_VmFirmwareConfigSpec proto.InternalMessageInfo

func (m *VmBootConfigSpec_VmFirmwareConfigSpec) GetNvramDiskSpec() *VmDiskSpec {
	if m != nil {
		return m.NvramDiskSpec
	}
	return nil
}

func (m *VmBootConfigSpec_VmFirmwareConfigSpec) GetNvramDiskUuid() []byte {
	if m != nil {
		return m.NvramDiskUuid
	}
	return nil
}

type VmCloneSpec struct {
	// A version 4 UUID that the client may specify for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The optional clone name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Optional field to override the number of vCPUs (sockets) assigned to the
	// clone.
	NumVcpus *uint64 `protobuf:"varint,3,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// Optional field to override the amount of RAM assigned to the clone.
	MemoryMb *uint64 `protobuf:"varint,4,opt,name=memory_mb,json=memoryMb" json:"memory_mb,omitempty"`
	// Whether to override the source VM's/snapshot's network configuration with
	// the one specified in the nic_list field. If false, the clone will inherit
	// its basic network configuration from the source, minus MAC and IP address
	// assignments.
	OverrideNetworkConfig *bool `protobuf:"varint,5,opt,name=override_network_config,json=overrideNetworkConfig" json:"override_network_config,omitempty"`
	// Explicit network configuration, when override_network_config is true.
	NicList []*VmNicSpec `protobuf:"bytes,6,rep,name=nic_list,json=nicList" json:"nic_list,omitempty"`
	// Optional field to override the boot configuration for the clone.
	Boot *VmBootConfigSpec `protobuf:"bytes,7,opt,name=boot" json:"boot,omitempty"`
	// Optional field to override the number of cores per vCPU.
	NumCoresPerVcpu *int64 `protobuf:"varint,8,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// Whether to clone source VM's affinity rules.
	CloneAffinity *bool `protobuf:"varint,9,opt,name=clone_affinity,json=cloneAffinity,def=0" json:"clone_affinity,omitempty"`
	// Optional field to override the number of logical threads per core.
	NumThreadsPerCore *int64 `protobuf:"varint,10,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	// Indicates whether the vcpus are hard pinned to specific pcpus.
	VcpuHardPin *bool `protobuf:"varint,11,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// Additional disks adding to the cloned VM. One use case is to append a
	// CD-ROM for guest customization. Note that the cloned VM preserves all
	// existing disks from the source VM.
	DiskList             []*VmDiskSpec `protobuf:"bytes,12,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VmCloneSpec) Reset()         { *m = VmCloneSpec{} }
func (m *VmCloneSpec) String() string { return proto.CompactTextString(m) }
func (*VmCloneSpec) ProtoMessage()    {}
func (*VmCloneSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{18}
}

func (m *VmCloneSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCloneSpec.Unmarshal(m, b)
}
func (m *VmCloneSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCloneSpec.Marshal(b, m, deterministic)
}
func (m *VmCloneSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCloneSpec.Merge(m, src)
}
func (m *VmCloneSpec) XXX_Size() int {
	return xxx_messageInfo_VmCloneSpec.Size(m)
}
func (m *VmCloneSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCloneSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmCloneSpec proto.InternalMessageInfo

const Default_VmCloneSpec_CloneAffinity bool = false

func (m *VmCloneSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmCloneSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmCloneSpec) GetNumVcpus() uint64 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmCloneSpec) GetMemoryMb() uint64 {
	if m != nil && m.MemoryMb != nil {
		return *m.MemoryMb
	}
	return 0
}

func (m *VmCloneSpec) GetOverrideNetworkConfig() bool {
	if m != nil && m.OverrideNetworkConfig != nil {
		return *m.OverrideNetworkConfig
	}
	return false
}

func (m *VmCloneSpec) GetNicList() []*VmNicSpec {
	if m != nil {
		return m.NicList
	}
	return nil
}

func (m *VmCloneSpec) GetBoot() *VmBootConfigSpec {
	if m != nil {
		return m.Boot
	}
	return nil
}

func (m *VmCloneSpec) GetNumCoresPerVcpu() int64 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *VmCloneSpec) GetCloneAffinity() bool {
	if m != nil && m.CloneAffinity != nil {
		return *m.CloneAffinity
	}
	return Default_VmCloneSpec_CloneAffinity
}

func (m *VmCloneSpec) GetNumThreadsPerCore() int64 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

func (m *VmCloneSpec) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *VmCloneSpec) GetDiskList() []*VmDiskSpec {
	if m != nil {
		return m.DiskList
	}
	return nil
}

type VmConfig struct {
	// The VM's human-readable name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An arbitrary string describing the VM.
	Annotation *string `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
	// Number of vCPUs (sockets).
	NumVcpus *uint64 `protobuf:"varint,3,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// The amount of RAM, in megabytes.
	MemoryMb *uint64 `protobuf:"varint,4,opt,name=memory_mb,json=memoryMb" json:"memory_mb,omitempty"`
	// Virtual disks.
	DiskList []*VmDiskConfig `protobuf:"bytes,5,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// Virtual NICs.
	NicList []*VmNicConfig `protobuf:"bytes,6,rep,name=nic_list,json=nicList" json:"nic_list,omitempty"`
	// The boot configuration.
	Boot *VmBootConfig `protobuf:"bytes,7,opt,name=boot" json:"boot,omitempty"`
	// The timezone for the VM's hardware clock.
	HwclockTimezone *string `protobuf:"bytes,8,opt,name=hwclock_timezone,json=hwclockTimezone,def=UTC" json:"hwclock_timezone,omitempty"`
	// Priority for restarting in case of HA event.
	HaPriority *int64 `protobuf:"varint,9,opt,name=ha_priority,json=haPriority,def=0" json:"ha_priority,omitempty"`
	// Number of cores per vCPU.
	NumCoresPerVcpu *int64 `protobuf:"varint,10,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu,def=1" json:"num_cores_per_vcpu,omitempty"`
	// If set to a non-empty string, this VM should be considered incompatible
	// with DR workflows.
	//
	// This field is deprecated. It should be exposed in the REST API, but as a
	// hidden parameter. In the future, it will be removed in favor of using tags
	// for identifying service VMs.
	CbrNotCapableReason *string `protobuf:"bytes,11,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Virtual serial ports.
	SerialPortList []*VmSerialPortConfig `protobuf:"bytes,12,rep,name=serial_port_list,json=serialPortList" json:"serial_port_list,omitempty"`
	// Whether or not to have a VGA console.
	VgaConsole *bool `protobuf:"varint,13,opt,name=vga_console,json=vgaConsole,def=1" json:"vga_console,omitempty"`
	// VM to Host affinity setting.
	Affinity *Affinity `protobuf:"bytes,14,opt,name=affinity" json:"affinity,omitempty"`
	// Whether to pass through the host's CPU features to the guest.
	// Setting this option disables live migration.
	// This option can also be used to nested hypervisor.
	CpuPassthrough *bool `protobuf:"varint,15,opt,name=cpu_passthrough,json=cpuPassthrough" json:"cpu_passthrough,omitempty"`
	// Additional VM specific flags.
	ExtraFlags []*GenericKeyValuePair `protobuf:"bytes,17,rep,name=extra_flags,json=extraFlags" json:"extra_flags,omitempty"`
	// UUID of VmGroup that VM belongs to.
	VmGroupUuid []byte `protobuf:"bytes,18,opt,name=vm_group_uuid,json=vmGroupUuid" json:"vm_group_uuid,omitempty"`
	// Whether this is an agent VM.
	AgentVm *bool `protobuf:"varint,19,opt,name=agent_vm,json=agentVm,def=0" json:"agent_vm,omitempty"`
	// Whether the VM can be live-migrated. Use AcropolisVm.allow_live_migrate
	// instead where possible.
	// TODO: This doesn't need a default value. Remove it once Gerrit allows.
	AllowLiveMigrate *bool `protobuf:"varint,20,opt,name=allow_live_migrate,json=allowLiveMigrate,def=1" json:"allow_live_migrate,omitempty"`
	// GPU resources.
	GpuConfigList []*VmGPUConfig `protobuf:"bytes,21,rep,name=gpu_config_list,json=gpuConfigList" json:"gpu_config_list,omitempty"`
	// The number of vNUMA nodes.
	NumVnumaNodes *uint64 `protobuf:"varint,22,opt,name=num_vnuma_nodes,json=numVnumaNodes" json:"num_vnuma_nodes,omitempty"`
	// The machine type of this VM.
	MachineType *string `protobuf:"bytes,23,opt,name=machine_type,json=machineType,def=pc" json:"machine_type,omitempty"`
	// Whether to disable Nutanix branding. This overrides the
	// acropolis_kvm_enable_branding GFlag.
	DisableBranding *bool   `protobuf:"varint,24,opt,name=disable_branding,json=disableBranding" json:"disable_branding,omitempty"`
	VmType          *VmType `protobuf:"varint,25,opt,name=vm_type,json=vmType,enum=nutanix.acropolis.VmType,def=1" json:"vm_type,omitempty"`
	// Whether to enable host metrics for this VM.
	EnableMetrics *bool `protobuf:"varint,26,opt,name=enable_metrics,json=enableMetrics" json:"enable_metrics,omitempty"`
	// Indicates how the power state changes.
	PowerStateMechanism *PowerStateMechanism `protobuf:"varint,27,opt,name=power_state_mechanism,json=powerStateMechanism,enum=nutanix.acropolis.PowerStateMechanism" json:"power_state_mechanism,omitempty"`
	// Indicates whether to execute set script before NGT shutdown or reboot.
	NgtEnableScriptExec *bool `protobuf:"varint,28,opt,name=ngt_enable_script_exec,json=ngtEnableScriptExec" json:"ngt_enable_script_exec,omitempty"`
	// Indicates whether to abort NGT shutdown/reboot if script fails.
	NgtFailOnScriptFailure *bool `protobuf:"varint,29,opt,name=ngt_fail_on_script_failure,json=ngtFailOnScriptFailure" json:"ngt_fail_on_script_failure,omitempty"`
	// Source VM uuid of which this VM is clone of.
	SourceVmUuid []byte `protobuf:"bytes,30,opt,name=source_vm_uuid,json=sourceVmUuid" json:"source_vm_uuid,omitempty"`
	// Replication configuration.
	SyncRepConfigList []*VmSyncRepConfig `protobuf:"bytes,31,rep,name=sync_rep_config_list,json=syncRepConfigList" json:"sync_rep_config_list,omitempty"`
	// Number of logical threads per core.
	NumThreadsPerCore *int64 `protobuf:"varint,32,opt,name=num_threads_per_core,json=numThreadsPerCore,def=1" json:"num_threads_per_core,omitempty"`
	// Indicates whether the vcpus are hard pinned to specific pcpus.
	VcpuHardPin *bool `protobuf:"varint,33,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// If non-empty, fail all VM tasks except for those tasks whose RPC names are
	// found in this list. If this list is empty, allow all tasks. One use case is
	// to disallow VM changes during cross cluster live migration.
	DisableUpdateWhiteList []string `protobuf:"bytes,35,rep,name=disable_update_white_list,json=disableUpdateWhiteList" json:"disable_update_white_list,omitempty"`
	// If True, the memory that belongs to the VM may reside outside of physical
	// memory. Otherwise, Acropolis will ensure that amount of memory the VM is
	// configured with resides completely in physical memory.
	MemoryOvercommit *bool `protobuf:"varint,36,opt,name=memory_overcommit,json=memoryOvercommit" json:"memory_overcommit,omitempty"`
	// Determines the initial memory allocation for this overcommitted VM.
	PowerOnMemoryMb *uint64 `protobuf:"varint,37,opt,name=power_on_memory_mb,json=powerOnMemoryMb" json:"power_on_memory_mb,omitempty"`
	// Determines the squeeze limit and also the minimum protection guarantee for
	// this overcommitted VM.
	MinimumMemoryMb *uint64 `protobuf:"varint,38,opt,name=minimum_memory_mb,json=minimumMemoryMb" json:"minimum_memory_mb,omitempty"`
	// If False, it will prevent users from hot plugging and unplugging of
	// PCI based devices from within VMs and from the hypervisor stack. Although
	// this applies equally for all VMs, it is primarily applicable for Windows
	// based VMs. By default, we allow hot-plugging and unplugging of devices.
	AllowHotPlug *bool `protobuf:"varint,39,opt,name=allow_hot_plug,json=allowHotPlug,def=1" json:"allow_hot_plug,omitempty"`
	// Whether flash mode is enabled for the VM.
	FlashMode            *bool    `protobuf:"varint,40,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmConfig) Reset()         { *m = VmConfig{} }
func (m *VmConfig) String() string { return proto.CompactTextString(m) }
func (*VmConfig) ProtoMessage()    {}
func (*VmConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{19}
}

func (m *VmConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmConfig.Unmarshal(m, b)
}
func (m *VmConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmConfig.Marshal(b, m, deterministic)
}
func (m *VmConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmConfig.Merge(m, src)
}
func (m *VmConfig) XXX_Size() int {
	return xxx_messageInfo_VmConfig.Size(m)
}
func (m *VmConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmConfig proto.InternalMessageInfo

const Default_VmConfig_HwclockTimezone string = "UTC"
const Default_VmConfig_HaPriority int64 = 0
const Default_VmConfig_NumCoresPerVcpu int64 = 1
const Default_VmConfig_VgaConsole bool = true
const Default_VmConfig_AgentVm bool = false
const Default_VmConfig_AllowLiveMigrate bool = true
const Default_VmConfig_MachineType string = "pc"
const Default_VmConfig_VmType VmType = VmType_kGuestVM
const Default_VmConfig_NumThreadsPerCore int64 = 1
const Default_VmConfig_AllowHotPlug bool = true

func (m *VmConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VmConfig) GetNumVcpus() uint64 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmConfig) GetMemoryMb() uint64 {
	if m != nil && m.MemoryMb != nil {
		return *m.MemoryMb
	}
	return 0
}

func (m *VmConfig) GetDiskList() []*VmDiskConfig {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *VmConfig) GetNicList() []*VmNicConfig {
	if m != nil {
		return m.NicList
	}
	return nil
}

func (m *VmConfig) GetBoot() *VmBootConfig {
	if m != nil {
		return m.Boot
	}
	return nil
}

func (m *VmConfig) GetHwclockTimezone() string {
	if m != nil && m.HwclockTimezone != nil {
		return *m.HwclockTimezone
	}
	return Default_VmConfig_HwclockTimezone
}

func (m *VmConfig) GetHaPriority() int64 {
	if m != nil && m.HaPriority != nil {
		return *m.HaPriority
	}
	return Default_VmConfig_HaPriority
}

func (m *VmConfig) GetNumCoresPerVcpu() int64 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return Default_VmConfig_NumCoresPerVcpu
}

func (m *VmConfig) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VmConfig) GetSerialPortList() []*VmSerialPortConfig {
	if m != nil {
		return m.SerialPortList
	}
	return nil
}

func (m *VmConfig) GetVgaConsole() bool {
	if m != nil && m.VgaConsole != nil {
		return *m.VgaConsole
	}
	return Default_VmConfig_VgaConsole
}

func (m *VmConfig) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *VmConfig) GetCpuPassthrough() bool {
	if m != nil && m.CpuPassthrough != nil {
		return *m.CpuPassthrough
	}
	return false
}

func (m *VmConfig) GetExtraFlags() []*GenericKeyValuePair {
	if m != nil {
		return m.ExtraFlags
	}
	return nil
}

func (m *VmConfig) GetVmGroupUuid() []byte {
	if m != nil {
		return m.VmGroupUuid
	}
	return nil
}

func (m *VmConfig) GetAgentVm() bool {
	if m != nil && m.AgentVm != nil {
		return *m.AgentVm
	}
	return Default_VmConfig_AgentVm
}

func (m *VmConfig) GetAllowLiveMigrate() bool {
	if m != nil && m.AllowLiveMigrate != nil {
		return *m.AllowLiveMigrate
	}
	return Default_VmConfig_AllowLiveMigrate
}

func (m *VmConfig) GetGpuConfigList() []*VmGPUConfig {
	if m != nil {
		return m.GpuConfigList
	}
	return nil
}

func (m *VmConfig) GetNumVnumaNodes() uint64 {
	if m != nil && m.NumVnumaNodes != nil {
		return *m.NumVnumaNodes
	}
	return 0
}

func (m *VmConfig) GetMachineType() string {
	if m != nil && m.MachineType != nil {
		return *m.MachineType
	}
	return Default_VmConfig_MachineType
}

func (m *VmConfig) GetDisableBranding() bool {
	if m != nil && m.DisableBranding != nil {
		return *m.DisableBranding
	}
	return false
}

func (m *VmConfig) GetVmType() VmType {
	if m != nil && m.VmType != nil {
		return *m.VmType
	}
	return Default_VmConfig_VmType
}

func (m *VmConfig) GetEnableMetrics() bool {
	if m != nil && m.EnableMetrics != nil {
		return *m.EnableMetrics
	}
	return false
}

func (m *VmConfig) GetPowerStateMechanism() PowerStateMechanism {
	if m != nil && m.PowerStateMechanism != nil {
		return *m.PowerStateMechanism
	}
	return PowerStateMechanism_kHard
}

func (m *VmConfig) GetNgtEnableScriptExec() bool {
	if m != nil && m.NgtEnableScriptExec != nil {
		return *m.NgtEnableScriptExec
	}
	return false
}

func (m *VmConfig) GetNgtFailOnScriptFailure() bool {
	if m != nil && m.NgtFailOnScriptFailure != nil {
		return *m.NgtFailOnScriptFailure
	}
	return false
}

func (m *VmConfig) GetSourceVmUuid() []byte {
	if m != nil {
		return m.SourceVmUuid
	}
	return nil
}

func (m *VmConfig) GetSyncRepConfigList() []*VmSyncRepConfig {
	if m != nil {
		return m.SyncRepConfigList
	}
	return nil
}

func (m *VmConfig) GetNumThreadsPerCore() int64 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return Default_VmConfig_NumThreadsPerCore
}

func (m *VmConfig) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *VmConfig) GetDisableUpdateWhiteList() []string {
	if m != nil {
		return m.DisableUpdateWhiteList
	}
	return nil
}

func (m *VmConfig) GetMemoryOvercommit() bool {
	if m != nil && m.MemoryOvercommit != nil {
		return *m.MemoryOvercommit
	}
	return false
}

func (m *VmConfig) GetPowerOnMemoryMb() uint64 {
	if m != nil && m.PowerOnMemoryMb != nil {
		return *m.PowerOnMemoryMb
	}
	return 0
}

func (m *VmConfig) GetMinimumMemoryMb() uint64 {
	if m != nil && m.MinimumMemoryMb != nil {
		return *m.MinimumMemoryMb
	}
	return 0
}

func (m *VmConfig) GetAllowHotPlug() bool {
	if m != nil && m.AllowHotPlug != nil {
		return *m.AllowHotPlug
	}
	return Default_VmConfig_AllowHotPlug
}

func (m *VmConfig) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

type VmCreateSpec struct {
	// The VM's human-readable name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An arbitrary string describing the VM.
	Annotation *string `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
	// Number of vCPUs (sockets).
	NumVcpus *uint64 `protobuf:"varint,3,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// The amount of RAM, in megabytes.
	MemoryMb *uint64 `protobuf:"varint,4,opt,name=memory_mb,json=memoryMb" json:"memory_mb,omitempty"`
	// Virtual disks.
	DiskList []*VmDiskSpec `protobuf:"bytes,5,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// Virtual NICs.
	NicList []*VmNicSpec `protobuf:"bytes,6,rep,name=nic_list,json=nicList" json:"nic_list,omitempty"`
	// A version 4 UUID that the client may specify for idempotence.
	Uuid []byte `protobuf:"bytes,7,opt,name=uuid" json:"uuid,omitempty"`
	// The boot configuration.
	Boot *VmBootConfigSpec `protobuf:"bytes,8,opt,name=boot" json:"boot,omitempty"`
	// The timezone for the VM's hardware clock.
	HwclockTimezone *string `protobuf:"bytes,9,opt,name=hwclock_timezone,json=hwclockTimezone,def=UTC" json:"hwclock_timezone,omitempty"`
	// Priority for restarting in case of HA event.
	HaPriority *int64 `protobuf:"varint,10,opt,name=ha_priority,json=haPriority" json:"ha_priority,omitempty"`
	// Number of cores per vCPU.
	NumCoresPerVcpu *int64 `protobuf:"varint,11,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// If set to a non-empty string, this VM should be considered incompatible
	// with DR workflows.
	//
	// This field is deprecated. It should be exposed in the REST API, but as a
	// hidden parameter. In the future, it will be removed in favor of using tags
	// for identifying service VMs.
	CbrNotCapableReason *string `protobuf:"bytes,12,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Virtual serial ports.
	SerialPortList []*VmSerialPortConfig `protobuf:"bytes,13,rep,name=serial_port_list,json=serialPortList" json:"serial_port_list,omitempty"`
	// Whether or not to have a VGA console. If unspecified, default will be
	// chosen based on the machine type of the VM.
	VgaConsole *bool `protobuf:"varint,14,opt,name=vga_console,json=vgaConsole" json:"vga_console,omitempty"`
	// VM to Host affinity setting.
	Affinity *Affinity `protobuf:"bytes,15,opt,name=affinity" json:"affinity,omitempty"`
	// Whether to pass through the host's CPU features.
	CpuPassthrough *bool `protobuf:"varint,16,opt,name=cpu_passthrough,json=cpuPassthrough" json:"cpu_passthrough,omitempty"`
	// UUID of VmGroup that VM belongs to.
	VmGroupUuid []byte `protobuf:"bytes,17,opt,name=vm_group_uuid,json=vmGroupUuid" json:"vm_group_uuid,omitempty"`
	// Whether this is an agent VM.
	AgentVm *bool `protobuf:"varint,19,opt,name=agent_vm,json=agentVm,def=0" json:"agent_vm,omitempty"`
	// GPU resources.
	GpuConfigList []*VmGPUConfig `protobuf:"bytes,20,rep,name=gpu_config_list,json=gpuConfigList" json:"gpu_config_list,omitempty"`
	// The number of vNUMA nodes.
	NumVnumaNodes *uint64 `protobuf:"varint,21,opt,name=num_vnuma_nodes,json=numVnumaNodes" json:"num_vnuma_nodes,omitempty"`
	// Additional comma-separated VM specific flags.
	ExtraFlags []*GenericKeyValuePair `protobuf:"bytes,22,rep,name=extra_flags,json=extraFlags" json:"extra_flags,omitempty"`
	// Machine type of this VM. If unspecified, the default machine type of
	// the current cluster will be used.
	MachineType *string `protobuf:"bytes,23,opt,name=machine_type,json=machineType" json:"machine_type,omitempty"`
	// Whether to disable Nutanix branding. This overrides the
	// acropolis_kvm_enable_branding GFlag.
	DisableBranding *bool `protobuf:"varint,24,opt,name=disable_branding,json=disableBranding,def=0" json:"disable_branding,omitempty"`
	// The type of the VM.
	VmType *VmType `protobuf:"varint,25,opt,name=vm_type,json=vmType,enum=nutanix.acropolis.VmType,def=1" json:"vm_type,omitempty"`
	// Whether to enable host metrics for this VM.
	EnableMetrics *bool `protobuf:"varint,26,opt,name=enable_metrics,json=enableMetrics" json:"enable_metrics,omitempty"`
	// Indicates how the power state changes.
	PowerStateMechanism *PowerStateMechanism `protobuf:"varint,27,opt,name=power_state_mechanism,json=powerStateMechanism,enum=nutanix.acropolis.PowerStateMechanism" json:"power_state_mechanism,omitempty"`
	// Indicates whether to execute set script before NGT shutdown/reboot.
	NgtEnableScriptExec *bool `protobuf:"varint,28,opt,name=ngt_enable_script_exec,json=ngtEnableScriptExec" json:"ngt_enable_script_exec,omitempty"`
	// Indicates whether to abort NGT shutdown/reboot if script fails.
	NgtFailOnScriptFailure *bool `protobuf:"varint,29,opt,name=ngt_fail_on_script_failure,json=ngtFailOnScriptFailure" json:"ngt_fail_on_script_failure,omitempty"`
	// Number of logical threads per core.
	NumThreadsPerCore *int64 `protobuf:"varint,30,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	// Indicates whether the vcpus are hard pinned to specific pcpus.
	VcpuHardPin *bool `protobuf:"varint,31,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// Source VM from which the VM spec was created.
	// For internal use only.
	SourceVmUuid []byte `protobuf:"bytes,32,opt,name=source_vm_uuid,json=sourceVmUuid" json:"source_vm_uuid,omitempty"`
	// Source snapshot from which VM spec was created.
	// For internal use only.
	SourceSnapshotUuid []byte `protobuf:"bytes,33,opt,name=source_snapshot_uuid,json=sourceSnapshotUuid" json:"source_snapshot_uuid,omitempty"`
	// Whether this VM is created from a dormant VM.
	FromDormantVm *bool `protobuf:"varint,34,opt,name=from_dormant_vm,json=fromDormantVm" json:"from_dormant_vm,omitempty"`
	// If True, the memory that belongs to the VM may reside outside of physical
	// memory. Otherwise, Acropolis will ensure that amount of memory the VM is
	// configured with resides completely in physical memory.
	MemoryOvercommit *bool `protobuf:"varint,36,opt,name=memory_overcommit,json=memoryOvercommit" json:"memory_overcommit,omitempty"`
	// If set, specify the stretch relationship for the VM.
	// For internal use only (used by DR workflows).
	SyncRepConfigList []*VmSyncRepConfig `protobuf:"bytes,37,rep,name=sync_rep_config_list,json=syncRepConfigList" json:"sync_rep_config_list,omitempty"`
	// If set, disable update to the newly created VM.
	DisableUpdate *bool `protobuf:"varint,38,opt,name=disable_update,json=disableUpdate" json:"disable_update,omitempty"`
	// Determines the initial memory allocation for this overcommitted VM.
	PowerOnMemoryMb *uint64 `protobuf:"varint,39,opt,name=power_on_memory_mb,json=powerOnMemoryMb" json:"power_on_memory_mb,omitempty"`
	// Determines the squeeze limit and also the minimum protection guarantee for
	// this overcommitted VM.
	MinimumMemoryMb *uint64 `protobuf:"varint,40,opt,name=minimum_memory_mb,json=minimumMemoryMb" json:"minimum_memory_mb,omitempty"`
	// If False, it will prevent users from hot plugging and unplugging of
	// PCI based devices from within VMs and from the hypervisor stack. Although
	// this applies equally for all VMs, it is primarily applicable for Windows
	// based VMs. By default, we allow hot-plugging and unplugging of devices.
	AllowHotPlug *bool `protobuf:"varint,41,opt,name=allow_hot_plug,json=allowHotPlug,def=1" json:"allow_hot_plug,omitempty"`
	// Enable/Disable flash mode for all VM disks.
	FlashMode            *bool    `protobuf:"varint,42,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmCreateSpec) Reset()         { *m = VmCreateSpec{} }
func (m *VmCreateSpec) String() string { return proto.CompactTextString(m) }
func (*VmCreateSpec) ProtoMessage()    {}
func (*VmCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{20}
}

func (m *VmCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCreateSpec.Unmarshal(m, b)
}
func (m *VmCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCreateSpec.Marshal(b, m, deterministic)
}
func (m *VmCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCreateSpec.Merge(m, src)
}
func (m *VmCreateSpec) XXX_Size() int {
	return xxx_messageInfo_VmCreateSpec.Size(m)
}
func (m *VmCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmCreateSpec proto.InternalMessageInfo

const Default_VmCreateSpec_HwclockTimezone string = "UTC"
const Default_VmCreateSpec_AgentVm bool = false
const Default_VmCreateSpec_DisableBranding bool = false
const Default_VmCreateSpec_VmType VmType = VmType_kGuestVM
const Default_VmCreateSpec_AllowHotPlug bool = true

func (m *VmCreateSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmCreateSpec) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VmCreateSpec) GetNumVcpus() uint64 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmCreateSpec) GetMemoryMb() uint64 {
	if m != nil && m.MemoryMb != nil {
		return *m.MemoryMb
	}
	return 0
}

func (m *VmCreateSpec) GetDiskList() []*VmDiskSpec {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *VmCreateSpec) GetNicList() []*VmNicSpec {
	if m != nil {
		return m.NicList
	}
	return nil
}

func (m *VmCreateSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmCreateSpec) GetBoot() *VmBootConfigSpec {
	if m != nil {
		return m.Boot
	}
	return nil
}

func (m *VmCreateSpec) GetHwclockTimezone() string {
	if m != nil && m.HwclockTimezone != nil {
		return *m.HwclockTimezone
	}
	return Default_VmCreateSpec_HwclockTimezone
}

func (m *VmCreateSpec) GetHaPriority() int64 {
	if m != nil && m.HaPriority != nil {
		return *m.HaPriority
	}
	return 0
}

func (m *VmCreateSpec) GetNumCoresPerVcpu() int64 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *VmCreateSpec) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VmCreateSpec) GetSerialPortList() []*VmSerialPortConfig {
	if m != nil {
		return m.SerialPortList
	}
	return nil
}

func (m *VmCreateSpec) GetVgaConsole() bool {
	if m != nil && m.VgaConsole != nil {
		return *m.VgaConsole
	}
	return false
}

func (m *VmCreateSpec) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *VmCreateSpec) GetCpuPassthrough() bool {
	if m != nil && m.CpuPassthrough != nil {
		return *m.CpuPassthrough
	}
	return false
}

func (m *VmCreateSpec) GetVmGroupUuid() []byte {
	if m != nil {
		return m.VmGroupUuid
	}
	return nil
}

func (m *VmCreateSpec) GetAgentVm() bool {
	if m != nil && m.AgentVm != nil {
		return *m.AgentVm
	}
	return Default_VmCreateSpec_AgentVm
}

func (m *VmCreateSpec) GetGpuConfigList() []*VmGPUConfig {
	if m != nil {
		return m.GpuConfigList
	}
	return nil
}

func (m *VmCreateSpec) GetNumVnumaNodes() uint64 {
	if m != nil && m.NumVnumaNodes != nil {
		return *m.NumVnumaNodes
	}
	return 0
}

func (m *VmCreateSpec) GetExtraFlags() []*GenericKeyValuePair {
	if m != nil {
		return m.ExtraFlags
	}
	return nil
}

func (m *VmCreateSpec) GetMachineType() string {
	if m != nil && m.MachineType != nil {
		return *m.MachineType
	}
	return ""
}

func (m *VmCreateSpec) GetDisableBranding() bool {
	if m != nil && m.DisableBranding != nil {
		return *m.DisableBranding
	}
	return Default_VmCreateSpec_DisableBranding
}

func (m *VmCreateSpec) GetVmType() VmType {
	if m != nil && m.VmType != nil {
		return *m.VmType
	}
	return Default_VmCreateSpec_VmType
}

func (m *VmCreateSpec) GetEnableMetrics() bool {
	if m != nil && m.EnableMetrics != nil {
		return *m.EnableMetrics
	}
	return false
}

func (m *VmCreateSpec) GetPowerStateMechanism() PowerStateMechanism {
	if m != nil && m.PowerStateMechanism != nil {
		return *m.PowerStateMechanism
	}
	return PowerStateMechanism_kHard
}

func (m *VmCreateSpec) GetNgtEnableScriptExec() bool {
	if m != nil && m.NgtEnableScriptExec != nil {
		return *m.NgtEnableScriptExec
	}
	return false
}

func (m *VmCreateSpec) GetNgtFailOnScriptFailure() bool {
	if m != nil && m.NgtFailOnScriptFailure != nil {
		return *m.NgtFailOnScriptFailure
	}
	return false
}

func (m *VmCreateSpec) GetNumThreadsPerCore() int64 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

func (m *VmCreateSpec) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *VmCreateSpec) GetSourceVmUuid() []byte {
	if m != nil {
		return m.SourceVmUuid
	}
	return nil
}

func (m *VmCreateSpec) GetSourceSnapshotUuid() []byte {
	if m != nil {
		return m.SourceSnapshotUuid
	}
	return nil
}

func (m *VmCreateSpec) GetFromDormantVm() bool {
	if m != nil && m.FromDormantVm != nil {
		return *m.FromDormantVm
	}
	return false
}

func (m *VmCreateSpec) GetMemoryOvercommit() bool {
	if m != nil && m.MemoryOvercommit != nil {
		return *m.MemoryOvercommit
	}
	return false
}

func (m *VmCreateSpec) GetSyncRepConfigList() []*VmSyncRepConfig {
	if m != nil {
		return m.SyncRepConfigList
	}
	return nil
}

func (m *VmCreateSpec) GetDisableUpdate() bool {
	if m != nil && m.DisableUpdate != nil {
		return *m.DisableUpdate
	}
	return false
}

func (m *VmCreateSpec) GetPowerOnMemoryMb() uint64 {
	if m != nil && m.PowerOnMemoryMb != nil {
		return *m.PowerOnMemoryMb
	}
	return 0
}

func (m *VmCreateSpec) GetMinimumMemoryMb() uint64 {
	if m != nil && m.MinimumMemoryMb != nil {
		return *m.MinimumMemoryMb
	}
	return 0
}

func (m *VmCreateSpec) GetAllowHotPlug() bool {
	if m != nil && m.AllowHotPlug != nil {
		return *m.AllowHotPlug
	}
	return Default_VmCreateSpec_AllowHotPlug
}

func (m *VmCreateSpec) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

type VmDiskAddr struct {
	// The device bus.
	// Acceptable values include: scsi, ide, pci, sata, spapr(only ppc) for AHV.
	// Acceptable values include: scsi, ide for Hyper-V.
	Bus *string `protobuf:"bytes,1,opt,name=bus" json:"bus,omitempty"`
	// Device index on the bus. This field is ignored unless bus is specified.
	Index                *uint32  `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskAddr) Reset()         { *m = VmDiskAddr{} }
func (m *VmDiskAddr) String() string { return proto.CompactTextString(m) }
func (*VmDiskAddr) ProtoMessage()    {}
func (*VmDiskAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{21}
}

func (m *VmDiskAddr) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskAddr.Unmarshal(m, b)
}
func (m *VmDiskAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskAddr.Marshal(b, m, deterministic)
}
func (m *VmDiskAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskAddr.Merge(m, src)
}
func (m *VmDiskAddr) XXX_Size() int {
	return xxx_messageInfo_VmDiskAddr.Size(m)
}
func (m *VmDiskAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskAddr.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskAddr proto.InternalMessageInfo

func (m *VmDiskAddr) GetBus() string {
	if m != nil && m.Bus != nil {
		return *m.Bus
	}
	return ""
}

func (m *VmDiskAddr) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

type VmDiskConfig struct {
	// The disk address.
	Addr *VmDiskAddr `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// Whether this is a CD-ROM drive.
	Cdrom *bool `protobuf:"varint,2,opt,name=cdrom" json:"cdrom,omitempty"`
	// Whether the drive is empty. This field only applies to CD-ROM drives.
	Empty *bool `protobuf:"varint,3,opt,name=empty" json:"empty,omitempty"`
	// The vmdisk identifier. For CD-ROM drives, this field may be unset,
	// indicating that the drive is empty.
	VmdiskUuid []byte `protobuf:"bytes,4,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// The source from which the disk was cloned. This is only a best-effort
	// hint. It is not guaranteed to be set, even if the disk was originally
	// cloned. These fields should not be used to determine whether a CD-ROM
	// drive is empty.
	SourceVmdiskUuid []byte  `protobuf:"bytes,5,opt,name=source_vmdisk_uuid,json=sourceVmdiskUuid" json:"source_vmdisk_uuid,omitempty"`
	SourceNfsPath    *string `protobuf:"bytes,6,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	// The container in which the backing vmdisk is provisioned. This field is
	// unset when the drive is empty.
	ContainerId *int64 `protobuf:"varint,7,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Whether this SCSI disk should be attached in passthrough mode to pass
	// all SCSI commands directly to Stargate via iSCSI.
	ScsiPassthrough *bool `protobuf:"varint,8,opt,name=scsi_passthrough,json=scsiPassthrough,def=1" json:"scsi_passthrough,omitempty"`
	// Disk size in bytes. This field is usually populated on-demand, during
	// certain queries. It is not stored in the Acropolis database.
	VmdiskSize *int64 `protobuf:"varint,9,opt,name=vmdisk_size,json=vmdiskSize" json:"vmdisk_size,omitempty"`
	// Whether the disk is shared with another VM. Shared disks are not included
	// in snapshots.
	Shared *bool `protobuf:"varint,11,opt,name=shared" json:"shared,omitempty"`
	// The volume group identifier. If this field is set, this disk object
	// represents a volume group. When this field is set, the vmdisk_uuid
	// field must be unset.
	VolumeGroupUuid []byte `protobuf:"bytes,12,opt,name=volume_group_uuid,json=volumeGroupUuid" json:"volume_group_uuid,omitempty"`
	// Disk NFS path. This field is usually populated on-demand, during certain
	// queries. It is not stored in the Acropolis database.
	VmdiskNfsPath *string `protobuf:"bytes,13,opt,name=vmdisk_nfs_path,json=vmdiskNfsPath" json:"vmdisk_nfs_path,omitempty"`
	// A device UUID.
	DeviceUuid []byte `protobuf:"bytes,14,opt,name=device_uuid,json=deviceUuid" json:"device_uuid,omitempty"`
	// NAA Id.
	NaaId *string `protobuf:"bytes,15,opt,name=naa_id,json=naaId" json:"naa_id,omitempty"`
	// If this disk is backed partially or fully by a datasource in an external
	// repository, the following property is applicable. However, this property
	// is usually populated only on-demand, during certain queries. It is not
	// stored in the Acropolis database. In addition, this property is not a
	// static property -- the value of this property will be cleared when the
	// disk is no longer dependent on the data outside the AOS cluster.
	DataSourceUrl *string `protobuf:"bytes,16,opt,name=data_source_url,json=dataSourceUrl" json:"data_source_url,omitempty"`
	// Override path for the VM disk, the path is relative to hypervisor fs.
	// This field is for internal use only.
	VmdiskOverridePath *string `protobuf:"bytes,17,opt,name=vmdisk_override_path,json=vmdiskOverridePath" json:"vmdisk_override_path,omitempty"`
	// Whether flash mode is enabled for the VM disk.
	FlashMode            *bool    `protobuf:"varint,18,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskConfig) Reset()         { *m = VmDiskConfig{} }
func (m *VmDiskConfig) String() string { return proto.CompactTextString(m) }
func (*VmDiskConfig) ProtoMessage()    {}
func (*VmDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{22}
}

func (m *VmDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskConfig.Unmarshal(m, b)
}
func (m *VmDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskConfig.Marshal(b, m, deterministic)
}
func (m *VmDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskConfig.Merge(m, src)
}
func (m *VmDiskConfig) XXX_Size() int {
	return xxx_messageInfo_VmDiskConfig.Size(m)
}
func (m *VmDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskConfig proto.InternalMessageInfo

const Default_VmDiskConfig_ScsiPassthrough bool = true

func (m *VmDiskConfig) GetAddr() *VmDiskAddr {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *VmDiskConfig) GetCdrom() bool {
	if m != nil && m.Cdrom != nil {
		return *m.Cdrom
	}
	return false
}

func (m *VmDiskConfig) GetEmpty() bool {
	if m != nil && m.Empty != nil {
		return *m.Empty
	}
	return false
}

func (m *VmDiskConfig) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VmDiskConfig) GetSourceVmdiskUuid() []byte {
	if m != nil {
		return m.SourceVmdiskUuid
	}
	return nil
}

func (m *VmDiskConfig) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

func (m *VmDiskConfig) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskConfig) GetScsiPassthrough() bool {
	if m != nil && m.ScsiPassthrough != nil {
		return *m.ScsiPassthrough
	}
	return Default_VmDiskConfig_ScsiPassthrough
}

func (m *VmDiskConfig) GetVmdiskSize() int64 {
	if m != nil && m.VmdiskSize != nil {
		return *m.VmdiskSize
	}
	return 0
}

func (m *VmDiskConfig) GetShared() bool {
	if m != nil && m.Shared != nil {
		return *m.Shared
	}
	return false
}

func (m *VmDiskConfig) GetVolumeGroupUuid() []byte {
	if m != nil {
		return m.VolumeGroupUuid
	}
	return nil
}

func (m *VmDiskConfig) GetVmdiskNfsPath() string {
	if m != nil && m.VmdiskNfsPath != nil {
		return *m.VmdiskNfsPath
	}
	return ""
}

func (m *VmDiskConfig) GetDeviceUuid() []byte {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *VmDiskConfig) GetNaaId() string {
	if m != nil && m.NaaId != nil {
		return *m.NaaId
	}
	return ""
}

func (m *VmDiskConfig) GetDataSourceUrl() string {
	if m != nil && m.DataSourceUrl != nil {
		return *m.DataSourceUrl
	}
	return ""
}

func (m *VmDiskConfig) GetVmdiskOverridePath() string {
	if m != nil && m.VmdiskOverridePath != nil {
		return *m.VmdiskOverridePath
	}
	return ""
}

func (m *VmDiskConfig) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

type VmDiskSpec struct {
	// The disk address.
	Addr *VmDiskAddr `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// Whether this is a CD-ROM drive.
	Cdrom *bool `protobuf:"varint,2,opt,name=cdrom" json:"cdrom,omitempty"`
	// Whether the drive should be empty. This field only applies to CD-ROM
	// drives, otherwise it is ignored. If this field is set to true and the
	// drive is a CD-ROM, then the disk creation fields below are ignored.
	Empty *bool `protobuf:"varint,3,opt,name=empty" json:"empty,omitempty"`
	// Disk creation style. Exactly one of {VmDiskSpecClone, VmDiskSpecCreate,
	// VmDiskSpecExisting, VmDiskSpecCloneExternal, VmDiskSpecPassthruExternal}
	// must be provided (if this is not an empty CD-ROM drive).
	Clone    *VmDiskSpecClone    `protobuf:"bytes,4,opt,name=clone" json:"clone,omitempty"`
	Create   *VmDiskSpecCreate   `protobuf:"bytes,5,opt,name=create" json:"create,omitempty"`
	Existing *VmDiskSpecExisting `protobuf:"bytes,6,opt,name=existing" json:"existing,omitempty"`
	// Whether this SCSI disk should be attached in passthrough mode to pass
	// all SCSI commands directly to Stargate via iSCSI.
	ScsiPassthrough *bool `protobuf:"varint,7,opt,name=scsi_passthrough,json=scsiPassthrough" json:"scsi_passthrough,omitempty"`
	// Whether the disk is shared with another VM.
	Shared *bool `protobuf:"varint,8,opt,name=shared" json:"shared,omitempty"`
	// Device UUID to be assigned to the newly created device.
	DeviceUuid []byte `protobuf:"bytes,9,opt,name=device_uuid,json=deviceUuid" json:"device_uuid,omitempty"`
	// The spec to be provided for creating a vmdisk that's based on a clone of
	// the data in the external datasource.
	CloneExternal *VmDiskSpecCloneExternal `protobuf:"bytes,10,opt,name=clone_external,json=cloneExternal" json:"clone_external,omitempty"`
	// Override path for the VM disk, the path is relative to hypervisor fs.
	// This field is for internal use only.
	VmdiskOverridePath *string `protobuf:"bytes,11,opt,name=vmdisk_override_path,json=vmdiskOverridePath" json:"vmdisk_override_path,omitempty"`
	// The "virtual_disk" entity incarnation ID as found in IDF.
	DbIncarnationId *uint64 `protobuf:"varint,12,opt,name=db_incarnation_id,json=dbIncarnationId" json:"db_incarnation_id,omitempty"`
	// The spec to be provided for creating a passthrough vmdisk that forwards
	// all reads and writes to the backing external datasource.
	PassthruExternal *VmDiskSpecPassthruExternal `protobuf:"bytes,13,opt,name=passthru_external,json=passthruExternal" json:"passthru_external,omitempty"`
	// Whether flash mode is enabled for the VM disk.
	FlashMode            *bool    `protobuf:"varint,14,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpec) Reset()         { *m = VmDiskSpec{} }
func (m *VmDiskSpec) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpec) ProtoMessage()    {}
func (*VmDiskSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{23}
}

func (m *VmDiskSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpec.Unmarshal(m, b)
}
func (m *VmDiskSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpec.Marshal(b, m, deterministic)
}
func (m *VmDiskSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpec.Merge(m, src)
}
func (m *VmDiskSpec) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpec.Size(m)
}
func (m *VmDiskSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpec proto.InternalMessageInfo

func (m *VmDiskSpec) GetAddr() *VmDiskAddr {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *VmDiskSpec) GetCdrom() bool {
	if m != nil && m.Cdrom != nil {
		return *m.Cdrom
	}
	return false
}

func (m *VmDiskSpec) GetEmpty() bool {
	if m != nil && m.Empty != nil {
		return *m.Empty
	}
	return false
}

func (m *VmDiskSpec) GetClone() *VmDiskSpecClone {
	if m != nil {
		return m.Clone
	}
	return nil
}

func (m *VmDiskSpec) GetCreate() *VmDiskSpecCreate {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *VmDiskSpec) GetExisting() *VmDiskSpecExisting {
	if m != nil {
		return m.Existing
	}
	return nil
}

func (m *VmDiskSpec) GetScsiPassthrough() bool {
	if m != nil && m.ScsiPassthrough != nil {
		return *m.ScsiPassthrough
	}
	return false
}

func (m *VmDiskSpec) GetShared() bool {
	if m != nil && m.Shared != nil {
		return *m.Shared
	}
	return false
}

func (m *VmDiskSpec) GetDeviceUuid() []byte {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *VmDiskSpec) GetCloneExternal() *VmDiskSpecCloneExternal {
	if m != nil {
		return m.CloneExternal
	}
	return nil
}

func (m *VmDiskSpec) GetVmdiskOverridePath() string {
	if m != nil && m.VmdiskOverridePath != nil {
		return *m.VmdiskOverridePath
	}
	return ""
}

func (m *VmDiskSpec) GetDbIncarnationId() uint64 {
	if m != nil && m.DbIncarnationId != nil {
		return *m.DbIncarnationId
	}
	return 0
}

func (m *VmDiskSpec) GetPassthruExternal() *VmDiskSpecPassthruExternal {
	if m != nil {
		return m.PassthruExternal
	}
	return nil
}

func (m *VmDiskSpec) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

type VmDiskSpecClone struct {
	// The source vmdisk or image from which to clone. Exactly one of the
	// following must be set (vmdisk_uuid, nfs_path). The nfs_path
	// may either be relative or absolute.
	VmdiskUuid []byte  `protobuf:"bytes,1,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	NfsPath    *string `protobuf:"bytes,2,opt,name=nfs_path,json=nfsPath" json:"nfs_path,omitempty"`
	// The minimum size of the resulting clone in bytes.
	MinSize *int64 `protobuf:"varint,3,opt,name=min_size,json=minSize" json:"min_size,omitempty"`
	// The container in which the specified image or vmdisk is stored.
	//
	// If the source is a vmdisk, this field is recommended, but optional.
	// If the source is a snapshot vmdisk, this field is required.
	// If the source is an absolute image path, this field is prohibited.
	// If the source is a relative image path, this field is required.
	ContainerId *int64 `protobuf:"varint,4,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// UUID of the snapshot consistency group from which to clone a snapshot
	// vmdisk. This group UUID can be found in a SnapshotInfo.optional bytes
	SnapshotGroupUuid []byte `protobuf:"bytes,5,opt,name=snapshot_group_uuid,json=snapshotGroupUuid" json:"snapshot_group_uuid,omitempty"`
	// UUID of the container.
	ContainerUuid []byte `protobuf:"bytes,7,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Reserved for internal use. Whether to inherit scsi serial number of the
	// parent disk. This is only used during VmRegister to restore a vmdisk.
	InheritScsiSerialNumber *bool `protobuf:"varint,8,opt,name=inherit_scsi_serial_number,json=inheritScsiSerialNumber" json:"inherit_scsi_serial_number,omitempty"`
	// Deprecated for Volume Disks and will be ignored even if set.
	// Reserved for internal use. The desired vmdisk_uuid for the clone. This is
	// only used during VmRegister to restore a vmdisk.
	NewVmdiskUuid []byte `protobuf:"bytes,9,opt,name=new_vmdisk_uuid,json=newVmdiskUuid" json:"new_vmdisk_uuid,omitempty"`
	// Reserved for internal use. Whether to inherit chain id from parent.
	// Must be set only for in-place restore operations and not on clone.
	InheritChainId *bool `protobuf:"varint,10,opt,name=inherit_chain_id,json=inheritChainId" json:"inherit_chain_id,omitempty"`
	// Cluster on which the VM is deployed. This field is populted when trying
	// to create image from vmdisk through V3 API from PC/PE. This field is for
	// internal use only.
	ClusterUuid []byte `protobuf:"bytes,11,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// The UUID of the source VM disk from which to clone the virtual disk.
	// This is only used when creating a VM from a dormant VM.
	SourceVmdiskUuid []byte `protobuf:"bytes,12,opt,name=source_vmdisk_uuid,json=sourceVmdiskUuid" json:"source_vmdisk_uuid,omitempty"`
	// The NFS path from which to clone the virtual disk.
	SourceNfsPath *string `protobuf:"bytes,13,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	// This field should be used to provide list of clusters where
	// the image should be created; should be a subset of AHV PEs which is
	// registered to the OnPrem PC. This field should only be used from OnPrem PC.
	InitialClusterLocationList [][]byte `protobuf:"bytes,14,rep,name=initial_cluster_location_list,json=initialClusterLocationList" json:"initial_cluster_location_list,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *VmDiskSpecClone) Reset()         { *m = VmDiskSpecClone{} }
func (m *VmDiskSpecClone) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecClone) ProtoMessage()    {}
func (*VmDiskSpecClone) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{24}
}

func (m *VmDiskSpecClone) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecClone.Unmarshal(m, b)
}
func (m *VmDiskSpecClone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecClone.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecClone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecClone.Merge(m, src)
}
func (m *VmDiskSpecClone) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecClone.Size(m)
}
func (m *VmDiskSpecClone) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecClone.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecClone proto.InternalMessageInfo

func (m *VmDiskSpecClone) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecClone) GetNfsPath() string {
	if m != nil && m.NfsPath != nil {
		return *m.NfsPath
	}
	return ""
}

func (m *VmDiskSpecClone) GetMinSize() int64 {
	if m != nil && m.MinSize != nil {
		return *m.MinSize
	}
	return 0
}

func (m *VmDiskSpecClone) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskSpecClone) GetSnapshotGroupUuid() []byte {
	if m != nil {
		return m.SnapshotGroupUuid
	}
	return nil
}

func (m *VmDiskSpecClone) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecClone) GetInheritScsiSerialNumber() bool {
	if m != nil && m.InheritScsiSerialNumber != nil {
		return *m.InheritScsiSerialNumber
	}
	return false
}

func (m *VmDiskSpecClone) GetNewVmdiskUuid() []byte {
	if m != nil {
		return m.NewVmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecClone) GetInheritChainId() bool {
	if m != nil && m.InheritChainId != nil {
		return *m.InheritChainId
	}
	return false
}

func (m *VmDiskSpecClone) GetClusterUuid() []byte {
	if m != nil {
		return m.ClusterUuid
	}
	return nil
}

func (m *VmDiskSpecClone) GetSourceVmdiskUuid() []byte {
	if m != nil {
		return m.SourceVmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecClone) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

func (m *VmDiskSpecClone) GetInitialClusterLocationList() [][]byte {
	if m != nil {
		return m.InitialClusterLocationList
	}
	return nil
}

type VmDiskSpecCreate struct {
	// The disk's size in bytes.
	Size *uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	// Container ID, name or UUID. Exactly one of the following must be set.
	ContainerId          *uint64  `protobuf:"varint,2,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	ContainerName        *string  `protobuf:"bytes,3,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	ContainerUuid        []byte   `protobuf:"bytes,4,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecCreate) Reset()         { *m = VmDiskSpecCreate{} }
func (m *VmDiskSpecCreate) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecCreate) ProtoMessage()    {}
func (*VmDiskSpecCreate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{25}
}

func (m *VmDiskSpecCreate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecCreate.Unmarshal(m, b)
}
func (m *VmDiskSpecCreate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecCreate.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecCreate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecCreate.Merge(m, src)
}
func (m *VmDiskSpecCreate) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecCreate.Size(m)
}
func (m *VmDiskSpecCreate) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecCreate.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecCreate proto.InternalMessageInfo

func (m *VmDiskSpecCreate) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *VmDiskSpecCreate) GetContainerId() uint64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskSpecCreate) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *VmDiskSpecCreate) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

type VmDiskSpecExisting struct {
	// The existing vmdisk to use.
	VmdiskUuid []byte `protobuf:"bytes,1,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// The container in which the specified vmdisk is provisioned. This parameter
	// is recommended, but optional.
	ContainerId   *uint64 `protobuf:"varint,2,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	ContainerUuid []byte  `protobuf:"bytes,3,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// This flag must be interpreted only during VG disk creations. If true, the
	// disk will derive the iscsi target name of the VG. If false, the disk's
	// iscsi target will use the "vmdisk-<uuid>" format - this is used for
	// non-disruptive migration of shared VMDisks from shell VMs into VGs.
	UseVgIscsiTargetName *bool `protobuf:"varint,4,opt,name=use_vg_iscsi_target_name,json=useVgIscsiTargetName" json:"use_vg_iscsi_target_name,omitempty"`
	// The UUID of the source VM disk from which to clone the virtual disk.
	SourceVmdiskUuid []byte `protobuf:"bytes,5,opt,name=source_vmdisk_uuid,json=sourceVmdiskUuid" json:"source_vmdisk_uuid,omitempty"`
	// The NFS path from which to clone the virtual disk.
	SourceNfsPath        *string  `protobuf:"bytes,6,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecExisting) Reset()         { *m = VmDiskSpecExisting{} }
func (m *VmDiskSpecExisting) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecExisting) ProtoMessage()    {}
func (*VmDiskSpecExisting) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{26}
}

func (m *VmDiskSpecExisting) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecExisting.Unmarshal(m, b)
}
func (m *VmDiskSpecExisting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecExisting.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecExisting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecExisting.Merge(m, src)
}
func (m *VmDiskSpecExisting) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecExisting.Size(m)
}
func (m *VmDiskSpecExisting) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecExisting.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecExisting proto.InternalMessageInfo

func (m *VmDiskSpecExisting) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecExisting) GetContainerId() uint64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskSpecExisting) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecExisting) GetUseVgIscsiTargetName() bool {
	if m != nil && m.UseVgIscsiTargetName != nil {
		return *m.UseVgIscsiTargetName
	}
	return false
}

func (m *VmDiskSpecExisting) GetSourceVmdiskUuid() []byte {
	if m != nil {
		return m.SourceVmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecExisting) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

// This message encapsulates the parameters that are required for cloning a
// vmdisk in AOS from a datasource outside an AOS cluster.
type VmDiskSpecCloneExternal struct {
	// The disk's size in bytes. If not specified, the vmdisk provisioned in
	// AOS will have the same size as the external datasource. If specified,
	// the value will be honored only if it is at least as large as the size of
	// the datasource.
	MinSize *uint64 `protobuf:"varint,1,opt,name=min_size,json=minSize" json:"min_size,omitempty"`
	// Container ID, name or UUID. Exactly one of the following three must be
	// set.
	ContainerId   *uint64 `protobuf:"varint,2,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	ContainerName *string `protobuf:"bytes,3,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	ContainerUuid []byte  `protobuf:"bytes,4,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Required. URL of the external datasource. It should be a hierarchical URL
	// of the form "scheme://server:<port>/path". Only NFS-based datasources
	// are supported today.
	// Example: "nfs://10.45.131.7/export1/sql_server/data_disk1"
	DiskUrl              *string  `protobuf:"bytes,5,opt,name=disk_url,json=diskUrl" json:"disk_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecCloneExternal) Reset()         { *m = VmDiskSpecCloneExternal{} }
func (m *VmDiskSpecCloneExternal) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecCloneExternal) ProtoMessage()    {}
func (*VmDiskSpecCloneExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{27}
}

func (m *VmDiskSpecCloneExternal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecCloneExternal.Unmarshal(m, b)
}
func (m *VmDiskSpecCloneExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecCloneExternal.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecCloneExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecCloneExternal.Merge(m, src)
}
func (m *VmDiskSpecCloneExternal) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecCloneExternal.Size(m)
}
func (m *VmDiskSpecCloneExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecCloneExternal.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecCloneExternal proto.InternalMessageInfo

func (m *VmDiskSpecCloneExternal) GetMinSize() uint64 {
	if m != nil && m.MinSize != nil {
		return *m.MinSize
	}
	return 0
}

func (m *VmDiskSpecCloneExternal) GetContainerId() uint64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskSpecCloneExternal) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *VmDiskSpecCloneExternal) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecCloneExternal) GetDiskUrl() string {
	if m != nil && m.DiskUrl != nil {
		return *m.DiskUrl
	}
	return ""
}

// This message encapsulates the parameters that are required for provisioning
// a passthrough vmdisk in AOS. A passthrough vmdisk forwards both reads and
// writes to the backing datasource.
type VmDiskSpecPassthruExternal struct {
	// Container ID, name or UUID. Specifying a container is completely optional
	// while provisioning a passthrough vmdisk because no data is stored in
	// AOS. In this case, the default container provisioned in an AOS cluster
	// will be used for the vmdisk. However, if it is desirable to specify a
	// container, exactly one of the following three must be set.
	ContainerId   *uint64 `protobuf:"varint,1,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	ContainerName *string `protobuf:"bytes,2,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	ContainerUuid []byte  `protobuf:"bytes,3,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Required. URL of the external datasource. It should be a hierarchical URL
	// of the form "scheme://server:<port>/path". Only NFS-based datasources
	// are supported today.
	// Example: "nfs://10.45.131.7/export1/sql_server/data_disk1"
	DiskUrl              *string  `protobuf:"bytes,4,opt,name=disk_url,json=diskUrl" json:"disk_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecPassthruExternal) Reset()         { *m = VmDiskSpecPassthruExternal{} }
func (m *VmDiskSpecPassthruExternal) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecPassthruExternal) ProtoMessage()    {}
func (*VmDiskSpecPassthruExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{28}
}

func (m *VmDiskSpecPassthruExternal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecPassthruExternal.Unmarshal(m, b)
}
func (m *VmDiskSpecPassthruExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecPassthruExternal.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecPassthruExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecPassthruExternal.Merge(m, src)
}
func (m *VmDiskSpecPassthruExternal) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecPassthruExternal.Size(m)
}
func (m *VmDiskSpecPassthruExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecPassthruExternal.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecPassthruExternal proto.InternalMessageInfo

func (m *VmDiskSpecPassthruExternal) GetContainerId() uint64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskSpecPassthruExternal) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *VmDiskSpecPassthruExternal) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecPassthruExternal) GetDiskUrl() string {
	if m != nil && m.DiskUrl != nil {
		return *m.DiskUrl
	}
	return ""
}

type VmHypervisorInfo struct {
	// The hypervisor type.
	Type *HypervisorType_Type `protobuf:"varint,1,opt,name=type,enum=nutanix.acropolis.HypervisorType_Type" json:"type,omitempty"`
	// The VM's hypervisor-specific data.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmHypervisorInfo) Reset()         { *m = VmHypervisorInfo{} }
func (m *VmHypervisorInfo) String() string { return proto.CompactTextString(m) }
func (*VmHypervisorInfo) ProtoMessage()    {}
func (*VmHypervisorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{29}
}

func (m *VmHypervisorInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmHypervisorInfo.Unmarshal(m, b)
}
func (m *VmHypervisorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmHypervisorInfo.Marshal(b, m, deterministic)
}
func (m *VmHypervisorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmHypervisorInfo.Merge(m, src)
}
func (m *VmHypervisorInfo) XXX_Size() int {
	return xxx_messageInfo_VmHypervisorInfo.Size(m)
}
func (m *VmHypervisorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmHypervisorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmHypervisorInfo proto.InternalMessageInfo

func (m *VmHypervisorInfo) GetType() HypervisorType_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return HypervisorType_kKvm
}

func (m *VmHypervisorInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type VmInfo struct {
	// The VM identifier.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Whether the VM has been deleted.
	Deleted *bool `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	// The VM's logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,3,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// The VM's configuration.
	Config *VmConfig `protobuf:"bytes,4,opt,name=config" json:"config,omitempty"`
	// The VM's hypervisor information.
	Hypervisor *VmHypervisorInfo `protobuf:"bytes,5,opt,name=hypervisor" json:"hypervisor,omitempty"`
	// The VM's current host.
	HostUuid []byte `protobuf:"bytes,6,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// The VM's current power state.
	State *VmState_State `protobuf:"varint,7,opt,name=state,enum=nutanix.acropolis.VmState_State" json:"state,omitempty"`
	// Last host uuid that VM was removed from.
	// We need to maintain this information for two cases:
	//   a) VM was removed from a host for temporary maintenance_mode/upgrade
	//   b) VM was moved from a host in HA failover
	//   c) VM gets shutdown unexpectedly (i.e. qemu crashes)
	// In either case, it is desired to implicitly migrate VM back to previous
	// host, where most of its data is assumed to reside.
	//
	// Note any explicit administrative VM operations before host returns to a
	// schedulable state will nullify this field.
	RemovedFromHostUuid []byte `protobuf:"bytes,9,opt,name=removed_from_host_uuid,json=removedFromHostUuid" json:"removed_from_host_uuid,omitempty"`
	// GPUs currently assigned to VM.
	GpuList []*NodeGPU `protobuf:"bytes,10,rep,name=gpu_list,json=gpuList" json:"gpu_list,omitempty"`
	// List of disk spec migrating to other container.
	MigratingDiskSpecList []*VmChangeDiskContainerSpec `protobuf:"bytes,11,rep,name=migrating_disk_spec_list,json=migratingDiskSpecList" json:"migrating_disk_spec_list,omitempty"`
	// Whether we are allowed to clear removed_from_host_uuid. This value
	// should be false in the case of a system triggered AcpiShutdown task.
	CanClearRemovedFromHostUuid *bool    `protobuf:"varint,12,opt,name=can_clear_removed_from_host_uuid,json=canClearRemovedFromHostUuid,def=1" json:"can_clear_removed_from_host_uuid,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *VmInfo) Reset()         { *m = VmInfo{} }
func (m *VmInfo) String() string { return proto.CompactTextString(m) }
func (*VmInfo) ProtoMessage()    {}
func (*VmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{30}
}

func (m *VmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmInfo.Unmarshal(m, b)
}
func (m *VmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmInfo.Marshal(b, m, deterministic)
}
func (m *VmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmInfo.Merge(m, src)
}
func (m *VmInfo) XXX_Size() int {
	return xxx_messageInfo_VmInfo.Size(m)
}
func (m *VmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmInfo proto.InternalMessageInfo

const Default_VmInfo_LogicalTimestamp int64 = -1
const Default_VmInfo_CanClearRemovedFromHostUuid bool = true

func (m *VmInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmInfo) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *VmInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_VmInfo_LogicalTimestamp
}

func (m *VmInfo) GetConfig() *VmConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *VmInfo) GetHypervisor() *VmHypervisorInfo {
	if m != nil {
		return m.Hypervisor
	}
	return nil
}

func (m *VmInfo) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *VmInfo) GetState() VmState_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return VmState_kUnknown
}

func (m *VmInfo) GetRemovedFromHostUuid() []byte {
	if m != nil {
		return m.RemovedFromHostUuid
	}
	return nil
}

func (m *VmInfo) GetGpuList() []*NodeGPU {
	if m != nil {
		return m.GpuList
	}
	return nil
}

func (m *VmInfo) GetMigratingDiskSpecList() []*VmChangeDiskContainerSpec {
	if m != nil {
		return m.MigratingDiskSpecList
	}
	return nil
}

func (m *VmInfo) GetCanClearRemovedFromHostUuid() bool {
	if m != nil && m.CanClearRemovedFromHostUuid != nil {
		return *m.CanClearRemovedFromHostUuid
	}
	return Default_VmInfo_CanClearRemovedFromHostUuid
}

type VmNicConfig struct {
	// The MAC address of the NIC.
	MacAddr []byte `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// The network to which the NIC is attached.
	NetworkUuid []byte `protobuf:"bytes,2,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// The model string.
	Model *string `protobuf:"bytes,3,opt,name=model" json:"model,omitempty"`
	// The currently-assigned IP address. This field is usually populated
	// on-demand, during certain queries. It is not stored in the Acropolis
	// database.
	IpAddress []byte `protobuf:"bytes,4,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// Vlan mode.
	VlanMode *VmNicVlanType `protobuf:"varint,5,opt,name=vlan_mode,json=vlanMode,enum=nutanix.acropolis.VmNicVlanType,def=1" json:"vlan_mode,omitempty"`
	// List of networks to trunk. Only valid if vlan_mode = kTrunked.
	// If trunked_network is empty, then it will trunk all vlan's.
	TrunkedNetworks []int32 `protobuf:"varint,6,rep,name=trunked_networks,json=trunkedNetworks" json:"trunked_networks,omitempty"`
	// Type of the nic. Normal or Network function.
	Type *VmNicType `protobuf:"varint,7,opt,name=type,enum=nutanix.acropolis.VmNicType,def=1" json:"type,omitempty"`
	// Remember the PCI slot where the nic is attached. Note that this field is
	// not meant to be exposed through the REST API or exposed directly to the
	// client.
	PciSlot *int32 `protobuf:"varint,9,opt,name=pci_slot,json=pciSlot" json:"pci_slot,omitempty"`
	// This is valid only if the nic type is kNetworkFunctionNic.
	NetworkFunctionNicType *NetworkFunctionNicType `protobuf:"varint,10,opt,name=network_function_nic_type,json=networkFunctionNicType,enum=nutanix.acropolis.NetworkFunctionNicType" json:"network_function_nic_type,omitempty"`
	// This is valid only if the nic type is kNormalNic.
	// UUID of the network function chain to use for this NIC.
	NetworkFunctionChainUuid []byte `protobuf:"bytes,11,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// If this port is managed by an external controller, these are the
	// external attributes for the port.
	ExternalAttrList []*GenericKeyValuePair `protobuf:"bytes,12,rep,name=external_attr_list,json=externalAttrList" json:"external_attr_list,omitempty"`
	// Virtual NIC UUID.
	// The virtual NIC UUID is generated using Uhura APIs when acropolis publishes
	// virtual NIC info to arithmos. The mapping from arithmos IDs ("<VM UUID>" +
	// ":" + "<MAC address>") to virtual NIC UUIDs are stored in Pithos. When we
	// need to return the virtual NIC UUID, say, in VmGet response, we need to
	// lookup the virtual NIC UUID from Pithos using the arithmos ID as the key.
	Uuid        []byte                   `protobuf:"bytes,13,opt,name=uuid" json:"uuid,omitempty"`
	NetworkType *VmNicConfig_NetworkType `protobuf:"varint,14,opt,name=network_type,json=networkType,enum=nutanix.acropolis.VmNicConfig_NetworkType,def=1" json:"network_type,omitempty"`
	// Whether or not the NIC is connected.
	Connected *bool `protobuf:"varint,15,opt,name=connected,def=1" json:"connected,omitempty"`
	// Maximum number of Tx/Rx queue pairs for this NIC.
	Queues *uint32 `protobuf:"varint,16,opt,name=queues,def=1" json:"queues,omitempty"`
	// Maximum rx queue depth.
	RxQueueSize          *uint32  `protobuf:"varint,17,opt,name=rx_queue_size,json=rxQueueSize,def=256" json:"rx_queue_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmNicConfig) Reset()         { *m = VmNicConfig{} }
func (m *VmNicConfig) String() string { return proto.CompactTextString(m) }
func (*VmNicConfig) ProtoMessage()    {}
func (*VmNicConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{31}
}

func (m *VmNicConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNicConfig.Unmarshal(m, b)
}
func (m *VmNicConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNicConfig.Marshal(b, m, deterministic)
}
func (m *VmNicConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNicConfig.Merge(m, src)
}
func (m *VmNicConfig) XXX_Size() int {
	return xxx_messageInfo_VmNicConfig.Size(m)
}
func (m *VmNicConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNicConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmNicConfig proto.InternalMessageInfo

const Default_VmNicConfig_VlanMode VmNicVlanType = VmNicVlanType_kAccess
const Default_VmNicConfig_Type VmNicType = VmNicType_kNormalNic
const Default_VmNicConfig_NetworkType VmNicConfig_NetworkType = VmNicConfig_kNativeNetwork
const Default_VmNicConfig_Connected bool = true
const Default_VmNicConfig_Queues uint32 = 1
const Default_VmNicConfig_RxQueueSize uint32 = 256

func (m *VmNicConfig) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *VmNicConfig) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *VmNicConfig) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *VmNicConfig) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *VmNicConfig) GetVlanMode() VmNicVlanType {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return Default_VmNicConfig_VlanMode
}

func (m *VmNicConfig) GetTrunkedNetworks() []int32 {
	if m != nil {
		return m.TrunkedNetworks
	}
	return nil
}

func (m *VmNicConfig) GetType() VmNicType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_VmNicConfig_Type
}

func (m *VmNicConfig) GetPciSlot() int32 {
	if m != nil && m.PciSlot != nil {
		return *m.PciSlot
	}
	return 0
}

func (m *VmNicConfig) GetNetworkFunctionNicType() NetworkFunctionNicType {
	if m != nil && m.NetworkFunctionNicType != nil {
		return *m.NetworkFunctionNicType
	}
	return NetworkFunctionNicType_kIngress
}

func (m *VmNicConfig) GetNetworkFunctionChainUuid() []byte {
	if m != nil {
		return m.NetworkFunctionChainUuid
	}
	return nil
}

func (m *VmNicConfig) GetExternalAttrList() []*GenericKeyValuePair {
	if m != nil {
		return m.ExternalAttrList
	}
	return nil
}

func (m *VmNicConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmNicConfig) GetNetworkType() VmNicConfig_NetworkType {
	if m != nil && m.NetworkType != nil {
		return *m.NetworkType
	}
	return Default_VmNicConfig_NetworkType
}

func (m *VmNicConfig) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_VmNicConfig_Connected
}

func (m *VmNicConfig) GetQueues() uint32 {
	if m != nil && m.Queues != nil {
		return *m.Queues
	}
	return Default_VmNicConfig_Queues
}

func (m *VmNicConfig) GetRxQueueSize() uint32 {
	if m != nil && m.RxQueueSize != nil {
		return *m.RxQueueSize
	}
	return Default_VmNicConfig_RxQueueSize
}

type VmNicSpec struct {
	// The MAC address of the NIC. This field is required when creating a NIC on
	// a network of type kExternal.
	MacAddr []byte `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// The network to which the NIC is attached. This is a required field for
	// VmNicCreate.
	NetworkUuid []byte `protobuf:"bytes,2,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// The model string.
	Model *string `protobuf:"bytes,3,opt,name=model" json:"model,omitempty"`
	// The requested IP address. Only valid if 'request_ip' is true.
	RequestedIpAddress []byte `protobuf:"bytes,4,opt,name=requested_ip_address,json=requestedIpAddress" json:"requested_ip_address,omitempty"`
	// Vlan mode.
	VlanMode *VmNicVlanType `protobuf:"varint,5,opt,name=vlan_mode,json=vlanMode,enum=nutanix.acropolis.VmNicVlanType,def=1" json:"vlan_mode,omitempty"`
	// List of networks to trunk. Only valid if vlan_mode = kTrunked.
	// If trunked_network is empty, then it will trunk all vlan's.
	TrunkedNetworks []int32 `protobuf:"varint,6,rep,name=trunked_networks,json=trunkedNetworks" json:"trunked_networks,omitempty"`
	// If request_ip is true
	//   If 'requested_ip_address' is set then request that IP from the network.
	//   If it's a managed network then request a dynamic IP from the network.
	//   Otherwise don't request an IP
	// If request_ip is false, then don't request an IP at all, regardless of
	// whether the network is managed or not.
	RequestIp *bool      `protobuf:"varint,7,opt,name=request_ip,json=requestIp,def=1" json:"request_ip,omitempty"`
	Type      *VmNicType `protobuf:"varint,8,opt,name=type,enum=nutanix.acropolis.VmNicType,def=1" json:"type,omitempty"`
	// UUID of the network function chain to use for this NIC.
	NetworkFunctionChainUuid []byte `protobuf:"bytes,10,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// The PCI slot where the nic is attached. Note that this field is not meant
	// to be exposed through the REST API or exposed directly to the client. This
	// field should only be used for restoring the VM.
	PciSlot *int32 `protobuf:"varint,11,opt,name=pci_slot,json=pciSlot" json:"pci_slot,omitempty"`
	// This is valid only if the nic type is kNetworkFunctionNic.
	NetworkFunctionNicType *NetworkFunctionNicType `protobuf:"varint,12,opt,name=network_function_nic_type,json=networkFunctionNicType,enum=nutanix.acropolis.NetworkFunctionNicType" json:"network_function_nic_type,omitempty"`
	// If this port is managed by an external controller, these are the
	// external attributes for the port.
	ExternalAttrList []*GenericKeyValuePair `protobuf:"bytes,13,rep,name=external_attr_list,json=externalAttrList" json:"external_attr_list,omitempty"`
	// A UUID to be assigned to the newly created virtual NIC.
	NicUuid []byte `protobuf:"bytes,14,opt,name=nic_uuid,json=nicUuid" json:"nic_uuid,omitempty"`
	// Whether or not the NIC is connected.
	Connected *bool `protobuf:"varint,15,opt,name=connected,def=1" json:"connected,omitempty"`
	// Maximum number of Tx/Rx queue pairs for this NIC.
	Queues *uint32 `protobuf:"varint,16,opt,name=queues,def=1" json:"queues,omitempty"`
	// Maximum rx queue depth.
	RxQueueSize *uint32 `protobuf:"varint,17,opt,name=rx_queue_size,json=rxQueueSize,def=256" json:"rx_queue_size,omitempty"`
	// The "virtual_nic" entity incarnation ID as found in IDF.
	DbIncarnationId      *uint64  `protobuf:"varint,18,opt,name=db_incarnation_id,json=dbIncarnationId" json:"db_incarnation_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmNicSpec) Reset()         { *m = VmNicSpec{} }
func (m *VmNicSpec) String() string { return proto.CompactTextString(m) }
func (*VmNicSpec) ProtoMessage()    {}
func (*VmNicSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{32}
}

func (m *VmNicSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNicSpec.Unmarshal(m, b)
}
func (m *VmNicSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNicSpec.Marshal(b, m, deterministic)
}
func (m *VmNicSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNicSpec.Merge(m, src)
}
func (m *VmNicSpec) XXX_Size() int {
	return xxx_messageInfo_VmNicSpec.Size(m)
}
func (m *VmNicSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNicSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmNicSpec proto.InternalMessageInfo

const Default_VmNicSpec_VlanMode VmNicVlanType = VmNicVlanType_kAccess
const Default_VmNicSpec_RequestIp bool = true
const Default_VmNicSpec_Type VmNicType = VmNicType_kNormalNic
const Default_VmNicSpec_Connected bool = true
const Default_VmNicSpec_Queues uint32 = 1
const Default_VmNicSpec_RxQueueSize uint32 = 256

func (m *VmNicSpec) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *VmNicSpec) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *VmNicSpec) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *VmNicSpec) GetRequestedIpAddress() []byte {
	if m != nil {
		return m.RequestedIpAddress
	}
	return nil
}

func (m *VmNicSpec) GetVlanMode() VmNicVlanType {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return Default_VmNicSpec_VlanMode
}

func (m *VmNicSpec) GetTrunkedNetworks() []int32 {
	if m != nil {
		return m.TrunkedNetworks
	}
	return nil
}

func (m *VmNicSpec) GetRequestIp() bool {
	if m != nil && m.RequestIp != nil {
		return *m.RequestIp
	}
	return Default_VmNicSpec_RequestIp
}

func (m *VmNicSpec) GetType() VmNicType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_VmNicSpec_Type
}

func (m *VmNicSpec) GetNetworkFunctionChainUuid() []byte {
	if m != nil {
		return m.NetworkFunctionChainUuid
	}
	return nil
}

func (m *VmNicSpec) GetPciSlot() int32 {
	if m != nil && m.PciSlot != nil {
		return *m.PciSlot
	}
	return 0
}

func (m *VmNicSpec) GetNetworkFunctionNicType() NetworkFunctionNicType {
	if m != nil && m.NetworkFunctionNicType != nil {
		return *m.NetworkFunctionNicType
	}
	return NetworkFunctionNicType_kIngress
}

func (m *VmNicSpec) GetExternalAttrList() []*GenericKeyValuePair {
	if m != nil {
		return m.ExternalAttrList
	}
	return nil
}

func (m *VmNicSpec) GetNicUuid() []byte {
	if m != nil {
		return m.NicUuid
	}
	return nil
}

func (m *VmNicSpec) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_VmNicSpec_Connected
}

func (m *VmNicSpec) GetQueues() uint32 {
	if m != nil && m.Queues != nil {
		return *m.Queues
	}
	return Default_VmNicSpec_Queues
}

func (m *VmNicSpec) GetRxQueueSize() uint32 {
	if m != nil && m.RxQueueSize != nil {
		return *m.RxQueueSize
	}
	return Default_VmNicSpec_RxQueueSize
}

func (m *VmNicSpec) GetDbIncarnationId() uint64 {
	if m != nil && m.DbIncarnationId != nil {
		return *m.DbIncarnationId
	}
	return 0
}

//-----------------------------------------------------------------------------
type VmNicUpdateSpec struct {
	// The MAC address of the NIC to update.
	MacAddr []byte `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// The network to change the NIC to update to. If this field is empty, then
	// don't change the network. Cannot change network while the VM is on.
	NetworkUuid []byte `protobuf:"bytes,2,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// If the nic is being moved to a new network, the request_ip semantics are
	// the same as VmNicCreateSpec and are as follows:
	//  - if the new network is unmanaged, release the current IP.
	//  - if the new network is managed, release the current IP and:
	//    - if request_ip is False, don't assign an IP on the new network at all.
	//    - if request_ip is True, either assign the `requested_ip_address' or
	//      assign a dynamic one if requested_ip_address is not specified.
	// Note: if the caller has not explicitly set request_ip when moving to a new
	// network, it'll be assumed to be set to True.
	//
	// If the nic remains on the same network:
	//  - if request_ip is not explicitly specified, then don't change current
	//    IP assignment.
	//  - if request_ip is set to False, then release current IP.
	//  - if request_ip is set to True, release current IP and either assign the
	//    `requested_ip_address' or assign a new dynamic one if
	//    requested_ip_address is not specified.
	//
	// Cannot request a new IP if the VM is on.
	RequestIp *bool `protobuf:"varint,3,opt,name=request_ip,json=requestIp" json:"request_ip,omitempty"`
	// The requested IP address. Only valid if request_ip = True. If this field
	// is empty and request_ip is true, then request a dynamic IP address from
	// Acropolis server.
	RequestedIpAddress []byte `protobuf:"bytes,4,opt,name=requested_ip_address,json=requestedIpAddress" json:"requested_ip_address,omitempty"`
	// If this is true, then change the vlan_mode and trunked_networks. Otherwise
	// these remain unchanged.
	ChangeVlanInfo *bool `protobuf:"varint,5,opt,name=change_vlan_info,json=changeVlanInfo" json:"change_vlan_info,omitempty"`
	// Vlan mode.
	VlanMode *VmNicVlanType `protobuf:"varint,6,opt,name=vlan_mode,json=vlanMode,enum=nutanix.acropolis.VmNicVlanType,def=1" json:"vlan_mode,omitempty"`
	// List of networks to trunk. Only valid if vlan_mode = kTrunked.
	// If trunked_network is empty, then it will trunk all vlan's.
	TrunkedNetworks []int32 `protobuf:"varint,7,rep,name=trunked_networks,json=trunkedNetworks" json:"trunked_networks,omitempty"`
	// UUID of the network function chain to use for this NIC.
	NetworkFunctionChainUuid []byte `protobuf:"bytes,8,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// If this is true then update the network_function_chain_uuid field.
	UpdateNetworkFunctionChainUuid *bool `protobuf:"varint,9,opt,name=update_network_function_chain_uuid,json=updateNetworkFunctionChainUuid" json:"update_network_function_chain_uuid,omitempty"`
	// If this port is managed by an external controller, these are the
	// external attributes for the port. A particular identifier may be cleared
	// by specifying its key with an unset value.
	ExternalAttrList []*GenericKeyValuePair `protobuf:"bytes,10,rep,name=external_attr_list,json=externalAttrList" json:"external_attr_list,omitempty"`
	// NIC type to change to. Can change between kNormal and kDirect nics, even
	// when the VM is powered on. Cannot change between kNetworkFunction and
	// either kNormal and kDirect.
	Type *VmNicType `protobuf:"varint,11,opt,name=type,enum=nutanix.acropolis.VmNicType" json:"type,omitempty"`
	// The UUID of the virtual NIC to be updated.
	NicUuid []byte `protobuf:"bytes,12,opt,name=nic_uuid,json=nicUuid" json:"nic_uuid,omitempty"`
	// Whether or not the NIC is connected.
	Connected *bool `protobuf:"varint,13,opt,name=connected" json:"connected,omitempty"`
	// Maximum number of Tx/Rx queue pairs for this NIC.
	Queues *uint32 `protobuf:"varint,14,opt,name=queues,def=1" json:"queues,omitempty"`
	// Maximum rx queue depth.
	RxQueueSize          *uint32  `protobuf:"varint,15,opt,name=rx_queue_size,json=rxQueueSize,def=256" json:"rx_queue_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmNicUpdateSpec) Reset()         { *m = VmNicUpdateSpec{} }
func (m *VmNicUpdateSpec) String() string { return proto.CompactTextString(m) }
func (*VmNicUpdateSpec) ProtoMessage()    {}
func (*VmNicUpdateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{33}
}

func (m *VmNicUpdateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNicUpdateSpec.Unmarshal(m, b)
}
func (m *VmNicUpdateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNicUpdateSpec.Marshal(b, m, deterministic)
}
func (m *VmNicUpdateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNicUpdateSpec.Merge(m, src)
}
func (m *VmNicUpdateSpec) XXX_Size() int {
	return xxx_messageInfo_VmNicUpdateSpec.Size(m)
}
func (m *VmNicUpdateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNicUpdateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmNicUpdateSpec proto.InternalMessageInfo

const Default_VmNicUpdateSpec_VlanMode VmNicVlanType = VmNicVlanType_kAccess
const Default_VmNicUpdateSpec_Queues uint32 = 1
const Default_VmNicUpdateSpec_RxQueueSize uint32 = 256

func (m *VmNicUpdateSpec) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *VmNicUpdateSpec) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *VmNicUpdateSpec) GetRequestIp() bool {
	if m != nil && m.RequestIp != nil {
		return *m.RequestIp
	}
	return false
}

func (m *VmNicUpdateSpec) GetRequestedIpAddress() []byte {
	if m != nil {
		return m.RequestedIpAddress
	}
	return nil
}

func (m *VmNicUpdateSpec) GetChangeVlanInfo() bool {
	if m != nil && m.ChangeVlanInfo != nil {
		return *m.ChangeVlanInfo
	}
	return false
}

func (m *VmNicUpdateSpec) GetVlanMode() VmNicVlanType {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return Default_VmNicUpdateSpec_VlanMode
}

func (m *VmNicUpdateSpec) GetTrunkedNetworks() []int32 {
	if m != nil {
		return m.TrunkedNetworks
	}
	return nil
}

func (m *VmNicUpdateSpec) GetNetworkFunctionChainUuid() []byte {
	if m != nil {
		return m.NetworkFunctionChainUuid
	}
	return nil
}

func (m *VmNicUpdateSpec) GetUpdateNetworkFunctionChainUuid() bool {
	if m != nil && m.UpdateNetworkFunctionChainUuid != nil {
		return *m.UpdateNetworkFunctionChainUuid
	}
	return false
}

func (m *VmNicUpdateSpec) GetExternalAttrList() []*GenericKeyValuePair {
	if m != nil {
		return m.ExternalAttrList
	}
	return nil
}

func (m *VmNicUpdateSpec) GetType() VmNicType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VmNicType_kNormalNic
}

func (m *VmNicUpdateSpec) GetNicUuid() []byte {
	if m != nil {
		return m.NicUuid
	}
	return nil
}

func (m *VmNicUpdateSpec) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return false
}

func (m *VmNicUpdateSpec) GetQueues() uint32 {
	if m != nil && m.Queues != nil {
		return *m.Queues
	}
	return Default_VmNicUpdateSpec_Queues
}

func (m *VmNicUpdateSpec) GetRxQueueSize() uint32 {
	if m != nil && m.RxQueueSize != nil {
		return *m.RxQueueSize
	}
	return Default_VmNicUpdateSpec_RxQueueSize
}

type VmSerialPortConfig struct {
	// The serial port index. Generally limited to the range [0..3],
	// coresponding to COM1 through COM4.
	Index                *int32                   `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Type                 *VmSerialPortConfig_Type `protobuf:"varint,2,opt,name=type,enum=nutanix.acropolis.VmSerialPortConfig_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *VmSerialPortConfig) Reset()         { *m = VmSerialPortConfig{} }
func (m *VmSerialPortConfig) String() string { return proto.CompactTextString(m) }
func (*VmSerialPortConfig) ProtoMessage()    {}
func (*VmSerialPortConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{34}
}

func (m *VmSerialPortConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSerialPortConfig.Unmarshal(m, b)
}
func (m *VmSerialPortConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSerialPortConfig.Marshal(b, m, deterministic)
}
func (m *VmSerialPortConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSerialPortConfig.Merge(m, src)
}
func (m *VmSerialPortConfig) XXX_Size() int {
	return xxx_messageInfo_VmSerialPortConfig.Size(m)
}
func (m *VmSerialPortConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSerialPortConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmSerialPortConfig proto.InternalMessageInfo

func (m *VmSerialPortConfig) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *VmSerialPortConfig) GetType() VmSerialPortConfig_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VmSerialPortConfig_kNull
}

type VmGPUConfig struct {
	// Type of the GPU resource.
	Type *GPUType `protobuf:"varint,1,opt,name=type,enum=nutanix.acropolis.GPUType" json:"type,omitempty"`
	// Device ID of GPU resource.
	DeviceId *int32 `protobuf:"varint,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Vendor of GPU resource.
	Vendor *GPUVendor `protobuf:"varint,3,opt,name=vendor,enum=nutanix.acropolis.GPUVendor" json:"vendor,omitempty"`
	// Extra parameters for vGPU resource.
	ExtraParam *string `protobuf:"bytes,4,opt,name=extra_param,json=extraParam" json:"extra_param,omitempty"`
	// UUID associated with the vGPU resource.
	VgpuUuid             []byte   `protobuf:"bytes,5,opt,name=vgpu_uuid,json=vgpuUuid" json:"vgpu_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmGPUConfig) Reset()         { *m = VmGPUConfig{} }
func (m *VmGPUConfig) String() string { return proto.CompactTextString(m) }
func (*VmGPUConfig) ProtoMessage()    {}
func (*VmGPUConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{35}
}

func (m *VmGPUConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmGPUConfig.Unmarshal(m, b)
}
func (m *VmGPUConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmGPUConfig.Marshal(b, m, deterministic)
}
func (m *VmGPUConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmGPUConfig.Merge(m, src)
}
func (m *VmGPUConfig) XXX_Size() int {
	return xxx_messageInfo_VmGPUConfig.Size(m)
}
func (m *VmGPUConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmGPUConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmGPUConfig proto.InternalMessageInfo

func (m *VmGPUConfig) GetType() GPUType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return GPUType_kPassthroughGraphics
}

func (m *VmGPUConfig) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return 0
}

func (m *VmGPUConfig) GetVendor() GPUVendor {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return GPUVendor_kNvidia
}

func (m *VmGPUConfig) GetExtraParam() string {
	if m != nil && m.ExtraParam != nil {
		return *m.ExtraParam
	}
	return ""
}

func (m *VmGPUConfig) GetVgpuUuid() []byte {
	if m != nil {
		return m.VgpuUuid
	}
	return nil
}

type NodeGPU struct {
	// GPU type.
	Type *GPUType `protobuf:"varint,1,opt,name=type,enum=nutanix.acropolis.GPUType" json:"type,omitempty"`
	// Device ID of GPU.
	DeviceId *int32 `protobuf:"varint,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Vendor of GPU.
	Vendor *GPUVendor `protobuf:"varint,3,opt,name=vendor,enum=nutanix.acropolis.GPUVendor" json:"vendor,omitempty"`
	// Vendor Device string.
	DeviceName *string `protobuf:"bytes,4,opt,name=device_name,json=deviceName" json:"device_name,omitempty"`
	// Whether the GPU resource is in use or not.
	InUse *int32 `protobuf:"varint,5,opt,name=in_use,json=inUse" json:"in_use,omitempty"`
	// Physical device location in host.
	// SBDF string must be in format: ffff:ff:ff.f
	Sbdf *string `protobuf:"bytes,6,opt,name=sbdf" json:"sbdf,omitempty"`
	// NUMA node GPU belongs to.
	NumaNode *int32 `protobuf:"varint,7,opt,name=numa_node,json=numaNode" json:"numa_node,omitempty"`
	// Whether this GPU can be assigned to a VM.
	Assignable *bool `protobuf:"varint,8,opt,name=assignable" json:"assignable,omitempty"`
	// Index of GPU if part of a set, field not valid on pGPU.
	Index *uint32 `protobuf:"varint,9,opt,name=index" json:"index,omitempty"`
	// UUID of GPU.
	Uuid *string `protobuf:"bytes,10,opt,name=uuid" json:"uuid,omitempty"`
	// Unique ID string, SBDF is not unique when vGPU resources are available.
	Id *string `protobuf:"bytes,11,opt,name=id" json:"id,omitempty"`
	// Number of allocated vGPUs for a particular pGPU, field not valid on vGPU.
	NumVgpusAllocated *uint32 `protobuf:"varint,12,opt,name=num_vgpus_allocated,json=numVgpusAllocated" json:"num_vgpus_allocated,omitempty"`
	// Maximum potential vGPUs for a particular pGPU, field not valid on vGPU.
	MaxAllocatable *uint32 `protobuf:"varint,13,opt,name=max_allocatable,json=maxAllocatable" json:"max_allocatable,omitempty"`
	// Maximum framebuffer GPU in MiB.
	MaxFramebufferMb *uint32 `protobuf:"varint,14,opt,name=max_framebuffer_mb,json=maxFramebufferMb" json:"max_framebuffer_mb,omitempty"`
	// GPU compute usage in PPM.
	GpuUsagePpm *int64 `protobuf:"varint,15,opt,name=gpu_usage_ppm,json=gpuUsagePpm" json:"gpu_usage_ppm,omitempty"`
	// Minimum fraction this GPU resource has of physical GPU.
	MinFraction *uint32 `protobuf:"varint,16,opt,name=min_fraction,json=minFraction" json:"min_fraction,omitempty"`
	// Number of display heads available supported.
	NumDisplayHeads *uint32 `protobuf:"varint,17,opt,name=num_display_heads,json=numDisplayHeads" json:"num_display_heads,omitempty"`
	// Resolution per display head (X by Y).
	ResolutionPerDisplayHead *string `protobuf:"bytes,18,opt,name=resolution_per_display_head,json=resolutionPerDisplayHead" json:"resolution_per_display_head,omitempty"`
	// Detected guest GPU driver version, field not valid on pGPU.
	GuestDriverVersion *string `protobuf:"bytes,19,opt,name=guest_driver_version,json=guestDriverVersion" json:"guest_driver_version,omitempty"`
	// Current framebuffer usage in PPM.
	FramebufferUsagePpm *int64 `protobuf:"varint,20,opt,name=framebuffer_usage_ppm,json=framebufferUsagePpm" json:"framebuffer_usage_ppm,omitempty"`
	// List of licenses which can be used for this GPU resource.
	Licenses []string `protobuf:"bytes,21,rep,name=licenses" json:"licenses,omitempty"`
	// Current Video Encoder usage in PPM.
	EncoderUsagePpm *int64 `protobuf:"varint,22,opt,name=encoder_usage_ppm,json=encoderUsagePpm" json:"encoder_usage_ppm,omitempty"`
	// Current Video Decoder usage in PPM.
	DecoderUsagePpm *int64 `protobuf:"varint,23,opt,name=decoder_usage_ppm,json=decoderUsagePpm" json:"decoder_usage_ppm,omitempty"`
	// Current mode of pGPU, field not valid on vGPU resources.
	Mode *GPUMode `protobuf:"varint,24,opt,name=mode,enum=nutanix.acropolis.GPUMode" json:"mode,omitempty"`
	// List VM UUIDs currently using this GPU resource.
	VmUuidList [][]byte `protobuf:"bytes,25,rep,name=vm_uuid_list,json=vmUuidList" json:"vm_uuid_list,omitempty"`
	// Extra parameters for vGPU resource.
	ExtraParam *string `protobuf:"bytes,26,opt,name=extra_param,json=extraParam" json:"extra_param,omitempty"`
	// Maximum number of vGPU instances of this kind that can be assigned to a VM.
	MaxInstancesPerVm *uint32 `protobuf:"varint,27,opt,name=max_instances_per_vm,json=maxInstancesPerVm" json:"max_instances_per_vm,omitempty"`
	// GPU driver metadata associated with the GPU instance.
	Metadata *string `protobuf:"bytes,28,opt,name=metadata" json:"metadata,omitempty"`
	// vGPU uuid associated with specific device id.
	VgpuUuid             []byte   `protobuf:"bytes,29,opt,name=vgpu_uuid,json=vgpuUuid" json:"vgpu_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeGPU) Reset()         { *m = NodeGPU{} }
func (m *NodeGPU) String() string { return proto.CompactTextString(m) }
func (*NodeGPU) ProtoMessage()    {}
func (*NodeGPU) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{36}
}

func (m *NodeGPU) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeGPU.Unmarshal(m, b)
}
func (m *NodeGPU) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeGPU.Marshal(b, m, deterministic)
}
func (m *NodeGPU) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeGPU.Merge(m, src)
}
func (m *NodeGPU) XXX_Size() int {
	return xxx_messageInfo_NodeGPU.Size(m)
}
func (m *NodeGPU) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeGPU.DiscardUnknown(m)
}

var xxx_messageInfo_NodeGPU proto.InternalMessageInfo

func (m *NodeGPU) GetType() GPUType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return GPUType_kPassthroughGraphics
}

func (m *NodeGPU) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return 0
}

func (m *NodeGPU) GetVendor() GPUVendor {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return GPUVendor_kNvidia
}

func (m *NodeGPU) GetDeviceName() string {
	if m != nil && m.DeviceName != nil {
		return *m.DeviceName
	}
	return ""
}

func (m *NodeGPU) GetInUse() int32 {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return 0
}

func (m *NodeGPU) GetSbdf() string {
	if m != nil && m.Sbdf != nil {
		return *m.Sbdf
	}
	return ""
}

func (m *NodeGPU) GetNumaNode() int32 {
	if m != nil && m.NumaNode != nil {
		return *m.NumaNode
	}
	return 0
}

func (m *NodeGPU) GetAssignable() bool {
	if m != nil && m.Assignable != nil {
		return *m.Assignable
	}
	return false
}

func (m *NodeGPU) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *NodeGPU) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *NodeGPU) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *NodeGPU) GetNumVgpusAllocated() uint32 {
	if m != nil && m.NumVgpusAllocated != nil {
		return *m.NumVgpusAllocated
	}
	return 0
}

func (m *NodeGPU) GetMaxAllocatable() uint32 {
	if m != nil && m.MaxAllocatable != nil {
		return *m.MaxAllocatable
	}
	return 0
}

func (m *NodeGPU) GetMaxFramebufferMb() uint32 {
	if m != nil && m.MaxFramebufferMb != nil {
		return *m.MaxFramebufferMb
	}
	return 0
}

func (m *NodeGPU) GetGpuUsagePpm() int64 {
	if m != nil && m.GpuUsagePpm != nil {
		return *m.GpuUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetMinFraction() uint32 {
	if m != nil && m.MinFraction != nil {
		return *m.MinFraction
	}
	return 0
}

func (m *NodeGPU) GetNumDisplayHeads() uint32 {
	if m != nil && m.NumDisplayHeads != nil {
		return *m.NumDisplayHeads
	}
	return 0
}

func (m *NodeGPU) GetResolutionPerDisplayHead() string {
	if m != nil && m.ResolutionPerDisplayHead != nil {
		return *m.ResolutionPerDisplayHead
	}
	return ""
}

func (m *NodeGPU) GetGuestDriverVersion() string {
	if m != nil && m.GuestDriverVersion != nil {
		return *m.GuestDriverVersion
	}
	return ""
}

func (m *NodeGPU) GetFramebufferUsagePpm() int64 {
	if m != nil && m.FramebufferUsagePpm != nil {
		return *m.FramebufferUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetLicenses() []string {
	if m != nil {
		return m.Licenses
	}
	return nil
}

func (m *NodeGPU) GetEncoderUsagePpm() int64 {
	if m != nil && m.EncoderUsagePpm != nil {
		return *m.EncoderUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetDecoderUsagePpm() int64 {
	if m != nil && m.DecoderUsagePpm != nil {
		return *m.DecoderUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetMode() GPUMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return GPUMode_kUnused
}

func (m *NodeGPU) GetVmUuidList() [][]byte {
	if m != nil {
		return m.VmUuidList
	}
	return nil
}

func (m *NodeGPU) GetExtraParam() string {
	if m != nil && m.ExtraParam != nil {
		return *m.ExtraParam
	}
	return ""
}

func (m *NodeGPU) GetMaxInstancesPerVm() uint32 {
	if m != nil && m.MaxInstancesPerVm != nil {
		return *m.MaxInstancesPerVm
	}
	return 0
}

func (m *NodeGPU) GetMetadata() string {
	if m != nil && m.Metadata != nil {
		return *m.Metadata
	}
	return ""
}

func (m *NodeGPU) GetVgpuUuid() []byte {
	if m != nil {
		return m.VgpuUuid
	}
	return nil
}

//------------------------------------------------------------------------------
// A network mapping consists of L2 network (VLAN) mappings and L3 network
// mappings between the primary and the secondary clusters.
type NetworkMapping struct {
	// L2 network mapping.
	L2Mapping *NetworkMapping_L2NetworkMapping `protobuf:"bytes,1,opt,name=l2_mapping,json=l2Mapping" json:"l2_mapping,omitempty"`
	// L3 network mapping.
	L3Mapping            *NetworkMapping_L3NetworkMapping `protobuf:"bytes,2,opt,name=l3_mapping,json=l3Mapping" json:"l3_mapping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *NetworkMapping) Reset()         { *m = NetworkMapping{} }
func (m *NetworkMapping) String() string { return proto.CompactTextString(m) }
func (*NetworkMapping) ProtoMessage()    {}
func (*NetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{37}
}

func (m *NetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkMapping.Unmarshal(m, b)
}
func (m *NetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkMapping.Marshal(b, m, deterministic)
}
func (m *NetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMapping.Merge(m, src)
}
func (m *NetworkMapping) XXX_Size() int {
	return xxx_messageInfo_NetworkMapping.Size(m)
}
func (m *NetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMapping proto.InternalMessageInfo

func (m *NetworkMapping) GetL2Mapping() *NetworkMapping_L2NetworkMapping {
	if m != nil {
		return m.L2Mapping
	}
	return nil
}

func (m *NetworkMapping) GetL3Mapping() *NetworkMapping_L3NetworkMapping {
	if m != nil {
		return m.L3Mapping
	}
	return nil
}

// Mapping from primary network UUID to secondary network UUID.
type NetworkMapping_L2NetworkMapping struct {
	// The UUID of the network on the primary cluster.
	PriNetworkUuid []byte `protobuf:"bytes,1,opt,name=pri_network_uuid,json=priNetworkUuid" json:"pri_network_uuid,omitempty"`
	// The UUID of the network on the secondary cluster.
	SecNetworkUuid       []byte   `protobuf:"bytes,2,opt,name=sec_network_uuid,json=secNetworkUuid" json:"sec_network_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkMapping_L2NetworkMapping) Reset()         { *m = NetworkMapping_L2NetworkMapping{} }
func (m *NetworkMapping_L2NetworkMapping) String() string { return proto.CompactTextString(m) }
func (*NetworkMapping_L2NetworkMapping) ProtoMessage()    {}
func (*NetworkMapping_L2NetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{37, 0}
}

func (m *NetworkMapping_L2NetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkMapping_L2NetworkMapping.Unmarshal(m, b)
}
func (m *NetworkMapping_L2NetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkMapping_L2NetworkMapping.Marshal(b, m, deterministic)
}
func (m *NetworkMapping_L2NetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMapping_L2NetworkMapping.Merge(m, src)
}
func (m *NetworkMapping_L2NetworkMapping) XXX_Size() int {
	return xxx_messageInfo_NetworkMapping_L2NetworkMapping.Size(m)
}
func (m *NetworkMapping_L2NetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMapping_L2NetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMapping_L2NetworkMapping proto.InternalMessageInfo

func (m *NetworkMapping_L2NetworkMapping) GetPriNetworkUuid() []byte {
	if m != nil {
		return m.PriNetworkUuid
	}
	return nil
}

func (m *NetworkMapping_L2NetworkMapping) GetSecNetworkUuid() []byte {
	if m != nil {
		return m.SecNetworkUuid
	}
	return nil
}

// IP address pool mapping between the primary and the secondary cluster.
type NetworkMapping_L3NetworkMapping struct {
	AddressMapping       []*NetworkMapping_L3NetworkMapping_AddressMapping `protobuf:"bytes,1,rep,name=address_mapping,json=addressMapping" json:"address_mapping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                          `json:"-"`
	XXX_unrecognized     []byte                                            `json:"-"`
	XXX_sizecache        int32                                             `json:"-"`
}

func (m *NetworkMapping_L3NetworkMapping) Reset()         { *m = NetworkMapping_L3NetworkMapping{} }
func (m *NetworkMapping_L3NetworkMapping) String() string { return proto.CompactTextString(m) }
func (*NetworkMapping_L3NetworkMapping) ProtoMessage()    {}
func (*NetworkMapping_L3NetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{37, 1}
}

func (m *NetworkMapping_L3NetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkMapping_L3NetworkMapping.Unmarshal(m, b)
}
func (m *NetworkMapping_L3NetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkMapping_L3NetworkMapping.Marshal(b, m, deterministic)
}
func (m *NetworkMapping_L3NetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMapping_L3NetworkMapping.Merge(m, src)
}
func (m *NetworkMapping_L3NetworkMapping) XXX_Size() int {
	return xxx_messageInfo_NetworkMapping_L3NetworkMapping.Size(m)
}
func (m *NetworkMapping_L3NetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMapping_L3NetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMapping_L3NetworkMapping proto.InternalMessageInfo

func (m *NetworkMapping_L3NetworkMapping) GetAddressMapping() []*NetworkMapping_L3NetworkMapping_AddressMapping {
	if m != nil {
		return m.AddressMapping
	}
	return nil
}

// Specify IP pool mapping from primary to secondary networks.
type NetworkMapping_L3NetworkMapping_AddressMapping struct {
	// Primary network address pool starting IP address, inclusively.
	PriStartIpAddress []byte `protobuf:"bytes,1,opt,name=pri_start_ip_address,json=priStartIpAddress" json:"pri_start_ip_address,omitempty"`
	// Primary network address pool ending IP address, inclusively.
	PriEndIpAddress []byte `protobuf:"bytes,2,opt,name=pri_end_ip_address,json=priEndIpAddress" json:"pri_end_ip_address,omitempty"`
	// Secondary network address pool starting IP address, inclusively.
	// Secondary network IP pool size must be the same as that of primary.
	SecStartIpAddress    []byte   `protobuf:"bytes,3,opt,name=sec_start_ip_address,json=secStartIpAddress" json:"sec_start_ip_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkMapping_L3NetworkMapping_AddressMapping) Reset() {
	*m = NetworkMapping_L3NetworkMapping_AddressMapping{}
}
func (m *NetworkMapping_L3NetworkMapping_AddressMapping) String() string {
	return proto.CompactTextString(m)
}
func (*NetworkMapping_L3NetworkMapping_AddressMapping) ProtoMessage() {}
func (*NetworkMapping_L3NetworkMapping_AddressMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{37, 1, 0}
}

func (m *NetworkMapping_L3NetworkMapping_AddressMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkMapping_L3NetworkMapping_AddressMapping.Unmarshal(m, b)
}
func (m *NetworkMapping_L3NetworkMapping_AddressMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkMapping_L3NetworkMapping_AddressMapping.Marshal(b, m, deterministic)
}
func (m *NetworkMapping_L3NetworkMapping_AddressMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMapping_L3NetworkMapping_AddressMapping.Merge(m, src)
}
func (m *NetworkMapping_L3NetworkMapping_AddressMapping) XXX_Size() int {
	return xxx_messageInfo_NetworkMapping_L3NetworkMapping_AddressMapping.Size(m)
}
func (m *NetworkMapping_L3NetworkMapping_AddressMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMapping_L3NetworkMapping_AddressMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMapping_L3NetworkMapping_AddressMapping proto.InternalMessageInfo

func (m *NetworkMapping_L3NetworkMapping_AddressMapping) GetPriStartIpAddress() []byte {
	if m != nil {
		return m.PriStartIpAddress
	}
	return nil
}

func (m *NetworkMapping_L3NetworkMapping_AddressMapping) GetPriEndIpAddress() []byte {
	if m != nil {
		return m.PriEndIpAddress
	}
	return nil
}

func (m *NetworkMapping_L3NetworkMapping_AddressMapping) GetSecStartIpAddress() []byte {
	if m != nil {
		return m.SecStartIpAddress
	}
	return nil
}

// This specifies the list of network mappings applicable for a recovery plan.
type RecoveryPlanNetworkMappings struct {
	// Recovery plan UUID.
	RecoveryPlanUuid []byte `protobuf:"bytes,1,opt,name=recovery_plan_uuid,json=recoveryPlanUuid" json:"recovery_plan_uuid,omitempty"`
	// A list of network mappings that specify how to map a NIC from primary
	// cluster to the secondary cluster.
	NetworkMappings      []*NetworkMapping `protobuf:"bytes,2,rep,name=network_mappings,json=networkMappings" json:"network_mappings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RecoveryPlanNetworkMappings) Reset()         { *m = RecoveryPlanNetworkMappings{} }
func (m *RecoveryPlanNetworkMappings) String() string { return proto.CompactTextString(m) }
func (*RecoveryPlanNetworkMappings) ProtoMessage()    {}
func (*RecoveryPlanNetworkMappings) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{38}
}

func (m *RecoveryPlanNetworkMappings) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecoveryPlanNetworkMappings.Unmarshal(m, b)
}
func (m *RecoveryPlanNetworkMappings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecoveryPlanNetworkMappings.Marshal(b, m, deterministic)
}
func (m *RecoveryPlanNetworkMappings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryPlanNetworkMappings.Merge(m, src)
}
func (m *RecoveryPlanNetworkMappings) XXX_Size() int {
	return xxx_messageInfo_RecoveryPlanNetworkMappings.Size(m)
}
func (m *RecoveryPlanNetworkMappings) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryPlanNetworkMappings.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryPlanNetworkMappings proto.InternalMessageInfo

func (m *RecoveryPlanNetworkMappings) GetRecoveryPlanUuid() []byte {
	if m != nil {
		return m.RecoveryPlanUuid
	}
	return nil
}

func (m *RecoveryPlanNetworkMappings) GetNetworkMappings() []*NetworkMapping {
	if m != nil {
		return m.NetworkMappings
	}
	return nil
}

// This specifies the mapping between the VM's MAC address and the
// corresponding tap device name.
type TapDeviceMapping struct {
	// The MAC address of the VM.
	MacAddress []byte `protobuf:"bytes,1,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// The corresponding tap device name created for the MAC address.
	TapDeviceName        *string  `protobuf:"bytes,2,opt,name=tap_device_name,json=tapDeviceName" json:"tap_device_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TapDeviceMapping) Reset()         { *m = TapDeviceMapping{} }
func (m *TapDeviceMapping) String() string { return proto.CompactTextString(m) }
func (*TapDeviceMapping) ProtoMessage()    {}
func (*TapDeviceMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{39}
}

func (m *TapDeviceMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TapDeviceMapping.Unmarshal(m, b)
}
func (m *TapDeviceMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TapDeviceMapping.Marshal(b, m, deterministic)
}
func (m *TapDeviceMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TapDeviceMapping.Merge(m, src)
}
func (m *TapDeviceMapping) XXX_Size() int {
	return xxx_messageInfo_TapDeviceMapping.Size(m)
}
func (m *TapDeviceMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_TapDeviceMapping.DiscardUnknown(m)
}

var xxx_messageInfo_TapDeviceMapping proto.InternalMessageInfo

func (m *TapDeviceMapping) GetMacAddress() []byte {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

func (m *TapDeviceMapping) GetTapDeviceName() string {
	if m != nil && m.TapDeviceName != nil {
		return *m.TapDeviceName
	}
	return ""
}

type VmSyncRepConfig struct {
	// Stretch params can be obtained from pithos using this key.
	StretchParamsId *stretch_params.StretchParams_UniversalId `protobuf:"bytes,1,opt,name=stretch_params_id,json=stretchParamsId" json:"stretch_params_id,omitempty"`
	// Stretch version.
	StretchVersion *stretch_params.StretchParams_UniversalId `protobuf:"bytes,2,opt,name=stretch_version,json=stretchVersion" json:"stretch_version,omitempty"`
	// A list of recovery plan network mappings that is applicable to this sync
	// rep enabled VM.
	RecoveryPlanNetworkMappings []*RecoveryPlanNetworkMappings `protobuf:"bytes,3,rep,name=recovery_plan_network_mappings,json=recoveryPlanNetworkMappings" json:"recovery_plan_network_mappings,omitempty"`
	XXX_NoUnkeyedLiteral        struct{}                       `json:"-"`
	XXX_unrecognized            []byte                         `json:"-"`
	XXX_sizecache               int32                          `json:"-"`
}

func (m *VmSyncRepConfig) Reset()         { *m = VmSyncRepConfig{} }
func (m *VmSyncRepConfig) String() string { return proto.CompactTextString(m) }
func (*VmSyncRepConfig) ProtoMessage()    {}
func (*VmSyncRepConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{40}
}

func (m *VmSyncRepConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSyncRepConfig.Unmarshal(m, b)
}
func (m *VmSyncRepConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSyncRepConfig.Marshal(b, m, deterministic)
}
func (m *VmSyncRepConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSyncRepConfig.Merge(m, src)
}
func (m *VmSyncRepConfig) XXX_Size() int {
	return xxx_messageInfo_VmSyncRepConfig.Size(m)
}
func (m *VmSyncRepConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSyncRepConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmSyncRepConfig proto.InternalMessageInfo

func (m *VmSyncRepConfig) GetStretchParamsId() *stretch_params.StretchParams_UniversalId {
	if m != nil {
		return m.StretchParamsId
	}
	return nil
}

func (m *VmSyncRepConfig) GetStretchVersion() *stretch_params.StretchParams_UniversalId {
	if m != nil {
		return m.StretchVersion
	}
	return nil
}

func (m *VmSyncRepConfig) GetRecoveryPlanNetworkMappings() []*RecoveryPlanNetworkMappings {
	if m != nil {
		return m.RecoveryPlanNetworkMappings
	}
	return nil
}

type VmState struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmState) Reset()         { *m = VmState{} }
func (m *VmState) String() string { return proto.CompactTextString(m) }
func (*VmState) ProtoMessage()    {}
func (*VmState) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{41}
}

func (m *VmState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmState.Unmarshal(m, b)
}
func (m *VmState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmState.Marshal(b, m, deterministic)
}
func (m *VmState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmState.Merge(m, src)
}
func (m *VmState) XXX_Size() int {
	return xxx_messageInfo_VmState.Size(m)
}
func (m *VmState) XXX_DiscardUnknown() {
	xxx_messageInfo_VmState.DiscardUnknown(m)
}

var xxx_messageInfo_VmState proto.InternalMessageInfo

type VmStateTransition struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmStateTransition) Reset()         { *m = VmStateTransition{} }
func (m *VmStateTransition) String() string { return proto.CompactTextString(m) }
func (*VmStateTransition) ProtoMessage()    {}
func (*VmStateTransition) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{42}
}

func (m *VmStateTransition) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmStateTransition.Unmarshal(m, b)
}
func (m *VmStateTransition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmStateTransition.Marshal(b, m, deterministic)
}
func (m *VmStateTransition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmStateTransition.Merge(m, src)
}
func (m *VmStateTransition) XXX_Size() int {
	return xxx_messageInfo_VmStateTransition.Size(m)
}
func (m *VmStateTransition) XXX_DiscardUnknown() {
	xxx_messageInfo_VmStateTransition.DiscardUnknown(m)
}

var xxx_messageInfo_VmStateTransition proto.InternalMessageInfo

type VmSnapshotTreeInfo struct {
	// VM UUID.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// List of links in the tree of snapshots for a particular VM.
	SnapshotLinkList []*VmSnapshotTreeInfo_SnapshotLink `protobuf:"bytes,2,rep,name=snapshot_link_list,json=snapshotLinkList" json:"snapshot_link_list,omitempty"`
	// The parent snapshot UUID for the VM.
	VmParentSnapshotUuid []byte `protobuf:"bytes,3,opt,name=vm_parent_snapshot_uuid,json=vmParentSnapshotUuid" json:"vm_parent_snapshot_uuid,omitempty"`
	// Logical timestamp used for consistency.
	LogicalTimestamp     *int64   `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmSnapshotTreeInfo) Reset()         { *m = VmSnapshotTreeInfo{} }
func (m *VmSnapshotTreeInfo) String() string { return proto.CompactTextString(m) }
func (*VmSnapshotTreeInfo) ProtoMessage()    {}
func (*VmSnapshotTreeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{43}
}

func (m *VmSnapshotTreeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSnapshotTreeInfo.Unmarshal(m, b)
}
func (m *VmSnapshotTreeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSnapshotTreeInfo.Marshal(b, m, deterministic)
}
func (m *VmSnapshotTreeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSnapshotTreeInfo.Merge(m, src)
}
func (m *VmSnapshotTreeInfo) XXX_Size() int {
	return xxx_messageInfo_VmSnapshotTreeInfo.Size(m)
}
func (m *VmSnapshotTreeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSnapshotTreeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmSnapshotTreeInfo proto.InternalMessageInfo

func (m *VmSnapshotTreeInfo) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *VmSnapshotTreeInfo) GetSnapshotLinkList() []*VmSnapshotTreeInfo_SnapshotLink {
	if m != nil {
		return m.SnapshotLinkList
	}
	return nil
}

func (m *VmSnapshotTreeInfo) GetVmParentSnapshotUuid() []byte {
	if m != nil {
		return m.VmParentSnapshotUuid
	}
	return nil
}

func (m *VmSnapshotTreeInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

// Parent-child link between snapshots.
type VmSnapshotTreeInfo_SnapshotLink struct {
	// Snapshot UUID.
	SnapshotUuid []byte `protobuf:"bytes,1,opt,name=snapshot_uuid,json=snapshotUuid" json:"snapshot_uuid,omitempty"`
	// Parent snapshot UUID.
	ParentSnapshotUuid []byte `protobuf:"bytes,2,opt,name=parent_snapshot_uuid,json=parentSnapshotUuid" json:"parent_snapshot_uuid,omitempty"`
	// Embedded snapshot information. This field may be populated in query
	// results, but is never populated in the entity that is stored to the
	// database.
	SnapshotInfo         *SnapshotInfo `protobuf:"bytes,3,opt,name=snapshot_info,json=snapshotInfo" json:"snapshot_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VmSnapshotTreeInfo_SnapshotLink) Reset()         { *m = VmSnapshotTreeInfo_SnapshotLink{} }
func (m *VmSnapshotTreeInfo_SnapshotLink) String() string { return proto.CompactTextString(m) }
func (*VmSnapshotTreeInfo_SnapshotLink) ProtoMessage()    {}
func (*VmSnapshotTreeInfo_SnapshotLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{43, 0}
}

func (m *VmSnapshotTreeInfo_SnapshotLink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSnapshotTreeInfo_SnapshotLink.Unmarshal(m, b)
}
func (m *VmSnapshotTreeInfo_SnapshotLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSnapshotTreeInfo_SnapshotLink.Marshal(b, m, deterministic)
}
func (m *VmSnapshotTreeInfo_SnapshotLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSnapshotTreeInfo_SnapshotLink.Merge(m, src)
}
func (m *VmSnapshotTreeInfo_SnapshotLink) XXX_Size() int {
	return xxx_messageInfo_VmSnapshotTreeInfo_SnapshotLink.Size(m)
}
func (m *VmSnapshotTreeInfo_SnapshotLink) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSnapshotTreeInfo_SnapshotLink.DiscardUnknown(m)
}

var xxx_messageInfo_VmSnapshotTreeInfo_SnapshotLink proto.InternalMessageInfo

func (m *VmSnapshotTreeInfo_SnapshotLink) GetSnapshotUuid() []byte {
	if m != nil {
		return m.SnapshotUuid
	}
	return nil
}

func (m *VmSnapshotTreeInfo_SnapshotLink) GetParentSnapshotUuid() []byte {
	if m != nil {
		return m.ParentSnapshotUuid
	}
	return nil
}

func (m *VmSnapshotTreeInfo_SnapshotLink) GetSnapshotInfo() *SnapshotInfo {
	if m != nil {
		return m.SnapshotInfo
	}
	return nil
}

type IPConfig struct {
	// Network address.
	NetworkAddress []byte `protobuf:"bytes,1,opt,name=network_address,json=networkAddress" json:"network_address,omitempty"`
	// Length of network prefix in number of bits.
	PrefixLength   *int32                    `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	RouteList      []*IPConfig_Route         `protobuf:"bytes,3,rep,name=route_list,json=routeList" json:"route_list,omitempty"`
	DhcpOptionList []*IPConfig_DHCPOption    `protobuf:"bytes,6,rep,name=dhcp_option_list,json=dhcpOptionList" json:"dhcp_option_list,omitempty"`
	IpPoolList     []*IPConfig_IpAddressPool `protobuf:"bytes,7,rep,name=ip_pool_list,json=ipPoolList" json:"ip_pool_list,omitempty"`
	// IP address of the DHCP server.
	DhcpServerAddress    []byte   `protobuf:"bytes,8,opt,name=dhcp_server_address,json=dhcpServerAddress" json:"dhcp_server_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig) Reset()         { *m = IPConfig{} }
func (m *IPConfig) String() string { return proto.CompactTextString(m) }
func (*IPConfig) ProtoMessage()    {}
func (*IPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{44}
}

func (m *IPConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig.Unmarshal(m, b)
}
func (m *IPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig.Marshal(b, m, deterministic)
}
func (m *IPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig.Merge(m, src)
}
func (m *IPConfig) XXX_Size() int {
	return xxx_messageInfo_IPConfig.Size(m)
}
func (m *IPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig proto.InternalMessageInfo

func (m *IPConfig) GetNetworkAddress() []byte {
	if m != nil {
		return m.NetworkAddress
	}
	return nil
}

func (m *IPConfig) GetPrefixLength() int32 {
	if m != nil && m.PrefixLength != nil {
		return *m.PrefixLength
	}
	return 0
}

func (m *IPConfig) GetRouteList() []*IPConfig_Route {
	if m != nil {
		return m.RouteList
	}
	return nil
}

func (m *IPConfig) GetDhcpOptionList() []*IPConfig_DHCPOption {
	if m != nil {
		return m.DhcpOptionList
	}
	return nil
}

func (m *IPConfig) GetIpPoolList() []*IPConfig_IpAddressPool {
	if m != nil {
		return m.IpPoolList
	}
	return nil
}

func (m *IPConfig) GetDhcpServerAddress() []byte {
	if m != nil {
		return m.DhcpServerAddress
	}
	return nil
}

// List of static routes, including the default gateway.
type IPConfig_Route struct {
	// IP address of desination.
	NetworkAddress []byte `protobuf:"bytes,1,opt,name=network_address,json=networkAddress" json:"network_address,omitempty"`
	// Length of network prefix in number of bits.
	PrefixLength *int32 `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	// Gateway IP address.
	Gateway              []byte   `protobuf:"bytes,3,opt,name=gateway" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig_Route) Reset()         { *m = IPConfig_Route{} }
func (m *IPConfig_Route) String() string { return proto.CompactTextString(m) }
func (*IPConfig_Route) ProtoMessage()    {}
func (*IPConfig_Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{44, 0}
}

func (m *IPConfig_Route) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig_Route.Unmarshal(m, b)
}
func (m *IPConfig_Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig_Route.Marshal(b, m, deterministic)
}
func (m *IPConfig_Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig_Route.Merge(m, src)
}
func (m *IPConfig_Route) XXX_Size() int {
	return xxx_messageInfo_IPConfig_Route.Size(m)
}
func (m *IPConfig_Route) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig_Route.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig_Route proto.InternalMessageInfo

func (m *IPConfig_Route) GetNetworkAddress() []byte {
	if m != nil {
		return m.NetworkAddress
	}
	return nil
}

func (m *IPConfig_Route) GetPrefixLength() int32 {
	if m != nil && m.PrefixLength != nil {
		return *m.PrefixLength
	}
	return 0
}

func (m *IPConfig_Route) GetGateway() []byte {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// Options passed along to client via DHCP. Consult RFC 2132 for how to
// encode and decode these.
type IPConfig_DHCPOption struct {
	// DHCP option code.
	OptionCode *int32 `protobuf:"varint,1,opt,name=option_code,json=optionCode" json:"option_code,omitempty"`
	// DHCP option value in network byte order.
	OptionValue          []byte   `protobuf:"bytes,2,opt,name=option_value,json=optionValue" json:"option_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig_DHCPOption) Reset()         { *m = IPConfig_DHCPOption{} }
func (m *IPConfig_DHCPOption) String() string { return proto.CompactTextString(m) }
func (*IPConfig_DHCPOption) ProtoMessage()    {}
func (*IPConfig_DHCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{44, 1}
}

func (m *IPConfig_DHCPOption) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig_DHCPOption.Unmarshal(m, b)
}
func (m *IPConfig_DHCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig_DHCPOption.Marshal(b, m, deterministic)
}
func (m *IPConfig_DHCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig_DHCPOption.Merge(m, src)
}
func (m *IPConfig_DHCPOption) XXX_Size() int {
	return xxx_messageInfo_IPConfig_DHCPOption.Size(m)
}
func (m *IPConfig_DHCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig_DHCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig_DHCPOption proto.InternalMessageInfo

func (m *IPConfig_DHCPOption) GetOptionCode() int32 {
	if m != nil && m.OptionCode != nil {
		return *m.OptionCode
	}
	return 0
}

func (m *IPConfig_DHCPOption) GetOptionValue() []byte {
	if m != nil {
		return m.OptionValue
	}
	return nil
}

// Dynamic IP address pools.
type IPConfig_IpAddressPool struct {
	StartAddress         []byte   `protobuf:"bytes,1,opt,name=start_address,json=startAddress" json:"start_address,omitempty"`
	EndAddress           []byte   `protobuf:"bytes,2,opt,name=end_address,json=endAddress" json:"end_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig_IpAddressPool) Reset()         { *m = IPConfig_IpAddressPool{} }
func (m *IPConfig_IpAddressPool) String() string { return proto.CompactTextString(m) }
func (*IPConfig_IpAddressPool) ProtoMessage()    {}
func (*IPConfig_IpAddressPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{44, 2}
}

func (m *IPConfig_IpAddressPool) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig_IpAddressPool.Unmarshal(m, b)
}
func (m *IPConfig_IpAddressPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig_IpAddressPool.Marshal(b, m, deterministic)
}
func (m *IPConfig_IpAddressPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig_IpAddressPool.Merge(m, src)
}
func (m *IPConfig_IpAddressPool) XXX_Size() int {
	return xxx_messageInfo_IPConfig_IpAddressPool.Size(m)
}
func (m *IPConfig_IpAddressPool) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig_IpAddressPool.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig_IpAddressPool proto.InternalMessageInfo

func (m *IPConfig_IpAddressPool) GetStartAddress() []byte {
	if m != nil {
		return m.StartAddress
	}
	return nil
}

func (m *IPConfig_IpAddressPool) GetEndAddress() []byte {
	if m != nil {
		return m.EndAddress
	}
	return nil
}

type NetworkConfig struct {
	// UUID of the network.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Whether the network has been deleted.
	Deleted *bool `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	// Logical timestamp of the network configuration.
	LogicalTimestamp *int64              `protobuf:"varint,3,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	Type             *NetworkConfig_Type `protobuf:"varint,4,opt,name=type,enum=nutanix.acropolis.NetworkConfig_Type,def=1" json:"type,omitempty"`
	// The network identifier, whose semantics depend on network type. This field
	// should not be set for networks of type kExternal.
	Identifier *int32 `protobuf:"varint,5,opt,name=identifier,def=0" json:"identifier,omitempty"`
	// For managed networks, this is the IP address database.
	IpConfig *IPConfig `protobuf:"bytes,6,opt,name=ip_config,json=ipConfig" json:"ip_config,omitempty"`
	// For overlay networks, whether to forward multicast traffic.
	ForwardMulticast *bool `protobuf:"varint,7,opt,name=forward_multicast,json=forwardMulticast" json:"forward_multicast,omitempty"`
	// Name of the vSwitch to attach to. We assume that all hypervisors in the
	// cluster has same way (e.g. a vSwitch named "foo" on one host has L2
	// connectivity to vSwitch named "foo" on every other host, and all VLANs
	// are truncked the same way).
	//
	// It is strongly recommended, but not enforced, that each externally-managed
	// network use a unique vswitch name.
	VswitchName *string `protobuf:"bytes,8,opt,name=vswitch_name,json=vswitchName" json:"vswitch_name,omitempty"`
	// MTU setting of a network.
	// User can overwrite MTU setting in NIC level inside guest VM.
	Mtu *int32 `protobuf:"varint,9,opt,name=mtu" json:"mtu,omitempty"`
	// The network's human-readable name.
	Name *string `protobuf:"bytes,10,opt,name=name" json:"name,omitempty"`
	// An arbitrary string describing the network.
	Annotation *string `protobuf:"bytes,11,opt,name=annotation" json:"annotation,omitempty"`
	// UUID of the network function chain to use for this network.
	NetworkFunctionChainUuid []byte `protobuf:"bytes,12,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// Distributed vswitch reference (UUID in hex string)
	VirtualSwitchUuid    *string  `protobuf:"bytes,13,opt,name=virtual_switch_uuid,json=virtualSwitchUuid" json:"virtual_switch_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkConfig) Reset()         { *m = NetworkConfig{} }
func (m *NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkConfig) ProtoMessage()    {}
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{45}
}

func (m *NetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkConfig.Unmarshal(m, b)
}
func (m *NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkConfig.Marshal(b, m, deterministic)
}
func (m *NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfig.Merge(m, src)
}
func (m *NetworkConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkConfig.Size(m)
}
func (m *NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfig proto.InternalMessageInfo

const Default_NetworkConfig_Type NetworkConfig_Type = NetworkConfig_kBridged
const Default_NetworkConfig_Identifier int32 = 0

func (m *NetworkConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NetworkConfig) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *NetworkConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *NetworkConfig) GetType() NetworkConfig_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_NetworkConfig_Type
}

func (m *NetworkConfig) GetIdentifier() int32 {
	if m != nil && m.Identifier != nil {
		return *m.Identifier
	}
	return Default_NetworkConfig_Identifier
}

func (m *NetworkConfig) GetIpConfig() *IPConfig {
	if m != nil {
		return m.IpConfig
	}
	return nil
}

func (m *NetworkConfig) GetForwardMulticast() bool {
	if m != nil && m.ForwardMulticast != nil {
		return *m.ForwardMulticast
	}
	return false
}

func (m *NetworkConfig) GetVswitchName() string {
	if m != nil && m.VswitchName != nil {
		return *m.VswitchName
	}
	return ""
}

func (m *NetworkConfig) GetMtu() int32 {
	if m != nil && m.Mtu != nil {
		return *m.Mtu
	}
	return 0
}

func (m *NetworkConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetworkConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *NetworkConfig) GetNetworkFunctionChainUuid() []byte {
	if m != nil {
		return m.NetworkFunctionChainUuid
	}
	return nil
}

func (m *NetworkConfig) GetVirtualSwitchUuid() string {
	if m != nil && m.VirtualSwitchUuid != nil {
		return *m.VirtualSwitchUuid
	}
	return ""
}

type AddressAssignment struct {
	// MAC address that the IP address belongs to.
	MacAddress []byte `protobuf:"bytes,1,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// Assigned IP address.
	IpAddress []byte `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// UUID of the Network. This should not be set in the assignment table.
	NetworkUuid []byte `protobuf:"bytes,3,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// UUID of the entity which owns this address assignment.
	EntityUuid []byte `protobuf:"bytes,4,opt,name=entity_uuid,json=entityUuid" json:"entity_uuid,omitempty"`
	// VNI of the network.
	OverlayNetworkId *int32                            `protobuf:"varint,5,opt,name=overlay_network_id,json=overlayNetworkId" json:"overlay_network_id,omitempty"`
	Type             *AddressAssignment_AssignmentType `protobuf:"varint,6,opt,name=type,enum=nutanix.acropolis.AddressAssignment_AssignmentType" json:"type,omitempty"`
	// Indicates that the assignment has been deleted from pithos. This flag
	// should never be set in a client request or in the assignment table.
	Deleted *bool `protobuf:"varint,7,opt,name=deleted" json:"deleted,omitempty"`
	// Indicates whether the assignment belongs to an Acropolis network or
	// an Atlas subnet
	// Set to true if the proto belongs to an Atlas subnet
	// Set to false if the proto belongs to an Acropolis network
	ForAtlasSubnet *bool `protobuf:"varint,8,opt,name=for_atlas_subnet,json=forAtlasSubnet" json:"for_atlas_subnet,omitempty"`
	// cookie field to be used by the client.
	Cookie               *string  `protobuf:"bytes,9,opt,name=cookie" json:"cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressAssignment) Reset()         { *m = AddressAssignment{} }
func (m *AddressAssignment) String() string { return proto.CompactTextString(m) }
func (*AddressAssignment) ProtoMessage()    {}
func (*AddressAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{46}
}

func (m *AddressAssignment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddressAssignment.Unmarshal(m, b)
}
func (m *AddressAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddressAssignment.Marshal(b, m, deterministic)
}
func (m *AddressAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressAssignment.Merge(m, src)
}
func (m *AddressAssignment) XXX_Size() int {
	return xxx_messageInfo_AddressAssignment.Size(m)
}
func (m *AddressAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_AddressAssignment proto.InternalMessageInfo

func (m *AddressAssignment) GetMacAddress() []byte {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

func (m *AddressAssignment) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *AddressAssignment) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *AddressAssignment) GetEntityUuid() []byte {
	if m != nil {
		return m.EntityUuid
	}
	return nil
}

func (m *AddressAssignment) GetOverlayNetworkId() int32 {
	if m != nil && m.OverlayNetworkId != nil {
		return *m.OverlayNetworkId
	}
	return 0
}

func (m *AddressAssignment) GetType() AddressAssignment_AssignmentType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return AddressAssignment_kVm
}

func (m *AddressAssignment) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *AddressAssignment) GetForAtlasSubnet() bool {
	if m != nil && m.ForAtlasSubnet != nil {
		return *m.ForAtlasSubnet
	}
	return false
}

func (m *AddressAssignment) GetCookie() string {
	if m != nil && m.Cookie != nil {
		return *m.Cookie
	}
	return ""
}

type NetworkAddressAssignmentTable struct {
	// uuid of the network
	NetworkUuid []byte `protobuf:"bytes,1,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// Table of assignemnts
	AssignmentList       []*AddressAssignment `protobuf:"bytes,2,rep,name=assignment_list,json=assignmentList" json:"assignment_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NetworkAddressAssignmentTable) Reset()         { *m = NetworkAddressAssignmentTable{} }
func (m *NetworkAddressAssignmentTable) String() string { return proto.CompactTextString(m) }
func (*NetworkAddressAssignmentTable) ProtoMessage()    {}
func (*NetworkAddressAssignmentTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{47}
}

func (m *NetworkAddressAssignmentTable) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkAddressAssignmentTable.Unmarshal(m, b)
}
func (m *NetworkAddressAssignmentTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkAddressAssignmentTable.Marshal(b, m, deterministic)
}
func (m *NetworkAddressAssignmentTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddressAssignmentTable.Merge(m, src)
}
func (m *NetworkAddressAssignmentTable) XXX_Size() int {
	return xxx_messageInfo_NetworkAddressAssignmentTable.Size(m)
}
func (m *NetworkAddressAssignmentTable) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddressAssignmentTable.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddressAssignmentTable proto.InternalMessageInfo

func (m *NetworkAddressAssignmentTable) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *NetworkAddressAssignmentTable) GetAssignmentList() []*AddressAssignment {
	if m != nil {
		return m.AssignmentList
	}
	return nil
}

type NetworkAddressCacheEntry struct {
	// The mac address.
	MacAddress []byte `protobuf:"bytes,1,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// The network id that the mac address belongs to. For L2 networks, this is
	// the vlan id.
	NetworkId *int32 `protobuf:"varint,2,opt,name=network_id,json=networkId" json:"network_id,omitempty"`
	// DEPRECATED. IP address the above MAC address maps to.
	IpAddress []byte `protobuf:"bytes,4,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"` // Deprecated: Do not use.
	// DEPRECATED. Expiry time in microseconds from epoch for this entry.
	ExpiryTimeUsecs *uint64 `protobuf:"fixed64,5,opt,name=expiry_time_usecs,json=expiryTimeUsecs" json:"expiry_time_usecs,omitempty"` // Deprecated: Do not use.
	// Indicates that the entry has been deleted from pithos.
	Deleted *bool `protobuf:"varint,6,opt,name=deleted" json:"deleted,omitempty"`
	// List of IP addresses that the above MAC address maps to.
	IpAddressList        []*NetworkAddressCacheEntry_IPAddressCacheEntry `protobuf:"bytes,7,rep,name=ip_address_list,json=ipAddressList" json:"ip_address_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *NetworkAddressCacheEntry) Reset()         { *m = NetworkAddressCacheEntry{} }
func (m *NetworkAddressCacheEntry) String() string { return proto.CompactTextString(m) }
func (*NetworkAddressCacheEntry) ProtoMessage()    {}
func (*NetworkAddressCacheEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{48}
}

func (m *NetworkAddressCacheEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkAddressCacheEntry.Unmarshal(m, b)
}
func (m *NetworkAddressCacheEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkAddressCacheEntry.Marshal(b, m, deterministic)
}
func (m *NetworkAddressCacheEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddressCacheEntry.Merge(m, src)
}
func (m *NetworkAddressCacheEntry) XXX_Size() int {
	return xxx_messageInfo_NetworkAddressCacheEntry.Size(m)
}
func (m *NetworkAddressCacheEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddressCacheEntry.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddressCacheEntry proto.InternalMessageInfo

func (m *NetworkAddressCacheEntry) GetMacAddress() []byte {
	if m != nil {
		return m.MacAddress
	}
	return nil
}

func (m *NetworkAddressCacheEntry) GetNetworkId() int32 {
	if m != nil && m.NetworkId != nil {
		return *m.NetworkId
	}
	return 0
}

// Deprecated: Do not use.
func (m *NetworkAddressCacheEntry) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

// Deprecated: Do not use.
func (m *NetworkAddressCacheEntry) GetExpiryTimeUsecs() uint64 {
	if m != nil && m.ExpiryTimeUsecs != nil {
		return *m.ExpiryTimeUsecs
	}
	return 0
}

func (m *NetworkAddressCacheEntry) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *NetworkAddressCacheEntry) GetIpAddressList() []*NetworkAddressCacheEntry_IPAddressCacheEntry {
	if m != nil {
		return m.IpAddressList
	}
	return nil
}

type NetworkAddressCacheEntry_IPAddressCacheEntry struct {
	// IP address the above MAC address maps to.
	IpAddress []byte `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// Expiry time in microseconds from epoch.
	ExpiryTimeUsecs *uint64 `protobuf:"fixed64,2,opt,name=expiry_time_usecs,json=expiryTimeUsecs" json:"expiry_time_usecs,omitempty"`
	// Last seen time in microseconds from epoch.
	LastSeenTimeUsecs    *uint64  `protobuf:"fixed64,3,opt,name=last_seen_time_usecs,json=lastSeenTimeUsecs" json:"last_seen_time_usecs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) Reset() {
	*m = NetworkAddressCacheEntry_IPAddressCacheEntry{}
}
func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) String() string {
	return proto.CompactTextString(m)
}
func (*NetworkAddressCacheEntry_IPAddressCacheEntry) ProtoMessage() {}
func (*NetworkAddressCacheEntry_IPAddressCacheEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{48, 0}
}

func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkAddressCacheEntry_IPAddressCacheEntry.Unmarshal(m, b)
}
func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkAddressCacheEntry_IPAddressCacheEntry.Marshal(b, m, deterministic)
}
func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddressCacheEntry_IPAddressCacheEntry.Merge(m, src)
}
func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) XXX_Size() int {
	return xxx_messageInfo_NetworkAddressCacheEntry_IPAddressCacheEntry.Size(m)
}
func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddressCacheEntry_IPAddressCacheEntry.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddressCacheEntry_IPAddressCacheEntry proto.InternalMessageInfo

func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) GetExpiryTimeUsecs() uint64 {
	if m != nil && m.ExpiryTimeUsecs != nil {
		return *m.ExpiryTimeUsecs
	}
	return 0
}

func (m *NetworkAddressCacheEntry_IPAddressCacheEntry) GetLastSeenTimeUsecs() uint64 {
	if m != nil && m.LastSeenTimeUsecs != nil {
		return *m.LastSeenTimeUsecs
	}
	return 0
}

type ImageInfo struct {
	// UUID of the image.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Image name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// String describing the image.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Image type.
	ImageType *ImageInfo_ImageType `protobuf:"varint,4,opt,name=image_type,json=imageType,enum=nutanix.acropolis.ImageInfo_ImageType" json:"image_type,omitempty"`
	// ID of the container where the image resides.
	ContainerId *int64 `protobuf:"varint,5,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Whether the image has been deleted.
	Deleted *bool `protobuf:"varint,6,opt,name=deleted" json:"deleted,omitempty"`
	// Checksum type.
	ChecksumType *ImageInfo_ChecksumType `protobuf:"varint,7,opt,name=checksum_type,json=checksumType,enum=nutanix.acropolis.ImageInfo_ChecksumType" json:"checksum_type,omitempty"`
	// Checksum represented as bytes.
	ChecksumBytes []byte `protobuf:"bytes,8,opt,name=checksum_bytes,json=checksumBytes" json:"checksum_bytes,omitempty"`
	// The logical timestamp for the image.
	LogicalTimestamp *int64 `protobuf:"varint,9,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// UUID of the backing vmdisk.
	VmdiskUuid []byte `protobuf:"bytes,10,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// Indicates the state of the image (whether it is usable or not).
	ImageState *ImageInfo_ImageState `protobuf:"varint,11,opt,name=image_state,json=imageState,enum=nutanix.acropolis.ImageInfo_ImageState,def=1" json:"image_state,omitempty"`
	// The epoch time in microseconds when this image was created.
	CreateTimeUsecs *uint64 `protobuf:"fixed64,12,opt,name=create_time_usecs,json=createTimeUsecs" json:"create_time_usecs,omitempty"`
	// The epoch time in microseconds when this image was updated.
	UpdateTimeUsecs *uint64 `protobuf:"fixed64,13,opt,name=update_time_usecs,json=updateTimeUsecs" json:"update_time_usecs,omitempty"`
	// Vmdisk size in bytes. This is only filled in on demand whenever an image
	// is fetched and the size is requested.
	VmdiskSize *int64 `protobuf:"varint,14,opt,name=vmdisk_size,json=vmdiskSize" json:"vmdisk_size,omitempty"`
	// Disk NFS path. This field is usually populated on-demand, during certain
	// queries. It is not stored in the Acropolis database.
	VmdiskNfsPath *string `protobuf:"bytes,15,opt,name=vmdisk_nfs_path,json=vmdiskNfsPath" json:"vmdisk_nfs_path,omitempty"`
	// Boolean indicating whether the image is referenced in the catalog. This
	// field is only populated on-demand and not stored in the Acropolis
	// database.
	InCatalog *bool `protobuf:"varint,16,opt,name=in_catalog,json=inCatalog" json:"in_catalog,omitempty"`
	// Whether the image is hidden or not
	Hidden *bool `protobuf:"varint,17,opt,name=hidden,def=0" json:"hidden,omitempty"`
	// The image version.
	Version *ImageVersion `protobuf:"bytes,18,opt,name=version" json:"version,omitempty"`
	// This field describes the source of the image, whether it is from a URL or
	// cloned from a file. Note that this field is not filled in for local file
	// uploads.
	ImageSource *ImageSource `protobuf:"bytes,19,opt,name=image_source,json=imageSource" json:"image_source,omitempty"`
	FileUuid    []byte       `protobuf:"bytes,20,opt,name=file_uuid,json=fileUuid" json:"file_uuid,omitempty"`
	// This field describes the processor architecture that the OS image is
	// compatible with.
	Architecture *ImageInfo_ImageArchitecture `protobuf:"varint,21,opt,name=architecture,enum=nutanix.acropolis.ImageInfo_ImageArchitecture" json:"architecture,omitempty"`
	// If the image is migrated to PC, this field can be used to indicate
	// owner uuid to the UI through groups API
	OwnerClusterUuid []byte `protobuf:"bytes,22,opt,name=owner_cluster_uuid,json=ownerClusterUuid" json:"owner_cluster_uuid,omitempty"`
	// The following fields are only used during the migration process from
	// pre-obelix to obelix. During the migration process image UUIDs will change
	// in order to make it easier for images to be re-mastered on PC. The
	// 'new_image_uuid' field is used to make the migration process crash
	// consistent and the 'old_image_uuid' is used to update entities that
	// reference images (e.g blueprints, marketplace items).
	OldImageUuid []byte `protobuf:"bytes,23,opt,name=old_image_uuid,json=oldImageUuid" json:"old_image_uuid,omitempty"`
	NewImageUuid []byte `protobuf:"bytes,24,opt,name=new_image_uuid,json=newImageUuid" json:"new_image_uuid,omitempty"`
	// This following field is used to denote if accessing image
	// url is allowed to be done insecurely. Typically this option
	// is explicitly specified by the user during the image create
	// API invokation. If true, server certificate check is ignored.
	// If false, complete server certificate check is performed.
	SourceInsecureUrl *bool `protobuf:"varint,25,opt,name=source_insecure_url,json=sourceInsecureUrl,def=0" json:"source_insecure_url,omitempty"`
	// This field should be used to provide list of clusters where
	// the image should be created; should be a subset of AHV PEs which is
	// registered to the OnPrem PC. This field should only be used from OnPrem PC.
	InitialClusterLocationList [][]byte `protobuf:"bytes,26,rep,name=initial_cluster_location_list,json=initialClusterLocationList" json:"initial_cluster_location_list,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *ImageInfo) Reset()         { *m = ImageInfo{} }
func (m *ImageInfo) String() string { return proto.CompactTextString(m) }
func (*ImageInfo) ProtoMessage()    {}
func (*ImageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{49}
}

func (m *ImageInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageInfo.Unmarshal(m, b)
}
func (m *ImageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageInfo.Marshal(b, m, deterministic)
}
func (m *ImageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageInfo.Merge(m, src)
}
func (m *ImageInfo) XXX_Size() int {
	return xxx_messageInfo_ImageInfo.Size(m)
}
func (m *ImageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ImageInfo proto.InternalMessageInfo

const Default_ImageInfo_ImageState ImageInfo_ImageState = ImageInfo_kActive
const Default_ImageInfo_Hidden bool = false
const Default_ImageInfo_SourceInsecureUrl bool = false

func (m *ImageInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ImageInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ImageInfo) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *ImageInfo) GetImageType() ImageInfo_ImageType {
	if m != nil && m.ImageType != nil {
		return *m.ImageType
	}
	return ImageInfo_kNoType
}

func (m *ImageInfo) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *ImageInfo) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *ImageInfo) GetChecksumType() ImageInfo_ChecksumType {
	if m != nil && m.ChecksumType != nil {
		return *m.ChecksumType
	}
	return ImageInfo_kSha256
}

func (m *ImageInfo) GetChecksumBytes() []byte {
	if m != nil {
		return m.ChecksumBytes
	}
	return nil
}

func (m *ImageInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *ImageInfo) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *ImageInfo) GetImageState() ImageInfo_ImageState {
	if m != nil && m.ImageState != nil {
		return *m.ImageState
	}
	return Default_ImageInfo_ImageState
}

func (m *ImageInfo) GetCreateTimeUsecs() uint64 {
	if m != nil && m.CreateTimeUsecs != nil {
		return *m.CreateTimeUsecs
	}
	return 0
}

func (m *ImageInfo) GetUpdateTimeUsecs() uint64 {
	if m != nil && m.UpdateTimeUsecs != nil {
		return *m.UpdateTimeUsecs
	}
	return 0
}

func (m *ImageInfo) GetVmdiskSize() int64 {
	if m != nil && m.VmdiskSize != nil {
		return *m.VmdiskSize
	}
	return 0
}

func (m *ImageInfo) GetVmdiskNfsPath() string {
	if m != nil && m.VmdiskNfsPath != nil {
		return *m.VmdiskNfsPath
	}
	return ""
}

func (m *ImageInfo) GetInCatalog() bool {
	if m != nil && m.InCatalog != nil {
		return *m.InCatalog
	}
	return false
}

func (m *ImageInfo) GetHidden() bool {
	if m != nil && m.Hidden != nil {
		return *m.Hidden
	}
	return Default_ImageInfo_Hidden
}

func (m *ImageInfo) GetVersion() *ImageVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ImageInfo) GetImageSource() *ImageSource {
	if m != nil {
		return m.ImageSource
	}
	return nil
}

func (m *ImageInfo) GetFileUuid() []byte {
	if m != nil {
		return m.FileUuid
	}
	return nil
}

func (m *ImageInfo) GetArchitecture() ImageInfo_ImageArchitecture {
	if m != nil && m.Architecture != nil {
		return *m.Architecture
	}
	return ImageInfo_kX86_64
}

func (m *ImageInfo) GetOwnerClusterUuid() []byte {
	if m != nil {
		return m.OwnerClusterUuid
	}
	return nil
}

func (m *ImageInfo) GetOldImageUuid() []byte {
	if m != nil {
		return m.OldImageUuid
	}
	return nil
}

func (m *ImageInfo) GetNewImageUuid() []byte {
	if m != nil {
		return m.NewImageUuid
	}
	return nil
}

func (m *ImageInfo) GetSourceInsecureUrl() bool {
	if m != nil && m.SourceInsecureUrl != nil {
		return *m.SourceInsecureUrl
	}
	return Default_ImageInfo_SourceInsecureUrl
}

func (m *ImageInfo) GetInitialClusterLocationList() [][]byte {
	if m != nil {
		return m.InitialClusterLocationList
	}
	return nil
}

type ImageVersion struct {
	// Name of the producer/distributor of the image (e.g red hat/windows).
	ProductName *string `protobuf:"bytes,1,opt,name=product_name,json=productName" json:"product_name,omitempty"`
	// Version string for the disk image.
	ProductVersion       *string  `protobuf:"bytes,2,opt,name=product_version,json=productVersion" json:"product_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageVersion) Reset()         { *m = ImageVersion{} }
func (m *ImageVersion) String() string { return proto.CompactTextString(m) }
func (*ImageVersion) ProtoMessage()    {}
func (*ImageVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{50}
}

func (m *ImageVersion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageVersion.Unmarshal(m, b)
}
func (m *ImageVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageVersion.Marshal(b, m, deterministic)
}
func (m *ImageVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageVersion.Merge(m, src)
}
func (m *ImageVersion) XXX_Size() int {
	return xxx_messageInfo_ImageVersion.Size(m)
}
func (m *ImageVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageVersion.DiscardUnknown(m)
}

var xxx_messageInfo_ImageVersion proto.InternalMessageInfo

func (m *ImageVersion) GetProductName() string {
	if m != nil && m.ProductName != nil {
		return *m.ProductName
	}
	return ""
}

func (m *ImageVersion) GetProductVersion() string {
	if m != nil && m.ProductVersion != nil {
		return *m.ProductVersion
	}
	return ""
}

type ImageSource struct {
	// Source vmdisk that the image was cloned from.
	SourceVmdiskUuid []byte `protobuf:"bytes,1,opt,name=source_vmdisk_uuid,json=sourceVmdiskUuid" json:"source_vmdisk_uuid,omitempty"`
	// Source URL that points at the remote location that the image was imported
	// from.
	SourceUrl            *string  `protobuf:"bytes,2,opt,name=source_url,json=sourceUrl" json:"source_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageSource) Reset()         { *m = ImageSource{} }
func (m *ImageSource) String() string { return proto.CompactTextString(m) }
func (*ImageSource) ProtoMessage()    {}
func (*ImageSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{51}
}

func (m *ImageSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageSource.Unmarshal(m, b)
}
func (m *ImageSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageSource.Marshal(b, m, deterministic)
}
func (m *ImageSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageSource.Merge(m, src)
}
func (m *ImageSource) XXX_Size() int {
	return xxx_messageInfo_ImageSource.Size(m)
}
func (m *ImageSource) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageSource.DiscardUnknown(m)
}

var xxx_messageInfo_ImageSource proto.InternalMessageInfo

func (m *ImageSource) GetSourceVmdiskUuid() []byte {
	if m != nil {
		return m.SourceVmdiskUuid
	}
	return nil
}

func (m *ImageSource) GetSourceUrl() string {
	if m != nil && m.SourceUrl != nil {
		return *m.SourceUrl
	}
	return ""
}

type ImageImportSpec struct {
	// Source URL, can point to NFS or HTTP.
	// NFS URLs should look like:
	//    nfs://<source address>/<path to file>
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// Destination container.
	ContainerId   *int64  `protobuf:"varint,2,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	ContainerName *string `protobuf:"bytes,3,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	// Checksum type. Note that we only support checksums for flat images.
	ChecksumType *ImageInfo_ChecksumType `protobuf:"varint,4,opt,name=checksum_type,json=checksumType,enum=nutanix.acropolis.ImageInfo_ChecksumType" json:"checksum_type,omitempty"`
	// Checksum represented as bytes.
	ChecksumBytes []byte `protobuf:"bytes,5,opt,name=checksum_bytes,json=checksumBytes" json:"checksum_bytes,omitempty"`
	// Image uploaded to a NDFS path. This is only used internally through a
	// HTTP handler that is used for uploading files.
	UploadNdfsPath *string `protobuf:"bytes,6,opt,name=upload_ndfs_path,json=uploadNdfsPath" json:"upload_ndfs_path,omitempty"`
	// Image upload size. This is a hint used so that we can report progress for
	// the image upload.
	UploadImageSize *int64 `protobuf:"varint,7,opt,name=upload_image_size,json=uploadImageSize" json:"upload_image_size,omitempty"`
	// UUID of the container.
	ContainerUuid []byte `protobuf:"bytes,8,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// If yes, SSL server certificate verification
	// will not be done. This option is typically
	// used when user has given explicit consent
	// to ignore server certificate error.
	AllowInsecureUrl *bool `protobuf:"varint,9,opt,name=allow_insecure_url,json=allowInsecureUrl,def=0" json:"allow_insecure_url,omitempty"`
	// This field should be used to provide list of clusters where
	// the image should be created; should be a subset of AHV PEs which is
	// registered to the OnPrem PC. This field should only be used from OnPrem PC.
	InitialClusterLocationList [][]byte `protobuf:"bytes,10,rep,name=initial_cluster_location_list,json=initialClusterLocationList" json:"initial_cluster_location_list,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *ImageImportSpec) Reset()         { *m = ImageImportSpec{} }
func (m *ImageImportSpec) String() string { return proto.CompactTextString(m) }
func (*ImageImportSpec) ProtoMessage()    {}
func (*ImageImportSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{52}
}

func (m *ImageImportSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageImportSpec.Unmarshal(m, b)
}
func (m *ImageImportSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageImportSpec.Marshal(b, m, deterministic)
}
func (m *ImageImportSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageImportSpec.Merge(m, src)
}
func (m *ImageImportSpec) XXX_Size() int {
	return xxx_messageInfo_ImageImportSpec.Size(m)
}
func (m *ImageImportSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageImportSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ImageImportSpec proto.InternalMessageInfo

const Default_ImageImportSpec_AllowInsecureUrl bool = false

func (m *ImageImportSpec) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *ImageImportSpec) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *ImageImportSpec) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *ImageImportSpec) GetChecksumType() ImageInfo_ChecksumType {
	if m != nil && m.ChecksumType != nil {
		return *m.ChecksumType
	}
	return ImageInfo_kSha256
}

func (m *ImageImportSpec) GetChecksumBytes() []byte {
	if m != nil {
		return m.ChecksumBytes
	}
	return nil
}

func (m *ImageImportSpec) GetUploadNdfsPath() string {
	if m != nil && m.UploadNdfsPath != nil {
		return *m.UploadNdfsPath
	}
	return ""
}

func (m *ImageImportSpec) GetUploadImageSize() int64 {
	if m != nil && m.UploadImageSize != nil {
		return *m.UploadImageSize
	}
	return 0
}

func (m *ImageImportSpec) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *ImageImportSpec) GetAllowInsecureUrl() bool {
	if m != nil && m.AllowInsecureUrl != nil {
		return *m.AllowInsecureUrl
	}
	return Default_ImageImportSpec_AllowInsecureUrl
}

func (m *ImageImportSpec) GetInitialClusterLocationList() [][]byte {
	if m != nil {
		return m.InitialClusterLocationList
	}
	return nil
}

type ImageCreateSpec struct {
	// Image UUID that can be provided for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Image name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// String describing the image.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Image type.
	ImageType *ImageInfo_ImageType `protobuf:"varint,4,opt,name=image_type,json=imageType,enum=nutanix.acropolis.ImageInfo_ImageType" json:"image_type,omitempty"`
	// One of the following (importfrom, clone, existing) must be provided.
	Importfrom *ImageImportSpec    `protobuf:"bytes,5,opt,name=importfrom" json:"importfrom,omitempty"`
	Clone      *VmDiskSpecClone    `protobuf:"bytes,6,opt,name=clone" json:"clone,omitempty"`
	Existing   *VmDiskSpecExisting `protobuf:"bytes,7,opt,name=existing" json:"existing,omitempty"`
	// Should the created image be hidden from being
	// visible to acli image commands or any non-catalog interaction
	HiddenImage *bool `protobuf:"varint,8,opt,name=hidden_image,json=hiddenImage,def=0" json:"hidden_image,omitempty"`
	// Image version.
	Version *ImageVersion `protobuf:"bytes,9,opt,name=version" json:"version,omitempty"`
	// This field describes the processor architecture that the OS image is
	// compatible with.
	Architecture *ImageInfo_ImageArchitecture `protobuf:"varint,10,opt,name=architecture,enum=nutanix.acropolis.ImageInfo_ImageArchitecture" json:"architecture,omitempty"`
	// Holds uuid of cluster that is allowed to perform CUD operations
	// on this image. For catalog items on PE that are not migrated
	// to PC, this will be the PE uuid. For catalog items on PE that are
	// migrated to PC, this will be the PC uuid.
	OwnerClusterUuid []byte `protobuf:"bytes,11,opt,name=owner_cluster_uuid,json=ownerClusterUuid" json:"owner_cluster_uuid,omitempty"`
	// Categories UUID list. This field should be provided only from
	// (OnPrem) PC. It is used during create.
	CategoriesUuidList   [][]byte `protobuf:"bytes,12,rep,name=categories_uuid_list,json=categoriesUuidList" json:"categories_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageCreateSpec) Reset()         { *m = ImageCreateSpec{} }
func (m *ImageCreateSpec) String() string { return proto.CompactTextString(m) }
func (*ImageCreateSpec) ProtoMessage()    {}
func (*ImageCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{53}
}

func (m *ImageCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageCreateSpec.Unmarshal(m, b)
}
func (m *ImageCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageCreateSpec.Marshal(b, m, deterministic)
}
func (m *ImageCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCreateSpec.Merge(m, src)
}
func (m *ImageCreateSpec) XXX_Size() int {
	return xxx_messageInfo_ImageCreateSpec.Size(m)
}
func (m *ImageCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCreateSpec proto.InternalMessageInfo

const Default_ImageCreateSpec_HiddenImage bool = false

func (m *ImageCreateSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ImageCreateSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ImageCreateSpec) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *ImageCreateSpec) GetImageType() ImageInfo_ImageType {
	if m != nil && m.ImageType != nil {
		return *m.ImageType
	}
	return ImageInfo_kNoType
}

func (m *ImageCreateSpec) GetImportfrom() *ImageImportSpec {
	if m != nil {
		return m.Importfrom
	}
	return nil
}

func (m *ImageCreateSpec) GetClone() *VmDiskSpecClone {
	if m != nil {
		return m.Clone
	}
	return nil
}

func (m *ImageCreateSpec) GetExisting() *VmDiskSpecExisting {
	if m != nil {
		return m.Existing
	}
	return nil
}

func (m *ImageCreateSpec) GetHiddenImage() bool {
	if m != nil && m.HiddenImage != nil {
		return *m.HiddenImage
	}
	return Default_ImageCreateSpec_HiddenImage
}

func (m *ImageCreateSpec) GetVersion() *ImageVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *ImageCreateSpec) GetArchitecture() ImageInfo_ImageArchitecture {
	if m != nil && m.Architecture != nil {
		return *m.Architecture
	}
	return ImageInfo_kX86_64
}

func (m *ImageCreateSpec) GetOwnerClusterUuid() []byte {
	if m != nil {
		return m.OwnerClusterUuid
	}
	return nil
}

func (m *ImageCreateSpec) GetCategoriesUuidList() [][]byte {
	if m != nil {
		return m.CategoriesUuidList
	}
	return nil
}

type VolumeDiskCreateSpec struct {
	// Index of disk in group.
	Index *uint32 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	// Disk creation style. Exactly one must be provided
	Create   *VmDiskSpecCreate   `protobuf:"bytes,2,opt,name=create" json:"create,omitempty"`
	Clone    *VmDiskSpecClone    `protobuf:"bytes,3,opt,name=clone" json:"clone,omitempty"`
	Existing *VmDiskSpecExisting `protobuf:"bytes,4,opt,name=existing" json:"existing,omitempty"`
	// String describing the volume disk.
	Annotation *string `protobuf:"bytes,5,opt,name=annotation" json:"annotation,omitempty"`
	// Whether to enable/disable flash mode on the volume disk.
	FlashMode            *bool    `protobuf:"varint,6,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeDiskCreateSpec) Reset()         { *m = VolumeDiskCreateSpec{} }
func (m *VolumeDiskCreateSpec) String() string { return proto.CompactTextString(m) }
func (*VolumeDiskCreateSpec) ProtoMessage()    {}
func (*VolumeDiskCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{54}
}

func (m *VolumeDiskCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeDiskCreateSpec.Unmarshal(m, b)
}
func (m *VolumeDiskCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeDiskCreateSpec.Marshal(b, m, deterministic)
}
func (m *VolumeDiskCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeDiskCreateSpec.Merge(m, src)
}
func (m *VolumeDiskCreateSpec) XXX_Size() int {
	return xxx_messageInfo_VolumeDiskCreateSpec.Size(m)
}
func (m *VolumeDiskCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeDiskCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeDiskCreateSpec proto.InternalMessageInfo

func (m *VolumeDiskCreateSpec) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *VolumeDiskCreateSpec) GetCreate() *VmDiskSpecCreate {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *VolumeDiskCreateSpec) GetClone() *VmDiskSpecClone {
	if m != nil {
		return m.Clone
	}
	return nil
}

func (m *VolumeDiskCreateSpec) GetExisting() *VmDiskSpecExisting {
	if m != nil {
		return m.Existing
	}
	return nil
}

func (m *VolumeDiskCreateSpec) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VolumeDiskCreateSpec) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

type IscsiClientSpec struct {
	// Client identifier.
	ClientId *pithos.IscsiClientParams_IscsiClientIdentifier `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// Client secret.
	ClientSecret         *string  `protobuf:"bytes,2,opt,name=client_secret,json=clientSecret" json:"client_secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IscsiClientSpec) Reset()         { *m = IscsiClientSpec{} }
func (m *IscsiClientSpec) String() string { return proto.CompactTextString(m) }
func (*IscsiClientSpec) ProtoMessage()    {}
func (*IscsiClientSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{55}
}

func (m *IscsiClientSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IscsiClientSpec.Unmarshal(m, b)
}
func (m *IscsiClientSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IscsiClientSpec.Marshal(b, m, deterministic)
}
func (m *IscsiClientSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IscsiClientSpec.Merge(m, src)
}
func (m *IscsiClientSpec) XXX_Size() int {
	return xxx_messageInfo_IscsiClientSpec.Size(m)
}
func (m *IscsiClientSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_IscsiClientSpec.DiscardUnknown(m)
}

var xxx_messageInfo_IscsiClientSpec proto.InternalMessageInfo

func (m *IscsiClientSpec) GetClientId() *pithos.IscsiClientParams_IscsiClientIdentifier {
	if m != nil {
		return m.ClientId
	}
	return nil
}

func (m *IscsiClientSpec) GetClientSecret() string {
	if m != nil && m.ClientSecret != nil {
		return *m.ClientSecret
	}
	return ""
}

type VolumeGroupCreateSpec struct {
	// Volume group UUID that can be provided for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Volume group name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// String describing the volume group.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// List of disks to create.
	DiskList []*VolumeDiskCreateSpec `protobuf:"bytes,4,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// Is volume shared?
	Shared *bool `protobuf:"varint,5,opt,name=shared,def=0" json:"shared,omitempty"`
	// iSCSI target name. If not specified, a default target name is assigned.
	// New clients should set the isci_target_prefix instead of this field so
	// that the generated IQN is world-wide unique.
	IscsiTargetName *string `protobuf:"bytes,6,opt,name=iscsi_target_name,json=iscsiTargetName" json:"iscsi_target_name,omitempty"`
	// List of external initiator IQNs for this VG.
	// Deprecated. Newer clients advised to use spec_list instead.
	ExternalInitiatorIqnList []string `protobuf:"bytes,7,rep,name=external_initiator_iqn_list,json=externalInitiatorIqnList" json:"external_initiator_iqn_list,omitempty"`
	// If set to a non-empty string, this VG should be considered incompatible
	// with DR workflows.
	CbrNotCapableReason *string `protobuf:"bytes,8,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Whether to enable flash mode for the VG disks.
	FlashMode *bool `protobuf:"varint,9,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	// target_secret for CHAP authentication to be used by clients
	TargetSecret *string `protobuf:"bytes,10,opt,name=target_secret,json=targetSecret" json:"target_secret,omitempty"`
	// iSCSI target prefix. If not specified, a default target name is assigned.
	// The VG's IQN is generated by concatentating the VG uuid to the specified
	// iscsi_target_prefix to guarantee uniqueness. New clients must set this
	// field instead of iscsi_target_name.
	IscsiTargetPrefix *string                                    `protobuf:"bytes,11,opt,name=iscsi_target_prefix,json=iscsiTargetPrefix" json:"iscsi_target_prefix,omitempty"`
	ClientSpecList    *VolumeGroupCreateSpec_IscsiClientSpecList `protobuf:"bytes,13,opt,name=client_spec_list,json=clientSpecList" json:"client_spec_list,omitempty"`
	FileSystemType    *VolumeGroupCreateSpec_FileSystemType      `protobuf:"varint,14,opt,name=file_system_type,json=fileSystemType,enum=nutanix.acropolis.VolumeGroupCreateSpec_FileSystemType" json:"file_system_type,omitempty"`
	// Whether VG load balance VM attachments is enabled/disabled.
	LoadBalanceVmAttachments *bool `protobuf:"varint,15,opt,name=load_balance_vm_attachments,json=loadBalanceVmAttachments" json:"load_balance_vm_attachments,omitempty"`
	// Source VG from which the VG spec was created.
	SourceVgUuid []byte `protobuf:"bytes,16,opt,name=source_vg_uuid,json=sourceVgUuid" json:"source_vg_uuid,omitempty"`
	// Name of the service/user which created this VG.
	CreatedBy            *string  `protobuf:"bytes,17,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeGroupCreateSpec) Reset()         { *m = VolumeGroupCreateSpec{} }
func (m *VolumeGroupCreateSpec) String() string { return proto.CompactTextString(m) }
func (*VolumeGroupCreateSpec) ProtoMessage()    {}
func (*VolumeGroupCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{56}
}

func (m *VolumeGroupCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeGroupCreateSpec.Unmarshal(m, b)
}
func (m *VolumeGroupCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeGroupCreateSpec.Marshal(b, m, deterministic)
}
func (m *VolumeGroupCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeGroupCreateSpec.Merge(m, src)
}
func (m *VolumeGroupCreateSpec) XXX_Size() int {
	return xxx_messageInfo_VolumeGroupCreateSpec.Size(m)
}
func (m *VolumeGroupCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeGroupCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeGroupCreateSpec proto.InternalMessageInfo

const Default_VolumeGroupCreateSpec_Shared bool = false

func (m *VolumeGroupCreateSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VolumeGroupCreateSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VolumeGroupCreateSpec) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VolumeGroupCreateSpec) GetDiskList() []*VolumeDiskCreateSpec {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *VolumeGroupCreateSpec) GetShared() bool {
	if m != nil && m.Shared != nil {
		return *m.Shared
	}
	return Default_VolumeGroupCreateSpec_Shared
}

func (m *VolumeGroupCreateSpec) GetIscsiTargetName() string {
	if m != nil && m.IscsiTargetName != nil {
		return *m.IscsiTargetName
	}
	return ""
}

func (m *VolumeGroupCreateSpec) GetExternalInitiatorIqnList() []string {
	if m != nil {
		return m.ExternalInitiatorIqnList
	}
	return nil
}

func (m *VolumeGroupCreateSpec) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VolumeGroupCreateSpec) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

func (m *VolumeGroupCreateSpec) GetTargetSecret() string {
	if m != nil && m.TargetSecret != nil {
		return *m.TargetSecret
	}
	return ""
}

func (m *VolumeGroupCreateSpec) GetIscsiTargetPrefix() string {
	if m != nil && m.IscsiTargetPrefix != nil {
		return *m.IscsiTargetPrefix
	}
	return ""
}

func (m *VolumeGroupCreateSpec) GetClientSpecList() *VolumeGroupCreateSpec_IscsiClientSpecList {
	if m != nil {
		return m.ClientSpecList
	}
	return nil
}

func (m *VolumeGroupCreateSpec) GetFileSystemType() VolumeGroupCreateSpec_FileSystemType {
	if m != nil && m.FileSystemType != nil {
		return *m.FileSystemType
	}
	return VolumeGroupCreateSpec_kUnknown
}

func (m *VolumeGroupCreateSpec) GetLoadBalanceVmAttachments() bool {
	if m != nil && m.LoadBalanceVmAttachments != nil {
		return *m.LoadBalanceVmAttachments
	}
	return false
}

func (m *VolumeGroupCreateSpec) GetSourceVgUuid() []byte {
	if m != nil {
		return m.SourceVgUuid
	}
	return nil
}

func (m *VolumeGroupCreateSpec) GetCreatedBy() string {
	if m != nil && m.CreatedBy != nil {
		return *m.CreatedBy
	}
	return ""
}

// List of external client attachment spec. Use this to also update client
// params such as secrets if attachment already exists.
type VolumeGroupCreateSpec_IscsiClientSpecList struct {
	SpecList             []*IscsiClientSpec `protobuf:"bytes,1,rep,name=spec_list,json=specList" json:"spec_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *VolumeGroupCreateSpec_IscsiClientSpecList) Reset() {
	*m = VolumeGroupCreateSpec_IscsiClientSpecList{}
}
func (m *VolumeGroupCreateSpec_IscsiClientSpecList) String() string { return proto.CompactTextString(m) }
func (*VolumeGroupCreateSpec_IscsiClientSpecList) ProtoMessage()    {}
func (*VolumeGroupCreateSpec_IscsiClientSpecList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{56, 0}
}

func (m *VolumeGroupCreateSpec_IscsiClientSpecList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeGroupCreateSpec_IscsiClientSpecList.Unmarshal(m, b)
}
func (m *VolumeGroupCreateSpec_IscsiClientSpecList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeGroupCreateSpec_IscsiClientSpecList.Marshal(b, m, deterministic)
}
func (m *VolumeGroupCreateSpec_IscsiClientSpecList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeGroupCreateSpec_IscsiClientSpecList.Merge(m, src)
}
func (m *VolumeGroupCreateSpec_IscsiClientSpecList) XXX_Size() int {
	return xxx_messageInfo_VolumeGroupCreateSpec_IscsiClientSpecList.Size(m)
}
func (m *VolumeGroupCreateSpec_IscsiClientSpecList) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeGroupCreateSpec_IscsiClientSpecList.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeGroupCreateSpec_IscsiClientSpecList proto.InternalMessageInfo

func (m *VolumeGroupCreateSpec_IscsiClientSpecList) GetSpecList() []*IscsiClientSpec {
	if m != nil {
		return m.SpecList
	}
	return nil
}

type VolumeGroupCloneSpec struct {
	// A version 4 UUID for the clone that the client may specify for idempotence.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// The optional clone name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Optional iSCSI target name for the clone. If not specified, a default
	// target name is assigned.
	IscsiTargetName *string `protobuf:"bytes,3,opt,name=iscsi_target_name,json=iscsiTargetName" json:"iscsi_target_name,omitempty"`
	// Optional CHAP secret for the clone.
	TargetSecret *string `protobuf:"bytes,4,opt,name=target_secret,json=targetSecret" json:"target_secret,omitempty"`
	// Optional iSCSI target prefix for the clone. If not specified, a default
	// target name is assigned. The VG's IQN is generated by concatentating the
	// VG uuid to the specified iscsi_target_prefix to guarantee uniqueness.  New
	// clients must set this field instead of iscsi_target_name.
	IscsiTargetPrefix *string `protobuf:"bytes,5,opt,name=iscsi_target_prefix,json=iscsiTargetPrefix" json:"iscsi_target_prefix,omitempty"`
	// Whether VG load balance VM attachments is enabled/disabled.
	LoadBalanceVmAttachments *bool `protobuf:"varint,17,opt,name=load_balance_vm_attachments,json=loadBalanceVmAttachments" json:"load_balance_vm_attachments,omitempty"`
	// Name of the service/user which created this VG.
	CreatedBy            *string  `protobuf:"bytes,18,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeGroupCloneSpec) Reset()         { *m = VolumeGroupCloneSpec{} }
func (m *VolumeGroupCloneSpec) String() string { return proto.CompactTextString(m) }
func (*VolumeGroupCloneSpec) ProtoMessage()    {}
func (*VolumeGroupCloneSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{57}
}

func (m *VolumeGroupCloneSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeGroupCloneSpec.Unmarshal(m, b)
}
func (m *VolumeGroupCloneSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeGroupCloneSpec.Marshal(b, m, deterministic)
}
func (m *VolumeGroupCloneSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeGroupCloneSpec.Merge(m, src)
}
func (m *VolumeGroupCloneSpec) XXX_Size() int {
	return xxx_messageInfo_VolumeGroupCloneSpec.Size(m)
}
func (m *VolumeGroupCloneSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeGroupCloneSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeGroupCloneSpec proto.InternalMessageInfo

func (m *VolumeGroupCloneSpec) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VolumeGroupCloneSpec) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VolumeGroupCloneSpec) GetIscsiTargetName() string {
	if m != nil && m.IscsiTargetName != nil {
		return *m.IscsiTargetName
	}
	return ""
}

func (m *VolumeGroupCloneSpec) GetTargetSecret() string {
	if m != nil && m.TargetSecret != nil {
		return *m.TargetSecret
	}
	return ""
}

func (m *VolumeGroupCloneSpec) GetIscsiTargetPrefix() string {
	if m != nil && m.IscsiTargetPrefix != nil {
		return *m.IscsiTargetPrefix
	}
	return ""
}

func (m *VolumeGroupCloneSpec) GetLoadBalanceVmAttachments() bool {
	if m != nil && m.LoadBalanceVmAttachments != nil {
		return *m.LoadBalanceVmAttachments
	}
	return false
}

func (m *VolumeGroupCloneSpec) GetCreatedBy() string {
	if m != nil && m.CreatedBy != nil {
		return *m.CreatedBy
	}
	return ""
}

type HostInfo struct {
	// UUID of the host.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Host name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// String describing the host.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Whether the host has been deleted.
	Deleted *bool `protobuf:"varint,4,opt,name=deleted" json:"deleted,omitempty"`
	// The logical timestamp for the host.
	LogicalTimestamp *int64 `protobuf:"varint,5,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// Average CPU usage expressed in parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	CpuUsagePpm *int64 `protobuf:"varint,6,opt,name=cpu_usage_ppm,json=cpuUsagePpm" json:"cpu_usage_ppm,omitempty"`
	// Memory usage percentage expressed parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	MemUsagePpm *int64 `protobuf:"varint,7,opt,name=mem_usage_ppm,json=memUsagePpm" json:"mem_usage_ppm,omitempty"`
	// Hypervisor type.
	HypervisorType *HypervisorType_Type `protobuf:"varint,8,opt,name=hypervisor_type,json=hypervisorType,enum=nutanix.acropolis.HypervisorType_Type" json:"hypervisor_type,omitempty"`
	// List of supported CPU feature flags. This field is assumed to be
	// hypervisor-specific.
	CpuFeatureList []string `protobuf:"bytes,9,rep,name=cpu_feature_list,json=cpuFeatureList" json:"cpu_feature_list,omitempty"`
	// Memory usage derived from MemTotal - (MemFree + Buffers + Cached).
	MemUsageBytes *int64 `protobuf:"varint,10,opt,name=mem_usage_bytes,json=memUsageBytes" json:"mem_usage_bytes,omitempty"`
	// List of GPUs available on this node.
	GpuList []*NodeGPU `protobuf:"bytes,11,rep,name=gpu_list,json=gpuList" json:"gpu_list,omitempty"`
	// Memory usage calculated from fields in "/proc/meminfo" and also including
	// the overheads like microsegmentation etc as seen by scheduler. It does not
	// account for the HA reservations. This value is obtained from
	// SchedulerNodeInfo. It is expressed as parts per million. To get percentage,
	// the value should be divided by 1 million and multiplied by 100.
	AggregateMemUsagePpm *int64 `protobuf:"varint,12,opt,name=aggregate_mem_usage_ppm,json=aggregateMemUsagePpm" json:"aggregate_mem_usage_ppm,omitempty"`
	// Size of a regular page on the host in bytes.
	RegularPageSizeBytes *int64 `protobuf:"varint,13,opt,name=regular_page_size_bytes,json=regularPageSizeBytes" json:"regular_page_size_bytes,omitempty"`
	// Size of a huge page on the host in kilobytes.
	HugepageSizeKb *int64 `protobuf:"varint,14,opt,name=hugepage_size_kb,json=hugepageSizeKb" json:"hugepage_size_kb,omitempty"`
	// Total huge pages that are currently allocated on the host in kilobytes.
	HugepagesTotalMemKb *int64 `protobuf:"varint,15,opt,name=hugepages_total_mem_kb,json=hugepagesTotalMemKb" json:"hugepages_total_mem_kb,omitempty"`
	// Huge pages that are currently used by the host in kilobytes.
	HugepagesUsedMemKb *int64 `protobuf:"varint,16,opt,name=hugepages_used_mem_kb,json=hugepagesUsedMemKb" json:"hugepages_used_mem_kb,omitempty"`
	// Regular pages used for the host in kilobytes.
	RegularPagesUsedMemKb *int64   `protobuf:"varint,17,opt,name=regular_pages_used_mem_kb,json=regularPagesUsedMemKb" json:"regular_pages_used_mem_kb,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *HostInfo) Reset()         { *m = HostInfo{} }
func (m *HostInfo) String() string { return proto.CompactTextString(m) }
func (*HostInfo) ProtoMessage()    {}
func (*HostInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{58}
}

func (m *HostInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostInfo.Unmarshal(m, b)
}
func (m *HostInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostInfo.Marshal(b, m, deterministic)
}
func (m *HostInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostInfo.Merge(m, src)
}
func (m *HostInfo) XXX_Size() int {
	return xxx_messageInfo_HostInfo.Size(m)
}
func (m *HostInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_HostInfo.DiscardUnknown(m)
}

var xxx_messageInfo_HostInfo proto.InternalMessageInfo

func (m *HostInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *HostInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *HostInfo) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *HostInfo) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *HostInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *HostInfo) GetCpuUsagePpm() int64 {
	if m != nil && m.CpuUsagePpm != nil {
		return *m.CpuUsagePpm
	}
	return 0
}

func (m *HostInfo) GetMemUsagePpm() int64 {
	if m != nil && m.MemUsagePpm != nil {
		return *m.MemUsagePpm
	}
	return 0
}

func (m *HostInfo) GetHypervisorType() HypervisorType_Type {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return HypervisorType_kKvm
}

func (m *HostInfo) GetCpuFeatureList() []string {
	if m != nil {
		return m.CpuFeatureList
	}
	return nil
}

func (m *HostInfo) GetMemUsageBytes() int64 {
	if m != nil && m.MemUsageBytes != nil {
		return *m.MemUsageBytes
	}
	return 0
}

func (m *HostInfo) GetGpuList() []*NodeGPU {
	if m != nil {
		return m.GpuList
	}
	return nil
}

func (m *HostInfo) GetAggregateMemUsagePpm() int64 {
	if m != nil && m.AggregateMemUsagePpm != nil {
		return *m.AggregateMemUsagePpm
	}
	return 0
}

func (m *HostInfo) GetRegularPageSizeBytes() int64 {
	if m != nil && m.RegularPageSizeBytes != nil {
		return *m.RegularPageSizeBytes
	}
	return 0
}

func (m *HostInfo) GetHugepageSizeKb() int64 {
	if m != nil && m.HugepageSizeKb != nil {
		return *m.HugepageSizeKb
	}
	return 0
}

func (m *HostInfo) GetHugepagesTotalMemKb() int64 {
	if m != nil && m.HugepagesTotalMemKb != nil {
		return *m.HugepagesTotalMemKb
	}
	return 0
}

func (m *HostInfo) GetHugepagesUsedMemKb() int64 {
	if m != nil && m.HugepagesUsedMemKb != nil {
		return *m.HugepagesUsedMemKb
	}
	return 0
}

func (m *HostInfo) GetRegularPagesUsedMemKb() int64 {
	if m != nil && m.RegularPagesUsedMemKb != nil {
		return *m.RegularPagesUsedMemKb
	}
	return 0
}

// Host GPU configuration proto for CPDB.
type HostGpu struct {
	// Type of the GPU resource.
	// kVirtual or kPassthroughCompute or kPassthroughGraphics.
	GpuType *string `protobuf:"bytes,1,opt,name=gpu_type,json=gpuType" json:"gpu_type,omitempty"`
	// Vendor of GPU resource (Eg: kNvidia).
	VendorName *string `protobuf:"bytes,2,opt,name=vendor_name,json=vendorName" json:"vendor_name,omitempty"`
	// Device ID of the GPU resource (Eg: 5106).
	DeviceId *string `protobuf:"bytes,3,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Vendor Device string (Eg: "GM204GL [Tesla M60]").
	DeviceName *string `protobuf:"bytes,4,opt,name=device_name,json=deviceName" json:"device_name,omitempty"`
	// Unique device information.
	// SBDF string must be in format: "ffff:ff:ff.f".
	Sbdf *string `protobuf:"bytes,5,opt,name=sbdf" json:"sbdf,omitempty"`
	// Whether the GPU device is in use or not.
	// 0-Not in use, 1-In use.
	InUse *int64 `protobuf:"varint,6,opt,name=in_use,json=inUse" json:"in_use,omitempty"`
	// NUMA node GPU belongs to.
	NumaNode *string `protobuf:"bytes,7,opt,name=numa_node,json=numaNode" json:"numa_node,omitempty"`
	// Host ID stored in zeus.
	HostId *string `protobuf:"bytes,8,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// UUID of the node.
	Node *string `protobuf:"bytes,9,opt,name=node" json:"node,omitempty"`
	// Cluster UUID.
	Cluster *string `protobuf:"bytes,10,opt,name=cluster" json:"cluster,omitempty"`
	// Cluster name.
	ClusterName *string `protobuf:"bytes,11,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// Last determined guest driver version.
	GuestDriverVersion *string `protobuf:"bytes,12,opt,name=guest_driver_version,json=guestDriverVersion" json:"guest_driver_version,omitempty"`
	// Number of supported virtual display heads.
	NumVirtualDisplayHeads *int64 `protobuf:"varint,13,opt,name=num_virtual_display_heads,json=numVirtualDisplayHeads" json:"num_virtual_display_heads,omitempty"`
	// Maximum resolution per display head.
	MaxResolution *string `protobuf:"bytes,14,opt,name=max_resolution,json=maxResolution" json:"max_resolution,omitempty"`
	// Fraction of the physical GPU, if this is a vGPU instance.
	Fraction *int64 `protobuf:"varint,15,opt,name=fraction" json:"fraction,omitempty"`
	// GPU framebuffer size.
	FrameBufferSizeBytes *int64 `protobuf:"varint,16,opt,name=frame_buffer_size_bytes,json=frameBufferSizeBytes" json:"frame_buffer_size_bytes,omitempty"`
	// List of license types associated with this GPU.
	LicenseList []string `protobuf:"bytes,17,rep,name=license_list,json=licenseList" json:"license_list,omitempty"`
	// Unused or UsedForPassthrough or UsedForVirtual.
	GpuMode *string `protobuf:"bytes,18,opt,name=gpu_mode,json=gpuMode" json:"gpu_mode,omitempty"`
	// Whether the GPU can be assigned to a VM (1 if True, else 0).
	Assignable *int64 `protobuf:"varint,19,opt,name=assignable" json:"assignable,omitempty"`
	// Number of allocated vGPUs if this is an instance of pGPU.
	NumVgpusAllocated *int64 `protobuf:"varint,20,opt,name=num_vgpus_allocated,json=numVgpusAllocated" json:"num_vgpus_allocated,omitempty"`
	// Maximum potential vGPUs if this is an instance of pGPU.
	MaxAllocatable *int64 `protobuf:"varint,21,opt,name=max_allocatable,json=maxAllocatable" json:"max_allocatable,omitempty"`
	// Index of GPU if this is an instance of vGPU.
	Index *int64 `protobuf:"varint,22,opt,name=index" json:"index,omitempty"`
	// Name of the host.
	NodeName *string `protobuf:"bytes,23,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	// UUID of the VMs to which the current entity is assigned for.
	// Incase when pGPU is acting as vGPU, all the VMs currently using its vGPU
	// resource will be listed, otherwise only single VM will be populated.
	VmUuidList []string `protobuf:"bytes,24,rep,name=vm_uuid_list,json=vmUuidList" json:"vm_uuid_list,omitempty"`
	// Profile of GPU.
	VgpuProfile *string `protobuf:"bytes,25,opt,name=vgpu_profile,json=vgpuProfile" json:"vgpu_profile,omitempty"`
	// Arithmos ID.
	XArithmosId_ *string `protobuf:"bytes,26,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Maximum number of vGPU instances of this kind that can be assigned to a VM.
	MaxInstancesPerVm    *uint32  `protobuf:"varint,27,opt,name=max_instances_per_vm,json=maxInstancesPerVm" json:"max_instances_per_vm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostGpu) Reset()         { *m = HostGpu{} }
func (m *HostGpu) String() string { return proto.CompactTextString(m) }
func (*HostGpu) ProtoMessage()    {}
func (*HostGpu) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{59}
}

func (m *HostGpu) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostGpu.Unmarshal(m, b)
}
func (m *HostGpu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostGpu.Marshal(b, m, deterministic)
}
func (m *HostGpu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostGpu.Merge(m, src)
}
func (m *HostGpu) XXX_Size() int {
	return xxx_messageInfo_HostGpu.Size(m)
}
func (m *HostGpu) XXX_DiscardUnknown() {
	xxx_messageInfo_HostGpu.DiscardUnknown(m)
}

var xxx_messageInfo_HostGpu proto.InternalMessageInfo

func (m *HostGpu) GetGpuType() string {
	if m != nil && m.GpuType != nil {
		return *m.GpuType
	}
	return ""
}

func (m *HostGpu) GetVendorName() string {
	if m != nil && m.VendorName != nil {
		return *m.VendorName
	}
	return ""
}

func (m *HostGpu) GetDeviceId() string {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return ""
}

func (m *HostGpu) GetDeviceName() string {
	if m != nil && m.DeviceName != nil {
		return *m.DeviceName
	}
	return ""
}

func (m *HostGpu) GetSbdf() string {
	if m != nil && m.Sbdf != nil {
		return *m.Sbdf
	}
	return ""
}

func (m *HostGpu) GetInUse() int64 {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return 0
}

func (m *HostGpu) GetNumaNode() string {
	if m != nil && m.NumaNode != nil {
		return *m.NumaNode
	}
	return ""
}

func (m *HostGpu) GetHostId() string {
	if m != nil && m.HostId != nil {
		return *m.HostId
	}
	return ""
}

func (m *HostGpu) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *HostGpu) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *HostGpu) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *HostGpu) GetGuestDriverVersion() string {
	if m != nil && m.GuestDriverVersion != nil {
		return *m.GuestDriverVersion
	}
	return ""
}

func (m *HostGpu) GetNumVirtualDisplayHeads() int64 {
	if m != nil && m.NumVirtualDisplayHeads != nil {
		return *m.NumVirtualDisplayHeads
	}
	return 0
}

func (m *HostGpu) GetMaxResolution() string {
	if m != nil && m.MaxResolution != nil {
		return *m.MaxResolution
	}
	return ""
}

func (m *HostGpu) GetFraction() int64 {
	if m != nil && m.Fraction != nil {
		return *m.Fraction
	}
	return 0
}

func (m *HostGpu) GetFrameBufferSizeBytes() int64 {
	if m != nil && m.FrameBufferSizeBytes != nil {
		return *m.FrameBufferSizeBytes
	}
	return 0
}

func (m *HostGpu) GetLicenseList() []string {
	if m != nil {
		return m.LicenseList
	}
	return nil
}

func (m *HostGpu) GetGpuMode() string {
	if m != nil && m.GpuMode != nil {
		return *m.GpuMode
	}
	return ""
}

func (m *HostGpu) GetAssignable() int64 {
	if m != nil && m.Assignable != nil {
		return *m.Assignable
	}
	return 0
}

func (m *HostGpu) GetNumVgpusAllocated() int64 {
	if m != nil && m.NumVgpusAllocated != nil {
		return *m.NumVgpusAllocated
	}
	return 0
}

func (m *HostGpu) GetMaxAllocatable() int64 {
	if m != nil && m.MaxAllocatable != nil {
		return *m.MaxAllocatable
	}
	return 0
}

func (m *HostGpu) GetIndex() int64 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *HostGpu) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

func (m *HostGpu) GetVmUuidList() []string {
	if m != nil {
		return m.VmUuidList
	}
	return nil
}

func (m *HostGpu) GetVgpuProfile() string {
	if m != nil && m.VgpuProfile != nil {
		return *m.VgpuProfile
	}
	return ""
}

func (m *HostGpu) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *HostGpu) GetMaxInstancesPerVm() uint32 {
	if m != nil && m.MaxInstancesPerVm != nil {
		return *m.MaxInstancesPerVm
	}
	return 0
}

// Host NIC configuration proto for CPDB.
type HostNic struct {
	// Management IP Address.
	SwitchMgmtIpAddress *string `protobuf:"bytes,1,opt,name=switch_mgmt_ip_address,json=switchMgmtIpAddress" json:"switch_mgmt_ip_address,omitempty"`
	// Switch platform name.
	SwitchHardwarePlatform *string `protobuf:"bytes,2,opt,name=switch_hardware_platform,json=switchHardwarePlatform" json:"switch_hardware_platform,omitempty"`
	// Switch port ID.
	SwitchPortId *string `protobuf:"bytes,3,opt,name=switch_port_id,json=switchPortId" json:"switch_port_id,omitempty"`
	// Switch device ID. (E.g.: R2-AGS)
	SwitchDevId *string `protobuf:"bytes,4,opt,name=switch_dev_id,json=switchDevId" json:"switch_dev_id,omitempty"`
	// Port name (eth0, eth1..).
	PortName *string `protobuf:"bytes,5,opt,name=port_name,json=portName" json:"port_name,omitempty"`
	// MAC address.
	MacAddress *string `protobuf:"bytes,6,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// IPV6 Address list.
	Ipv6Addresses []string `protobuf:"bytes,7,rep,name=ipv6_addresses,json=ipv6Addresses" json:"ipv6_addresses,omitempty"`
	// IPV4 Address list.
	Ipv4Addresses []string `protobuf:"bytes,8,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// Discovery protocol used for switch.
	DiscoveryProtocol *string `protobuf:"bytes,9,opt,name=discovery_protocol,json=discoveryProtocol" json:"discovery_protocol,omitempty"`
	// DHCP enabled.
	DhcpEnabled *int64 `protobuf:"varint,10,opt,name=dhcp_enabled,json=dhcpEnabled" json:"dhcp_enabled,omitempty"`
	// Switch VLAN ID.
	SwitchVlanId *int64 `protobuf:"varint,11,opt,name=switch_vlan_id,json=switchVlanId" json:"switch_vlan_id,omitempty"`
	// Node uuid. For compatibility with insights we don't call it node_uuid.
	Node *string `protobuf:"bytes,12,opt,name=node" json:"node,omitempty"`
	// Host ID stored in zeus.
	HostId *string `protobuf:"bytes,13,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// Description for nic.
	Description *string `protobuf:"bytes,14,opt,name=description" json:"description,omitempty"`
	// MTU.
	MtuBytes *int64 `protobuf:"varint,15,opt,name=mtu_bytes,json=mtuBytes" json:"mtu_bytes,omitempty"`
	// Status of the pnic.
	Status *string `protobuf:"bytes,16,opt,name=status" json:"status,omitempty"`
	// Speed of the link.
	LinkSpeedKbps *int64 `protobuf:"varint,17,opt,name=link_speed_kbps,json=linkSpeedKbps" json:"link_speed_kbps,omitempty"`
	// Switch name.
	SwitchName *string `protobuf:"bytes,18,opt,name=switch_name,json=switchName" json:"switch_name,omitempty"`
	// Switch MAC addr.
	SwitchMacAddr *string `protobuf:"bytes,19,opt,name=switch_mac_addr,json=switchMacAddr" json:"switch_mac_addr,omitempty"`
	// Switch port name.
	SwitchPortName *string `protobuf:"bytes,20,opt,name=switch_port_name,json=switchPortName" json:"switch_port_name,omitempty"`
	// Switch port description.
	SwitchPortDescr *string `protobuf:"bytes,21,opt,name=switch_port_descr,json=switchPortDescr" json:"switch_port_descr,omitempty"`
	// Host nic link capacity.
	LinkCapacity *int64 `protobuf:"varint,22,opt,name=link_capacity,json=linkCapacity" json:"link_capacity,omitempty"`
	// Host nic link connectivity.
	LinkDetected *uint64 `protobuf:"varint,23,opt,name=link_detected,json=linkDetected" json:"link_detected,omitempty"`
	// Switch port native VLAN id.
	SwitchPortNativeVlan *string  `protobuf:"bytes,24,opt,name=switch_port_native_vlan,json=switchPortNativeVlan" json:"switch_port_native_vlan,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostNic) Reset()         { *m = HostNic{} }
func (m *HostNic) String() string { return proto.CompactTextString(m) }
func (*HostNic) ProtoMessage()    {}
func (*HostNic) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{60}
}

func (m *HostNic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostNic.Unmarshal(m, b)
}
func (m *HostNic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostNic.Marshal(b, m, deterministic)
}
func (m *HostNic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostNic.Merge(m, src)
}
func (m *HostNic) XXX_Size() int {
	return xxx_messageInfo_HostNic.Size(m)
}
func (m *HostNic) XXX_DiscardUnknown() {
	xxx_messageInfo_HostNic.DiscardUnknown(m)
}

var xxx_messageInfo_HostNic proto.InternalMessageInfo

func (m *HostNic) GetSwitchMgmtIpAddress() string {
	if m != nil && m.SwitchMgmtIpAddress != nil {
		return *m.SwitchMgmtIpAddress
	}
	return ""
}

func (m *HostNic) GetSwitchHardwarePlatform() string {
	if m != nil && m.SwitchHardwarePlatform != nil {
		return *m.SwitchHardwarePlatform
	}
	return ""
}

func (m *HostNic) GetSwitchPortId() string {
	if m != nil && m.SwitchPortId != nil {
		return *m.SwitchPortId
	}
	return ""
}

func (m *HostNic) GetSwitchDevId() string {
	if m != nil && m.SwitchDevId != nil {
		return *m.SwitchDevId
	}
	return ""
}

func (m *HostNic) GetPortName() string {
	if m != nil && m.PortName != nil {
		return *m.PortName
	}
	return ""
}

func (m *HostNic) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *HostNic) GetIpv6Addresses() []string {
	if m != nil {
		return m.Ipv6Addresses
	}
	return nil
}

func (m *HostNic) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *HostNic) GetDiscoveryProtocol() string {
	if m != nil && m.DiscoveryProtocol != nil {
		return *m.DiscoveryProtocol
	}
	return ""
}

func (m *HostNic) GetDhcpEnabled() int64 {
	if m != nil && m.DhcpEnabled != nil {
		return *m.DhcpEnabled
	}
	return 0
}

func (m *HostNic) GetSwitchVlanId() int64 {
	if m != nil && m.SwitchVlanId != nil {
		return *m.SwitchVlanId
	}
	return 0
}

func (m *HostNic) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *HostNic) GetHostId() string {
	if m != nil && m.HostId != nil {
		return *m.HostId
	}
	return ""
}

func (m *HostNic) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *HostNic) GetMtuBytes() int64 {
	if m != nil && m.MtuBytes != nil {
		return *m.MtuBytes
	}
	return 0
}

func (m *HostNic) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *HostNic) GetLinkSpeedKbps() int64 {
	if m != nil && m.LinkSpeedKbps != nil {
		return *m.LinkSpeedKbps
	}
	return 0
}

func (m *HostNic) GetSwitchName() string {
	if m != nil && m.SwitchName != nil {
		return *m.SwitchName
	}
	return ""
}

func (m *HostNic) GetSwitchMacAddr() string {
	if m != nil && m.SwitchMacAddr != nil {
		return *m.SwitchMacAddr
	}
	return ""
}

func (m *HostNic) GetSwitchPortName() string {
	if m != nil && m.SwitchPortName != nil {
		return *m.SwitchPortName
	}
	return ""
}

func (m *HostNic) GetSwitchPortDescr() string {
	if m != nil && m.SwitchPortDescr != nil {
		return *m.SwitchPortDescr
	}
	return ""
}

func (m *HostNic) GetLinkCapacity() int64 {
	if m != nil && m.LinkCapacity != nil {
		return *m.LinkCapacity
	}
	return 0
}

func (m *HostNic) GetLinkDetected() uint64 {
	if m != nil && m.LinkDetected != nil {
		return *m.LinkDetected
	}
	return 0
}

func (m *HostNic) GetSwitchPortNativeVlan() string {
	if m != nil && m.SwitchPortNativeVlan != nil {
		return *m.SwitchPortNativeVlan
	}
	return ""
}

// Virtual network proto in CPDB. Note that this is used for both acropolis
// networks (subnets) and overlay subnets.
type VirtualNetwork struct {
	// Gateway. E.g: 10.1.64.1
	Ipv4Gateway *string `protobuf:"bytes,1,opt,name=ipv4_gateway,json=ipv4Gateway" json:"ipv4_gateway,omitempty"`
	// Subnet. E.g: 10.1.64.0/255.255.255.0
	Ipv4Subnet *string `protobuf:"bytes,2,opt,name=ipv4_subnet,json=ipv4Subnet" json:"ipv4_subnet,omitempty"`
	// VLAN ID. 64
	VlanId *string `protobuf:"bytes,3,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// Name of the virtual network.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Hypervisor type. E.g: "github.com/nutanix-core/acs-aos-go/acropolis".
	HypervisorType *string `protobuf:"bytes,5,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// ID of the virtual network.
	Id *string `protobuf:"bytes,6,opt,name=id" json:"id,omitempty"`
	// Managed type (for esx).
	ManagedType *string `protobuf:"bytes,7,opt,name=managed_type,json=managedType" json:"managed_type,omitempty"`
	// Cluster UUID.
	ClusterUuid *string `protobuf:"bytes,8,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Cluster name.
	ClusterName *string `protobuf:"bytes,9,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// Arithmos ID.
	XArithmosId_ *string `protobuf:"bytes,10,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Virtual switch name.
	VirtualSwitchName *string `protobuf:"bytes,11,opt,name=virtual_switch_name,json=virtualSwitchName" json:"virtual_switch_name,omitempty"`
	// Number of Physical NICs.
	PnicNum *int64 `protobuf:"varint,12,opt,name=pnic_num,json=pnicNum" json:"pnic_num,omitempty"`
	// DVS switch uuid.
	SwitchUuid *string `protobuf:"bytes,13,opt,name=switch_uuid,json=switchUuid" json:"switch_uuid,omitempty"`
	// Subnet type: "VLAN" or "EXTERNAL".
	SubnetType     *string                         `protobuf:"bytes,14,opt,name=subnet_type,json=subnetType" json:"subnet_type,omitempty"`
	DhcpOptionList []*VirtualNetwork_DHCPOption    `protobuf:"bytes,15,rep,name=dhcp_option_list,json=dhcpOptionList" json:"dhcp_option_list,omitempty"`
	IpPoolList     []*VirtualNetwork_IpAddressPool `protobuf:"bytes,16,rep,name=ip_pool_list,json=ipPoolList" json:"ip_pool_list,omitempty"`
	// IP address of the DHCP server for an Acropolis managed network.
	DhcpServerAddress *string `protobuf:"bytes,17,opt,name=dhcp_server_address,json=dhcpServerAddress" json:"dhcp_server_address,omitempty"`
	// UUID of the network function chain to use for this network.
	NetworkFunctionChainUuid *string `protobuf:"bytes,18,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// User annotation for the virtual network.
	Annotation *string `protobuf:"bytes,19,opt,name=annotation" json:"annotation,omitempty"`
	// UUID for the overlay network this virtual network is a part of.
	OverlayNetworkUuid *string `protobuf:"bytes,20,opt,name=overlay_network_uuid,json=overlayNetworkUuid" json:"overlay_network_uuid,omitempty"`
	// Whether external connectivity via source nat is enabled for this subnet.
	SourceNatEnabled *bool `protobuf:"varint,21,opt,name=source_nat_enabled,json=sourceNatEnabled" json:"source_nat_enabled,omitempty"`
	// The availability zone list for this subnet.
	AvailabilityZoneUuidList []string `protobuf:"bytes,22,rep,name=availability_zone_uuid_list,json=availabilityZoneUuidList" json:"availability_zone_uuid_list,omitempty"`
	// Distributed virtual switch UUID.
	VirtualSwitchUuid *string `protobuf:"bytes,23,opt,name=virtual_switch_uuid,json=virtualSwitchUuid" json:"virtual_switch_uuid,omitempty"`
	// Whether the subnet is an external subnet or not.
	IsExternal *bool `protobuf:"varint,24,opt,name=is_external,json=isExternal" json:"is_external,omitempty"`
	// Whether advanced networking is enabled for this subnet or not.
	AdvancedNetworking *bool `protobuf:"varint,25,opt,name=advanced_networking,json=advancedNetworking" json:"advanced_networking,omitempty"`
	// List of reserved IP addresses that can't be assigned to ports or vNICs.
	ReservedIpAddressList []string `protobuf:"bytes,26,rep,name=reserved_ip_address_list,json=reservedIpAddressList" json:"reserved_ip_address_list,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *VirtualNetwork) Reset()         { *m = VirtualNetwork{} }
func (m *VirtualNetwork) String() string { return proto.CompactTextString(m) }
func (*VirtualNetwork) ProtoMessage()    {}
func (*VirtualNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{61}
}

func (m *VirtualNetwork) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetwork.Unmarshal(m, b)
}
func (m *VirtualNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetwork.Marshal(b, m, deterministic)
}
func (m *VirtualNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetwork.Merge(m, src)
}
func (m *VirtualNetwork) XXX_Size() int {
	return xxx_messageInfo_VirtualNetwork.Size(m)
}
func (m *VirtualNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetwork proto.InternalMessageInfo

func (m *VirtualNetwork) GetIpv4Gateway() string {
	if m != nil && m.Ipv4Gateway != nil {
		return *m.Ipv4Gateway
	}
	return ""
}

func (m *VirtualNetwork) GetIpv4Subnet() string {
	if m != nil && m.Ipv4Subnet != nil {
		return *m.Ipv4Subnet
	}
	return ""
}

func (m *VirtualNetwork) GetVlanId() string {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return ""
}

func (m *VirtualNetwork) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VirtualNetwork) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VirtualNetwork) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *VirtualNetwork) GetManagedType() string {
	if m != nil && m.ManagedType != nil {
		return *m.ManagedType
	}
	return ""
}

func (m *VirtualNetwork) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *VirtualNetwork) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *VirtualNetwork) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VirtualNetwork) GetVirtualSwitchName() string {
	if m != nil && m.VirtualSwitchName != nil {
		return *m.VirtualSwitchName
	}
	return ""
}

func (m *VirtualNetwork) GetPnicNum() int64 {
	if m != nil && m.PnicNum != nil {
		return *m.PnicNum
	}
	return 0
}

func (m *VirtualNetwork) GetSwitchUuid() string {
	if m != nil && m.SwitchUuid != nil {
		return *m.SwitchUuid
	}
	return ""
}

func (m *VirtualNetwork) GetSubnetType() string {
	if m != nil && m.SubnetType != nil {
		return *m.SubnetType
	}
	return ""
}

func (m *VirtualNetwork) GetDhcpOptionList() []*VirtualNetwork_DHCPOption {
	if m != nil {
		return m.DhcpOptionList
	}
	return nil
}

func (m *VirtualNetwork) GetIpPoolList() []*VirtualNetwork_IpAddressPool {
	if m != nil {
		return m.IpPoolList
	}
	return nil
}

func (m *VirtualNetwork) GetDhcpServerAddress() string {
	if m != nil && m.DhcpServerAddress != nil {
		return *m.DhcpServerAddress
	}
	return ""
}

func (m *VirtualNetwork) GetNetworkFunctionChainUuid() string {
	if m != nil && m.NetworkFunctionChainUuid != nil {
		return *m.NetworkFunctionChainUuid
	}
	return ""
}

func (m *VirtualNetwork) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VirtualNetwork) GetOverlayNetworkUuid() string {
	if m != nil && m.OverlayNetworkUuid != nil {
		return *m.OverlayNetworkUuid
	}
	return ""
}

func (m *VirtualNetwork) GetSourceNatEnabled() bool {
	if m != nil && m.SourceNatEnabled != nil {
		return *m.SourceNatEnabled
	}
	return false
}

func (m *VirtualNetwork) GetAvailabilityZoneUuidList() []string {
	if m != nil {
		return m.AvailabilityZoneUuidList
	}
	return nil
}

func (m *VirtualNetwork) GetVirtualSwitchUuid() string {
	if m != nil && m.VirtualSwitchUuid != nil {
		return *m.VirtualSwitchUuid
	}
	return ""
}

func (m *VirtualNetwork) GetIsExternal() bool {
	if m != nil && m.IsExternal != nil {
		return *m.IsExternal
	}
	return false
}

func (m *VirtualNetwork) GetAdvancedNetworking() bool {
	if m != nil && m.AdvancedNetworking != nil {
		return *m.AdvancedNetworking
	}
	return false
}

func (m *VirtualNetwork) GetReservedIpAddressList() []string {
	if m != nil {
		return m.ReservedIpAddressList
	}
	return nil
}

// DHCP options for an Acropolis managed network.
type VirtualNetwork_DHCPOption struct {
	// DHCP option name.
	OptionName *string `protobuf:"bytes,1,opt,name=option_name,json=optionName" json:"option_name,omitempty"`
	// DHCP option value.
	OptionValueStr *string `protobuf:"bytes,2,opt,name=option_value_str,json=optionValueStr" json:"option_value_str,omitempty"`
	// DHCP option code.
	OptionCode *int32 `protobuf:"varint,3,opt,name=option_code,json=optionCode" json:"option_code,omitempty"`
	// DHCP option value in network byte order.
	OptionValue          []byte   `protobuf:"bytes,4,opt,name=option_value,json=optionValue" json:"option_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNetwork_DHCPOption) Reset()         { *m = VirtualNetwork_DHCPOption{} }
func (m *VirtualNetwork_DHCPOption) String() string { return proto.CompactTextString(m) }
func (*VirtualNetwork_DHCPOption) ProtoMessage()    {}
func (*VirtualNetwork_DHCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{61, 0}
}

func (m *VirtualNetwork_DHCPOption) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetwork_DHCPOption.Unmarshal(m, b)
}
func (m *VirtualNetwork_DHCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetwork_DHCPOption.Marshal(b, m, deterministic)
}
func (m *VirtualNetwork_DHCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetwork_DHCPOption.Merge(m, src)
}
func (m *VirtualNetwork_DHCPOption) XXX_Size() int {
	return xxx_messageInfo_VirtualNetwork_DHCPOption.Size(m)
}
func (m *VirtualNetwork_DHCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetwork_DHCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetwork_DHCPOption proto.InternalMessageInfo

func (m *VirtualNetwork_DHCPOption) GetOptionName() string {
	if m != nil && m.OptionName != nil {
		return *m.OptionName
	}
	return ""
}

func (m *VirtualNetwork_DHCPOption) GetOptionValueStr() string {
	if m != nil && m.OptionValueStr != nil {
		return *m.OptionValueStr
	}
	return ""
}

func (m *VirtualNetwork_DHCPOption) GetOptionCode() int32 {
	if m != nil && m.OptionCode != nil {
		return *m.OptionCode
	}
	return 0
}

func (m *VirtualNetwork_DHCPOption) GetOptionValue() []byte {
	if m != nil {
		return m.OptionValue
	}
	return nil
}

// Dynamic IP address pools for an Acropolis managed network.
type VirtualNetwork_IpAddressPool struct {
	StartAddress         *string  `protobuf:"bytes,1,opt,name=start_address,json=startAddress" json:"start_address,omitempty"`
	EndAddress           *string  `protobuf:"bytes,2,opt,name=end_address,json=endAddress" json:"end_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNetwork_IpAddressPool) Reset()         { *m = VirtualNetwork_IpAddressPool{} }
func (m *VirtualNetwork_IpAddressPool) String() string { return proto.CompactTextString(m) }
func (*VirtualNetwork_IpAddressPool) ProtoMessage()    {}
func (*VirtualNetwork_IpAddressPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{61, 1}
}

func (m *VirtualNetwork_IpAddressPool) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetwork_IpAddressPool.Unmarshal(m, b)
}
func (m *VirtualNetwork_IpAddressPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetwork_IpAddressPool.Marshal(b, m, deterministic)
}
func (m *VirtualNetwork_IpAddressPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetwork_IpAddressPool.Merge(m, src)
}
func (m *VirtualNetwork_IpAddressPool) XXX_Size() int {
	return xxx_messageInfo_VirtualNetwork_IpAddressPool.Size(m)
}
func (m *VirtualNetwork_IpAddressPool) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetwork_IpAddressPool.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetwork_IpAddressPool proto.InternalMessageInfo

func (m *VirtualNetwork_IpAddressPool) GetStartAddress() string {
	if m != nil && m.StartAddress != nil {
		return *m.StartAddress
	}
	return ""
}

func (m *VirtualNetwork_IpAddressPool) GetEndAddress() string {
	if m != nil && m.EndAddress != nil {
		return *m.EndAddress
	}
	return ""
}

// Virtual switch proto in CPDB
type VirtualSwitch struct {
	// List of host nic UUIDs.
	HostNic []string `protobuf:"bytes,1,rep,name=host_nic,json=hostNic" json:"host_nic,omitempty"`
	// Hypervisor type.
	HypervisorType *string `protobuf:"bytes,2,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// Name of the virtual nic. (br0)
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Node UUID should be string for CPDB.
	Node *string `protobuf:"bytes,4,opt,name=node" json:"node,omitempty"`
	// MTU bytes
	MtuBytes *int64 `protobuf:"varint,5,opt,name=mtu_bytes,json=mtuBytes" json:"mtu_bytes,omitempty"`
	// Virtual network UUID associated with this switch.
	VirtualNetwork []string `protobuf:"bytes,6,rep,name=virtual_network,json=virtualNetwork" json:"virtual_network,omitempty"`
	// Nic team. Nic team UUIDs this virtual switch belongs to.
	NicTeam              []string `protobuf:"bytes,7,rep,name=nic_team,json=nicTeam" json:"nic_team,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualSwitch) Reset()         { *m = VirtualSwitch{} }
func (m *VirtualSwitch) String() string { return proto.CompactTextString(m) }
func (*VirtualSwitch) ProtoMessage()    {}
func (*VirtualSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{62}
}

func (m *VirtualSwitch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualSwitch.Unmarshal(m, b)
}
func (m *VirtualSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualSwitch.Marshal(b, m, deterministic)
}
func (m *VirtualSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualSwitch.Merge(m, src)
}
func (m *VirtualSwitch) XXX_Size() int {
	return xxx_messageInfo_VirtualSwitch.Size(m)
}
func (m *VirtualSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualSwitch proto.InternalMessageInfo

func (m *VirtualSwitch) GetHostNic() []string {
	if m != nil {
		return m.HostNic
	}
	return nil
}

func (m *VirtualSwitch) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VirtualSwitch) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VirtualSwitch) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *VirtualSwitch) GetMtuBytes() int64 {
	if m != nil && m.MtuBytes != nil {
		return *m.MtuBytes
	}
	return 0
}

func (m *VirtualSwitch) GetVirtualNetwork() []string {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *VirtualSwitch) GetNicTeam() []string {
	if m != nil {
		return m.NicTeam
	}
	return nil
}

// Nic bond proto in CPDB
type NicTeam struct {
	// Host nics in this bond.
	HostNic []string `protobuf:"bytes,1,rep,name=host_nic,json=hostNic" json:"host_nic,omitempty"`
	// Active host nic in this bond.
	ActiveHostNic []string `protobuf:"bytes,2,rep,name=active_host_nic,json=activeHostNic" json:"active_host_nic,omitempty"`
	// Passive host nic in this bond.
	PassiveHostNic []string `protobuf:"bytes,3,rep,name=passive_host_nic,json=passiveHostNic" json:"passive_host_nic,omitempty"`
	// Bond type.
	Type *string `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// Bond name.
	Name *string `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	// Node UUID string.
	Node *string `protobuf:"bytes,6,opt,name=node" json:"node,omitempty"`
	// LACP status.
	LacpStatus           *string  `protobuf:"bytes,7,opt,name=lacp_status,json=lacpStatus" json:"lacp_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NicTeam) Reset()         { *m = NicTeam{} }
func (m *NicTeam) String() string { return proto.CompactTextString(m) }
func (*NicTeam) ProtoMessage()    {}
func (*NicTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{63}
}

func (m *NicTeam) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NicTeam.Unmarshal(m, b)
}
func (m *NicTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NicTeam.Marshal(b, m, deterministic)
}
func (m *NicTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NicTeam.Merge(m, src)
}
func (m *NicTeam) XXX_Size() int {
	return xxx_messageInfo_NicTeam.Size(m)
}
func (m *NicTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_NicTeam.DiscardUnknown(m)
}

var xxx_messageInfo_NicTeam proto.InternalMessageInfo

func (m *NicTeam) GetHostNic() []string {
	if m != nil {
		return m.HostNic
	}
	return nil
}

func (m *NicTeam) GetActiveHostNic() []string {
	if m != nil {
		return m.ActiveHostNic
	}
	return nil
}

func (m *NicTeam) GetPassiveHostNic() []string {
	if m != nil {
		return m.PassiveHostNic
	}
	return nil
}

func (m *NicTeam) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *NicTeam) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NicTeam) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *NicTeam) GetLacpStatus() string {
	if m != nil && m.LacpStatus != nil {
		return *m.LacpStatus
	}
	return ""
}

type SchedulerNodeInfo struct {
	// UUID of the scheduler host.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Host name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// String describing the host.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Whether the host has been deleted.
	Deleted *bool `protobuf:"varint,4,opt,name=deleted" json:"deleted,omitempty"`
	// The logical timestamp for the host.
	LogicalTimestamp *int64 `protobuf:"varint,5,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// Average CPU usage expressed in parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	CpuUsagePpm *int64 `protobuf:"varint,6,opt,name=cpu_usage_ppm,json=cpuUsagePpm" json:"cpu_usage_ppm,omitempty"`
	// Number of CPUs.
	NumCpus *uint64 `protobuf:"varint,7,opt,name=num_cpus,json=numCpus" json:"num_cpus,omitempty"`
	// Total memory size in bytes.
	MemorySizeBytes *uint64 `protobuf:"varint,8,opt,name=memory_size_bytes,json=memorySizeBytes" json:"memory_size_bytes,omitempty"`
	// Memory usage in bytes.
	MemUsageBytes *uint64 `protobuf:"varint,9,opt,name=mem_usage_bytes,json=memUsageBytes" json:"mem_usage_bytes,omitempty"`
	// CVM number of CPUs.
	CvmNumVcpus *uint64 `protobuf:"varint,11,opt,name=cvm_num_vcpus,json=cvmNumVcpus" json:"cvm_num_vcpus,omitempty"`
	// CVM memory size in bytes.
	CvmMemorySizeBytes *uint64 `protobuf:"varint,12,opt,name=cvm_memory_size_bytes,json=cvmMemorySizeBytes" json:"cvm_memory_size_bytes,omitempty"`
	// CVM UUID.
	CvmUuid []byte `protobuf:"bytes,13,opt,name=cvm_uuid,json=cvmUuid" json:"cvm_uuid,omitempty"`
	// Node is schedulable or not.
	Schedulable *bool `protobuf:"varint,14,opt,name=schedulable" json:"schedulable,omitempty"`
	// Size of the memory chunks reserved for HA failover. This is a cluster wide
	// setting.
	// Deprecated.
	MemSegmentSizeBytes *uint64 `protobuf:"varint,16,opt,name=mem_segment_size_bytes,json=memSegmentSizeBytes" json:"mem_segment_size_bytes,omitempty"`
	// Number of memory chunks reserved for HA failover.
	// Deprecated.
	NumReservedMemSegments *uint64 `protobuf:"varint,17,opt,name=num_reserved_mem_segments,json=numReservedMemSegments" json:"num_reserved_mem_segments,omitempty"`
	// Number of memory chunks assigned to a failover in progress.
	// Deprecated.
	NumAssignedMemSegments *uint64 `protobuf:"varint,18,opt,name=num_assigned_mem_segments,json=numAssignedMemSegments" json:"num_assigned_mem_segments,omitempty"`
	// The maximum memory that will be reserved upon HA event on this node,
	// considering all possible host failover combinations.
	MaxMemHaReservedBytes *uint64 `protobuf:"varint,19,opt,name=max_mem_ha_reserved_bytes,json=maxMemHaReservedBytes" json:"max_mem_ha_reserved_bytes,omitempty"`
	// Total memory assigned to VMs restarting on this host due to host failure.
	MemAssignedBytes *uint64 `protobuf:"varint,20,opt,name=mem_assigned_bytes,json=memAssignedBytes" json:"mem_assigned_bytes,omitempty"`
	// List of GPU available on this node.
	GpuList []*NodeGPU `protobuf:"bytes,21,rep,name=gpu_list,json=gpuList" json:"gpu_list,omitempty"`
	// Total amount of memory that overcommitted VMs can use on this node, in
	// bytes.
	PoolSizeBytes        *uint64  `protobuf:"varint,22,opt,name=pool_size_bytes,json=poolSizeBytes" json:"pool_size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerNodeInfo) Reset()         { *m = SchedulerNodeInfo{} }
func (m *SchedulerNodeInfo) String() string { return proto.CompactTextString(m) }
func (*SchedulerNodeInfo) ProtoMessage()    {}
func (*SchedulerNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{64}
}

func (m *SchedulerNodeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchedulerNodeInfo.Unmarshal(m, b)
}
func (m *SchedulerNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchedulerNodeInfo.Marshal(b, m, deterministic)
}
func (m *SchedulerNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerNodeInfo.Merge(m, src)
}
func (m *SchedulerNodeInfo) XXX_Size() int {
	return xxx_messageInfo_SchedulerNodeInfo.Size(m)
}
func (m *SchedulerNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerNodeInfo proto.InternalMessageInfo

func (m *SchedulerNodeInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SchedulerNodeInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SchedulerNodeInfo) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *SchedulerNodeInfo) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *SchedulerNodeInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *SchedulerNodeInfo) GetCpuUsagePpm() int64 {
	if m != nil && m.CpuUsagePpm != nil {
		return *m.CpuUsagePpm
	}
	return 0
}

func (m *SchedulerNodeInfo) GetNumCpus() uint64 {
	if m != nil && m.NumCpus != nil {
		return *m.NumCpus
	}
	return 0
}

func (m *SchedulerNodeInfo) GetMemorySizeBytes() uint64 {
	if m != nil && m.MemorySizeBytes != nil {
		return *m.MemorySizeBytes
	}
	return 0
}

func (m *SchedulerNodeInfo) GetMemUsageBytes() uint64 {
	if m != nil && m.MemUsageBytes != nil {
		return *m.MemUsageBytes
	}
	return 0
}

func (m *SchedulerNodeInfo) GetCvmNumVcpus() uint64 {
	if m != nil && m.CvmNumVcpus != nil {
		return *m.CvmNumVcpus
	}
	return 0
}

func (m *SchedulerNodeInfo) GetCvmMemorySizeBytes() uint64 {
	if m != nil && m.CvmMemorySizeBytes != nil {
		return *m.CvmMemorySizeBytes
	}
	return 0
}

func (m *SchedulerNodeInfo) GetCvmUuid() []byte {
	if m != nil {
		return m.CvmUuid
	}
	return nil
}

func (m *SchedulerNodeInfo) GetSchedulable() bool {
	if m != nil && m.Schedulable != nil {
		return *m.Schedulable
	}
	return false
}

func (m *SchedulerNodeInfo) GetMemSegmentSizeBytes() uint64 {
	if m != nil && m.MemSegmentSizeBytes != nil {
		return *m.MemSegmentSizeBytes
	}
	return 0
}

func (m *SchedulerNodeInfo) GetNumReservedMemSegments() uint64 {
	if m != nil && m.NumReservedMemSegments != nil {
		return *m.NumReservedMemSegments
	}
	return 0
}

func (m *SchedulerNodeInfo) GetNumAssignedMemSegments() uint64 {
	if m != nil && m.NumAssignedMemSegments != nil {
		return *m.NumAssignedMemSegments
	}
	return 0
}

func (m *SchedulerNodeInfo) GetMaxMemHaReservedBytes() uint64 {
	if m != nil && m.MaxMemHaReservedBytes != nil {
		return *m.MaxMemHaReservedBytes
	}
	return 0
}

func (m *SchedulerNodeInfo) GetMemAssignedBytes() uint64 {
	if m != nil && m.MemAssignedBytes != nil {
		return *m.MemAssignedBytes
	}
	return 0
}

func (m *SchedulerNodeInfo) GetGpuList() []*NodeGPU {
	if m != nil {
		return m.GpuList
	}
	return nil
}

func (m *SchedulerNodeInfo) GetPoolSizeBytes() uint64 {
	if m != nil && m.PoolSizeBytes != nil {
		return *m.PoolSizeBytes
	}
	return 0
}

type HypervisorVmIdMap struct {
	// AcropolisUuid of the VM.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// Hypervisor VMId of the VM.
	HypervisorVmid []byte `protobuf:"bytes,2,opt,name=hypervisor_vmid,json=hypervisorVmid" json:"hypervisor_vmid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HypervisorVmIdMap) Reset()         { *m = HypervisorVmIdMap{} }
func (m *HypervisorVmIdMap) String() string { return proto.CompactTextString(m) }
func (*HypervisorVmIdMap) ProtoMessage()    {}
func (*HypervisorVmIdMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{65}
}

func (m *HypervisorVmIdMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HypervisorVmIdMap.Unmarshal(m, b)
}
func (m *HypervisorVmIdMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HypervisorVmIdMap.Marshal(b, m, deterministic)
}
func (m *HypervisorVmIdMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HypervisorVmIdMap.Merge(m, src)
}
func (m *HypervisorVmIdMap) XXX_Size() int {
	return xxx_messageInfo_HypervisorVmIdMap.Size(m)
}
func (m *HypervisorVmIdMap) XXX_DiscardUnknown() {
	xxx_messageInfo_HypervisorVmIdMap.DiscardUnknown(m)
}

var xxx_messageInfo_HypervisorVmIdMap proto.InternalMessageInfo

func (m *HypervisorVmIdMap) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *HypervisorVmIdMap) GetHypervisorVmid() []byte {
	if m != nil {
		return m.HypervisorVmid
	}
	return nil
}

func (m *HypervisorVmIdMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VmUuidMap struct {
	// The arithmos ID for VM entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic VM UUIDs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmUuidMap) Reset()         { *m = VmUuidMap{} }
func (m *VmUuidMap) String() string { return proto.CompactTextString(m) }
func (*VmUuidMap) ProtoMessage()    {}
func (*VmUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{66}
}

func (m *VmUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmUuidMap.Unmarshal(m, b)
}
func (m *VmUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmUuidMap.Marshal(b, m, deterministic)
}
func (m *VmUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmUuidMap.Merge(m, src)
}
func (m *VmUuidMap) XXX_Size() int {
	return xxx_messageInfo_VmUuidMap.Size(m)
}
func (m *VmUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VmUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VmUuidMap proto.InternalMessageInfo

func (m *VmUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VmUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualDiskUuidMap struct {
	// The arithmos ID for virtual disk entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for virtual disks.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDiskUuidMap) Reset()         { *m = VirtualDiskUuidMap{} }
func (m *VirtualDiskUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualDiskUuidMap) ProtoMessage()    {}
func (*VirtualDiskUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{67}
}

func (m *VirtualDiskUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDiskUuidMap.Unmarshal(m, b)
}
func (m *VirtualDiskUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDiskUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualDiskUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDiskUuidMap.Merge(m, src)
}
func (m *VirtualDiskUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualDiskUuidMap.Size(m)
}
func (m *VirtualDiskUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDiskUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDiskUuidMap proto.InternalMessageInfo

func (m *VirtualDiskUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualDiskUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualDiskUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualNicUuidMap struct {
	// The arithmos ID for virtual NIC entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for virtual NICs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNicUuidMap) Reset()         { *m = VirtualNicUuidMap{} }
func (m *VirtualNicUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualNicUuidMap) ProtoMessage()    {}
func (*VirtualNicUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{68}
}

func (m *VirtualNicUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNicUuidMap.Unmarshal(m, b)
}
func (m *VirtualNicUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNicUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualNicUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNicUuidMap.Merge(m, src)
}
func (m *VirtualNicUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualNicUuidMap.Size(m)
}
func (m *VirtualNicUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNicUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNicUuidMap proto.InternalMessageInfo

func (m *VirtualNicUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualNicUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualNicUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualGpuUuidMap struct {
	// The arithmos ID for virtual GPU entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for virtual GPUs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualGpuUuidMap) Reset()         { *m = VirtualGpuUuidMap{} }
func (m *VirtualGpuUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualGpuUuidMap) ProtoMessage()    {}
func (*VirtualGpuUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{69}
}

func (m *VirtualGpuUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualGpuUuidMap.Unmarshal(m, b)
}
func (m *VirtualGpuUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualGpuUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualGpuUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualGpuUuidMap.Merge(m, src)
}
func (m *VirtualGpuUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualGpuUuidMap.Size(m)
}
func (m *VirtualGpuUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualGpuUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualGpuUuidMap proto.InternalMessageInfo

func (m *VirtualGpuUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualGpuUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualGpuUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VmSnapshotUuidMap struct {
	// The arithmos ID for VM snapshot entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for VM snapshot.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmSnapshotUuidMap) Reset()         { *m = VmSnapshotUuidMap{} }
func (m *VmSnapshotUuidMap) String() string { return proto.CompactTextString(m) }
func (*VmSnapshotUuidMap) ProtoMessage()    {}
func (*VmSnapshotUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{70}
}

func (m *VmSnapshotUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSnapshotUuidMap.Unmarshal(m, b)
}
func (m *VmSnapshotUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSnapshotUuidMap.Marshal(b, m, deterministic)
}
func (m *VmSnapshotUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSnapshotUuidMap.Merge(m, src)
}
func (m *VmSnapshotUuidMap) XXX_Size() int {
	return xxx_messageInfo_VmSnapshotUuidMap.Size(m)
}
func (m *VmSnapshotUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSnapshotUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VmSnapshotUuidMap proto.InternalMessageInfo

func (m *VmSnapshotUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VmSnapshotUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmSnapshotUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type NodeGpuUuidMap struct {
	// The arithmos ID for node GPU entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for node GPUs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeGpuUuidMap) Reset()         { *m = NodeGpuUuidMap{} }
func (m *NodeGpuUuidMap) String() string { return proto.CompactTextString(m) }
func (*NodeGpuUuidMap) ProtoMessage()    {}
func (*NodeGpuUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{71}
}

func (m *NodeGpuUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeGpuUuidMap.Unmarshal(m, b)
}
func (m *NodeGpuUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeGpuUuidMap.Marshal(b, m, deterministic)
}
func (m *NodeGpuUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeGpuUuidMap.Merge(m, src)
}
func (m *NodeGpuUuidMap) XXX_Size() int {
	return xxx_messageInfo_NodeGpuUuidMap.Size(m)
}
func (m *NodeGpuUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeGpuUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodeGpuUuidMap proto.InternalMessageInfo

func (m *NodeGpuUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *NodeGpuUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NodeGpuUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type NodePhysicalNicUuidMap struct {
	// The arithmos ID for node physical NIC entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for node physical NICs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodePhysicalNicUuidMap) Reset()         { *m = NodePhysicalNicUuidMap{} }
func (m *NodePhysicalNicUuidMap) String() string { return proto.CompactTextString(m) }
func (*NodePhysicalNicUuidMap) ProtoMessage()    {}
func (*NodePhysicalNicUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{72}
}

func (m *NodePhysicalNicUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodePhysicalNicUuidMap.Unmarshal(m, b)
}
func (m *NodePhysicalNicUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodePhysicalNicUuidMap.Marshal(b, m, deterministic)
}
func (m *NodePhysicalNicUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodePhysicalNicUuidMap.Merge(m, src)
}
func (m *NodePhysicalNicUuidMap) XXX_Size() int {
	return xxx_messageInfo_NodePhysicalNicUuidMap.Size(m)
}
func (m *NodePhysicalNicUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodePhysicalNicUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodePhysicalNicUuidMap proto.InternalMessageInfo

func (m *NodePhysicalNicUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *NodePhysicalNicUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NodePhysicalNicUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type NodeVirtualNicUuidMap struct {
	// The arithmos ID for node virtual NIC entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for node virtual NICs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeVirtualNicUuidMap) Reset()         { *m = NodeVirtualNicUuidMap{} }
func (m *NodeVirtualNicUuidMap) String() string { return proto.CompactTextString(m) }
func (*NodeVirtualNicUuidMap) ProtoMessage()    {}
func (*NodeVirtualNicUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{73}
}

func (m *NodeVirtualNicUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeVirtualNicUuidMap.Unmarshal(m, b)
}
func (m *NodeVirtualNicUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeVirtualNicUuidMap.Marshal(b, m, deterministic)
}
func (m *NodeVirtualNicUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeVirtualNicUuidMap.Merge(m, src)
}
func (m *NodeVirtualNicUuidMap) XXX_Size() int {
	return xxx_messageInfo_NodeVirtualNicUuidMap.Size(m)
}
func (m *NodeVirtualNicUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeVirtualNicUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodeVirtualNicUuidMap proto.InternalMessageInfo

func (m *NodeVirtualNicUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *NodeVirtualNicUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NodeVirtualNicUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualNetworkUuidMap struct {
	// The arithmos ID for node virtual network entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for a virtual network.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNetworkUuidMap) Reset()         { *m = VirtualNetworkUuidMap{} }
func (m *VirtualNetworkUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualNetworkUuidMap) ProtoMessage()    {}
func (*VirtualNetworkUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{74}
}

func (m *VirtualNetworkUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetworkUuidMap.Unmarshal(m, b)
}
func (m *VirtualNetworkUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetworkUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualNetworkUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkUuidMap.Merge(m, src)
}
func (m *VirtualNetworkUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualNetworkUuidMap.Size(m)
}
func (m *VirtualNetworkUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkUuidMap proto.InternalMessageInfo

func (m *VirtualNetworkUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualNetworkUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualNetworkUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualDeviceUuidMap struct {
	// The arithmos ID for node virtual device entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// Device UUID.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDeviceUuidMap) Reset()         { *m = VirtualDeviceUuidMap{} }
func (m *VirtualDeviceUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualDeviceUuidMap) ProtoMessage()    {}
func (*VirtualDeviceUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{75}
}

func (m *VirtualDeviceUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDeviceUuidMap.Unmarshal(m, b)
}
func (m *VirtualDeviceUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDeviceUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualDeviceUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDeviceUuidMap.Merge(m, src)
}
func (m *VirtualDeviceUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualDeviceUuidMap.Size(m)
}
func (m *VirtualDeviceUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDeviceUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDeviceUuidMap proto.InternalMessageInfo

func (m *VirtualDeviceUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualDeviceUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualDeviceUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

// This is for persisting RPC sequence numbers to be sent to other services,
// e.g. Cerebro for sync rep.
type RpcSeqNumber struct {
	// Name of the service to which to send the sequence number.
	ServiceName *string `protobuf:"bytes,1,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
	// Last sent sequence number to a service.
	SeqNumber *int64 `protobuf:"varint,2,opt,name=seq_number,json=seqNumber" json:"seq_number,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RpcSeqNumber) Reset()         { *m = RpcSeqNumber{} }
func (m *RpcSeqNumber) String() string { return proto.CompactTextString(m) }
func (*RpcSeqNumber) ProtoMessage()    {}
func (*RpcSeqNumber) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{76}
}

func (m *RpcSeqNumber) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RpcSeqNumber.Unmarshal(m, b)
}
func (m *RpcSeqNumber) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RpcSeqNumber.Marshal(b, m, deterministic)
}
func (m *RpcSeqNumber) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcSeqNumber.Merge(m, src)
}
func (m *RpcSeqNumber) XXX_Size() int {
	return xxx_messageInfo_RpcSeqNumber.Size(m)
}
func (m *RpcSeqNumber) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcSeqNumber.DiscardUnknown(m)
}

var xxx_messageInfo_RpcSeqNumber proto.InternalMessageInfo

func (m *RpcSeqNumber) GetServiceName() string {
	if m != nil && m.ServiceName != nil {
		return *m.ServiceName
	}
	return ""
}

func (m *RpcSeqNumber) GetSeqNumber() int64 {
	if m != nil && m.SeqNumber != nil {
		return *m.SeqNumber
	}
	return 0
}

func (m *RpcSeqNumber) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

// This is to maintain the list of UUIDs of uncommitted VM disks that have been
// created but not yet committed to pithos.
type UncommittedDisk struct {
	// The key to the pithos entries.
	DiskType *string `protobuf:"bytes,1,opt,name=disk_type,json=diskType" json:"disk_type,omitempty"`
	// The list of VM disk UUIDs for the given disk type.
	DiskUuidList [][]byte `protobuf:"bytes,2,rep,name=disk_uuid_list,json=diskUuidList" json:"disk_uuid_list,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UncommittedDisk) Reset()         { *m = UncommittedDisk{} }
func (m *UncommittedDisk) String() string { return proto.CompactTextString(m) }
func (*UncommittedDisk) ProtoMessage()    {}
func (*UncommittedDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{77}
}

func (m *UncommittedDisk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UncommittedDisk.Unmarshal(m, b)
}
func (m *UncommittedDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UncommittedDisk.Marshal(b, m, deterministic)
}
func (m *UncommittedDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UncommittedDisk.Merge(m, src)
}
func (m *UncommittedDisk) XXX_Size() int {
	return xxx_messageInfo_UncommittedDisk.Size(m)
}
func (m *UncommittedDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_UncommittedDisk.DiscardUnknown(m)
}

var xxx_messageInfo_UncommittedDisk proto.InternalMessageInfo

func (m *UncommittedDisk) GetDiskType() string {
	if m != nil && m.DiskType != nil {
		return *m.DiskType
	}
	return ""
}

func (m *UncommittedDisk) GetDiskUuidList() [][]byte {
	if m != nil {
		return m.DiskUuidList
	}
	return nil
}

func (m *UncommittedDisk) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type SchedulerPolicy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerPolicy) Reset()         { *m = SchedulerPolicy{} }
func (m *SchedulerPolicy) String() string { return proto.CompactTextString(m) }
func (*SchedulerPolicy) ProtoMessage()    {}
func (*SchedulerPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{78}
}

func (m *SchedulerPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchedulerPolicy.Unmarshal(m, b)
}
func (m *SchedulerPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchedulerPolicy.Marshal(b, m, deterministic)
}
func (m *SchedulerPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerPolicy.Merge(m, src)
}
func (m *SchedulerPolicy) XXX_Size() int {
	return xxx_messageInfo_SchedulerPolicy.Size(m)
}
func (m *SchedulerPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerPolicy proto.InternalMessageInfo

type ParcelConfig struct {
	// A human readable parcel name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Number of vCPUs. When hot plugging CPU, this is set to the
	// total number of CPUs after hotplug operation is complete.
	NumCpus *uint64 `protobuf:"varint,2,opt,name=num_cpus,json=numCpus" json:"num_cpus,omitempty"`
	// The amount of RAM, in bytes. When hot plugging memory, this is set to the
	// total final memory. In case of memory overcommit, this is set to indicate
	// the amount of memory allocated currently which is different from the
	// configured memory for the entity.
	MemoryBytes *uint64              `protobuf:"varint,3,opt,name=memory_bytes,json=memoryBytes" json:"memory_bytes,omitempty"`
	Entity      *ParcelConfig_Entity `protobuf:"bytes,4,opt,name=entity" json:"entity,omitempty"`
	// Scheduler can reclaim the parcel if entity is not active on cluster.
	OkToReclaim *bool `protobuf:"varint,6,opt,name=ok_to_reclaim,json=okToReclaim,def=1" json:"ok_to_reclaim,omitempty"`
	// In case of memory hotplug add, this field is set to the amount of memory,
	// in bytes, before the hot plug.
	PreHotplugMemoryBytes *uint64 `protobuf:"varint,7,opt,name=pre_hotplug_memory_bytes,json=preHotplugMemoryBytes" json:"pre_hotplug_memory_bytes,omitempty"`
	// Only set for CPU hot plug. This field is set to the vcpu count
	// before the hotplug.
	PreHotplugVcpuCount *uint64 `protobuf:"varint,8,opt,name=pre_hotplug_vcpu_count,json=preHotplugVcpuCount" json:"pre_hotplug_vcpu_count,omitempty"`
	// The parcel is allocated from reserved segments.
	UseSegments *bool `protobuf:"varint,9,opt,name=use_segments,json=useSegments,def=0" json:"use_segments,omitempty"`
	// GPU resources.
	GpuConfigList []*VmGPUConfig `protobuf:"bytes,10,rep,name=gpu_config_list,json=gpuConfigList" json:"gpu_config_list,omitempty"`
	// Affinity spec to uphold.
	AffinitySpec *EntityAffinitySpec `protobuf:"bytes,11,opt,name=affinity_spec,json=affinitySpec" json:"affinity_spec,omitempty"`
	// Logical timestamp for the scheduler's segment assignment.
	SegmentsTimestamp *int64 `protobuf:"varint,12,opt,name=segments_timestamp,json=segmentsTimestamp" json:"segments_timestamp,omitempty"`
	// Whether the Entity is HA-protected.
	HaProtected *bool `protobuf:"varint,13,opt,name=ha_protected,json=haProtected" json:"ha_protected,omitempty"`
	// Whether cross cluster live migration of this entity to another cluster is
	// in progress.
	CrossClusterLiveMigrateInProgress *bool `protobuf:"varint,14,opt,name=cross_cluster_live_migrate_in_progress,json=crossClusterLiveMigrateInProgress" json:"cross_cluster_live_migrate_in_progress,omitempty"`
	// Number of vNICs attached to this parcel.
	NumVnics *uint64 `protobuf:"varint,15,opt,name=num_vnics,json=numVnics" json:"num_vnics,omitempty"`
	// In case of NIC hot add/remove, this field is set to the number of NICs
	// before the hot add/remove.
	PreHotplugNumVnics *uint64 `protobuf:"varint,16,opt,name=pre_hotplug_num_vnics,json=preHotplugNumVnics" json:"pre_hotplug_num_vnics,omitempty"`
	// If True, the memory that belongs to the VM may reside outside of physical
	// memory. Otherwise, Acropolis will ensure that the amount of memory the VM
	// is configured with resides completely in physical memory.
	MemoryOvercommit *bool `protobuf:"varint,17,opt,name=memory_overcommit,json=memoryOvercommit" json:"memory_overcommit,omitempty"`
	// In case of memory overcommit, this field is set to the amount of actual
	// memory configured in bytes. memory_bytes field will then indicate the
	// amount of memory allocated currently.
	ConfiguredMemoryBytes *uint64 `protobuf:"varint,18,opt,name=configured_memory_bytes,json=configuredMemoryBytes" json:"configured_memory_bytes,omitempty"`
	// In case of memory overcommit, this field is set to the amount of memory
	// which is reserved to honor HA, in bytes.
	// memory_bytes - protected_memory_bytes will then give us the amount of
	// memory unprotected for this VM.
	ProtectedMemoryBytes *uint64  `protobuf:"varint,19,opt,name=protected_memory_bytes,json=protectedMemoryBytes" json:"protected_memory_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParcelConfig) Reset()         { *m = ParcelConfig{} }
func (m *ParcelConfig) String() string { return proto.CompactTextString(m) }
func (*ParcelConfig) ProtoMessage()    {}
func (*ParcelConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{79}
}

func (m *ParcelConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ParcelConfig.Unmarshal(m, b)
}
func (m *ParcelConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ParcelConfig.Marshal(b, m, deterministic)
}
func (m *ParcelConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParcelConfig.Merge(m, src)
}
func (m *ParcelConfig) XXX_Size() int {
	return xxx_messageInfo_ParcelConfig.Size(m)
}
func (m *ParcelConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ParcelConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ParcelConfig proto.InternalMessageInfo

const Default_ParcelConfig_OkToReclaim bool = true
const Default_ParcelConfig_UseSegments bool = false

func (m *ParcelConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ParcelConfig) GetNumCpus() uint64 {
	if m != nil && m.NumCpus != nil {
		return *m.NumCpus
	}
	return 0
}

func (m *ParcelConfig) GetMemoryBytes() uint64 {
	if m != nil && m.MemoryBytes != nil {
		return *m.MemoryBytes
	}
	return 0
}

func (m *ParcelConfig) GetEntity() *ParcelConfig_Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *ParcelConfig) GetOkToReclaim() bool {
	if m != nil && m.OkToReclaim != nil {
		return *m.OkToReclaim
	}
	return Default_ParcelConfig_OkToReclaim
}

func (m *ParcelConfig) GetPreHotplugMemoryBytes() uint64 {
	if m != nil && m.PreHotplugMemoryBytes != nil {
		return *m.PreHotplugMemoryBytes
	}
	return 0
}

func (m *ParcelConfig) GetPreHotplugVcpuCount() uint64 {
	if m != nil && m.PreHotplugVcpuCount != nil {
		return *m.PreHotplugVcpuCount
	}
	return 0
}

func (m *ParcelConfig) GetUseSegments() bool {
	if m != nil && m.UseSegments != nil {
		return *m.UseSegments
	}
	return Default_ParcelConfig_UseSegments
}

func (m *ParcelConfig) GetGpuConfigList() []*VmGPUConfig {
	if m != nil {
		return m.GpuConfigList
	}
	return nil
}

func (m *ParcelConfig) GetAffinitySpec() *EntityAffinitySpec {
	if m != nil {
		return m.AffinitySpec
	}
	return nil
}

func (m *ParcelConfig) GetSegmentsTimestamp() int64 {
	if m != nil && m.SegmentsTimestamp != nil {
		return *m.SegmentsTimestamp
	}
	return 0
}

func (m *ParcelConfig) GetHaProtected() bool {
	if m != nil && m.HaProtected != nil {
		return *m.HaProtected
	}
	return false
}

func (m *ParcelConfig) GetCrossClusterLiveMigrateInProgress() bool {
	if m != nil && m.CrossClusterLiveMigrateInProgress != nil {
		return *m.CrossClusterLiveMigrateInProgress
	}
	return false
}

func (m *ParcelConfig) GetNumVnics() uint64 {
	if m != nil && m.NumVnics != nil {
		return *m.NumVnics
	}
	return 0
}

func (m *ParcelConfig) GetPreHotplugNumVnics() uint64 {
	if m != nil && m.PreHotplugNumVnics != nil {
		return *m.PreHotplugNumVnics
	}
	return 0
}

func (m *ParcelConfig) GetMemoryOvercommit() bool {
	if m != nil && m.MemoryOvercommit != nil {
		return *m.MemoryOvercommit
	}
	return false
}

func (m *ParcelConfig) GetConfiguredMemoryBytes() uint64 {
	if m != nil && m.ConfiguredMemoryBytes != nil {
		return *m.ConfiguredMemoryBytes
	}
	return 0
}

func (m *ParcelConfig) GetProtectedMemoryBytes() uint64 {
	if m != nil && m.ProtectedMemoryBytes != nil {
		return *m.ProtectedMemoryBytes
	}
	return 0
}

type ParcelConfig_Entity struct {
	// UUID of the entity.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Entity type.
	EntityType *ParcelConfig_EntityType `protobuf:"varint,2,opt,name=entity_type,json=entityType,enum=nutanix.acropolis.ParcelConfig_EntityType,def=1" json:"entity_type,omitempty"`
	// Entity name. This is not stored to the database, but resolved on demand.
	EntityName           *string  `protobuf:"bytes,3,opt,name=entity_name,json=entityName" json:"entity_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParcelConfig_Entity) Reset()         { *m = ParcelConfig_Entity{} }
func (m *ParcelConfig_Entity) String() string { return proto.CompactTextString(m) }
func (*ParcelConfig_Entity) ProtoMessage()    {}
func (*ParcelConfig_Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{79, 0}
}

func (m *ParcelConfig_Entity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ParcelConfig_Entity.Unmarshal(m, b)
}
func (m *ParcelConfig_Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ParcelConfig_Entity.Marshal(b, m, deterministic)
}
func (m *ParcelConfig_Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParcelConfig_Entity.Merge(m, src)
}
func (m *ParcelConfig_Entity) XXX_Size() int {
	return xxx_messageInfo_ParcelConfig_Entity.Size(m)
}
func (m *ParcelConfig_Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_ParcelConfig_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_ParcelConfig_Entity proto.InternalMessageInfo

const Default_ParcelConfig_Entity_EntityType ParcelConfig_EntityType = ParcelConfig_kVM

func (m *ParcelConfig_Entity) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ParcelConfig_Entity) GetEntityType() ParcelConfig_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return Default_ParcelConfig_Entity_EntityType
}

func (m *ParcelConfig_Entity) GetEntityName() string {
	if m != nil && m.EntityName != nil {
		return *m.EntityName
	}
	return ""
}

type Affinity struct {
	Policy     *Affinity_Policy     `protobuf:"varint,1,opt,name=policy,enum=nutanix.acropolis.Affinity_Policy,def=1" json:"policy,omitempty"`
	Constraint *Affinity_Constraint `protobuf:"varint,2,opt,name=constraint,enum=nutanix.acropolis.Affinity_Constraint,def=1" json:"constraint,omitempty"`
	// List of binding hosts.
	HostUuids            [][]byte                     `protobuf:"bytes,3,rep,name=host_uuids,json=hostUuids" json:"host_uuids,omitempty"`
	LegacyCfg            *Affinity_LegacyHostAffinity `protobuf:"bytes,4,opt,name=legacy_cfg,json=legacyCfg" json:"legacy_cfg,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *Affinity) Reset()         { *m = Affinity{} }
func (m *Affinity) String() string { return proto.CompactTextString(m) }
func (*Affinity) ProtoMessage()    {}
func (*Affinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{80}
}

func (m *Affinity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Affinity.Unmarshal(m, b)
}
func (m *Affinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Affinity.Marshal(b, m, deterministic)
}
func (m *Affinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Affinity.Merge(m, src)
}
func (m *Affinity) XXX_Size() int {
	return xxx_messageInfo_Affinity.Size(m)
}
func (m *Affinity) XXX_DiscardUnknown() {
	xxx_messageInfo_Affinity.DiscardUnknown(m)
}

var xxx_messageInfo_Affinity proto.InternalMessageInfo

const Default_Affinity_Policy Affinity_Policy = Affinity_kAffinity
const Default_Affinity_Constraint Affinity_Constraint = Affinity_kMust

func (m *Affinity) GetPolicy() Affinity_Policy {
	if m != nil && m.Policy != nil {
		return *m.Policy
	}
	return Default_Affinity_Policy
}

func (m *Affinity) GetConstraint() Affinity_Constraint {
	if m != nil && m.Constraint != nil {
		return *m.Constraint
	}
	return Default_Affinity_Constraint
}

func (m *Affinity) GetHostUuids() [][]byte {
	if m != nil {
		return m.HostUuids
	}
	return nil
}

func (m *Affinity) GetLegacyCfg() *Affinity_LegacyHostAffinity {
	if m != nil {
		return m.LegacyCfg
	}
	return nil
}

type Affinity_LegacyHostAffinity struct {
	// Node list due to legacy affinities.
	UuidList [][]byte `protobuf:"bytes,1,rep,name=uuid_list,json=uuidList" json:"uuid_list,omitempty"`
	// Set to True when updating legacy affinities.
	Update               *bool    `protobuf:"varint,2,opt,name=update" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Affinity_LegacyHostAffinity) Reset()         { *m = Affinity_LegacyHostAffinity{} }
func (m *Affinity_LegacyHostAffinity) String() string { return proto.CompactTextString(m) }
func (*Affinity_LegacyHostAffinity) ProtoMessage()    {}
func (*Affinity_LegacyHostAffinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{80, 0}
}

func (m *Affinity_LegacyHostAffinity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Affinity_LegacyHostAffinity.Unmarshal(m, b)
}
func (m *Affinity_LegacyHostAffinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Affinity_LegacyHostAffinity.Marshal(b, m, deterministic)
}
func (m *Affinity_LegacyHostAffinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Affinity_LegacyHostAffinity.Merge(m, src)
}
func (m *Affinity_LegacyHostAffinity) XXX_Size() int {
	return xxx_messageInfo_Affinity_LegacyHostAffinity.Size(m)
}
func (m *Affinity_LegacyHostAffinity) XXX_DiscardUnknown() {
	xxx_messageInfo_Affinity_LegacyHostAffinity.DiscardUnknown(m)
}

var xxx_messageInfo_Affinity_LegacyHostAffinity proto.InternalMessageInfo

func (m *Affinity_LegacyHostAffinity) GetUuidList() [][]byte {
	if m != nil {
		return m.UuidList
	}
	return nil
}

func (m *Affinity_LegacyHostAffinity) GetUpdate() bool {
	if m != nil && m.Update != nil {
		return *m.Update
	}
	return false
}

type ParcelInfo struct {
	// The parcel identifier.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Parcel configuration.
	Config *ParcelConfig `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
	// Whether the Parcel has been deleted.
	Deleted *bool `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	// The Parcel's logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Binding of parcel to node. This value can be None if parcel is not bound
	// to a node.
	NodeUuid []byte `protobuf:"bytes,5,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// GPUs currently assigned to Parcel.
	GpuList []*NodeGPU `protobuf:"bytes,6,rep,name=gpu_list,json=gpuList" json:"gpu_list,omitempty"`
	// UUID of the task that owns the parcel.
	OwnerTaskUuid        []byte   `protobuf:"bytes,7,opt,name=owner_task_uuid,json=ownerTaskUuid" json:"owner_task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParcelInfo) Reset()         { *m = ParcelInfo{} }
func (m *ParcelInfo) String() string { return proto.CompactTextString(m) }
func (*ParcelInfo) ProtoMessage()    {}
func (*ParcelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{81}
}

func (m *ParcelInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ParcelInfo.Unmarshal(m, b)
}
func (m *ParcelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ParcelInfo.Marshal(b, m, deterministic)
}
func (m *ParcelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParcelInfo.Merge(m, src)
}
func (m *ParcelInfo) XXX_Size() int {
	return xxx_messageInfo_ParcelInfo.Size(m)
}
func (m *ParcelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ParcelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ParcelInfo proto.InternalMessageInfo

const Default_ParcelInfo_LogicalTimestamp int64 = -1

func (m *ParcelInfo) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *ParcelInfo) GetConfig() *ParcelConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ParcelInfo) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *ParcelInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_ParcelInfo_LogicalTimestamp
}

func (m *ParcelInfo) GetNodeUuid() []byte {
	if m != nil {
		return m.NodeUuid
	}
	return nil
}

func (m *ParcelInfo) GetGpuList() []*NodeGPU {
	if m != nil {
		return m.GpuList
	}
	return nil
}

func (m *ParcelInfo) GetOwnerTaskUuid() []byte {
	if m != nil {
		return m.OwnerTaskUuid
	}
	return nil
}

type ParcelCreateSpec struct {
	// Parcel configuration.
	Config *ParcelConfig `protobuf:"bytes,1,opt,name=config" json:"config,omitempty"`
	// List of nodes that parcel should not be scheduled to.
	ExcludeNodeUuids [][]byte `protobuf:"bytes,2,rep,name=exclude_node_uuids,json=excludeNodeUuids" json:"exclude_node_uuids,omitempty"`
	// Node that parcel should be scheduled to.
	NodeUuid []byte `protobuf:"bytes,3,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// Force CPU overcommit.
	ForceOvercommit *bool `protobuf:"varint,4,opt,name=force_overcommit,json=forceOvercommit,def=0" json:"force_overcommit,omitempty"`
	// Parcel request is part of HA failover. Allows Parcel to be scheduled on
	// the request, even if the host is technically not marked as schedulable.
	Failover *bool `protobuf:"varint,5,opt,name=failover,def=0" json:"failover,omitempty"`
	// Parcel request is part of HA healing. And hence not subject to admission
	// control.
	HaHealing *bool `protobuf:"varint,7,opt,name=ha_healing,json=haHealing,def=0" json:"ha_healing,omitempty"`
	// Lazily-evaluated CPU usage of the entity run time state that is filled in
	// by the scheduler.
	CpuUsagePpm *int64 `protobuf:"varint,8,opt,name=cpu_usage_ppm,json=cpuUsagePpm" json:"cpu_usage_ppm,omitempty"`
	// Up-to-date entity memory usage by monitoring the entity run time state.
	// This field can be filled in by scheduler. For hotplug, set to the
	// difference in memory usage due to hotplug operation.
	MemUsageBytes *int64 `protobuf:"varint,9,opt,name=mem_usage_bytes,json=memUsageBytes" json:"mem_usage_bytes,omitempty"`
	// True if memory hotplug add is being performed and therefore, a parcel
	// update is needed.
	HotplugAdd *bool `protobuf:"varint,10,opt,name=hotplug_add,json=hotplugAdd,def=0" json:"hotplug_add,omitempty"`
	// Parcel UUID.  Set when parcel already exists, e.g. in case of hotplug
	// operation.
	ParcelUuid []byte `protobuf:"bytes,11,opt,name=parcel_uuid,json=parcelUuid" json:"parcel_uuid,omitempty"`
	// Total memory usage after memory hotplug.
	PostHotplugMemUsageBytes *int64 `protobuf:"varint,12,opt,name=post_hotplug_mem_usage_bytes,json=postHotplugMemUsageBytes" json:"post_hotplug_mem_usage_bytes,omitempty"`
	// UUID of the failed node from where this parcel needs to be moved.
	FailedNodeUuid []byte `protobuf:"bytes,13,opt,name=failed_node_uuid,json=failedNodeUuid" json:"failed_node_uuid,omitempty"`
	// Optional spec to associate preferences for vGPU live migration.
	VgpuMigrateSpec []*VGPUMigrateSpec `protobuf:"bytes,14,rep,name=vgpu_migrate_spec,json=vgpuMigrateSpec" json:"vgpu_migrate_spec,omitempty"`
	// Optional spec to associate vGpu placement to a pGpu. The pGpus will be on
	// the node_uuid field of ParcelCreateSpec message. If node_uuid is not
	// present, this field should also be empty.
	VgpuSbdfList         []*VGPUBootSpec `protobuf:"bytes,15,rep,name=vgpu_sbdf_list,json=vgpuSbdfList" json:"vgpu_sbdf_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ParcelCreateSpec) Reset()         { *m = ParcelCreateSpec{} }
func (m *ParcelCreateSpec) String() string { return proto.CompactTextString(m) }
func (*ParcelCreateSpec) ProtoMessage()    {}
func (*ParcelCreateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{82}
}

func (m *ParcelCreateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ParcelCreateSpec.Unmarshal(m, b)
}
func (m *ParcelCreateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ParcelCreateSpec.Marshal(b, m, deterministic)
}
func (m *ParcelCreateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParcelCreateSpec.Merge(m, src)
}
func (m *ParcelCreateSpec) XXX_Size() int {
	return xxx_messageInfo_ParcelCreateSpec.Size(m)
}
func (m *ParcelCreateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ParcelCreateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ParcelCreateSpec proto.InternalMessageInfo

const Default_ParcelCreateSpec_ForceOvercommit bool = false
const Default_ParcelCreateSpec_Failover bool = false
const Default_ParcelCreateSpec_HaHealing bool = false
const Default_ParcelCreateSpec_HotplugAdd bool = false

func (m *ParcelCreateSpec) GetConfig() *ParcelConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *ParcelCreateSpec) GetExcludeNodeUuids() [][]byte {
	if m != nil {
		return m.ExcludeNodeUuids
	}
	return nil
}

func (m *ParcelCreateSpec) GetNodeUuid() []byte {
	if m != nil {
		return m.NodeUuid
	}
	return nil
}

func (m *ParcelCreateSpec) GetForceOvercommit() bool {
	if m != nil && m.ForceOvercommit != nil {
		return *m.ForceOvercommit
	}
	return Default_ParcelCreateSpec_ForceOvercommit
}

func (m *ParcelCreateSpec) GetFailover() bool {
	if m != nil && m.Failover != nil {
		return *m.Failover
	}
	return Default_ParcelCreateSpec_Failover
}

func (m *ParcelCreateSpec) GetHaHealing() bool {
	if m != nil && m.HaHealing != nil {
		return *m.HaHealing
	}
	return Default_ParcelCreateSpec_HaHealing
}

func (m *ParcelCreateSpec) GetCpuUsagePpm() int64 {
	if m != nil && m.CpuUsagePpm != nil {
		return *m.CpuUsagePpm
	}
	return 0
}

func (m *ParcelCreateSpec) GetMemUsageBytes() int64 {
	if m != nil && m.MemUsageBytes != nil {
		return *m.MemUsageBytes
	}
	return 0
}

func (m *ParcelCreateSpec) GetHotplugAdd() bool {
	if m != nil && m.HotplugAdd != nil {
		return *m.HotplugAdd
	}
	return Default_ParcelCreateSpec_HotplugAdd
}

func (m *ParcelCreateSpec) GetParcelUuid() []byte {
	if m != nil {
		return m.ParcelUuid
	}
	return nil
}

func (m *ParcelCreateSpec) GetPostHotplugMemUsageBytes() int64 {
	if m != nil && m.PostHotplugMemUsageBytes != nil {
		return *m.PostHotplugMemUsageBytes
	}
	return 0
}

func (m *ParcelCreateSpec) GetFailedNodeUuid() []byte {
	if m != nil {
		return m.FailedNodeUuid
	}
	return nil
}

func (m *ParcelCreateSpec) GetVgpuMigrateSpec() []*VGPUMigrateSpec {
	if m != nil {
		return m.VgpuMigrateSpec
	}
	return nil
}

func (m *ParcelCreateSpec) GetVgpuSbdfList() []*VGPUBootSpec {
	if m != nil {
		return m.VgpuSbdfList
	}
	return nil
}

type VGPUMigrateSpec struct {
	// UUID of the host.
	HostUuid []byte `protobuf:"bytes,1,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// List of host GPU sbdfs that are live migration compatibile.
	SbdfList             []string `protobuf:"bytes,2,rep,name=sbdf_list,json=sbdfList" json:"sbdf_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VGPUMigrateSpec) Reset()         { *m = VGPUMigrateSpec{} }
func (m *VGPUMigrateSpec) String() string { return proto.CompactTextString(m) }
func (*VGPUMigrateSpec) ProtoMessage()    {}
func (*VGPUMigrateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{83}
}

func (m *VGPUMigrateSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VGPUMigrateSpec.Unmarshal(m, b)
}
func (m *VGPUMigrateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VGPUMigrateSpec.Marshal(b, m, deterministic)
}
func (m *VGPUMigrateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VGPUMigrateSpec.Merge(m, src)
}
func (m *VGPUMigrateSpec) XXX_Size() int {
	return xxx_messageInfo_VGPUMigrateSpec.Size(m)
}
func (m *VGPUMigrateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VGPUMigrateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VGPUMigrateSpec proto.InternalMessageInfo

func (m *VGPUMigrateSpec) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *VGPUMigrateSpec) GetSbdfList() []string {
	if m != nil {
		return m.SbdfList
	}
	return nil
}

// Message for vGpu assignment to sbdf of a pGpu.
type VGPUBootSpec struct {
	// UUID of the vGpu.
	VgpuUuid []byte `protobuf:"bytes,1,opt,name=vgpu_uuid,json=vgpuUuid" json:"vgpu_uuid,omitempty"`
	// Sbdf of a pGpu to which the vGpu is assigned.
	Sbdf                 *string  `protobuf:"bytes,2,opt,name=sbdf" json:"sbdf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VGPUBootSpec) Reset()         { *m = VGPUBootSpec{} }
func (m *VGPUBootSpec) String() string { return proto.CompactTextString(m) }
func (*VGPUBootSpec) ProtoMessage()    {}
func (*VGPUBootSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{84}
}

func (m *VGPUBootSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VGPUBootSpec.Unmarshal(m, b)
}
func (m *VGPUBootSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VGPUBootSpec.Marshal(b, m, deterministic)
}
func (m *VGPUBootSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VGPUBootSpec.Merge(m, src)
}
func (m *VGPUBootSpec) XXX_Size() int {
	return xxx_messageInfo_VGPUBootSpec.Size(m)
}
func (m *VGPUBootSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VGPUBootSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VGPUBootSpec proto.InternalMessageInfo

func (m *VGPUBootSpec) GetVgpuUuid() []byte {
	if m != nil {
		return m.VgpuUuid
	}
	return nil
}

func (m *VGPUBootSpec) GetSbdf() string {
	if m != nil && m.Sbdf != nil {
		return *m.Sbdf
	}
	return ""
}

type StretchConfig struct {
	// UUID for this config.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// List of vstore ids where acropolis has enabled stretch.
	VstoreIdList         []int64  `protobuf:"varint,2,rep,name=vstore_id_list,json=vstoreIdList" json:"vstore_id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StretchConfig) Reset()         { *m = StretchConfig{} }
func (m *StretchConfig) String() string { return proto.CompactTextString(m) }
func (*StretchConfig) ProtoMessage()    {}
func (*StretchConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{85}
}

func (m *StretchConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StretchConfig.Unmarshal(m, b)
}
func (m *StretchConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StretchConfig.Marshal(b, m, deterministic)
}
func (m *StretchConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StretchConfig.Merge(m, src)
}
func (m *StretchConfig) XXX_Size() int {
	return xxx_messageInfo_StretchConfig.Size(m)
}
func (m *StretchConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StretchConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StretchConfig proto.InternalMessageInfo

func (m *StretchConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *StretchConfig) GetVstoreIdList() []int64 {
	if m != nil {
		return m.VstoreIdList
	}
	return nil
}

type VmGroup struct {
	// VM group identifier. Entity DB uses string for uuid.
	Uuid *string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// VM group name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Affinity rule.
	Affinity             *Affinity `protobuf:"bytes,3,opt,name=affinity" json:"affinity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VmGroup) Reset()         { *m = VmGroup{} }
func (m *VmGroup) String() string { return proto.CompactTextString(m) }
func (*VmGroup) ProtoMessage()    {}
func (*VmGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{86}
}

func (m *VmGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmGroup.Unmarshal(m, b)
}
func (m *VmGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmGroup.Marshal(b, m, deterministic)
}
func (m *VmGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmGroup.Merge(m, src)
}
func (m *VmGroup) XXX_Size() int {
	return xxx_messageInfo_VmGroup.Size(m)
}
func (m *VmGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_VmGroup.DiscardUnknown(m)
}

var xxx_messageInfo_VmGroup proto.InternalMessageInfo

func (m *VmGroup) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *VmGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmGroup) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

type EntityAffinitySpec struct {
	// Host affinity policy of the VM.
	HostAffinity *Affinity `protobuf:"bytes,1,opt,name=host_affinity,json=hostAffinity" json:"host_affinity,omitempty"`
	// UUID of the VM group containing the VM.
	VmGroupUuid          []byte   `protobuf:"bytes,2,opt,name=vm_group_uuid,json=vmGroupUuid" json:"vm_group_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntityAffinitySpec) Reset()         { *m = EntityAffinitySpec{} }
func (m *EntityAffinitySpec) String() string { return proto.CompactTextString(m) }
func (*EntityAffinitySpec) ProtoMessage()    {}
func (*EntityAffinitySpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{87}
}

func (m *EntityAffinitySpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EntityAffinitySpec.Unmarshal(m, b)
}
func (m *EntityAffinitySpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EntityAffinitySpec.Marshal(b, m, deterministic)
}
func (m *EntityAffinitySpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntityAffinitySpec.Merge(m, src)
}
func (m *EntityAffinitySpec) XXX_Size() int {
	return xxx_messageInfo_EntityAffinitySpec.Size(m)
}
func (m *EntityAffinitySpec) XXX_DiscardUnknown() {
	xxx_messageInfo_EntityAffinitySpec.DiscardUnknown(m)
}

var xxx_messageInfo_EntityAffinitySpec proto.InternalMessageInfo

func (m *EntityAffinitySpec) GetHostAffinity() *Affinity {
	if m != nil {
		return m.HostAffinity
	}
	return nil
}

func (m *EntityAffinitySpec) GetVmGroupUuid() []byte {
	if m != nil {
		return m.VmGroupUuid
	}
	return nil
}

type DbKey struct {
	// The Category the key belongs to
	Category *string `protobuf:"bytes,1,opt,name=category" json:"category,omitempty"`
	// The key's row.
	Row *string `protobuf:"bytes,2,opt,name=row" json:"row,omitempty"`
	// The key's column.
	Col                  *string  `protobuf:"bytes,3,opt,name=col" json:"col,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DbKey) Reset()         { *m = DbKey{} }
func (m *DbKey) String() string { return proto.CompactTextString(m) }
func (*DbKey) ProtoMessage()    {}
func (*DbKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{88}
}

func (m *DbKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DbKey.Unmarshal(m, b)
}
func (m *DbKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DbKey.Marshal(b, m, deterministic)
}
func (m *DbKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbKey.Merge(m, src)
}
func (m *DbKey) XXX_Size() int {
	return xxx_messageInfo_DbKey.Size(m)
}
func (m *DbKey) XXX_DiscardUnknown() {
	xxx_messageInfo_DbKey.DiscardUnknown(m)
}

var xxx_messageInfo_DbKey proto.InternalMessageInfo

func (m *DbKey) GetCategory() string {
	if m != nil && m.Category != nil {
		return *m.Category
	}
	return ""
}

func (m *DbKey) GetRow() string {
	if m != nil && m.Row != nil {
		return *m.Row
	}
	return ""
}

func (m *DbKey) GetCol() string {
	if m != nil && m.Col != nil {
		return *m.Col
	}
	return ""
}

type DbValue struct {
	// The logical timestamp when the entry is written into the DB
	Timestamp *int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The entry's value
	Val []byte `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	// A boolean to indicate if the entry is to be tombstoned
	Tombstone            *bool    `protobuf:"varint,3,opt,name=tombstone" json:"tombstone,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DbValue) Reset()         { *m = DbValue{} }
func (m *DbValue) String() string { return proto.CompactTextString(m) }
func (*DbValue) ProtoMessage()    {}
func (*DbValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{89}
}

func (m *DbValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DbValue.Unmarshal(m, b)
}
func (m *DbValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DbValue.Marshal(b, m, deterministic)
}
func (m *DbValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbValue.Merge(m, src)
}
func (m *DbValue) XXX_Size() int {
	return xxx_messageInfo_DbValue.Size(m)
}
func (m *DbValue) XXX_DiscardUnknown() {
	xxx_messageInfo_DbValue.DiscardUnknown(m)
}

var xxx_messageInfo_DbValue proto.InternalMessageInfo

func (m *DbValue) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *DbValue) GetVal() []byte {
	if m != nil {
		return m.Val
	}
	return nil
}

func (m *DbValue) GetTombstone() bool {
	if m != nil && m.Tombstone != nil {
		return *m.Tombstone
	}
	return false
}

type DbEntry struct {
	// A DB entry's encapsulated key and value
	Key                  *DbKey   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                *DbValue `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DbEntry) Reset()         { *m = DbEntry{} }
func (m *DbEntry) String() string { return proto.CompactTextString(m) }
func (*DbEntry) ProtoMessage()    {}
func (*DbEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{90}
}

func (m *DbEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DbEntry.Unmarshal(m, b)
}
func (m *DbEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DbEntry.Marshal(b, m, deterministic)
}
func (m *DbEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DbEntry.Merge(m, src)
}
func (m *DbEntry) XXX_Size() int {
	return xxx_messageInfo_DbEntry.Size(m)
}
func (m *DbEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_DbEntry.DiscardUnknown(m)
}

var xxx_messageInfo_DbEntry proto.InternalMessageInfo

func (m *DbEntry) GetKey() *DbKey {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DbEntry) GetValue() *DbValue {
	if m != nil {
		return m.Value
	}
	return nil
}

type NetworkFunctionConfig struct {
	Type *NetworkFunctionConfig_Type `protobuf:"varint,1,opt,name=type,enum=nutanix.acropolis.NetworkFunctionConfig_Type,def=2" json:"type,omitempty"`
	// The network function name. This is set as an extra_flags on the function
	// VM instances (typically one per node).
	NetworkFunctionName  *string  `protobuf:"bytes,2,opt,name=network_function_name,json=networkFunctionName" json:"network_function_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkFunctionConfig) Reset()         { *m = NetworkFunctionConfig{} }
func (m *NetworkFunctionConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkFunctionConfig) ProtoMessage()    {}
func (*NetworkFunctionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{91}
}

func (m *NetworkFunctionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkFunctionConfig.Unmarshal(m, b)
}
func (m *NetworkFunctionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkFunctionConfig.Marshal(b, m, deterministic)
}
func (m *NetworkFunctionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkFunctionConfig.Merge(m, src)
}
func (m *NetworkFunctionConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkFunctionConfig.Size(m)
}
func (m *NetworkFunctionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkFunctionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkFunctionConfig proto.InternalMessageInfo

const Default_NetworkFunctionConfig_Type NetworkFunctionConfig_Type = NetworkFunctionConfig_kTap

func (m *NetworkFunctionConfig) GetType() NetworkFunctionConfig_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_NetworkFunctionConfig_Type
}

func (m *NetworkFunctionConfig) GetNetworkFunctionName() string {
	if m != nil && m.NetworkFunctionName != nil {
		return *m.NetworkFunctionName
	}
	return ""
}

type NetworkFunctionChainConfig struct {
	// Generic db object header.
	Header *GenericDbObjectHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// A list of network functions.
	NetworkFunctionConfigs []*NetworkFunctionConfig `protobuf:"bytes,2,rep,name=network_function_configs,json=networkFunctionConfigs" json:"network_function_configs,omitempty"`
	// A list of UUID's of the networks that use this chain.
	RegisteredNetworkUuidList [][]byte `protobuf:"bytes,3,rep,name=registered_network_uuid_list,json=registeredNetworkUuidList" json:"registered_network_uuid_list,omitempty"`
	// A list of VNIC's that use this chain.
	RegisteredNics       []*NetworkFunctionChainConfig_VmNicInfo `protobuf:"bytes,4,rep,name=registered_nics,json=registeredNics" json:"registered_nics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *NetworkFunctionChainConfig) Reset()         { *m = NetworkFunctionChainConfig{} }
func (m *NetworkFunctionChainConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkFunctionChainConfig) ProtoMessage()    {}
func (*NetworkFunctionChainConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{92}
}

func (m *NetworkFunctionChainConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkFunctionChainConfig.Unmarshal(m, b)
}
func (m *NetworkFunctionChainConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkFunctionChainConfig.Marshal(b, m, deterministic)
}
func (m *NetworkFunctionChainConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkFunctionChainConfig.Merge(m, src)
}
func (m *NetworkFunctionChainConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkFunctionChainConfig.Size(m)
}
func (m *NetworkFunctionChainConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkFunctionChainConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkFunctionChainConfig proto.InternalMessageInfo

func (m *NetworkFunctionChainConfig) GetHeader() *GenericDbObjectHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *NetworkFunctionChainConfig) GetNetworkFunctionConfigs() []*NetworkFunctionConfig {
	if m != nil {
		return m.NetworkFunctionConfigs
	}
	return nil
}

func (m *NetworkFunctionChainConfig) GetRegisteredNetworkUuidList() [][]byte {
	if m != nil {
		return m.RegisteredNetworkUuidList
	}
	return nil
}

func (m *NetworkFunctionChainConfig) GetRegisteredNics() []*NetworkFunctionChainConfig_VmNicInfo {
	if m != nil {
		return m.RegisteredNics
	}
	return nil
}

type NetworkFunctionChainConfig_VmNicInfo struct {
	// UUID of the VM.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// Mac address of the vnic.
	MacAddr              []byte   `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkFunctionChainConfig_VmNicInfo) Reset()         { *m = NetworkFunctionChainConfig_VmNicInfo{} }
func (m *NetworkFunctionChainConfig_VmNicInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkFunctionChainConfig_VmNicInfo) ProtoMessage()    {}
func (*NetworkFunctionChainConfig_VmNicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{92, 0}
}

func (m *NetworkFunctionChainConfig_VmNicInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkFunctionChainConfig_VmNicInfo.Unmarshal(m, b)
}
func (m *NetworkFunctionChainConfig_VmNicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkFunctionChainConfig_VmNicInfo.Marshal(b, m, deterministic)
}
func (m *NetworkFunctionChainConfig_VmNicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkFunctionChainConfig_VmNicInfo.Merge(m, src)
}
func (m *NetworkFunctionChainConfig_VmNicInfo) XXX_Size() int {
	return xxx_messageInfo_NetworkFunctionChainConfig_VmNicInfo.Size(m)
}
func (m *NetworkFunctionChainConfig_VmNicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkFunctionChainConfig_VmNicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkFunctionChainConfig_VmNicInfo proto.InternalMessageInfo

func (m *NetworkFunctionChainConfig_VmNicInfo) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *NetworkFunctionChainConfig_VmNicInfo) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

type SchedulerSegmentAssignmentRecord struct {
	// Required: the uuid of the source node to which this record applies.
	Uuid            []byte                                                `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	NodeAssignments []*SchedulerSegmentAssignmentRecord_PerNodeAssignment `protobuf:"bytes,2,rep,name=node_assignments,json=nodeAssignments" json:"node_assignments,omitempty"`
	// Whether this is a deleted entry.
	Deleted *bool `protobuf:"varint,4,opt,name=deleted" json:"deleted,omitempty"`
	// Segment assignment is for node failover or maintenance.
	Failover *bool `protobuf:"varint,5,opt,name=failover" json:"failover,omitempty"`
	// Task uuid that owns the segment assignments.
	TaskUuid             []byte   `protobuf:"bytes,6,opt,name=task_uuid,json=taskUuid" json:"task_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerSegmentAssignmentRecord) Reset()         { *m = SchedulerSegmentAssignmentRecord{} }
func (m *SchedulerSegmentAssignmentRecord) String() string { return proto.CompactTextString(m) }
func (*SchedulerSegmentAssignmentRecord) ProtoMessage()    {}
func (*SchedulerSegmentAssignmentRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{93}
}

func (m *SchedulerSegmentAssignmentRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchedulerSegmentAssignmentRecord.Unmarshal(m, b)
}
func (m *SchedulerSegmentAssignmentRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchedulerSegmentAssignmentRecord.Marshal(b, m, deterministic)
}
func (m *SchedulerSegmentAssignmentRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerSegmentAssignmentRecord.Merge(m, src)
}
func (m *SchedulerSegmentAssignmentRecord) XXX_Size() int {
	return xxx_messageInfo_SchedulerSegmentAssignmentRecord.Size(m)
}
func (m *SchedulerSegmentAssignmentRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerSegmentAssignmentRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerSegmentAssignmentRecord proto.InternalMessageInfo

func (m *SchedulerSegmentAssignmentRecord) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SchedulerSegmentAssignmentRecord) GetNodeAssignments() []*SchedulerSegmentAssignmentRecord_PerNodeAssignment {
	if m != nil {
		return m.NodeAssignments
	}
	return nil
}

func (m *SchedulerSegmentAssignmentRecord) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *SchedulerSegmentAssignmentRecord) GetFailover() bool {
	if m != nil && m.Failover != nil {
		return *m.Failover
	}
	return false
}

func (m *SchedulerSegmentAssignmentRecord) GetTaskUuid() []byte {
	if m != nil {
		return m.TaskUuid
	}
	return nil
}

type SchedulerSegmentAssignmentRecord_PerNodeAssignment struct {
	// assigned node UUID.
	NodeUuid []byte `protobuf:"bytes,1,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// VMs assigned to this node.
	VmUuids [][]byte `protobuf:"bytes,2,rep,name=vm_uuids,json=vmUuids" json:"vm_uuids,omitempty"`
	// Number of segments taken up by the assigned VMs.
	NumAssignedSegments *int64 `protobuf:"varint,3,opt,name=num_assigned_segments,json=numAssignedSegments" json:"num_assigned_segments,omitempty"`
	// Memory assigned to each VM.
	AssignedMemBytes []int64 `protobuf:"varint,4,rep,name=assigned_mem_bytes,json=assignedMemBytes" json:"assigned_mem_bytes,omitempty"`
	// Affinity spec of the parcel on the failing node.
	AffinitySpecs []*EntityAffinitySpec `protobuf:"bytes,5,rep,name=affinity_specs,json=affinitySpecs" json:"affinity_specs,omitempty"`
	// VMs that are done restarting or don't need any segments.
	DoneVmUuids          [][]byte `protobuf:"bytes,6,rep,name=done_vm_uuids,json=doneVmUuids" json:"done_vm_uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) Reset() {
	*m = SchedulerSegmentAssignmentRecord_PerNodeAssignment{}
}
func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) String() string {
	return proto.CompactTextString(m)
}
func (*SchedulerSegmentAssignmentRecord_PerNodeAssignment) ProtoMessage() {}
func (*SchedulerSegmentAssignmentRecord_PerNodeAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{93, 0}
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchedulerSegmentAssignmentRecord_PerNodeAssignment.Unmarshal(m, b)
}
func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchedulerSegmentAssignmentRecord_PerNodeAssignment.Marshal(b, m, deterministic)
}
func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerSegmentAssignmentRecord_PerNodeAssignment.Merge(m, src)
}
func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) XXX_Size() int {
	return xxx_messageInfo_SchedulerSegmentAssignmentRecord_PerNodeAssignment.Size(m)
}
func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerSegmentAssignmentRecord_PerNodeAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerSegmentAssignmentRecord_PerNodeAssignment proto.InternalMessageInfo

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) GetNodeUuid() []byte {
	if m != nil {
		return m.NodeUuid
	}
	return nil
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) GetVmUuids() [][]byte {
	if m != nil {
		return m.VmUuids
	}
	return nil
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) GetNumAssignedSegments() int64 {
	if m != nil && m.NumAssignedSegments != nil {
		return *m.NumAssignedSegments
	}
	return 0
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) GetAssignedMemBytes() []int64 {
	if m != nil {
		return m.AssignedMemBytes
	}
	return nil
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) GetAffinitySpecs() []*EntityAffinitySpec {
	if m != nil {
		return m.AffinitySpecs
	}
	return nil
}

func (m *SchedulerSegmentAssignmentRecord_PerNodeAssignment) GetDoneVmUuids() [][]byte {
	if m != nil {
		return m.DoneVmUuids
	}
	return nil
}

type SchedulerSegmentAssignmentLogicalTimestamp struct {
	// UUID of the node to which this record applies.
	NodeUuid []byte `protobuf:"bytes,1,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// Logical timestamp tracking changes to the scheduler's segment assignments.
	Timestamp *int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulerSegmentAssignmentLogicalTimestamp) Reset() {
	*m = SchedulerSegmentAssignmentLogicalTimestamp{}
}
func (m *SchedulerSegmentAssignmentLogicalTimestamp) String() string {
	return proto.CompactTextString(m)
}
func (*SchedulerSegmentAssignmentLogicalTimestamp) ProtoMessage() {}
func (*SchedulerSegmentAssignmentLogicalTimestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{94}
}

func (m *SchedulerSegmentAssignmentLogicalTimestamp) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SchedulerSegmentAssignmentLogicalTimestamp.Unmarshal(m, b)
}
func (m *SchedulerSegmentAssignmentLogicalTimestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SchedulerSegmentAssignmentLogicalTimestamp.Marshal(b, m, deterministic)
}
func (m *SchedulerSegmentAssignmentLogicalTimestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulerSegmentAssignmentLogicalTimestamp.Merge(m, src)
}
func (m *SchedulerSegmentAssignmentLogicalTimestamp) XXX_Size() int {
	return xxx_messageInfo_SchedulerSegmentAssignmentLogicalTimestamp.Size(m)
}
func (m *SchedulerSegmentAssignmentLogicalTimestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulerSegmentAssignmentLogicalTimestamp.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulerSegmentAssignmentLogicalTimestamp proto.InternalMessageInfo

func (m *SchedulerSegmentAssignmentLogicalTimestamp) GetNodeUuid() []byte {
	if m != nil {
		return m.NodeUuid
	}
	return nil
}

func (m *SchedulerSegmentAssignmentLogicalTimestamp) GetTimestamp() int64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *SchedulerSegmentAssignmentLogicalTimestamp) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type BatchUpdateErr struct {
	//Microseg Policy UUID
	Uuid *string `protobuf:"bytes,1,req,name=uuid" json:"uuid,omitempty"`
	//Acropolis Error code
	ErrorCode            *AcropolisError_Type `protobuf:"varint,2,req,name=error_code,json=errorCode,enum=nutanix.acropolis.AcropolisError_Type" json:"error_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *BatchUpdateErr) Reset()         { *m = BatchUpdateErr{} }
func (m *BatchUpdateErr) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateErr) ProtoMessage()    {}
func (*BatchUpdateErr) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{95}
}

func (m *BatchUpdateErr) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateErr.Unmarshal(m, b)
}
func (m *BatchUpdateErr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateErr.Marshal(b, m, deterministic)
}
func (m *BatchUpdateErr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateErr.Merge(m, src)
}
func (m *BatchUpdateErr) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateErr.Size(m)
}
func (m *BatchUpdateErr) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateErr.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateErr proto.InternalMessageInfo

func (m *BatchUpdateErr) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *BatchUpdateErr) GetErrorCode() AcropolisError_Type {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return AcropolisError_kNoError
}

type MicrosegCategoryToVmMap struct {
	// Category uuid.
	CategoryUuid *string `protobuf:"bytes,1,opt,name=category_uuid,json=categoryUuid" json:"category_uuid,omitempty"`
	// VM UUIDs that are part of this category.
	VmUuidList           []string `protobuf:"bytes,2,rep,name=vm_uuid_list,json=vmUuidList" json:"vm_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MicrosegCategoryToVmMap) Reset()         { *m = MicrosegCategoryToVmMap{} }
func (m *MicrosegCategoryToVmMap) String() string { return proto.CompactTextString(m) }
func (*MicrosegCategoryToVmMap) ProtoMessage()    {}
func (*MicrosegCategoryToVmMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{96}
}

func (m *MicrosegCategoryToVmMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegCategoryToVmMap.Unmarshal(m, b)
}
func (m *MicrosegCategoryToVmMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegCategoryToVmMap.Marshal(b, m, deterministic)
}
func (m *MicrosegCategoryToVmMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegCategoryToVmMap.Merge(m, src)
}
func (m *MicrosegCategoryToVmMap) XXX_Size() int {
	return xxx_messageInfo_MicrosegCategoryToVmMap.Size(m)
}
func (m *MicrosegCategoryToVmMap) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegCategoryToVmMap.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegCategoryToVmMap proto.InternalMessageInfo

func (m *MicrosegCategoryToVmMap) GetCategoryUuid() string {
	if m != nil && m.CategoryUuid != nil {
		return *m.CategoryUuid
	}
	return ""
}

func (m *MicrosegCategoryToVmMap) GetVmUuidList() []string {
	if m != nil {
		return m.VmUuidList
	}
	return nil
}

type MicrosegMacInfo struct {
	MacAddr              *string  `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	Bridge               *string  `protobuf:"bytes,2,opt,name=bridge" json:"bridge,omitempty"`
	VlanList             []string `protobuf:"bytes,3,rep,name=vlan_list,json=vlanList" json:"vlan_list,omitempty"`
	NicType              *string  `protobuf:"bytes,4,opt,name=nic_type,json=nicType" json:"nic_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MicrosegMacInfo) Reset()         { *m = MicrosegMacInfo{} }
func (m *MicrosegMacInfo) String() string { return proto.CompactTextString(m) }
func (*MicrosegMacInfo) ProtoMessage()    {}
func (*MicrosegMacInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{97}
}

func (m *MicrosegMacInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegMacInfo.Unmarshal(m, b)
}
func (m *MicrosegMacInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegMacInfo.Marshal(b, m, deterministic)
}
func (m *MicrosegMacInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegMacInfo.Merge(m, src)
}
func (m *MicrosegMacInfo) XXX_Size() int {
	return xxx_messageInfo_MicrosegMacInfo.Size(m)
}
func (m *MicrosegMacInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegMacInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegMacInfo proto.InternalMessageInfo

func (m *MicrosegMacInfo) GetMacAddr() string {
	if m != nil && m.MacAddr != nil {
		return *m.MacAddr
	}
	return ""
}

func (m *MicrosegMacInfo) GetBridge() string {
	if m != nil && m.Bridge != nil {
		return *m.Bridge
	}
	return ""
}

func (m *MicrosegMacInfo) GetVlanList() []string {
	if m != nil {
		return m.VlanList
	}
	return nil
}

func (m *MicrosegMacInfo) GetNicType() string {
	if m != nil && m.NicType != nil {
		return *m.NicType
	}
	return ""
}

type MicrosegEventMacInfo struct {
	MacAddr              []byte         `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	NetworkUuid          []byte         `protobuf:"bytes,2,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	VlanMode             *VmNicVlanType `protobuf:"varint,3,opt,name=vlan_mode,json=vlanMode,enum=nutanix.acropolis.VmNicVlanType" json:"vlan_mode,omitempty"`
	TrunkedNetworks      []int32        `protobuf:"varint,4,rep,name=trunked_networks,json=trunkedNetworks" json:"trunked_networks,omitempty"`
	NicType              *string        `protobuf:"bytes,5,opt,name=nic_type,json=nicType" json:"nic_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *MicrosegEventMacInfo) Reset()         { *m = MicrosegEventMacInfo{} }
func (m *MicrosegEventMacInfo) String() string { return proto.CompactTextString(m) }
func (*MicrosegEventMacInfo) ProtoMessage()    {}
func (*MicrosegEventMacInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{98}
}

func (m *MicrosegEventMacInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegEventMacInfo.Unmarshal(m, b)
}
func (m *MicrosegEventMacInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegEventMacInfo.Marshal(b, m, deterministic)
}
func (m *MicrosegEventMacInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegEventMacInfo.Merge(m, src)
}
func (m *MicrosegEventMacInfo) XXX_Size() int {
	return xxx_messageInfo_MicrosegEventMacInfo.Size(m)
}
func (m *MicrosegEventMacInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegEventMacInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegEventMacInfo proto.InternalMessageInfo

func (m *MicrosegEventMacInfo) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *MicrosegEventMacInfo) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *MicrosegEventMacInfo) GetVlanMode() VmNicVlanType {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return VmNicVlanType_kAccess
}

func (m *MicrosegEventMacInfo) GetTrunkedNetworks() []int32 {
	if m != nil {
		return m.TrunkedNetworks
	}
	return nil
}

func (m *MicrosegEventMacInfo) GetNicType() string {
	if m != nil && m.NicType != nil {
		return *m.NicType
	}
	return ""
}

type MicrosegVmToIpMap struct {
	// VM uuid.
	VmUuid *string `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// IP addresses of the VM.
	IpAddressList []string `protobuf:"bytes,2,rep,name=ip_address_list,json=ipAddressList" json:"ip_address_list,omitempty"`
	// MAC addresses of the VM.
	MacAddressList []string `protobuf:"bytes,3,rep,name=mac_address_list,json=macAddressList" json:"mac_address_list,omitempty"`
	// Port ids of the VM.
	PortIdList []string `protobuf:"bytes,4,rep,name=port_id_list,json=portIdList" json:"port_id_list,omitempty"`
	// MAC information for every mac listed
	MacInfoList          []*MicrosegMacInfo `protobuf:"bytes,5,rep,name=mac_info_list,json=macInfoList" json:"mac_info_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MicrosegVmToIpMap) Reset()         { *m = MicrosegVmToIpMap{} }
func (m *MicrosegVmToIpMap) String() string { return proto.CompactTextString(m) }
func (*MicrosegVmToIpMap) ProtoMessage()    {}
func (*MicrosegVmToIpMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{99}
}

func (m *MicrosegVmToIpMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegVmToIpMap.Unmarshal(m, b)
}
func (m *MicrosegVmToIpMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegVmToIpMap.Marshal(b, m, deterministic)
}
func (m *MicrosegVmToIpMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegVmToIpMap.Merge(m, src)
}
func (m *MicrosegVmToIpMap) XXX_Size() int {
	return xxx_messageInfo_MicrosegVmToIpMap.Size(m)
}
func (m *MicrosegVmToIpMap) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegVmToIpMap.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegVmToIpMap proto.InternalMessageInfo

func (m *MicrosegVmToIpMap) GetVmUuid() string {
	if m != nil && m.VmUuid != nil {
		return *m.VmUuid
	}
	return ""
}

func (m *MicrosegVmToIpMap) GetIpAddressList() []string {
	if m != nil {
		return m.IpAddressList
	}
	return nil
}

func (m *MicrosegVmToIpMap) GetMacAddressList() []string {
	if m != nil {
		return m.MacAddressList
	}
	return nil
}

func (m *MicrosegVmToIpMap) GetPortIdList() []string {
	if m != nil {
		return m.PortIdList
	}
	return nil
}

func (m *MicrosegVmToIpMap) GetMacInfoList() []*MicrosegMacInfo {
	if m != nil {
		return m.MacInfoList
	}
	return nil
}

// Microsegmentation policy config metadata that is sent in the RPC from PC to
// PE.  This metadata is consumed entirely by the PE.
type MicrosegConfigMetadata struct {
	// Operation to perform on the host.
	Operation *MicrosegConfigOperation `protobuf:"varint,1,opt,name=operation,enum=nutanix.acropolis.MicrosegConfigOperation,def=1" json:"operation,omitempty"`
	// Reason for policy change.
	Reason *MicrosegConfigReason `protobuf:"varint,2,opt,name=reason,enum=nutanix.acropolis.MicrosegConfigReason,def=1" json:"reason,omitempty"`
	// Command to be executed on the host.
	Command *MicrosegConfigCommand `protobuf:"varint,3,opt,name=command,enum=nutanix.acropolis.MicrosegConfigCommand,def=1" json:"command,omitempty"`
	// VMs and the categories that they are part of, used for delta updates.
	DeltaCategoryToVmMapList []*MicrosegCategoryToVmMap `protobuf:"bytes,4,rep,name=delta_category_to_vm_map_list,json=deltaCategoryToVmMapList" json:"delta_category_to_vm_map_list,omitempty"`
	// VM to IP map for VMs involved in delta updates.
	DeltaVmToIpMapList []*MicrosegVmToIpMap `protobuf:"bytes,5,rep,name=delta_vm_to_ip_map_list,json=deltaVmToIpMapList" json:"delta_vm_to_ip_map_list,omitempty"`
	// VMs that are part of delta update.
	DeltaVmUuidList      []string `protobuf:"bytes,6,rep,name=delta_vm_uuid_list,json=deltaVmUuidList" json:"delta_vm_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MicrosegConfigMetadata) Reset()         { *m = MicrosegConfigMetadata{} }
func (m *MicrosegConfigMetadata) String() string { return proto.CompactTextString(m) }
func (*MicrosegConfigMetadata) ProtoMessage()    {}
func (*MicrosegConfigMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{100}
}

func (m *MicrosegConfigMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegConfigMetadata.Unmarshal(m, b)
}
func (m *MicrosegConfigMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegConfigMetadata.Marshal(b, m, deterministic)
}
func (m *MicrosegConfigMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegConfigMetadata.Merge(m, src)
}
func (m *MicrosegConfigMetadata) XXX_Size() int {
	return xxx_messageInfo_MicrosegConfigMetadata.Size(m)
}
func (m *MicrosegConfigMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegConfigMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegConfigMetadata proto.InternalMessageInfo

const Default_MicrosegConfigMetadata_Operation MicrosegConfigOperation = MicrosegConfigOperation_kMicrosegOpInvalid
const Default_MicrosegConfigMetadata_Reason MicrosegConfigReason = MicrosegConfigReason_kMicrosegReasonInvalid
const Default_MicrosegConfigMetadata_Command MicrosegConfigCommand = MicrosegConfigCommand_kNetworkSecurityRuleInvalid

func (m *MicrosegConfigMetadata) GetOperation() MicrosegConfigOperation {
	if m != nil && m.Operation != nil {
		return *m.Operation
	}
	return Default_MicrosegConfigMetadata_Operation
}

func (m *MicrosegConfigMetadata) GetReason() MicrosegConfigReason {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return Default_MicrosegConfigMetadata_Reason
}

func (m *MicrosegConfigMetadata) GetCommand() MicrosegConfigCommand {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return Default_MicrosegConfigMetadata_Command
}

func (m *MicrosegConfigMetadata) GetDeltaCategoryToVmMapList() []*MicrosegCategoryToVmMap {
	if m != nil {
		return m.DeltaCategoryToVmMapList
	}
	return nil
}

func (m *MicrosegConfigMetadata) GetDeltaVmToIpMapList() []*MicrosegVmToIpMap {
	if m != nil {
		return m.DeltaVmToIpMapList
	}
	return nil
}

func (m *MicrosegConfigMetadata) GetDeltaVmUuidList() []string {
	if m != nil {
		return m.DeltaVmUuidList
	}
	return nil
}

// Microsegmentation policy config that is used for RPC across two
// control plane entities: PC to PE or PE to AHV. This is meant to be
// consumed on the enforcement entity which is AHV.
type MicrosegConfig struct {
	// Microsegmentation network security rule info which includes the rule.
	RuleInfo *microseg.NetworkSecurityRuleInfo `protobuf:"bytes,1,opt,name=rule_info,json=ruleInfo" json:"rule_info,omitempty"`
	// Category to VM map for the categories in rule.
	CategoryToVmMapList []*MicrosegCategoryToVmMap `protobuf:"bytes,2,rep,name=category_to_vm_map_list,json=categoryToVmMapList" json:"category_to_vm_map_list,omitempty"`
	// VM to IP map for VMs in categories.
	VmToIpMapList []*MicrosegVmToIpMap `protobuf:"bytes,3,rep,name=vm_to_ip_map_list,json=vmToIpMapList" json:"vm_to_ip_map_list,omitempty"`
	// VMs that are part of this rule.
	VmUuidList []string `protobuf:"bytes,4,rep,name=vm_uuid_list,json=vmUuidList" json:"vm_uuid_list,omitempty"`
	// Generation number used as part of the rule during creation. Used during
	// deletion to delete all rules that dont match the generation number.
	GenerationNumber     *int64   `protobuf:"varint,5,opt,name=generation_number,json=generationNumber" json:"generation_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MicrosegConfig) Reset()         { *m = MicrosegConfig{} }
func (m *MicrosegConfig) String() string { return proto.CompactTextString(m) }
func (*MicrosegConfig) ProtoMessage()    {}
func (*MicrosegConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{101}
}

func (m *MicrosegConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegConfig.Unmarshal(m, b)
}
func (m *MicrosegConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegConfig.Marshal(b, m, deterministic)
}
func (m *MicrosegConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegConfig.Merge(m, src)
}
func (m *MicrosegConfig) XXX_Size() int {
	return xxx_messageInfo_MicrosegConfig.Size(m)
}
func (m *MicrosegConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegConfig proto.InternalMessageInfo

func (m *MicrosegConfig) GetRuleInfo() *microseg.NetworkSecurityRuleInfo {
	if m != nil {
		return m.RuleInfo
	}
	return nil
}

func (m *MicrosegConfig) GetCategoryToVmMapList() []*MicrosegCategoryToVmMap {
	if m != nil {
		return m.CategoryToVmMapList
	}
	return nil
}

func (m *MicrosegConfig) GetVmToIpMapList() []*MicrosegVmToIpMap {
	if m != nil {
		return m.VmToIpMapList
	}
	return nil
}

func (m *MicrosegConfig) GetVmUuidList() []string {
	if m != nil {
		return m.VmUuidList
	}
	return nil
}

func (m *MicrosegConfig) GetGenerationNumber() int64 {
	if m != nil && m.GenerationNumber != nil {
		return *m.GenerationNumber
	}
	return 0
}

// Acropolis-wise configurations.
type AcropolisConfig struct {
	// UUID for this config.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Indicates whether acropolis has initialized virtual NIC and disk UUIDs.
	AcropolisInitVdiskVnicUuidDone *bool `protobuf:"varint,2,opt,name=acropolis_init_vdisk_vnic_uuid_done,json=acropolisInitVdiskVnicUuidDone" json:"acropolis_init_vdisk_vnic_uuid_done,omitempty"`
	// Indicates whether acropolis has updated IDF state of all the VMs.
	AcropolisIdfVmStateUpdateDone *bool `protobuf:"varint,3,opt,name=acropolis_idf_vm_state_update_done,json=acropolisIdfVmStateUpdateDone" json:"acropolis_idf_vm_state_update_done,omitempty"`
	// Indicates whether acropolis has retriggered the publishing of VM state in
	// IDF. This is intended to be used to fix publishing issues during upgrade
	// paths.
	AcropolisRetriggerIdfVmStateUpdateDone *bool `protobuf:"varint,4,opt,name=acropolis_retrigger_idf_vm_state_update_done,json=acropolisRetriggerIdfVmStateUpdateDone" json:"acropolis_retrigger_idf_vm_state_update_done,omitempty"`
	// Indicates whether acropolis has fixed the inconsistency in IDF with respect
	// to virtual_gpu_uuids field of VM entity in IDF.
	AcropolisVirtualGpuUuidsInconsistencyFixed *bool `protobuf:"varint,5,opt,name=acropolis_virtual_gpu_uuids_inconsistency_fixed,json=acropolisVirtualGpuUuidsInconsistencyFixed" json:"acropolis_virtual_gpu_uuids_inconsistency_fixed,omitempty"`
	// Indicates whether acropolis has updated IDF state of all the VMs.
	AcropolisInitNumThreadsPerCoreDone *bool `protobuf:"varint,6,opt,name=acropolis_init_num_threads_per_core_done,json=acropolisInitNumThreadsPerCoreDone" json:"acropolis_init_num_threads_per_core_done,omitempty"`
	// Indicates whether acropolis has correctly populated removed_from_host field
	// for all pre-existing VM IDF entities post upgrade.
	AcropolisRemovedFromHostPublishingDone *bool `protobuf:"varint,7,opt,name=acropolis_removed_from_host_publishing_done,json=acropolisRemovedFromHostPublishingDone" json:"acropolis_removed_from_host_publishing_done,omitempty"`
	// Indicates whether we have already successfully created anduril VM DB
	// entries for each acropolis VM.
	AcropolisCreatedAndurilVmDbEntries *bool `protobuf:"varint,8,opt,name=acropolis_created_anduril_vm_db_entries,json=acropolisCreatedAndurilVmDbEntries" json:"acropolis_created_anduril_vm_db_entries,omitempty"`
	// Indicates whether we have successfully cloned NVRAM disks for all the VMs.
	AcropolisClonedNvramDisks *bool    `protobuf:"varint,9,opt,name=acropolis_cloned_nvram_disks,json=acropolisClonedNvramDisks" json:"acropolis_cloned_nvram_disks,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *AcropolisConfig) Reset()         { *m = AcropolisConfig{} }
func (m *AcropolisConfig) String() string { return proto.CompactTextString(m) }
func (*AcropolisConfig) ProtoMessage()    {}
func (*AcropolisConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{102}
}

func (m *AcropolisConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AcropolisConfig.Unmarshal(m, b)
}
func (m *AcropolisConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AcropolisConfig.Marshal(b, m, deterministic)
}
func (m *AcropolisConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcropolisConfig.Merge(m, src)
}
func (m *AcropolisConfig) XXX_Size() int {
	return xxx_messageInfo_AcropolisConfig.Size(m)
}
func (m *AcropolisConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AcropolisConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AcropolisConfig proto.InternalMessageInfo

func (m *AcropolisConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *AcropolisConfig) GetAcropolisInitVdiskVnicUuidDone() bool {
	if m != nil && m.AcropolisInitVdiskVnicUuidDone != nil {
		return *m.AcropolisInitVdiskVnicUuidDone
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisIdfVmStateUpdateDone() bool {
	if m != nil && m.AcropolisIdfVmStateUpdateDone != nil {
		return *m.AcropolisIdfVmStateUpdateDone
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisRetriggerIdfVmStateUpdateDone() bool {
	if m != nil && m.AcropolisRetriggerIdfVmStateUpdateDone != nil {
		return *m.AcropolisRetriggerIdfVmStateUpdateDone
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisVirtualGpuUuidsInconsistencyFixed() bool {
	if m != nil && m.AcropolisVirtualGpuUuidsInconsistencyFixed != nil {
		return *m.AcropolisVirtualGpuUuidsInconsistencyFixed
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisInitNumThreadsPerCoreDone() bool {
	if m != nil && m.AcropolisInitNumThreadsPerCoreDone != nil {
		return *m.AcropolisInitNumThreadsPerCoreDone
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisRemovedFromHostPublishingDone() bool {
	if m != nil && m.AcropolisRemovedFromHostPublishingDone != nil {
		return *m.AcropolisRemovedFromHostPublishingDone
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisCreatedAndurilVmDbEntries() bool {
	if m != nil && m.AcropolisCreatedAndurilVmDbEntries != nil {
		return *m.AcropolisCreatedAndurilVmDbEntries
	}
	return false
}

func (m *AcropolisConfig) GetAcropolisClonedNvramDisks() bool {
	if m != nil && m.AcropolisClonedNvramDisks != nil {
		return *m.AcropolisClonedNvramDisks
	}
	return false
}

// Acropolis-wise Volume Group configurations.
type AcropolisVolumeConfig struct {
	// UUID for this config.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Once the pithos and IDF updates corresponding to
	// VG and Iscsi Client entities get complete, and the cluster gets upgraded,
	// the volumes_version is set in "capabilities" IDF entity to reflect if
	// the upgrade has completed for the PC to forward the calls to PE.
	VolumesVersion       *VolumesVersion `protobuf:"varint,2,opt,name=volumes_version,json=volumesVersion,enum=nutanix.acropolis.VolumesVersion,def=0" json:"volumes_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AcropolisVolumeConfig) Reset()         { *m = AcropolisVolumeConfig{} }
func (m *AcropolisVolumeConfig) String() string { return proto.CompactTextString(m) }
func (*AcropolisVolumeConfig) ProtoMessage()    {}
func (*AcropolisVolumeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{103}
}

func (m *AcropolisVolumeConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AcropolisVolumeConfig.Unmarshal(m, b)
}
func (m *AcropolisVolumeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AcropolisVolumeConfig.Marshal(b, m, deterministic)
}
func (m *AcropolisVolumeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcropolisVolumeConfig.Merge(m, src)
}
func (m *AcropolisVolumeConfig) XXX_Size() int {
	return xxx_messageInfo_AcropolisVolumeConfig.Size(m)
}
func (m *AcropolisVolumeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AcropolisVolumeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AcropolisVolumeConfig proto.InternalMessageInfo

const Default_AcropolisVolumeConfig_VolumesVersion VolumesVersion = VolumesVersion_kInitialVersion

func (m *AcropolisVolumeConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *AcropolisVolumeConfig) GetVolumesVersion() VolumesVersion {
	if m != nil && m.VolumesVersion != nil {
		return *m.VolumesVersion
	}
	return Default_AcropolisVolumeConfig_VolumesVersion
}

type ClusterVswitchConfig struct {
	// UUID of the cluster wide switch configuration.
	ClusterVswitchUuid []byte `protobuf:"bytes,1,opt,name=cluster_vswitch_uuid,json=clusterVswitchUuid" json:"cluster_vswitch_uuid,omitempty"`
	// Name of the bridge (e.g., br0, br1 etc). This should be unique.
	BridgeName *string `protobuf:"bytes,2,opt,name=bridge_name,json=bridgeName" json:"bridge_name,omitempty"`
	// Bond name (e.g., br0-up, br1-up etc).
	// A bridge can only have one bond.
	BondName *string `protobuf:"bytes,3,opt,name=bond_name,json=bondName" json:"bond_name,omitempty"`
	// Nic teaming policy set on the bond.
	NicTeamPolicy *ClusterVswitchConfig_NicTeamPolicy `protobuf:"varint,4,opt,name=nic_team_policy,json=nicTeamPolicy,enum=nutanix.acropolis.ClusterVswitchConfig_NicTeamPolicy" json:"nic_team_policy,omitempty"`
	// Lacp configuration.
	LacpConfig            *ClusterVswitchConfig_LacpConfig           `protobuf:"bytes,5,opt,name=lacp_config,json=lacpConfig" json:"lacp_config,omitempty"`
	DefaultUplinkGrouping *ClusterVswitchConfig_UplinkGroupingType   `protobuf:"varint,6,opt,name=default_uplink_grouping,json=defaultUplinkGrouping,enum=nutanix.acropolis.ClusterVswitchConfig_UplinkGroupingType" json:"default_uplink_grouping,omitempty"`
	HostUplinkOverrides   []*ClusterVswitchConfig_UplinkHostOverride `protobuf:"bytes,7,rep,name=host_uplink_overrides,json=hostUplinkOverrides" json:"host_uplink_overrides,omitempty"`
	// Flag to indicate if update is in-progres.
	InProgress           *bool    `protobuf:"varint,8,opt,name=in_progress,json=inProgress" json:"in_progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterVswitchConfig) Reset()         { *m = ClusterVswitchConfig{} }
func (m *ClusterVswitchConfig) String() string { return proto.CompactTextString(m) }
func (*ClusterVswitchConfig) ProtoMessage()    {}
func (*ClusterVswitchConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{104}
}

func (m *ClusterVswitchConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterVswitchConfig.Unmarshal(m, b)
}
func (m *ClusterVswitchConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterVswitchConfig.Marshal(b, m, deterministic)
}
func (m *ClusterVswitchConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterVswitchConfig.Merge(m, src)
}
func (m *ClusterVswitchConfig) XXX_Size() int {
	return xxx_messageInfo_ClusterVswitchConfig.Size(m)
}
func (m *ClusterVswitchConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterVswitchConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterVswitchConfig proto.InternalMessageInfo

func (m *ClusterVswitchConfig) GetClusterVswitchUuid() []byte {
	if m != nil {
		return m.ClusterVswitchUuid
	}
	return nil
}

func (m *ClusterVswitchConfig) GetBridgeName() string {
	if m != nil && m.BridgeName != nil {
		return *m.BridgeName
	}
	return ""
}

func (m *ClusterVswitchConfig) GetBondName() string {
	if m != nil && m.BondName != nil {
		return *m.BondName
	}
	return ""
}

func (m *ClusterVswitchConfig) GetNicTeamPolicy() ClusterVswitchConfig_NicTeamPolicy {
	if m != nil && m.NicTeamPolicy != nil {
		return *m.NicTeamPolicy
	}
	return ClusterVswitchConfig_kActiveBackup
}

func (m *ClusterVswitchConfig) GetLacpConfig() *ClusterVswitchConfig_LacpConfig {
	if m != nil {
		return m.LacpConfig
	}
	return nil
}

func (m *ClusterVswitchConfig) GetDefaultUplinkGrouping() ClusterVswitchConfig_UplinkGroupingType {
	if m != nil && m.DefaultUplinkGrouping != nil {
		return *m.DefaultUplinkGrouping
	}
	return ClusterVswitchConfig_kNone
}

func (m *ClusterVswitchConfig) GetHostUplinkOverrides() []*ClusterVswitchConfig_UplinkHostOverride {
	if m != nil {
		return m.HostUplinkOverrides
	}
	return nil
}

func (m *ClusterVswitchConfig) GetInProgress() bool {
	if m != nil && m.InProgress != nil {
		return *m.InProgress
	}
	return false
}

// Lacp configuration applicable to the bond.
type ClusterVswitchConfig_LacpConfig struct {
	// Whether to enable LACP on the bond.
	Lacp *bool `protobuf:"varint,1,opt,name=lacp" json:"lacp,omitempty"`
	// Lacp timeout value.
	LacpTimeout *ClusterVswitchConfig_LacpConfig_LacpTimeout `protobuf:"varint,2,opt,name=lacp_timeout,json=lacpTimeout,enum=nutanix.acropolis.ClusterVswitchConfig_LacpConfig_LacpTimeout" json:"lacp_timeout,omitempty"`
	// Whether to enable LACP fall back to active-backup on LACP negotiation
	// failure.
	LacpFallback         *bool    `protobuf:"varint,3,opt,name=lacp_fallback,json=lacpFallback" json:"lacp_fallback,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterVswitchConfig_LacpConfig) Reset()         { *m = ClusterVswitchConfig_LacpConfig{} }
func (m *ClusterVswitchConfig_LacpConfig) String() string { return proto.CompactTextString(m) }
func (*ClusterVswitchConfig_LacpConfig) ProtoMessage()    {}
func (*ClusterVswitchConfig_LacpConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{104, 0}
}

func (m *ClusterVswitchConfig_LacpConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterVswitchConfig_LacpConfig.Unmarshal(m, b)
}
func (m *ClusterVswitchConfig_LacpConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterVswitchConfig_LacpConfig.Marshal(b, m, deterministic)
}
func (m *ClusterVswitchConfig_LacpConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterVswitchConfig_LacpConfig.Merge(m, src)
}
func (m *ClusterVswitchConfig_LacpConfig) XXX_Size() int {
	return xxx_messageInfo_ClusterVswitchConfig_LacpConfig.Size(m)
}
func (m *ClusterVswitchConfig_LacpConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterVswitchConfig_LacpConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterVswitchConfig_LacpConfig proto.InternalMessageInfo

func (m *ClusterVswitchConfig_LacpConfig) GetLacp() bool {
	if m != nil && m.Lacp != nil {
		return *m.Lacp
	}
	return false
}

func (m *ClusterVswitchConfig_LacpConfig) GetLacpTimeout() ClusterVswitchConfig_LacpConfig_LacpTimeout {
	if m != nil && m.LacpTimeout != nil {
		return *m.LacpTimeout
	}
	return ClusterVswitchConfig_LacpConfig_kFast
}

func (m *ClusterVswitchConfig_LacpConfig) GetLacpFallback() bool {
	if m != nil && m.LacpFallback != nil {
		return *m.LacpFallback
	}
	return false
}

// Per-host override grouping of uplink interfaces for this bond.
type ClusterVswitchConfig_UplinkHostOverride struct {
	// host uuid this override is for.
	HostUuid []byte `protobuf:"bytes,1,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// List of uplink ethernet interfaces (e.g., ["eth0", "eth1"]
	UplinkList           []string `protobuf:"bytes,2,rep,name=uplink_list,json=uplinkList" json:"uplink_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterVswitchConfig_UplinkHostOverride) Reset() {
	*m = ClusterVswitchConfig_UplinkHostOverride{}
}
func (m *ClusterVswitchConfig_UplinkHostOverride) String() string { return proto.CompactTextString(m) }
func (*ClusterVswitchConfig_UplinkHostOverride) ProtoMessage()    {}
func (*ClusterVswitchConfig_UplinkHostOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{104, 1}
}

func (m *ClusterVswitchConfig_UplinkHostOverride) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClusterVswitchConfig_UplinkHostOverride.Unmarshal(m, b)
}
func (m *ClusterVswitchConfig_UplinkHostOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClusterVswitchConfig_UplinkHostOverride.Marshal(b, m, deterministic)
}
func (m *ClusterVswitchConfig_UplinkHostOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterVswitchConfig_UplinkHostOverride.Merge(m, src)
}
func (m *ClusterVswitchConfig_UplinkHostOverride) XXX_Size() int {
	return xxx_messageInfo_ClusterVswitchConfig_UplinkHostOverride.Size(m)
}
func (m *ClusterVswitchConfig_UplinkHostOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterVswitchConfig_UplinkHostOverride.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterVswitchConfig_UplinkHostOverride proto.InternalMessageInfo

func (m *ClusterVswitchConfig_UplinkHostOverride) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *ClusterVswitchConfig_UplinkHostOverride) GetUplinkList() []string {
	if m != nil {
		return m.UplinkList
	}
	return nil
}

type AcropolisAtlasConfig struct {
	// Logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,1,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Whether to enable atlas networking integration.
	EnableAtlasNetworking *bool `protobuf:"varint,2,opt,name=enable_atlas_networking,json=enableAtlasNetworking" json:"enable_atlas_networking,omitempty"`
	// OVN remote address. This is provided to the ovn-controller agent running
	// on AHV, and usually refers to the network address of an OVN southbound
	// OVSDB instance. Represented as either tcp:<host>:<port> or
	// ssl:<host>:<port>, depending on whether SSL is in use.
	OvnRemoteAddress *string `protobuf:"bytes,3,opt,name=ovn_remote_address,json=ovnRemoteAddress" json:"ovn_remote_address,omitempty"`
	// Path to private key on the CVM.
	OvnPrivkeyPath *string `protobuf:"bytes,4,opt,name=ovn_privkey_path,json=ovnPrivkeyPath" json:"ovn_privkey_path,omitempty"`
	// Path to public key certificate on the CVM.
	OvnCertificatePath *string `protobuf:"bytes,5,opt,name=ovn_certificate_path,json=ovnCertificatePath" json:"ovn_certificate_path,omitempty"`
	// Path to CA certificate to be used to verify the SSL peer certificate
	OvnCacertPath *string `protobuf:"bytes,6,opt,name=ovn_cacert_path,json=ovnCacertPath" json:"ovn_cacert_path,omitempty"`
	// Domain name servers used by ovn-controller to resolve the name of the OVN
	// southbound OVSDB service defined in the ovn_remote_address field.
	AncDomainNameServerList []string `protobuf:"bytes,7,rep,name=anc_domain_name_server_list,json=ancDomainNameServerList" json:"anc_domain_name_server_list,omitempty"`
	// Minimum AHV version that the ANC supports.
	MinimumAhvVersion    *string  `protobuf:"bytes,8,opt,name=minimum_ahv_version,json=minimumAhvVersion" json:"minimum_ahv_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcropolisAtlasConfig) Reset()         { *m = AcropolisAtlasConfig{} }
func (m *AcropolisAtlasConfig) String() string { return proto.CompactTextString(m) }
func (*AcropolisAtlasConfig) ProtoMessage()    {}
func (*AcropolisAtlasConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{105}
}

func (m *AcropolisAtlasConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AcropolisAtlasConfig.Unmarshal(m, b)
}
func (m *AcropolisAtlasConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AcropolisAtlasConfig.Marshal(b, m, deterministic)
}
func (m *AcropolisAtlasConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcropolisAtlasConfig.Merge(m, src)
}
func (m *AcropolisAtlasConfig) XXX_Size() int {
	return xxx_messageInfo_AcropolisAtlasConfig.Size(m)
}
func (m *AcropolisAtlasConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AcropolisAtlasConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AcropolisAtlasConfig proto.InternalMessageInfo

const Default_AcropolisAtlasConfig_LogicalTimestamp int64 = -1

func (m *AcropolisAtlasConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_AcropolisAtlasConfig_LogicalTimestamp
}

func (m *AcropolisAtlasConfig) GetEnableAtlasNetworking() bool {
	if m != nil && m.EnableAtlasNetworking != nil {
		return *m.EnableAtlasNetworking
	}
	return false
}

func (m *AcropolisAtlasConfig) GetOvnRemoteAddress() string {
	if m != nil && m.OvnRemoteAddress != nil {
		return *m.OvnRemoteAddress
	}
	return ""
}

func (m *AcropolisAtlasConfig) GetOvnPrivkeyPath() string {
	if m != nil && m.OvnPrivkeyPath != nil {
		return *m.OvnPrivkeyPath
	}
	return ""
}

func (m *AcropolisAtlasConfig) GetOvnCertificatePath() string {
	if m != nil && m.OvnCertificatePath != nil {
		return *m.OvnCertificatePath
	}
	return ""
}

func (m *AcropolisAtlasConfig) GetOvnCacertPath() string {
	if m != nil && m.OvnCacertPath != nil {
		return *m.OvnCacertPath
	}
	return ""
}

func (m *AcropolisAtlasConfig) GetAncDomainNameServerList() []string {
	if m != nil {
		return m.AncDomainNameServerList
	}
	return nil
}

func (m *AcropolisAtlasConfig) GetMinimumAhvVersion() string {
	if m != nil && m.MinimumAhvVersion != nil {
		return *m.MinimumAhvVersion
	}
	return ""
}

type MicrosegSecurityMonitoringConfigSpec struct {
	// Whether security monitoring should be enabled or disabled.
	Enable *bool `protobuf:"varint,1,opt,name=enable,def=1" json:"enable,omitempty"`
	// IP address of the collector.
	DataCollectorIpAddress *string `protobuf:"bytes,2,opt,name=data_collector_ip_address,json=dataCollectorIpAddress" json:"data_collector_ip_address,omitempty"`
	// Port number of the collector.
	DataCollectorPortNumber *int32 `protobuf:"varint,3,opt,name=data_collector_port_number,json=dataCollectorPortNumber" json:"data_collector_port_number,omitempty"`
	// IP Protocol used by the collector.
	DataCollectorProtocol *string  `protobuf:"bytes,4,opt,name=data_collector_protocol,json=dataCollectorProtocol,def=tcp" json:"data_collector_protocol,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *MicrosegSecurityMonitoringConfigSpec) Reset()         { *m = MicrosegSecurityMonitoringConfigSpec{} }
func (m *MicrosegSecurityMonitoringConfigSpec) String() string { return proto.CompactTextString(m) }
func (*MicrosegSecurityMonitoringConfigSpec) ProtoMessage()    {}
func (*MicrosegSecurityMonitoringConfigSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{106}
}

func (m *MicrosegSecurityMonitoringConfigSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MicrosegSecurityMonitoringConfigSpec.Unmarshal(m, b)
}
func (m *MicrosegSecurityMonitoringConfigSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MicrosegSecurityMonitoringConfigSpec.Marshal(b, m, deterministic)
}
func (m *MicrosegSecurityMonitoringConfigSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MicrosegSecurityMonitoringConfigSpec.Merge(m, src)
}
func (m *MicrosegSecurityMonitoringConfigSpec) XXX_Size() int {
	return xxx_messageInfo_MicrosegSecurityMonitoringConfigSpec.Size(m)
}
func (m *MicrosegSecurityMonitoringConfigSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_MicrosegSecurityMonitoringConfigSpec.DiscardUnknown(m)
}

var xxx_messageInfo_MicrosegSecurityMonitoringConfigSpec proto.InternalMessageInfo

const Default_MicrosegSecurityMonitoringConfigSpec_Enable bool = true
const Default_MicrosegSecurityMonitoringConfigSpec_DataCollectorProtocol string = "tcp"

func (m *MicrosegSecurityMonitoringConfigSpec) GetEnable() bool {
	if m != nil && m.Enable != nil {
		return *m.Enable
	}
	return Default_MicrosegSecurityMonitoringConfigSpec_Enable
}

func (m *MicrosegSecurityMonitoringConfigSpec) GetDataCollectorIpAddress() string {
	if m != nil && m.DataCollectorIpAddress != nil {
		return *m.DataCollectorIpAddress
	}
	return ""
}

func (m *MicrosegSecurityMonitoringConfigSpec) GetDataCollectorPortNumber() int32 {
	if m != nil && m.DataCollectorPortNumber != nil {
		return *m.DataCollectorPortNumber
	}
	return 0
}

func (m *MicrosegSecurityMonitoringConfigSpec) GetDataCollectorProtocol() string {
	if m != nil && m.DataCollectorProtocol != nil {
		return *m.DataCollectorProtocol
	}
	return Default_MicrosegSecurityMonitoringConfigSpec_DataCollectorProtocol
}

//-----------------------------------------------------------------------------
// VM cross cluster live migration precheck results.
type CrossClusterLiveMigratePrecheckResult struct {
	// The precheck status.
	Status *CrossClusterLiveMigratePrecheckResult_PrecheckStatus `protobuf:"varint,1,opt,name=status,enum=nutanix.acropolis.CrossClusterLiveMigratePrecheckResult_PrecheckStatus" json:"status,omitempty"`
	// The details regarding a precheck status.
	StatusDetail         *string  `protobuf:"bytes,2,opt,name=status_detail,json=statusDetail" json:"status_detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CrossClusterLiveMigratePrecheckResult) Reset()         { *m = CrossClusterLiveMigratePrecheckResult{} }
func (m *CrossClusterLiveMigratePrecheckResult) String() string { return proto.CompactTextString(m) }
func (*CrossClusterLiveMigratePrecheckResult) ProtoMessage()    {}
func (*CrossClusterLiveMigratePrecheckResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{107}
}

func (m *CrossClusterLiveMigratePrecheckResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CrossClusterLiveMigratePrecheckResult.Unmarshal(m, b)
}
func (m *CrossClusterLiveMigratePrecheckResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CrossClusterLiveMigratePrecheckResult.Marshal(b, m, deterministic)
}
func (m *CrossClusterLiveMigratePrecheckResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossClusterLiveMigratePrecheckResult.Merge(m, src)
}
func (m *CrossClusterLiveMigratePrecheckResult) XXX_Size() int {
	return xxx_messageInfo_CrossClusterLiveMigratePrecheckResult.Size(m)
}
func (m *CrossClusterLiveMigratePrecheckResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossClusterLiveMigratePrecheckResult.DiscardUnknown(m)
}

var xxx_messageInfo_CrossClusterLiveMigratePrecheckResult proto.InternalMessageInfo

func (m *CrossClusterLiveMigratePrecheckResult) GetStatus() CrossClusterLiveMigratePrecheckResult_PrecheckStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return CrossClusterLiveMigratePrecheckResult_kOk
}

func (m *CrossClusterLiveMigratePrecheckResult) GetStatusDetail() string {
	if m != nil && m.StatusDetail != nil {
		return *m.StatusDetail
	}
	return ""
}

//-----------------------------------------------------------------------------
// This specifies the incarnation IDs for IDF entities related to a VM. One use
// case for this structure is for live VM migration from one cluster to another.
// All VM related IDF entities will retain the same entity UUIDs, and the
// destination cluster needs to have AttachEntity() invoked to take ownership
// of all those VM related IDF entities.
type VmIncarnation struct {
	// VM incarnation ID.
	VmIncarnationId *uint64 `protobuf:"varint,1,opt,name=vm_incarnation_id,json=vmIncarnationId" json:"vm_incarnation_id,omitempty"`
	// A list of VM disk incarnation IDs.
	DiskIncarnations []*VmIncarnation_DiskIncarnation `protobuf:"bytes,2,rep,name=disk_incarnations,json=diskIncarnations" json:"disk_incarnations,omitempty"`
	// A list of VM NIC incarnation IDs.
	NicIncarnations      []*VmIncarnation_NicIncarnation `protobuf:"bytes,3,rep,name=nic_incarnations,json=nicIncarnations" json:"nic_incarnations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *VmIncarnation) Reset()         { *m = VmIncarnation{} }
func (m *VmIncarnation) String() string { return proto.CompactTextString(m) }
func (*VmIncarnation) ProtoMessage()    {}
func (*VmIncarnation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{108}
}

func (m *VmIncarnation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmIncarnation.Unmarshal(m, b)
}
func (m *VmIncarnation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmIncarnation.Marshal(b, m, deterministic)
}
func (m *VmIncarnation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmIncarnation.Merge(m, src)
}
func (m *VmIncarnation) XXX_Size() int {
	return xxx_messageInfo_VmIncarnation.Size(m)
}
func (m *VmIncarnation) XXX_DiscardUnknown() {
	xxx_messageInfo_VmIncarnation.DiscardUnknown(m)
}

var xxx_messageInfo_VmIncarnation proto.InternalMessageInfo

func (m *VmIncarnation) GetVmIncarnationId() uint64 {
	if m != nil && m.VmIncarnationId != nil {
		return *m.VmIncarnationId
	}
	return 0
}

func (m *VmIncarnation) GetDiskIncarnations() []*VmIncarnation_DiskIncarnation {
	if m != nil {
		return m.DiskIncarnations
	}
	return nil
}

func (m *VmIncarnation) GetNicIncarnations() []*VmIncarnation_NicIncarnation {
	if m != nil {
		return m.NicIncarnations
	}
	return nil
}

type VmIncarnation_DiskIncarnation struct {
	// Identify a VM disk.
	Addr *VmDiskAddr `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// VM disk incarnation ID.
	DiskIncarnationId    *uint64  `protobuf:"varint,2,opt,name=disk_incarnation_id,json=diskIncarnationId" json:"disk_incarnation_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmIncarnation_DiskIncarnation) Reset()         { *m = VmIncarnation_DiskIncarnation{} }
func (m *VmIncarnation_DiskIncarnation) String() string { return proto.CompactTextString(m) }
func (*VmIncarnation_DiskIncarnation) ProtoMessage()    {}
func (*VmIncarnation_DiskIncarnation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{108, 0}
}

func (m *VmIncarnation_DiskIncarnation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmIncarnation_DiskIncarnation.Unmarshal(m, b)
}
func (m *VmIncarnation_DiskIncarnation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmIncarnation_DiskIncarnation.Marshal(b, m, deterministic)
}
func (m *VmIncarnation_DiskIncarnation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmIncarnation_DiskIncarnation.Merge(m, src)
}
func (m *VmIncarnation_DiskIncarnation) XXX_Size() int {
	return xxx_messageInfo_VmIncarnation_DiskIncarnation.Size(m)
}
func (m *VmIncarnation_DiskIncarnation) XXX_DiscardUnknown() {
	xxx_messageInfo_VmIncarnation_DiskIncarnation.DiscardUnknown(m)
}

var xxx_messageInfo_VmIncarnation_DiskIncarnation proto.InternalMessageInfo

func (m *VmIncarnation_DiskIncarnation) GetAddr() *VmDiskAddr {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *VmIncarnation_DiskIncarnation) GetDiskIncarnationId() uint64 {
	if m != nil && m.DiskIncarnationId != nil {
		return *m.DiskIncarnationId
	}
	return 0
}

type VmIncarnation_NicIncarnation struct {
	// Identify a VM NIC.
	MacAddr []byte `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// VM NIC incarnation ID.
	NicIncarnationId     *uint64  `protobuf:"varint,2,opt,name=nic_incarnation_id,json=nicIncarnationId" json:"nic_incarnation_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmIncarnation_NicIncarnation) Reset()         { *m = VmIncarnation_NicIncarnation{} }
func (m *VmIncarnation_NicIncarnation) String() string { return proto.CompactTextString(m) }
func (*VmIncarnation_NicIncarnation) ProtoMessage()    {}
func (*VmIncarnation_NicIncarnation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{108, 1}
}

func (m *VmIncarnation_NicIncarnation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmIncarnation_NicIncarnation.Unmarshal(m, b)
}
func (m *VmIncarnation_NicIncarnation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmIncarnation_NicIncarnation.Marshal(b, m, deterministic)
}
func (m *VmIncarnation_NicIncarnation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmIncarnation_NicIncarnation.Merge(m, src)
}
func (m *VmIncarnation_NicIncarnation) XXX_Size() int {
	return xxx_messageInfo_VmIncarnation_NicIncarnation.Size(m)
}
func (m *VmIncarnation_NicIncarnation) XXX_DiscardUnknown() {
	xxx_messageInfo_VmIncarnation_NicIncarnation.DiscardUnknown(m)
}

var xxx_messageInfo_VmIncarnation_NicIncarnation proto.InternalMessageInfo

func (m *VmIncarnation_NicIncarnation) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *VmIncarnation_NicIncarnation) GetNicIncarnationId() uint64 {
	if m != nil && m.NicIncarnationId != nil {
		return *m.NicIncarnationId
	}
	return 0
}

type DistributedVirtualSwitch struct {
	// UUID of the distributed virtual switch
	VswitchUuid []byte `protobuf:"bytes,1,opt,name=vswitch_uuid,json=vswitchUuid" json:"vswitch_uuid,omitempty"`
	// Name of the distributed virtual switch. This should be unique.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Description of the distributed virtual switch.
	Description *string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Whether this is default DVS, which can not be deleted.
	Default *bool `protobuf:"varint,4,opt,name=default" json:"default,omitempty"`
	// MTU
	Mtu *int64 `protobuf:"varint,5,opt,name=mtu" json:"mtu,omitempty"`
	// Nic teaming policy set on the bond (bond mode).
	NicTeamPolicy *DistributedVirtualSwitch_NicTeamPolicy `protobuf:"varint,6,opt,name=nic_team_policy,json=nicTeamPolicy,enum=nutanix.acropolis.DistributedVirtualSwitch_NicTeamPolicy" json:"nic_team_policy,omitempty"`
	// Lacp configuration.
	LacpConfig *DistributedVirtualSwitch_LacpConfig `protobuf:"bytes,7,opt,name=lacp_config,json=lacpConfig" json:"lacp_config,omitempty"`
	// List of cluster configuration
	ClusterConfigurationList []*DistributedVirtualSwitch_ClusterConfig `protobuf:"bytes,8,rep,name=cluster_configuration_list,json=clusterConfigurationList" json:"cluster_configuration_list,omitempty"`
	// Flag to indicate if update is done partially.
	PartiallyDone *bool `protobuf:"varint,9,opt,name=partially_done,json=partiallyDone" json:"partially_done,omitempty"`
	// Flag to indicate if storage-only nodes are excluded from this DVS
	ExcludeStorageOnlyNode *bool `protobuf:"varint,10,opt,name=exclude_storage_only_node,json=excludeStorageOnlyNode" json:"exclude_storage_only_node,omitempty"`
	// UUID string of the distributed virtual switch
	UuidHex              *string  `protobuf:"bytes,11,opt,name=uuid_hex,json=uuidHex" json:"uuid_hex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DistributedVirtualSwitch) Reset()         { *m = DistributedVirtualSwitch{} }
func (m *DistributedVirtualSwitch) String() string { return proto.CompactTextString(m) }
func (*DistributedVirtualSwitch) ProtoMessage()    {}
func (*DistributedVirtualSwitch) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109}
}

func (m *DistributedVirtualSwitch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DistributedVirtualSwitch.Unmarshal(m, b)
}
func (m *DistributedVirtualSwitch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DistributedVirtualSwitch.Marshal(b, m, deterministic)
}
func (m *DistributedVirtualSwitch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributedVirtualSwitch.Merge(m, src)
}
func (m *DistributedVirtualSwitch) XXX_Size() int {
	return xxx_messageInfo_DistributedVirtualSwitch.Size(m)
}
func (m *DistributedVirtualSwitch) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributedVirtualSwitch.DiscardUnknown(m)
}

var xxx_messageInfo_DistributedVirtualSwitch proto.InternalMessageInfo

func (m *DistributedVirtualSwitch) GetVswitchUuid() []byte {
	if m != nil {
		return m.VswitchUuid
	}
	return nil
}

func (m *DistributedVirtualSwitch) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DistributedVirtualSwitch) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *DistributedVirtualSwitch) GetDefault() bool {
	if m != nil && m.Default != nil {
		return *m.Default
	}
	return false
}

func (m *DistributedVirtualSwitch) GetMtu() int64 {
	if m != nil && m.Mtu != nil {
		return *m.Mtu
	}
	return 0
}

func (m *DistributedVirtualSwitch) GetNicTeamPolicy() DistributedVirtualSwitch_NicTeamPolicy {
	if m != nil && m.NicTeamPolicy != nil {
		return *m.NicTeamPolicy
	}
	return DistributedVirtualSwitch_kNoBond
}

func (m *DistributedVirtualSwitch) GetLacpConfig() *DistributedVirtualSwitch_LacpConfig {
	if m != nil {
		return m.LacpConfig
	}
	return nil
}

func (m *DistributedVirtualSwitch) GetClusterConfigurationList() []*DistributedVirtualSwitch_ClusterConfig {
	if m != nil {
		return m.ClusterConfigurationList
	}
	return nil
}

func (m *DistributedVirtualSwitch) GetPartiallyDone() bool {
	if m != nil && m.PartiallyDone != nil {
		return *m.PartiallyDone
	}
	return false
}

func (m *DistributedVirtualSwitch) GetExcludeStorageOnlyNode() bool {
	if m != nil && m.ExcludeStorageOnlyNode != nil {
		return *m.ExcludeStorageOnlyNode
	}
	return false
}

func (m *DistributedVirtualSwitch) GetUuidHex() string {
	if m != nil && m.UuidHex != nil {
		return *m.UuidHex
	}
	return ""
}

// Lacp configuration applicable to the bond.
type DistributedVirtualSwitch_LacpConfig struct {
	// Whether to enable LACP on the bond.
	Lacp *bool `protobuf:"varint,1,opt,name=lacp" json:"lacp,omitempty"`
	// Lacp timeout value.
	LacpTimeout *DistributedVirtualSwitch_LacpConfig_LacpTimeout `protobuf:"varint,2,opt,name=lacp_timeout,json=lacpTimeout,enum=nutanix.acropolis.DistributedVirtualSwitch_LacpConfig_LacpTimeout" json:"lacp_timeout,omitempty"`
	// Whether to enable LACP fall back to active-backup on LACP negotiation
	// failure.
	LacpFallback         *bool    `protobuf:"varint,3,opt,name=lacp_fallback,json=lacpFallback" json:"lacp_fallback,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DistributedVirtualSwitch_LacpConfig) Reset()         { *m = DistributedVirtualSwitch_LacpConfig{} }
func (m *DistributedVirtualSwitch_LacpConfig) String() string { return proto.CompactTextString(m) }
func (*DistributedVirtualSwitch_LacpConfig) ProtoMessage()    {}
func (*DistributedVirtualSwitch_LacpConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109, 0}
}

func (m *DistributedVirtualSwitch_LacpConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DistributedVirtualSwitch_LacpConfig.Unmarshal(m, b)
}
func (m *DistributedVirtualSwitch_LacpConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DistributedVirtualSwitch_LacpConfig.Marshal(b, m, deterministic)
}
func (m *DistributedVirtualSwitch_LacpConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributedVirtualSwitch_LacpConfig.Merge(m, src)
}
func (m *DistributedVirtualSwitch_LacpConfig) XXX_Size() int {
	return xxx_messageInfo_DistributedVirtualSwitch_LacpConfig.Size(m)
}
func (m *DistributedVirtualSwitch_LacpConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributedVirtualSwitch_LacpConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DistributedVirtualSwitch_LacpConfig proto.InternalMessageInfo

func (m *DistributedVirtualSwitch_LacpConfig) GetLacp() bool {
	if m != nil && m.Lacp != nil {
		return *m.Lacp
	}
	return false
}

func (m *DistributedVirtualSwitch_LacpConfig) GetLacpTimeout() DistributedVirtualSwitch_LacpConfig_LacpTimeout {
	if m != nil && m.LacpTimeout != nil {
		return *m.LacpTimeout
	}
	return DistributedVirtualSwitch_LacpConfig_kFast
}

func (m *DistributedVirtualSwitch_LacpConfig) GetLacpFallback() bool {
	if m != nil && m.LacpFallback != nil {
		return *m.LacpFallback
	}
	return false
}

// Definition of cluster configuration.
type DistributedVirtualSwitch_ClusterConfig struct {
	// Cluster uuid.
	ClusterUuid           *string                                                    `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	DefaultUplinkGrouping *DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType `protobuf:"varint,2,opt,name=default_uplink_grouping,json=defaultUplinkGrouping,enum=nutanix.acropolis.DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType" json:"default_uplink_grouping,omitempty"`
	// List of host configuration.
	HostConfigurationList []*DistributedVirtualSwitch_ClusterConfig_HostConfig `protobuf:"bytes,3,rep,name=host_configuration_list,json=hostConfigurationList" json:"host_configuration_list,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                             `json:"-"`
	XXX_unrecognized      []byte                                               `json:"-"`
	XXX_sizecache         int32                                                `json:"-"`
}

func (m *DistributedVirtualSwitch_ClusterConfig) Reset() {
	*m = DistributedVirtualSwitch_ClusterConfig{}
}
func (m *DistributedVirtualSwitch_ClusterConfig) String() string { return proto.CompactTextString(m) }
func (*DistributedVirtualSwitch_ClusterConfig) ProtoMessage()    {}
func (*DistributedVirtualSwitch_ClusterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109, 1}
}

func (m *DistributedVirtualSwitch_ClusterConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig.Unmarshal(m, b)
}
func (m *DistributedVirtualSwitch_ClusterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig.Marshal(b, m, deterministic)
}
func (m *DistributedVirtualSwitch_ClusterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig.Merge(m, src)
}
func (m *DistributedVirtualSwitch_ClusterConfig) XXX_Size() int {
	return xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig.Size(m)
}
func (m *DistributedVirtualSwitch_ClusterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig proto.InternalMessageInfo

func (m *DistributedVirtualSwitch_ClusterConfig) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *DistributedVirtualSwitch_ClusterConfig) GetDefaultUplinkGrouping() DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType {
	if m != nil && m.DefaultUplinkGrouping != nil {
		return *m.DefaultUplinkGrouping
	}
	return DistributedVirtualSwitch_ClusterConfig_kMixed
}

func (m *DistributedVirtualSwitch_ClusterConfig) GetHostConfigurationList() []*DistributedVirtualSwitch_ClusterConfig_HostConfig {
	if m != nil {
		return m.HostConfigurationList
	}
	return nil
}

// Definition of host configuration.
type DistributedVirtualSwitch_ClusterConfig_HostConfig struct {
	// Host uuid.
	HostUuid *string `protobuf:"bytes,1,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// Internal bridge name (br0, br1, etc).
	InternalBridge *string `protobuf:"bytes,2,opt,name=internal_bridge,json=internalBridge" json:"internal_bridge,omitempty"`
	// List of uplink ethernet interfaces (e.g., ["eth0", "eth1"]
	UplinkList []string `protobuf:"bytes,3,rep,name=uplink_list,json=uplinkList" json:"uplink_list,omitempty"`
	// Whether VS deployment failed on this host, default is false
	ConfigFailed         *bool    `protobuf:"varint,4,opt,name=config_failed,json=configFailed" json:"config_failed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) Reset() {
	*m = DistributedVirtualSwitch_ClusterConfig_HostConfig{}
}
func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) String() string {
	return proto.CompactTextString(m)
}
func (*DistributedVirtualSwitch_ClusterConfig_HostConfig) ProtoMessage() {}
func (*DistributedVirtualSwitch_ClusterConfig_HostConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{109, 1, 0}
}

func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig_HostConfig.Unmarshal(m, b)
}
func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig_HostConfig.Marshal(b, m, deterministic)
}
func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig_HostConfig.Merge(m, src)
}
func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) XXX_Size() int {
	return xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig_HostConfig.Size(m)
}
func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig_HostConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DistributedVirtualSwitch_ClusterConfig_HostConfig proto.InternalMessageInfo

func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) GetHostUuid() string {
	if m != nil && m.HostUuid != nil {
		return *m.HostUuid
	}
	return ""
}

func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) GetInternalBridge() string {
	if m != nil && m.InternalBridge != nil {
		return *m.InternalBridge
	}
	return ""
}

func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) GetUplinkList() []string {
	if m != nil {
		return m.UplinkList
	}
	return nil
}

func (m *DistributedVirtualSwitch_ClusterConfig_HostConfig) GetConfigFailed() bool {
	if m != nil && m.ConfigFailed != nil {
		return *m.ConfigFailed
	}
	return false
}

type VmChangeDiskContainerSpec struct {
	// Device UUID
	DeviceUuid []byte `protobuf:"bytes,1,opt,name=device_uuid,json=deviceUuid" json:"device_uuid,omitempty"`
	// Target container uuid
	TgtCtrUuid           []byte   `protobuf:"bytes,2,opt,name=tgt_ctr_uuid,json=tgtCtrUuid" json:"tgt_ctr_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmChangeDiskContainerSpec) Reset()         { *m = VmChangeDiskContainerSpec{} }
func (m *VmChangeDiskContainerSpec) String() string { return proto.CompactTextString(m) }
func (*VmChangeDiskContainerSpec) ProtoMessage()    {}
func (*VmChangeDiskContainerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{110}
}

func (m *VmChangeDiskContainerSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmChangeDiskContainerSpec.Unmarshal(m, b)
}
func (m *VmChangeDiskContainerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmChangeDiskContainerSpec.Marshal(b, m, deterministic)
}
func (m *VmChangeDiskContainerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmChangeDiskContainerSpec.Merge(m, src)
}
func (m *VmChangeDiskContainerSpec) XXX_Size() int {
	return xxx_messageInfo_VmChangeDiskContainerSpec.Size(m)
}
func (m *VmChangeDiskContainerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_VmChangeDiskContainerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_VmChangeDiskContainerSpec proto.InternalMessageInfo

func (m *VmChangeDiskContainerSpec) GetDeviceUuid() []byte {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *VmChangeDiskContainerSpec) GetTgtCtrUuid() []byte {
	if m != nil {
		return m.TgtCtrUuid
	}
	return nil
}

type VpnLbRouteConfig struct {
	// List of RouteConfig instances that might exist due to
	// 1. A gateway possibly in same subnet as PC as well as PE
	// 2. In future, on-prem might pair with multiple AZs
	//    resulting in a VPN gateway forwarding to different
	//    LB prefixes.
	LbRouteConfigList []*VpnLbRouteConfig_RouteConfig `protobuf:"bytes,1,rep,name=lb_route_config_list,json=lbRouteConfigList" json:"lb_route_config_list,omitempty"`
	// The logical timestamp of the LB Route configuration.
	LogicalTimestamp     *int64   `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VpnLbRouteConfig) Reset()         { *m = VpnLbRouteConfig{} }
func (m *VpnLbRouteConfig) String() string { return proto.CompactTextString(m) }
func (*VpnLbRouteConfig) ProtoMessage()    {}
func (*VpnLbRouteConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{111}
}

func (m *VpnLbRouteConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VpnLbRouteConfig.Unmarshal(m, b)
}
func (m *VpnLbRouteConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VpnLbRouteConfig.Marshal(b, m, deterministic)
}
func (m *VpnLbRouteConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VpnLbRouteConfig.Merge(m, src)
}
func (m *VpnLbRouteConfig) XXX_Size() int {
	return xxx_messageInfo_VpnLbRouteConfig.Size(m)
}
func (m *VpnLbRouteConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VpnLbRouteConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VpnLbRouteConfig proto.InternalMessageInfo

func (m *VpnLbRouteConfig) GetLbRouteConfigList() []*VpnLbRouteConfig_RouteConfig {
	if m != nil {
		return m.LbRouteConfigList
	}
	return nil
}

func (m *VpnLbRouteConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

type VpnLbRouteConfig_RouteConfig struct {
	// UUID of the cluster, where this route needs to be applied
	ClusterUuid *string `protobuf:"bytes,1,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// LB prefix indicating an AZ
	// This field has to be in IPv4 address format
	LbPrefix *string `protobuf:"bytes,2,opt,name=lb_prefix,json=lbPrefix" json:"lb_prefix,omitempty"`
	// Subnet of the LB prefix
	LbPrefixLength *int32 `protobuf:"varint,3,opt,name=lb_prefix_length,json=lbPrefixLength" json:"lb_prefix_length,omitempty"`
	// IP address of the nexthop
	// This field has to be in IPv4 address format
	NextHop              *string  `protobuf:"bytes,4,opt,name=next_hop,json=nextHop" json:"next_hop,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VpnLbRouteConfig_RouteConfig) Reset()         { *m = VpnLbRouteConfig_RouteConfig{} }
func (m *VpnLbRouteConfig_RouteConfig) String() string { return proto.CompactTextString(m) }
func (*VpnLbRouteConfig_RouteConfig) ProtoMessage()    {}
func (*VpnLbRouteConfig_RouteConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{111, 0}
}

func (m *VpnLbRouteConfig_RouteConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VpnLbRouteConfig_RouteConfig.Unmarshal(m, b)
}
func (m *VpnLbRouteConfig_RouteConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VpnLbRouteConfig_RouteConfig.Marshal(b, m, deterministic)
}
func (m *VpnLbRouteConfig_RouteConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VpnLbRouteConfig_RouteConfig.Merge(m, src)
}
func (m *VpnLbRouteConfig_RouteConfig) XXX_Size() int {
	return xxx_messageInfo_VpnLbRouteConfig_RouteConfig.Size(m)
}
func (m *VpnLbRouteConfig_RouteConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VpnLbRouteConfig_RouteConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VpnLbRouteConfig_RouteConfig proto.InternalMessageInfo

func (m *VpnLbRouteConfig_RouteConfig) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *VpnLbRouteConfig_RouteConfig) GetLbPrefix() string {
	if m != nil && m.LbPrefix != nil {
		return *m.LbPrefix
	}
	return ""
}

func (m *VpnLbRouteConfig_RouteConfig) GetLbPrefixLength() int32 {
	if m != nil && m.LbPrefixLength != nil {
		return *m.LbPrefixLength
	}
	return 0
}

func (m *VpnLbRouteConfig_RouteConfig) GetNextHop() string {
	if m != nil && m.NextHop != nil {
		return *m.NextHop
	}
	return ""
}

type HostSwapDiskConfig struct {
	// The vmdisk identifier.
	VmdiskUuid []byte `protobuf:"bytes,1,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// The container in which the backing vmdisk is provisioned. This field is
	// unset when the drive is empty.
	ContainerId          *int64   `protobuf:"varint,2,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostSwapDiskConfig) Reset()         { *m = HostSwapDiskConfig{} }
func (m *HostSwapDiskConfig) String() string { return proto.CompactTextString(m) }
func (*HostSwapDiskConfig) ProtoMessage()    {}
func (*HostSwapDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{112}
}

func (m *HostSwapDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostSwapDiskConfig.Unmarshal(m, b)
}
func (m *HostSwapDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostSwapDiskConfig.Marshal(b, m, deterministic)
}
func (m *HostSwapDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostSwapDiskConfig.Merge(m, src)
}
func (m *HostSwapDiskConfig) XXX_Size() int {
	return xxx_messageInfo_HostSwapDiskConfig.Size(m)
}
func (m *HostSwapDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostSwapDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostSwapDiskConfig proto.InternalMessageInfo

func (m *HostSwapDiskConfig) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *HostSwapDiskConfig) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

type HostSwap struct {
	// Host UUID.
	HostUuid []byte `protobuf:"bytes,1,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// List of disks that back the host swap.
	DiskList []*HostSwapDiskConfig `protobuf:"bytes,2,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// Host swap logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,3,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// If True, the host swap entry has been tombstoned.
	Deleted              *bool    `protobuf:"varint,4,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostSwap) Reset()         { *m = HostSwap{} }
func (m *HostSwap) String() string { return proto.CompactTextString(m) }
func (*HostSwap) ProtoMessage()    {}
func (*HostSwap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{113}
}

func (m *HostSwap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostSwap.Unmarshal(m, b)
}
func (m *HostSwap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostSwap.Marshal(b, m, deterministic)
}
func (m *HostSwap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostSwap.Merge(m, src)
}
func (m *HostSwap) XXX_Size() int {
	return xxx_messageInfo_HostSwap.Size(m)
}
func (m *HostSwap) XXX_DiscardUnknown() {
	xxx_messageInfo_HostSwap.DiscardUnknown(m)
}

var xxx_messageInfo_HostSwap proto.InternalMessageInfo

func (m *HostSwap) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *HostSwap) GetDiskList() []*HostSwapDiskConfig {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *HostSwap) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *HostSwap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

//-----------------------------------------------------------------------------
// Message which is persisted to Pithos for host port management for
// live migrations. This value is persisted for every port which has been
// reserved for a cross cluster live migration.
type MigrationPortReservation struct {
	// VM UUID which is migrating.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// UUID of the destination host.
	DestinationHostUuid []byte `protobuf:"bytes,2,opt,name=destination_host_uuid,json=destinationHostUuid" json:"destination_host_uuid,omitempty"`
	// Port on the destination host.
	DestinationHostPort *uint64 `protobuf:"varint,3,opt,name=destination_host_port,json=destinationHostPort" json:"destination_host_port,omitempty"`
	// If True, the entry has been tombstoned.
	Deleted *bool `protobuf:"varint,4,opt,name=deleted" json:"deleted,omitempty"`
	// IP of the source host where VM is currently migrating from. This is
	// needed to open the port in firewall on the destination host.
	SourceHostIp *string `protobuf:"bytes,5,opt,name=source_host_ip,json=sourceHostIp" json:"source_host_ip,omitempty"`
	// If True, the entry should be tombstoned. On encountering errors while
	// modifying iptables, a reserved port is marked to be deleted. These
	// ports are cleaned up during reconciliation and marked deleted. This is
	// done to not fail the task and avoid leaving ports open in the firewall.
	ToBeDeleted          *bool    `protobuf:"varint,6,opt,name=to_be_deleted,json=toBeDeleted" json:"to_be_deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MigrationPortReservation) Reset()         { *m = MigrationPortReservation{} }
func (m *MigrationPortReservation) String() string { return proto.CompactTextString(m) }
func (*MigrationPortReservation) ProtoMessage()    {}
func (*MigrationPortReservation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{114}
}

func (m *MigrationPortReservation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MigrationPortReservation.Unmarshal(m, b)
}
func (m *MigrationPortReservation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MigrationPortReservation.Marshal(b, m, deterministic)
}
func (m *MigrationPortReservation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationPortReservation.Merge(m, src)
}
func (m *MigrationPortReservation) XXX_Size() int {
	return xxx_messageInfo_MigrationPortReservation.Size(m)
}
func (m *MigrationPortReservation) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationPortReservation.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationPortReservation proto.InternalMessageInfo

func (m *MigrationPortReservation) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *MigrationPortReservation) GetDestinationHostUuid() []byte {
	if m != nil {
		return m.DestinationHostUuid
	}
	return nil
}

func (m *MigrationPortReservation) GetDestinationHostPort() uint64 {
	if m != nil && m.DestinationHostPort != nil {
		return *m.DestinationHostPort
	}
	return 0
}

func (m *MigrationPortReservation) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *MigrationPortReservation) GetSourceHostIp() string {
	if m != nil && m.SourceHostIp != nil {
		return *m.SourceHostIp
	}
	return ""
}

func (m *MigrationPortReservation) GetToBeDeleted() bool {
	if m != nil && m.ToBeDeleted != nil {
		return *m.ToBeDeleted
	}
	return false
}

//-----------------------------------------------------------------------------
// Message which is persisted to Pithos for managing iptable rules for
// destination ports on the source host for live migrations. This value is
// persisted for every port which has been reserved on the destination side for
// a cross cluster live migration. This entry is persisted only when
// acropolis_cclm_tso_bug_workaround gflag is set and the cleanup of the
// iptable rule at the end of the task failed due to host disconnection.
type MigrationSourceIptableRecord struct {
	// VM UUID which is migrating.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// UUID of the source host where the iptable rule will be added.
	SourceHostUuid []byte `protobuf:"bytes,2,opt,name=source_host_uuid,json=sourceHostUuid" json:"source_host_uuid,omitempty"`
	// Port on the destination host which is sending the ACK/SACK packets.
	DestinationHostPort *uint64 `protobuf:"varint,3,opt,name=destination_host_port,json=destinationHostPort" json:"destination_host_port,omitempty"`
	// IP of the destination host where VM is currently migrating to.
	DestinationHostIp *string `protobuf:"bytes,4,opt,name=destination_host_ip,json=destinationHostIp" json:"destination_host_ip,omitempty"`
	// If True, the entry has been tombstoned.
	Deleted              *bool    `protobuf:"varint,5,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MigrationSourceIptableRecord) Reset()         { *m = MigrationSourceIptableRecord{} }
func (m *MigrationSourceIptableRecord) String() string { return proto.CompactTextString(m) }
func (*MigrationSourceIptableRecord) ProtoMessage()    {}
func (*MigrationSourceIptableRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{115}
}

func (m *MigrationSourceIptableRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MigrationSourceIptableRecord.Unmarshal(m, b)
}
func (m *MigrationSourceIptableRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MigrationSourceIptableRecord.Marshal(b, m, deterministic)
}
func (m *MigrationSourceIptableRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationSourceIptableRecord.Merge(m, src)
}
func (m *MigrationSourceIptableRecord) XXX_Size() int {
	return xxx_messageInfo_MigrationSourceIptableRecord.Size(m)
}
func (m *MigrationSourceIptableRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationSourceIptableRecord.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationSourceIptableRecord proto.InternalMessageInfo

func (m *MigrationSourceIptableRecord) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *MigrationSourceIptableRecord) GetSourceHostUuid() []byte {
	if m != nil {
		return m.SourceHostUuid
	}
	return nil
}

func (m *MigrationSourceIptableRecord) GetDestinationHostPort() uint64 {
	if m != nil && m.DestinationHostPort != nil {
		return *m.DestinationHostPort
	}
	return 0
}

func (m *MigrationSourceIptableRecord) GetDestinationHostIp() string {
	if m != nil && m.DestinationHostIp != nil {
		return *m.DestinationHostIp
	}
	return ""
}

func (m *MigrationSourceIptableRecord) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

//-----------------------------------------------------------------------------
// Message which is persisted to Pithos for cleanup of host SSH keys pertaining
// to live migrations. This value is persisted only if the cleanup of any SSH
// key fails due to host connectivity issues.
type MigrationSSHKeyRecord struct {
	// UUID of the VM which is migrating.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// UUID of the host where the the SSH key is present.
	HostUuid []byte `protobuf:"bytes,2,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// If True, the entry has been tombstoned.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MigrationSSHKeyRecord) Reset()         { *m = MigrationSSHKeyRecord{} }
func (m *MigrationSSHKeyRecord) String() string { return proto.CompactTextString(m) }
func (*MigrationSSHKeyRecord) ProtoMessage()    {}
func (*MigrationSSHKeyRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{116}
}

func (m *MigrationSSHKeyRecord) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MigrationSSHKeyRecord.Unmarshal(m, b)
}
func (m *MigrationSSHKeyRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MigrationSSHKeyRecord.Marshal(b, m, deterministic)
}
func (m *MigrationSSHKeyRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrationSSHKeyRecord.Merge(m, src)
}
func (m *MigrationSSHKeyRecord) XXX_Size() int {
	return xxx_messageInfo_MigrationSSHKeyRecord.Size(m)
}
func (m *MigrationSSHKeyRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrationSSHKeyRecord.DiscardUnknown(m)
}

var xxx_messageInfo_MigrationSSHKeyRecord proto.InternalMessageInfo

func (m *MigrationSSHKeyRecord) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *MigrationSSHKeyRecord) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *MigrationSSHKeyRecord) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

// Message to list compatible pGpu's sbdfs for a host which can serve as a
// target for a live migration of a VM's vGpu.
type HostGpus struct {
	// UUID of the host.
	HostUuid []byte `protobuf:"bytes,1,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// List of sbdf of pGpus on the given host which are compatible for live
	// migration.
	Sbdf                 []string `protobuf:"bytes,2,rep,name=sbdf" json:"sbdf,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostGpus) Reset()         { *m = HostGpus{} }
func (m *HostGpus) String() string { return proto.CompactTextString(m) }
func (*HostGpus) ProtoMessage()    {}
func (*HostGpus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{117}
}

func (m *HostGpus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostGpus.Unmarshal(m, b)
}
func (m *HostGpus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostGpus.Marshal(b, m, deterministic)
}
func (m *HostGpus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostGpus.Merge(m, src)
}
func (m *HostGpus) XXX_Size() int {
	return xxx_messageInfo_HostGpus.Size(m)
}
func (m *HostGpus) XXX_DiscardUnknown() {
	xxx_messageInfo_HostGpus.DiscardUnknown(m)
}

var xxx_messageInfo_HostGpus proto.InternalMessageInfo

func (m *HostGpus) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *HostGpus) GetSbdf() []string {
	if m != nil {
		return m.Sbdf
	}
	return nil
}

// Message to list compatible host pGpus which can serve as a target for a live
// migration of a VM with vGpus.
type VmCompatibleHostGpus struct {
	// UUID of the VM.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// List of hosts with pGpus which are compatible to a VM.
	HostGpus []*HostGpus `protobuf:"bytes,2,rep,name=host_gpus,json=hostGpus" json:"host_gpus,omitempty"`
	// Whether the VM is managed by Acropolis. Will be set to False if VM is not
	// found when the RPC call is made.
	VmExists             *bool    `protobuf:"varint,3,opt,name=vm_exists,json=vmExists" json:"vm_exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmCompatibleHostGpus) Reset()         { *m = VmCompatibleHostGpus{} }
func (m *VmCompatibleHostGpus) String() string { return proto.CompactTextString(m) }
func (*VmCompatibleHostGpus) ProtoMessage()    {}
func (*VmCompatibleHostGpus) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c689b321cdcad6d, []int{118}
}

func (m *VmCompatibleHostGpus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCompatibleHostGpus.Unmarshal(m, b)
}
func (m *VmCompatibleHostGpus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCompatibleHostGpus.Marshal(b, m, deterministic)
}
func (m *VmCompatibleHostGpus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCompatibleHostGpus.Merge(m, src)
}
func (m *VmCompatibleHostGpus) XXX_Size() int {
	return xxx_messageInfo_VmCompatibleHostGpus.Size(m)
}
func (m *VmCompatibleHostGpus) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCompatibleHostGpus.DiscardUnknown(m)
}

var xxx_messageInfo_VmCompatibleHostGpus proto.InternalMessageInfo

func (m *VmCompatibleHostGpus) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *VmCompatibleHostGpus) GetHostGpus() []*HostGpus {
	if m != nil {
		return m.HostGpus
	}
	return nil
}

func (m *VmCompatibleHostGpus) GetVmExists() bool {
	if m != nil && m.VmExists != nil {
		return *m.VmExists
	}
	return false
}

func init() {
	proto.RegisterEnum("nutanix.acropolis.VmChildEntityType", VmChildEntityType_name, VmChildEntityType_value)
	proto.RegisterEnum("nutanix.acropolis.VmType", VmType_name, VmType_value)
	proto.RegisterEnum("nutanix.acropolis.VmNicVlanType", VmNicVlanType_name, VmNicVlanType_value)
	proto.RegisterEnum("nutanix.acropolis.VmNicType", VmNicType_name, VmNicType_value)
	proto.RegisterEnum("nutanix.acropolis.NetworkFunctionNicType", NetworkFunctionNicType_name, NetworkFunctionNicType_value)
	proto.RegisterEnum("nutanix.acropolis.GPUType", GPUType_name, GPUType_value)
	proto.RegisterEnum("nutanix.acropolis.GPUVendor", GPUVendor_name, GPUVendor_value)
	proto.RegisterEnum("nutanix.acropolis.GPUMode", GPUMode_name, GPUMode_value)
	proto.RegisterEnum("nutanix.acropolis.AssignedMemoryUpdateType", AssignedMemoryUpdateType_name, AssignedMemoryUpdateType_value)
	proto.RegisterEnum("nutanix.acropolis.MicrosegConfigOperation", MicrosegConfigOperation_name, MicrosegConfigOperation_value)
	proto.RegisterEnum("nutanix.acropolis.MicrosegConfigReason", MicrosegConfigReason_name, MicrosegConfigReason_value)
	proto.RegisterEnum("nutanix.acropolis.MicrosegConfigCommand", MicrosegConfigCommand_name, MicrosegConfigCommand_value)
	proto.RegisterEnum("nutanix.acropolis.MicrosegUpdateRequestType", MicrosegUpdateRequestType_name, MicrosegUpdateRequestType_value)
	proto.RegisterEnum("nutanix.acropolis.VolumesVersion", VolumesVersion_name, VolumesVersion_value)
	proto.RegisterEnum("nutanix.acropolis.PowerStateMechanism", PowerStateMechanism_name, PowerStateMechanism_value)
	proto.RegisterEnum("nutanix.acropolis.HypervisorType_Type", HypervisorType_Type_name, HypervisorType_Type_value)
	proto.RegisterEnum("nutanix.acropolis.HostType_Type", HostType_Type_name, HostType_Type_value)
	proto.RegisterEnum("nutanix.acropolis.Task_Entity", Task_Entity_name, Task_Entity_value)
	proto.RegisterEnum("nutanix.acropolis.Task_OperationType", Task_OperationType_name, Task_OperationType_value)
	proto.RegisterEnum("nutanix.acropolis.Task_Status", Task_Status_name, Task_Status_value)
	proto.RegisterEnum("nutanix.acropolis.Task_Capability", Task_Capability_name, Task_Capability_value)
	proto.RegisterEnum("nutanix.acropolis.EnterMaintenanceModeTypes_VmNonMigratableOption", EnterMaintenanceModeTypes_VmNonMigratableOption_name, EnterMaintenanceModeTypes_VmNonMigratableOption_value)
	proto.RegisterEnum("nutanix.acropolis.VmBootDeviceType_Type", VmBootDeviceType_Type_name, VmBootDeviceType_Type_value)
	proto.RegisterEnum("nutanix.acropolis.VmNicConfig_NetworkType", VmNicConfig_NetworkType_name, VmNicConfig_NetworkType_value)
	proto.RegisterEnum("nutanix.acropolis.VmSerialPortConfig_Type", VmSerialPortConfig_Type_name, VmSerialPortConfig_Type_value)
	proto.RegisterEnum("nutanix.acropolis.VmState_State", VmState_State_name, VmState_State_value)
	proto.RegisterEnum("nutanix.acropolis.VmStateTransition_Transition", VmStateTransition_Transition_name, VmStateTransition_Transition_value)
	proto.RegisterEnum("nutanix.acropolis.NetworkConfig_Type", NetworkConfig_Type_name, NetworkConfig_Type_value)
	proto.RegisterEnum("nutanix.acropolis.AddressAssignment_AssignmentType", AddressAssignment_AssignmentType_name, AddressAssignment_AssignmentType_value)
	proto.RegisterEnum("nutanix.acropolis.ImageInfo_ImageType", ImageInfo_ImageType_name, ImageInfo_ImageType_value)
	proto.RegisterEnum("nutanix.acropolis.ImageInfo_ChecksumType", ImageInfo_ChecksumType_name, ImageInfo_ChecksumType_value)
	proto.RegisterEnum("nutanix.acropolis.ImageInfo_ImageState", ImageInfo_ImageState_name, ImageInfo_ImageState_value)
	proto.RegisterEnum("nutanix.acropolis.ImageInfo_ImageArchitecture", ImageInfo_ImageArchitecture_name, ImageInfo_ImageArchitecture_value)
	proto.RegisterEnum("nutanix.acropolis.VolumeGroupCreateSpec_FileSystemType", VolumeGroupCreateSpec_FileSystemType_name, VolumeGroupCreateSpec_FileSystemType_value)
	proto.RegisterEnum("nutanix.acropolis.SchedulerPolicy_Qualifier", SchedulerPolicy_Qualifier_name, SchedulerPolicy_Qualifier_value)
	proto.RegisterEnum("nutanix.acropolis.SchedulerPolicy_Priority", SchedulerPolicy_Priority_name, SchedulerPolicy_Priority_value)
	proto.RegisterEnum("nutanix.acropolis.ParcelConfig_EntityType", ParcelConfig_EntityType_name, ParcelConfig_EntityType_value)
	proto.RegisterEnum("nutanix.acropolis.Affinity_Policy", Affinity_Policy_name, Affinity_Policy_value)
	proto.RegisterEnum("nutanix.acropolis.Affinity_Constraint", Affinity_Constraint_name, Affinity_Constraint_value)
	proto.RegisterEnum("nutanix.acropolis.NetworkFunctionConfig_Type", NetworkFunctionConfig_Type_name, NetworkFunctionConfig_Type_value)
	proto.RegisterEnum("nutanix.acropolis.ClusterVswitchConfig_NicTeamPolicy", ClusterVswitchConfig_NicTeamPolicy_name, ClusterVswitchConfig_NicTeamPolicy_value)
	proto.RegisterEnum("nutanix.acropolis.ClusterVswitchConfig_UplinkGroupingType", ClusterVswitchConfig_UplinkGroupingType_name, ClusterVswitchConfig_UplinkGroupingType_value)
	proto.RegisterEnum("nutanix.acropolis.ClusterVswitchConfig_LacpConfig_LacpTimeout", ClusterVswitchConfig_LacpConfig_LacpTimeout_name, ClusterVswitchConfig_LacpConfig_LacpTimeout_value)
	proto.RegisterEnum("nutanix.acropolis.CrossClusterLiveMigratePrecheckResult_PrecheckStatus", CrossClusterLiveMigratePrecheckResult_PrecheckStatus_name, CrossClusterLiveMigratePrecheckResult_PrecheckStatus_value)
	proto.RegisterEnum("nutanix.acropolis.DistributedVirtualSwitch_NicTeamPolicy", DistributedVirtualSwitch_NicTeamPolicy_name, DistributedVirtualSwitch_NicTeamPolicy_value)
	proto.RegisterEnum("nutanix.acropolis.DistributedVirtualSwitch_LacpConfig_LacpTimeout", DistributedVirtualSwitch_LacpConfig_LacpTimeout_name, DistributedVirtualSwitch_LacpConfig_LacpTimeout_value)
	proto.RegisterEnum("nutanix.acropolis.DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType", DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType_name, DistributedVirtualSwitch_ClusterConfig_UplinkGroupingType_value)
	proto.RegisterType((*GenericDbObjectHeader)(nil), "nutanix.acropolis.GenericDbObjectHeader")
	proto.RegisterType((*TestDbObject)(nil), "nutanix.acropolis.TestDbObject")
	proto.RegisterType((*GenericQueryRequest)(nil), "nutanix.acropolis.GenericQueryRequest")
	proto.RegisterType((*GenericQueryResponse)(nil), "nutanix.acropolis.GenericQueryResponse")
	proto.RegisterType((*HypervisorType)(nil), "nutanix.acropolis.HypervisorType")
	proto.RegisterType((*HostType)(nil), "nutanix.acropolis.HostType")
	proto.RegisterType((*GenericKeyValuePair)(nil), "nutanix.acropolis.GenericKeyValuePair")
	proto.RegisterType((*MetaRequest)(nil), "nutanix.acropolis.MetaRequest")
	proto.RegisterType((*MetaResponse)(nil), "nutanix.acropolis.MetaResponse")
	proto.RegisterType((*PayloadValue)(nil), "nutanix.acropolis.PayloadValue")
	proto.RegisterType((*PayloadOrEmbeddedValue)(nil), "nutanix.acropolis.PayloadOrEmbeddedValue")
	proto.RegisterType((*SnapshotInfo)(nil), "nutanix.acropolis.SnapshotInfo")
	proto.RegisterType((*SnapshotSpec)(nil), "nutanix.acropolis.SnapshotSpec")
	proto.RegisterType((*Task)(nil), "nutanix.acropolis.Task")
	proto.RegisterType((*Task_EntityId)(nil), "nutanix.acropolis.Task.EntityId")
	proto.RegisterType((*EnterMaintenanceModeTypes)(nil), "nutanix.acropolis.EnterMaintenanceModeTypes")
	proto.RegisterType((*VmBootDeviceType)(nil), "nutanix.acropolis.VmBootDeviceType")
	proto.RegisterType((*VmBootConfig)(nil), "nutanix.acropolis.VmBootConfig")
	proto.RegisterType((*VmBootConfig_VmBootDevice)(nil), "nutanix.acropolis.VmBootConfig.VmBootDevice")
	proto.RegisterType((*VmBootConfig_VmFirmwareConfig)(nil), "nutanix.acropolis.VmBootConfig.VmFirmwareConfig")
	proto.RegisterType((*VmBootConfigSpec)(nil), "nutanix.acropolis.VmBootConfigSpec")
	proto.RegisterType((*VmBootConfigSpec_VmBootDeviceSpec)(nil), "nutanix.acropolis.VmBootConfigSpec.VmBootDeviceSpec")
	proto.RegisterType((*VmBootConfigSpec_VmFirmwareConfigSpec)(nil), "nutanix.acropolis.VmBootConfigSpec.VmFirmwareConfigSpec")
	proto.RegisterType((*VmCloneSpec)(nil), "nutanix.acropolis.VmCloneSpec")
	proto.RegisterType((*VmConfig)(nil), "nutanix.acropolis.VmConfig")
	proto.RegisterType((*VmCreateSpec)(nil), "nutanix.acropolis.VmCreateSpec")
	proto.RegisterType((*VmDiskAddr)(nil), "nutanix.acropolis.VmDiskAddr")
	proto.RegisterType((*VmDiskConfig)(nil), "nutanix.acropolis.VmDiskConfig")
	proto.RegisterType((*VmDiskSpec)(nil), "nutanix.acropolis.VmDiskSpec")
	proto.RegisterType((*VmDiskSpecClone)(nil), "nutanix.acropolis.VmDiskSpecClone")
	proto.RegisterType((*VmDiskSpecCreate)(nil), "nutanix.acropolis.VmDiskSpecCreate")
	proto.RegisterType((*VmDiskSpecExisting)(nil), "nutanix.acropolis.VmDiskSpecExisting")
	proto.RegisterType((*VmDiskSpecCloneExternal)(nil), "nutanix.acropolis.VmDiskSpecCloneExternal")
	proto.RegisterType((*VmDiskSpecPassthruExternal)(nil), "nutanix.acropolis.VmDiskSpecPassthruExternal")
	proto.RegisterType((*VmHypervisorInfo)(nil), "nutanix.acropolis.VmHypervisorInfo")
	proto.RegisterType((*VmInfo)(nil), "nutanix.acropolis.VmInfo")
	proto.RegisterType((*VmNicConfig)(nil), "nutanix.acropolis.VmNicConfig")
	proto.RegisterType((*VmNicSpec)(nil), "nutanix.acropolis.VmNicSpec")
	proto.RegisterType((*VmNicUpdateSpec)(nil), "nutanix.acropolis.VmNicUpdateSpec")
	proto.RegisterType((*VmSerialPortConfig)(nil), "nutanix.acropolis.VmSerialPortConfig")
	proto.RegisterType((*VmGPUConfig)(nil), "nutanix.acropolis.VmGPUConfig")
	proto.RegisterType((*NodeGPU)(nil), "nutanix.acropolis.NodeGPU")
	proto.RegisterType((*NetworkMapping)(nil), "nutanix.acropolis.NetworkMapping")
	proto.RegisterType((*NetworkMapping_L2NetworkMapping)(nil), "nutanix.acropolis.NetworkMapping.L2NetworkMapping")
	proto.RegisterType((*NetworkMapping_L3NetworkMapping)(nil), "nutanix.acropolis.NetworkMapping.L3NetworkMapping")
	proto.RegisterType((*NetworkMapping_L3NetworkMapping_AddressMapping)(nil), "nutanix.acropolis.NetworkMapping.L3NetworkMapping.AddressMapping")
	proto.RegisterType((*RecoveryPlanNetworkMappings)(nil), "nutanix.acropolis.RecoveryPlanNetworkMappings")
	proto.RegisterType((*TapDeviceMapping)(nil), "nutanix.acropolis.TapDeviceMapping")
	proto.RegisterType((*VmSyncRepConfig)(nil), "nutanix.acropolis.VmSyncRepConfig")
	proto.RegisterType((*VmState)(nil), "nutanix.acropolis.VmState")
	proto.RegisterType((*VmStateTransition)(nil), "nutanix.acropolis.VmStateTransition")
	proto.RegisterType((*VmSnapshotTreeInfo)(nil), "nutanix.acropolis.VmSnapshotTreeInfo")
	proto.RegisterType((*VmSnapshotTreeInfo_SnapshotLink)(nil), "nutanix.acropolis.VmSnapshotTreeInfo.SnapshotLink")
	proto.RegisterType((*IPConfig)(nil), "nutanix.acropolis.IPConfig")
	proto.RegisterType((*IPConfig_Route)(nil), "nutanix.acropolis.IPConfig.Route")
	proto.RegisterType((*IPConfig_DHCPOption)(nil), "nutanix.acropolis.IPConfig.DHCPOption")
	proto.RegisterType((*IPConfig_IpAddressPool)(nil), "nutanix.acropolis.IPConfig.IpAddressPool")
	proto.RegisterType((*NetworkConfig)(nil), "nutanix.acropolis.NetworkConfig")
	proto.RegisterType((*AddressAssignment)(nil), "nutanix.acropolis.AddressAssignment")
	proto.RegisterType((*NetworkAddressAssignmentTable)(nil), "nutanix.acropolis.NetworkAddressAssignmentTable")
	proto.RegisterType((*NetworkAddressCacheEntry)(nil), "nutanix.acropolis.NetworkAddressCacheEntry")
	proto.RegisterType((*NetworkAddressCacheEntry_IPAddressCacheEntry)(nil), "nutanix.acropolis.NetworkAddressCacheEntry.IPAddressCacheEntry")
	proto.RegisterType((*ImageInfo)(nil), "nutanix.acropolis.ImageInfo")
	proto.RegisterType((*ImageVersion)(nil), "nutanix.acropolis.ImageVersion")
	proto.RegisterType((*ImageSource)(nil), "nutanix.acropolis.ImageSource")
	proto.RegisterType((*ImageImportSpec)(nil), "nutanix.acropolis.ImageImportSpec")
	proto.RegisterType((*ImageCreateSpec)(nil), "nutanix.acropolis.ImageCreateSpec")
	proto.RegisterType((*VolumeDiskCreateSpec)(nil), "nutanix.acropolis.VolumeDiskCreateSpec")
	proto.RegisterType((*IscsiClientSpec)(nil), "nutanix.acropolis.IscsiClientSpec")
	proto.RegisterType((*VolumeGroupCreateSpec)(nil), "nutanix.acropolis.VolumeGroupCreateSpec")
	proto.RegisterType((*VolumeGroupCreateSpec_IscsiClientSpecList)(nil), "nutanix.acropolis.VolumeGroupCreateSpec.IscsiClientSpecList")
	proto.RegisterType((*VolumeGroupCloneSpec)(nil), "nutanix.acropolis.VolumeGroupCloneSpec")
	proto.RegisterType((*HostInfo)(nil), "nutanix.acropolis.HostInfo")
	proto.RegisterType((*HostGpu)(nil), "nutanix.acropolis.HostGpu")
	proto.RegisterType((*HostNic)(nil), "nutanix.acropolis.HostNic")
	proto.RegisterType((*VirtualNetwork)(nil), "nutanix.acropolis.VirtualNetwork")
	proto.RegisterType((*VirtualNetwork_DHCPOption)(nil), "nutanix.acropolis.VirtualNetwork.DHCPOption")
	proto.RegisterType((*VirtualNetwork_IpAddressPool)(nil), "nutanix.acropolis.VirtualNetwork.IpAddressPool")
	proto.RegisterType((*VirtualSwitch)(nil), "nutanix.acropolis.VirtualSwitch")
	proto.RegisterType((*NicTeam)(nil), "nutanix.acropolis.NicTeam")
	proto.RegisterType((*SchedulerNodeInfo)(nil), "nutanix.acropolis.SchedulerNodeInfo")
	proto.RegisterType((*HypervisorVmIdMap)(nil), "nutanix.acropolis.HypervisorVmIdMap")
	proto.RegisterType((*VmUuidMap)(nil), "nutanix.acropolis.VmUuidMap")
	proto.RegisterType((*VirtualDiskUuidMap)(nil), "nutanix.acropolis.VirtualDiskUuidMap")
	proto.RegisterType((*VirtualNicUuidMap)(nil), "nutanix.acropolis.VirtualNicUuidMap")
	proto.RegisterType((*VirtualGpuUuidMap)(nil), "nutanix.acropolis.VirtualGpuUuidMap")
	proto.RegisterType((*VmSnapshotUuidMap)(nil), "nutanix.acropolis.VmSnapshotUuidMap")
	proto.RegisterType((*NodeGpuUuidMap)(nil), "nutanix.acropolis.NodeGpuUuidMap")
	proto.RegisterType((*NodePhysicalNicUuidMap)(nil), "nutanix.acropolis.NodePhysicalNicUuidMap")
	proto.RegisterType((*NodeVirtualNicUuidMap)(nil), "nutanix.acropolis.NodeVirtualNicUuidMap")
	proto.RegisterType((*VirtualNetworkUuidMap)(nil), "nutanix.acropolis.VirtualNetworkUuidMap")
	proto.RegisterType((*VirtualDeviceUuidMap)(nil), "nutanix.acropolis.VirtualDeviceUuidMap")
	proto.RegisterType((*RpcSeqNumber)(nil), "nutanix.acropolis.RpcSeqNumber")
	proto.RegisterType((*UncommittedDisk)(nil), "nutanix.acropolis.UncommittedDisk")
	proto.RegisterType((*SchedulerPolicy)(nil), "nutanix.acropolis.SchedulerPolicy")
	proto.RegisterType((*ParcelConfig)(nil), "nutanix.acropolis.ParcelConfig")
	proto.RegisterType((*ParcelConfig_Entity)(nil), "nutanix.acropolis.ParcelConfig.Entity")
	proto.RegisterType((*Affinity)(nil), "nutanix.acropolis.Affinity")
	proto.RegisterType((*Affinity_LegacyHostAffinity)(nil), "nutanix.acropolis.Affinity.LegacyHostAffinity")
	proto.RegisterType((*ParcelInfo)(nil), "nutanix.acropolis.ParcelInfo")
	proto.RegisterType((*ParcelCreateSpec)(nil), "nutanix.acropolis.ParcelCreateSpec")
	proto.RegisterType((*VGPUMigrateSpec)(nil), "nutanix.acropolis.VGPUMigrateSpec")
	proto.RegisterType((*VGPUBootSpec)(nil), "nutanix.acropolis.VGPUBootSpec")
	proto.RegisterType((*StretchConfig)(nil), "nutanix.acropolis.StretchConfig")
	proto.RegisterType((*VmGroup)(nil), "nutanix.acropolis.VmGroup")
	proto.RegisterType((*EntityAffinitySpec)(nil), "nutanix.acropolis.EntityAffinitySpec")
	proto.RegisterType((*DbKey)(nil), "nutanix.acropolis.DbKey")
	proto.RegisterType((*DbValue)(nil), "nutanix.acropolis.DbValue")
	proto.RegisterType((*DbEntry)(nil), "nutanix.acropolis.DbEntry")
	proto.RegisterType((*NetworkFunctionConfig)(nil), "nutanix.acropolis.NetworkFunctionConfig")
	proto.RegisterType((*NetworkFunctionChainConfig)(nil), "nutanix.acropolis.NetworkFunctionChainConfig")
	proto.RegisterType((*NetworkFunctionChainConfig_VmNicInfo)(nil), "nutanix.acropolis.NetworkFunctionChainConfig.VmNicInfo")
	proto.RegisterType((*SchedulerSegmentAssignmentRecord)(nil), "nutanix.acropolis.SchedulerSegmentAssignmentRecord")
	proto.RegisterType((*SchedulerSegmentAssignmentRecord_PerNodeAssignment)(nil), "nutanix.acropolis.SchedulerSegmentAssignmentRecord.PerNodeAssignment")
	proto.RegisterType((*SchedulerSegmentAssignmentLogicalTimestamp)(nil), "nutanix.acropolis.SchedulerSegmentAssignmentLogicalTimestamp")
	proto.RegisterType((*BatchUpdateErr)(nil), "nutanix.acropolis.BatchUpdateErr")
	proto.RegisterType((*MicrosegCategoryToVmMap)(nil), "nutanix.acropolis.MicrosegCategoryToVmMap")
	proto.RegisterType((*MicrosegMacInfo)(nil), "nutanix.acropolis.MicrosegMacInfo")
	proto.RegisterType((*MicrosegEventMacInfo)(nil), "nutanix.acropolis.MicrosegEventMacInfo")
	proto.RegisterType((*MicrosegVmToIpMap)(nil), "nutanix.acropolis.MicrosegVmToIpMap")
	proto.RegisterType((*MicrosegConfigMetadata)(nil), "nutanix.acropolis.MicrosegConfigMetadata")
	proto.RegisterType((*MicrosegConfig)(nil), "nutanix.acropolis.MicrosegConfig")
	proto.RegisterType((*AcropolisConfig)(nil), "nutanix.acropolis.AcropolisConfig")
	proto.RegisterType((*AcropolisVolumeConfig)(nil), "nutanix.acropolis.AcropolisVolumeConfig")
	proto.RegisterType((*ClusterVswitchConfig)(nil), "nutanix.acropolis.ClusterVswitchConfig")
	proto.RegisterType((*ClusterVswitchConfig_LacpConfig)(nil), "nutanix.acropolis.ClusterVswitchConfig.LacpConfig")
	proto.RegisterType((*ClusterVswitchConfig_UplinkHostOverride)(nil), "nutanix.acropolis.ClusterVswitchConfig.UplinkHostOverride")
	proto.RegisterType((*AcropolisAtlasConfig)(nil), "nutanix.acropolis.AcropolisAtlasConfig")
	proto.RegisterType((*MicrosegSecurityMonitoringConfigSpec)(nil), "nutanix.acropolis.MicrosegSecurityMonitoringConfigSpec")
	proto.RegisterType((*CrossClusterLiveMigratePrecheckResult)(nil), "nutanix.acropolis.CrossClusterLiveMigratePrecheckResult")
	proto.RegisterType((*VmIncarnation)(nil), "nutanix.acropolis.VmIncarnation")
	proto.RegisterType((*VmIncarnation_DiskIncarnation)(nil), "nutanix.acropolis.VmIncarnation.DiskIncarnation")
	proto.RegisterType((*VmIncarnation_NicIncarnation)(nil), "nutanix.acropolis.VmIncarnation.NicIncarnation")
	proto.RegisterType((*DistributedVirtualSwitch)(nil), "nutanix.acropolis.DistributedVirtualSwitch")
	proto.RegisterType((*DistributedVirtualSwitch_LacpConfig)(nil), "nutanix.acropolis.DistributedVirtualSwitch.LacpConfig")
	proto.RegisterType((*DistributedVirtualSwitch_ClusterConfig)(nil), "nutanix.acropolis.DistributedVirtualSwitch.ClusterConfig")
	proto.RegisterType((*DistributedVirtualSwitch_ClusterConfig_HostConfig)(nil), "nutanix.acropolis.DistributedVirtualSwitch.ClusterConfig.HostConfig")
	proto.RegisterType((*VmChangeDiskContainerSpec)(nil), "nutanix.acropolis.VmChangeDiskContainerSpec")
	proto.RegisterType((*VpnLbRouteConfig)(nil), "nutanix.acropolis.VpnLbRouteConfig")
	proto.RegisterType((*VpnLbRouteConfig_RouteConfig)(nil), "nutanix.acropolis.VpnLbRouteConfig.RouteConfig")
	proto.RegisterType((*HostSwapDiskConfig)(nil), "nutanix.acropolis.HostSwapDiskConfig")
	proto.RegisterType((*HostSwap)(nil), "nutanix.acropolis.HostSwap")
	proto.RegisterType((*MigrationPortReservation)(nil), "nutanix.acropolis.MigrationPortReservation")
	proto.RegisterType((*MigrationSourceIptableRecord)(nil), "nutanix.acropolis.MigrationSourceIptableRecord")
	proto.RegisterType((*MigrationSSHKeyRecord)(nil), "nutanix.acropolis.MigrationSSHKeyRecord")
	proto.RegisterType((*HostGpus)(nil), "nutanix.acropolis.HostGpus")
	proto.RegisterType((*VmCompatibleHostGpus)(nil), "nutanix.acropolis.VmCompatibleHostGpus")
}

func init() { proto.RegisterFile("acropolis/acropolis_types.proto", fileDescriptor_6c689b321cdcad6d) }

var fileDescriptor_6c689b321cdcad6d = []byte{
	// 15306 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x59, 0x6c, 0x1c, 0xc9,
	0xb6, 0x20, 0x76, 0xab, 0x8a, 0x4b, 0xd5, 0xa9, 0x2d, 0x99, 0x24, 0x25, 0x92, 0x6a, 0xb5, 0xa4,
	0xea, 0x96, 0x9a, 0x57, 0xdd, 0x97, 0x52, 0xab, 0x77, 0xdd, 0x95, 0x22, 0xb5, 0xf0, 0xb5, 0x48,
	0xb1, 0x93, 0x12, 0xef, 0x7b, 0xfd, 0x96, 0xbc, 0x59, 0x99, 0xc1, 0xaa, 0xbc, 0x95, 0xdb, 0xcd,
	0xcc, 0x2a, 0x89, 0x17, 0xf3, 0x33, 0xb0, 0xdf, 0xc0, 0x30, 0x6c, 0x18, 0x6f, 0x00, 0xc3, 0x36,
	0x8c, 0xc1, 0x9d, 0xf9, 0x18, 0x7b, 0xe0, 0x99, 0x01, 0xbc, 0x60, 0x6c, 0xc0, 0x86, 0x37, 0x60,
	0x0c, 0x63, 0x0c, 0x3c, 0x1b, 0xb6, 0xe1, 0xc1, 0x3c, 0x63, 0x00, 0xff, 0xfa, 0xc7, 0x1f, 0xfe,
	0xf0, 0xfa, 0x33, 0x46, 0x9c, 0x13, 0x91, 0x19, 0x59, 0x0b, 0x29, 0xea, 0xb6, 0xde, 0xcc, 0x03,
	0xcc, 0x1f, 0x56, 0x9e, 0x38, 0xb1, 0x9f, 0x38, 0xe7, 0xc4, 0x89, 0x13, 0x27, 0xe0, 0x9a, 0x65,
	0xc7, 0x61, 0x14, 0x7a, 0x6e, 0x72, 0x27, 0xfb, 0x65, 0xa6, 0xa7, 0x11, 0x4b, 0xb6, 0xa2, 0x38,
	0x4c, 0x43, 0x7d, 0x29, 0x18, 0xa6, 0x56, 0xe0, 0xbe, 0xda, 0xca, 0x92, 0x37, 0xa6, 0xe6, 0x61,
	0x71, 0x1c, 0xc6, 0x94, 0x67, 0xe3, 0xaa, 0xef, 0xda, 0x71, 0x98, 0xb0, 0xde, 0x1d, 0xf9, 0x43,
	0x2d, 0x72, 0x63, 0x39, 0x72, 0xd3, 0x7e, 0x98, 0xdc, 0xa1, 0x7f, 0x02, 0x78, 0x45, 0x00, 0x93,
	0x34, 0x66, 0xa9, 0xdd, 0x37, 0x23, 0x2b, 0xb6, 0x7c, 0x99, 0xb8, 0x31, 0x4c, 0x5d, 0xef, 0x4e,
	0xe2, 0x99, 0xdd, 0xe1, 0x49, 0x72, 0x27, 0x60, 0xe9, 0x9d, 0x38, 0xb2, 0x29, 0xad, 0xf3, 0xb7,
	0x4a, 0xb0, 0xfa, 0x98, 0x05, 0x2c, 0x76, 0xed, 0xdd, 0xee, 0xb3, 0xee, 0x2f, 0x99, 0x9d, 0x3e,
	0x61, 0x96, 0xc3, 0x62, 0x5d, 0x87, 0xb9, 0xe1, 0xd0, 0x75, 0xd6, 0x4a, 0xd7, 0x4b, 0x9b, 0x0d,
	0x03, 0x7f, 0xeb, 0x6b, 0xb0, 0xe8, 0x30, 0x8f, 0xa5, 0xcc, 0x59, 0x2b, 0x5f, 0x2f, 0x6d, 0x56,
	0x0d, 0xf9, 0xa9, 0x7f, 0x08, 0x4b, 0x5e, 0xd8, 0x73, 0x6d, 0xcb, 0x33, 0x53, 0xd7, 0x67, 0x49,
	0x6a, 0xf9, 0xd1, 0x5a, 0xe5, 0x7a, 0x69, 0xb3, 0x62, 0x68, 0x22, 0xe1, 0xb9, 0x84, 0xf3, 0xa2,
	0x03, 0xcb, 0x67, 0x6b, 0x73, 0xd7, 0x4b, 0x9b, 0x35, 0x03, 0x7f, 0xeb, 0xd7, 0xa1, 0xee, 0xb0,
	0xc4, 0x8e, 0xdd, 0x28, 0x75, 0xc3, 0x60, 0x6d, 0x1e, 0x93, 0x54, 0x50, 0xa7, 0x0b, 0x8d, 0xe7,
	0x2c, 0x49, 0x65, 0x33, 0xf5, 0x9f, 0xc1, 0x42, 0x1f, 0x9b, 0x8a, 0x4d, 0xac, 0xdf, 0xdb, 0xdc,
	0x9a, 0x18, 0xec, 0xad, 0xa9, 0x5d, 0x33, 0x44, 0x3e, 0x5d, 0x83, 0x4a, 0x30, 0xf4, 0xb1, 0x2b,
	0xf3, 0x06, 0xff, 0xd9, 0xf9, 0x93, 0x12, 0x2c, 0x8b, 0x3c, 0xdf, 0x0c, 0x59, 0x7c, 0x6a, 0xb0,
	0x5f, 0x0d, 0x59, 0x92, 0xea, 0x1f, 0x40, 0xfb, 0xc4, 0xf5, 0x52, 0x16, 0x9b, 0x76, 0xec, 0xa6,
	0x2c, 0x76, 0x2d, 0xac, 0xb4, 0x66, 0xb4, 0x08, 0xbc, 0x23, 0xa0, 0xfa, 0x7b, 0xd0, 0x4c, 0xc2,
	0x38, 0xcd, 0xd1, 0xca, 0x88, 0xd6, 0xe0, 0xc0, 0x0c, 0x69, 0x05, 0xe6, 0x3d, 0xd7, 0x77, 0x53,
	0x1c, 0xa0, 0x39, 0x83, 0x3e, 0xf4, 0x4b, 0xb0, 0x60, 0x0f, 0xe3, 0x24, 0x8c, 0x71, 0x5c, 0x1a,
	0x86, 0xf8, 0xea, 0xec, 0xc2, 0x4a, 0xb1, 0x49, 0x49, 0x14, 0x06, 0x09, 0x53, 0xf0, 0x4b, 0x2a,
	0x3e, 0x2f, 0x3d, 0x0d, 0x53, 0xcb, 0xc3, 0xaa, 0xe7, 0x0c, 0xfa, 0xe8, 0xec, 0x40, 0xeb, 0xc9,
	0x69, 0xc4, 0xe2, 0x91, 0x9b, 0x84, 0xf1, 0xf3, 0xd3, 0x88, 0x75, 0x3e, 0x86, 0x39, 0xfe, 0x5f,
	0xaf, 0xc2, 0xdc, 0xe0, 0xeb, 0x91, 0xaf, 0x95, 0xf4, 0x3a, 0x2c, 0x0e, 0x10, 0xe9, 0x58, 0x2b,
	0x23, 0xf8, 0x61, 0xf2, 0x4a, 0xab, 0xe0, 0xaf, 0xdf, 0x65, 0x81, 0x36, 0xd7, 0x39, 0x84, 0xea,
	0x93, 0x30, 0x49, 0x31, 0xfb, 0xae, 0xc8, 0xbe, 0x0c, 0x6d, 0xca, 0xb4, 0x13, 0x06, 0x23, 0x16,
	0xf7, 0x98, 0xa3, 0x95, 0x74, 0x0d, 0x1a, 0x83, 0x9d, 0xd0, 0x8f, 0x86, 0x29, 0x7b, 0x16, 0x78,
	0xa7, 0x5a, 0x59, 0x5f, 0x85, 0xa5, 0xc1, 0x01, 0x1b, 0xb1, 0xf8, 0xc8, 0xee, 0x33, 0x67, 0xe8,
	0x59, 0x5d, 0x8f, 0x69, 0x95, 0xce, 0x8f, 0xb3, 0xf1, 0xfe, 0x9a, 0x9d, 0x1e, 0x5b, 0xde, 0x90,
	0x1d, 0x5a, 0x2e, 0xce, 0xcc, 0x80, 0x9d, 0x8a, 0x31, 0xe6, 0x3f, 0x79, 0xaf, 0x46, 0x3c, 0x59,
	0x0c, 0x28, 0x7d, 0x74, 0xfe, 0x87, 0x12, 0xd4, 0xf7, 0x59, 0x6a, 0xc9, 0x79, 0xba, 0x06, 0x75,
	0x9f, 0xa5, 0xfd, 0xd0, 0x31, 0x91, 0xc0, 0x28, 0x3f, 0x10, 0xe8, 0x80, 0x93, 0xd9, 0x0f, 0xa1,
	0x62, 0xc5, 0x3d, 0x2c, 0xa4, 0x7e, 0xef, 0xfb, 0x53, 0x28, 0xe6, 0xd0, 0x3a, 0xf5, 0x42, 0xcb,
	0x79, 0x16, 0x3f, 0xf4, 0xbb, 0xcc, 0x71, 0x98, 0x83, 0x8d, 0x32, 0x78, 0x2e, 0xfd, 0x1d, 0xa8,
	0x9d, 0x84, 0xf1, 0x4b, 0x2b, 0x76, 0x98, 0x83, 0x73, 0x57, 0x35, 0x72, 0x80, 0xfe, 0x18, 0xda,
	0x31, 0x35, 0xc3, 0xb4, 0xc3, 0x20, 0x65, 0xaf, 0x52, 0x9c, 0xc8, 0xfa, 0xbd, 0x77, 0xb3, 0x6a,
	0x02, 0x96, 0x6e, 0x19, 0x91, 0x2d, 0x5a, 0xbb, 0x43, 0x58, 0x46, 0x2b, 0x2e, 0x7c, 0x77, 0xfe,
	0x5e, 0x09, 0x1a, 0xd4, 0x29, 0x31, 0xd3, 0x0f, 0x01, 0x90, 0x41, 0x98, 0x76, 0xe8, 0x50, 0xa7,
	0x5a, 0xf7, 0x6e, 0x4d, 0x69, 0xfb, 0xb6, 0xfc, 0xf5, 0x10, 0xd9, 0x09, 0x9f, 0x1e, 0xa3, 0x86,
	0x39, 0x77, 0x42, 0x87, 0xe9, 0x37, 0xa0, 0x41, 0xc5, 0x38, 0x2c, 0xb5, 0x5c, 0x4f, 0x8c, 0x64,
	0x1d, 0x61, 0xbb, 0x08, 0xe2, 0xc3, 0x13, 0x33, 0xa2, 0xcb, 0x8b, 0x0d, 0x4f, 0xcc, 0xd2, 0xce,
	0x7d, 0x68, 0x88, 0x64, 0x04, 0x72, 0x02, 0x0d, 0x4f, 0x4e, 0x12, 0x96, 0x62, 0x93, 0xe7, 0x0c,
	0xf1, 0xc5, 0x97, 0x7f, 0xe2, 0xfe, 0x9a, 0x09, 0xfa, 0xc4, 0xdf, 0x9d, 0x10, 0x2e, 0x4d, 0x2f,
	0x5a, 0xff, 0x0a, 0x16, 0x23, 0x4a, 0x11, 0xeb, 0xfc, 0xda, 0xec, 0x66, 0x51, 0x63, 0x24, 0xbe,
	0xbe, 0x01, 0x55, 0x26, 0xca, 0xc2, 0xca, 0x1a, 0x46, 0xf6, 0xdd, 0xf9, 0x87, 0x65, 0x68, 0x1c,
	0x05, 0x56, 0x94, 0xf4, 0xc3, 0x74, 0x2f, 0x38, 0x09, 0x2f, 0xc8, 0xef, 0xee, 0x4c, 0xe3, 0x77,
	0x7c, 0xba, 0x2b, 0xf7, 0xcb, 0x3f, 0xf8, 0x78, 0x0a, 0xcf, 0xbb, 0x0d, 0x4b, 0x76, 0xcc, 0xac,
	0x94, 0x21, 0xbe, 0x39, 0x4c, 0x98, 0x9d, 0x20, 0x97, 0xab, 0x18, 0x6d, 0x4a, 0xe0, 0xb8, 0x2f,
	0x38, 0x58, 0xbf, 0x0a, 0xd0, 0x8b, 0xc3, 0x61, 0x64, 0x62, 0x83, 0x16, 0xb1, 0x41, 0x35, 0x84,
	0xbc, 0xe0, 0xad, 0xba, 0x0c, 0x8b, 0x23, 0x9f, 0xd2, 0x6a, 0xb4, 0xf2, 0x47, 0x3e, 0x26, 0x7c,
	0x89, 0x09, 0x49, 0xc4, 0xec, 0x35, 0x98, 0x39, 0x54, 0xc7, 0xfe, 0x0e, 0x56, 0x77, 0x14, 0x31,
	0x9b, 0xe7, 0xe4, 0xff, 0x33, 0x8e, 0x5c, 0x57, 0x38, 0xf2, 0x67, 0x50, 0x1d, 0xf9, 0x26, 0x56,
	0xbb, 0xd6, 0xc0, 0xe2, 0x36, 0xa6, 0x16, 0xf7, 0x98, 0x63, 0x18, 0x8b, 0x23, 0xfa, 0xd1, 0xf9,
	0xe3, 0x52, 0x3e, 0xb0, 0xb2, 0xec, 0x89, 0x81, 0x55, 0xba, 0x50, 0x2e, 0x74, 0xe1, 0x53, 0x58,
	0x19, 0xf9, 0xe6, 0x0c, 0x51, 0x82, 0x43, 0xab, 0x8f, 0xfc, 0xa7, 0xaf, 0x21, 0x50, 0x3a, 0xff,
	0xe8, 0x5d, 0x98, 0x7b, 0x6e, 0x25, 0x83, 0xa9, 0xf5, 0x7f, 0x09, 0x8b, 0x62, 0xd1, 0x09, 0x56,
	0xf0, 0xee, 0x94, 0xae, 0x29, 0x8c, 0xc5, 0x90, 0xe8, 0xfa, 0x0f, 0xa1, 0x1a, 0x8b, 0x75, 0x29,
	0x96, 0xc9, 0xb5, 0x99, 0x59, 0x09, 0xcd, 0xc8, 0x32, 0x70, 0xf6, 0xa4, 0x10, 0x01, 0x36, 0x77,
	0xc1, 0x80, 0x7c, 0xfa, 0xf9, 0xcc, 0x27, 0xa9, 0x15, 0xa7, 0x94, 0x3e, 0x8f, 0xe9, 0x35, 0x84,
	0x60, 0xf2, 0x7b, 0xd0, 0xb4, 0x43, 0x3f, 0xe2, 0x24, 0x48, 0x18, 0x0b, 0x88, 0xd1, 0x90, 0x40,
	0x44, 0xba, 0x0d, 0x4b, 0x9e, 0x95, 0xa4, 0xe6, 0x30, 0x72, 0xac, 0x94, 0x39, 0x84, 0xb8, 0x88,
	0x88, 0x6d, 0x9e, 0xf0, 0x82, 0xe0, 0x88, 0xbb, 0x0d, 0x75, 0x16, 0xa4, 0x6e, 0x7a, 0x6a, 0x7a,
	0x6e, 0x92, 0xae, 0x55, 0xaf, 0x57, 0x36, 0xeb, 0xf7, 0xae, 0x4f, 0xe9, 0x10, 0x1f, 0xc9, 0xad,
	0x87, 0x88, 0xba, 0xe7, 0x18, 0x40, 0x99, 0x9e, 0xba, 0x49, 0xaa, 0x3f, 0x85, 0x56, 0x18, 0xb1,
	0xd8, 0xe2, 0x32, 0x1a, 0x15, 0x15, 0x24, 0xca, 0xd6, 0xbd, 0x9b, 0xb3, 0x4a, 0x79, 0x26, 0xb1,
	0x91, 0x3f, 0x35, 0x43, 0xf5, 0x93, 0xaf, 0x38, 0x9f, 0x25, 0x89, 0xd5, 0x63, 0x48, 0xc2, 0x35,
	0x43, 0x7e, 0xea, 0x77, 0x60, 0x39, 0x62, 0xb1, 0xcd, 0x82, 0xd4, 0xea, 0x31, 0x53, 0xf6, 0x18,
	0x29, 0x76, 0xde, 0xd0, 0xf3, 0xa4, 0x1d, 0x91, 0xc2, 0xf9, 0x71, 0x14, 0x87, 0xbd, 0x98, 0x25,
	0x89, 0x99, 0xa4, 0x56, 0x3a, 0x4c, 0x90, 0x8c, 0x5b, 0x53, 0xe7, 0x1a, 0x5b, 0x76, 0x84, 0x58,
	0x46, 0x4b, 0x66, 0xa3, 0x6f, 0x7d, 0x13, 0xb4, 0xc8, 0x8a, 0x59, 0x90, 0x9a, 0xa9, 0x95, 0x0c,
	0x88, 0x6a, 0x9b, 0x48, 0x4c, 0x2d, 0x82, 0xf3, 0xcc, 0x48, 0xbd, 0xb7, 0x61, 0x29, 0x19, 0x76,
	0x33, 0x2c, 0x1a, 0xd4, 0xd6, 0xf5, 0xca, 0x66, 0xc3, 0x68, 0x8b, 0x04, 0x8e, 0x87, 0xe3, 0x76,
	0x1b, 0x9a, 0x6e, 0x90, 0xb2, 0x38, 0xe0, 0x74, 0x6e, 0x25, 0x83, 0xb5, 0x36, 0xe7, 0x30, 0xf7,
	0xe7, 0x4f, 0x2c, 0x2f, 0x61, 0x46, 0x43, 0xa6, 0x21, 0x09, 0xdf, 0x80, 0xaa, 0x6d, 0x05, 0x36,
	0xf3, 0x98, 0xb3, 0xa6, 0xa9, 0x68, 0x19, 0x98, 0x33, 0x77, 0xc7, 0x4d, 0x22, 0xcf, 0x3a, 0x25,
	0xd1, 0xb7, 0x24, 0x14, 0x28, 0x82, 0xa1, 0xec, 0xdb, 0x82, 0x65, 0xd9, 0xba, 0x84, 0x53, 0x73,
	0x60, 0x33, 0xd3, 0x75, 0xd6, 0x74, 0x64, 0xc3, 0xb2, 0xe1, 0x47, 0x22, 0x65, 0x8f, 0xf3, 0x38,
	0x4d, 0x16, 0x79, 0x62, 0xb9, 0xde, 0x30, 0x66, 0xc9, 0xda, 0x32, 0xd6, 0x3e, 0x97, 0xc6, 0x43,
	0x66, 0xb4, 0x45, 0xea, 0x23, 0x91, 0xa8, 0x3f, 0x82, 0x86, 0x6d, 0x45, 0x56, 0xd7, 0xf5, 0xdc,
	0xd4, 0x65, 0xc9, 0xda, 0xca, 0xf5, 0xca, 0x66, 0xeb, 0x5e, 0x67, 0xd6, 0x70, 0xef, 0x48, 0xdc,
	0x53, 0xa3, 0x90, 0x6f, 0x9a, 0x24, 0x5d, 0x7d, 0x13, 0x49, 0xca, 0x7b, 0x30, 0x4c, 0x98, 0x99,
	0x9c, 0x06, 0xb6, 0xd9, 0xb5, 0xe2, 0xd8, 0x65, 0xf1, 0xda, 0x25, 0x75, 0xfc, 0x5a, 0xc3, 0x84,
	0x1d, 0x9d, 0x06, 0xf6, 0x03, 0x4a, 0xdc, 0xf8, 0xbb, 0x25, 0xa8, 0x4a, 0x2a, 0x9f, 0xca, 0x38,
	0x7e, 0x9a, 0x2d, 0x18, 0x24, 0xf5, 0xf2, 0xd9, 0x04, 0x45, 0x45, 0xc9, 0xe5, 0x82, 0x04, 0x7e,
	0x2d, 0x2b, 0x00, 0xa7, 0xa9, 0x42, 0x1a, 0x0a, 0x81, 0x70, 0x96, 0x3e, 0x9c, 0x29, 0x59, 0x26,
	0xa5, 0x4a, 0xe7, 0x7f, 0x2e, 0xc1, 0x02, 0x55, 0xa2, 0xd7, 0x60, 0x7e, 0x70, 0x10, 0x3a, 0x4c,
	0x2b, 0xe9, 0x8b, 0x50, 0x19, 0x1c, 0xef, 0x6b, 0x65, 0xbd, 0x09, 0xb5, 0x81, 0xe4, 0xc5, 0x5a,
	0x45, 0x07, 0x58, 0x18, 0xec, 0xf9, 0x56, 0x8f, 0x69, 0x73, 0xa8, 0xa1, 0x1d, 0x87, 0xde, 0xd0,
	0x67, 0xc8, 0xb6, 0xb5, 0x79, 0x54, 0xe4, 0x8e, 0xdd, 0x38, 0x1d, 0x5a, 0xde, 0x01, 0x4b, 0x5f,
	0x86, 0xf1, 0x40, 0x5b, 0xd0, 0x1b, 0x50, 0x1d, 0x08, 0x16, 0xaf, 0x2d, 0xea, 0x4b, 0xd0, 0x1c,
	0xec, 0x8b, 0x4d, 0x89, 0x31, 0xf4, 0x98, 0x56, 0x45, 0x84, 0x1d, 0x6f, 0x98, 0xa4, 0x2c, 0xd6,
	0x6a, 0x58, 0x86, 0xf8, 0x3a, 0x4e, 0x5e, 0xba, 0xa9, 0xdd, 0xd7, 0x40, 0xd7, 0xa1, 0x25, 0x0b,
	0x3e, 0x22, 0x58, 0x9d, 0xaa, 0x27, 0xd8, 0xae, 0x9b, 0x0c, 0xb4, 0x06, 0x42, 0xf6, 0x12, 0x3b,
	0x71, 0x77, 0x3c, 0x97, 0x05, 0xa9, 0xd6, 0xec, 0xfc, 0xb1, 0x0e, 0xcd, 0x02, 0xb3, 0xc0, 0xe2,
	0x65, 0x7f, 0x48, 0x8a, 0x69, 0x25, 0xec, 0xa4, 0x14, 0x6a, 0x5a, 0x59, 0xb4, 0x78, 0xc7, 0x0b,
	0x03, 0xa6, 0x55, 0xf4, 0x16, 0xc0, 0xe0, 0xd8, 0xdf, 0x77, 0x7b, 0x31, 0x4f, 0x9d, 0x13, 0xdf,
	0x06, 0x4b, 0xd2, 0x30, 0x66, 0xda, 0xbc, 0xc8, 0x4c, 0x2c, 0x51, 0x5b, 0xd0, 0x57, 0x40, 0x1b,
	0x1c, 0xfb, 0x47, 0x2c, 0x3d, 0x0c, 0x5f, 0xb2, 0x98, 0xaf, 0x7f, 0xa6, 0x2d, 0x0a, 0xa4, 0x5d,
	0x14, 0xfd, 0x5a, 0x15, 0x47, 0xe1, 0xd8, 0xe7, 0xcd, 0x16, 0x95, 0xd6, 0x14, 0x90, 0x28, 0x0a,
	0x14, 0x90, 0xc8, 0x28, 0x3a, 0xed, 0x1f, 0xb8, 0xb6, 0xc8, 0xd7, 0xc8, 0x21, 0x22, 0x5b, 0x33,
	0x87, 0x88, 0x5c, 0x2d, 0x7d, 0x1d, 0x56, 0x07, 0x0f, 0x39, 0x37, 0xd8, 0xb7, 0x38, 0x53, 0x08,
	0xf8, 0x8a, 0xdf, 0xe7, 0x13, 0xdd, 0xd6, 0xd7, 0x60, 0x65, 0xf0, 0xf0, 0x95, 0x9b, 0x8e, 0xa7,
	0x68, 0x7a, 0x1b, 0xea, 0xd8, 0xcf, 0x9e, 0x8b, 0x33, 0xb3, 0x24, 0x7a, 0xf6, 0x28, 0x8c, 0x6d,
	0x86, 0x7d, 0x7b, 0x76, 0x72, 0xa2, 0xe9, 0x85, 0x01, 0x15, 0x15, 0x2e, 0xd3, 0x4c, 0x70, 0x32,
	0x11, 0xcd, 0x5c, 0xc9, 0x21, 0x02, 0x67, 0x55, 0xbf, 0x04, 0xfa, 0x80, 0x6f, 0x05, 0xf8, 0x48,
	0x5a, 0x71, 0xba, 0xed, 0x79, 0xc7, 0x7e, 0xa2, 0x5d, 0xc2, 0xa1, 0x7a, 0x62, 0x89, 0xde, 0x5c,
	0xc6, 0x5a, 0x8f, 0x38, 0xc2, 0x93, 0x6d, 0xce, 0x25, 0xc2, 0x11, 0x8b, 0xb5, 0x35, 0xac, 0x55,
	0x64, 0x94, 0xb4, 0xb5, 0xae, 0x5f, 0x85, 0x75, 0xd9, 0x40, 0xc9, 0xc2, 0x69, 0xda, 0xdc, 0x30,
	0xd0, 0x36, 0xb0, 0x42, 0x85, 0x5e, 0x45, 0xd3, 0xae, 0x8c, 0xc3, 0x45, 0xcd, 0xef, 0x8c, 0xc3,
	0x45, 0xc3, 0xaf, 0xe2, 0x3e, 0x84, 0xe0, 0xca, 0x04, 0xbe, 0x3b, 0x06, 0x16, 0xd8, 0xd7, 0xf2,
	0x8e, 0x8b, 0x72, 0xaf, 0xe3, 0x90, 0x2b, 0xe5, 0x6e, 0xa7, 0xa9, 0x65, 0xf7, 0x8f, 0x7d, 0xed,
	0x86, 0x18, 0x72, 0x01, 0xe8, 0x69, 0x9d, 0x71, 0xd4, 0x6c, 0x32, 0xde, 0x43, 0xd4, 0x27, 0x56,
	0x36, 0x22, 0xef, 0xeb, 0x1b, 0x70, 0x29, 0x1b, 0xce, 0x30, 0x66, 0xc7, 0xfe, 0xd3, 0xd0, 0xb6,
	0x38, 0x67, 0xd4, 0x6e, 0x8e, 0x35, 0x4d, 0x34, 0xe4, 0x96, 0x02, 0xa6, 0x01, 0x41, 0x82, 0xff,
	0x00, 0xc1, 0x47, 0x64, 0x05, 0xd8, 0x09, 0x83, 0x13, 0xb7, 0x37, 0x8c, 0x99, 0xb6, 0x49, 0x13,
	0x4d, 0x60, 0x83, 0xd9, 0x58, 0xeb, 0xf7, 0x69, 0x61, 0xfa, 0xea, 0x78, 0xde, 0x56, 0x61, 0x62,
	0x14, 0x3e, 0x54, 0x61, 0xa2, 0xfa, 0x8f, 0x10, 0x76, 0x68, 0xc5, 0x36, 0xf3, 0x12, 0x91, 0xf7,
	0x07, 0x48, 0xf2, 0x04, 0x13, 0x59, 0xb7, 0x10, 0x4d, 0x70, 0x13, 0x81, 0x76, 0x47, 0x85, 0x89,
	0xe2, 0xee, 0xaa, 0x30, 0x91, 0xf7, 0x63, 0xfd, 0x32, 0x2c, 0x0f, 0xb6, 0x4f, 0x4e, 0xdc, 0x80,
	0xf3, 0xd0, 0xa1, 0x27, 0xe7, 0xe0, 0x1e, 0x75, 0xdd, 0x97, 0x49, 0x02, 0xfc, 0x09, 0x4e, 0xf9,
	0x53, 0xeb, 0xd7, 0x56, 0x40, 0x6d, 0x10, 0xf0, 0x4f, 0xf5, 0x6b, 0x70, 0x85, 0xe0, 0x07, 0x61,
	0xea, 0x9e, 0x9c, 0x22, 0xf9, 0x3f, 0x8f, 0xad, 0x20, 0x71, 0x91, 0xb6, 0x3e, 0xd7, 0xaf, 0xc0,
	0x65, 0x42, 0x28, 0x12, 0x1e, 0x3b, 0xf6, 0xb5, 0x2f, 0x70, 0xf9, 0x61, 0xe2, 0x11, 0x4b, 0xf9,
	0x14, 0x49, 0x69, 0xa7, 0x7d, 0xa9, 0x5f, 0x87, 0x77, 0xd4, 0x82, 0xe5, 0x7c, 0xca, 0x52, 0xb4,
	0xaf, 0x90, 0x04, 0x10, 0x63, 0x3b, 0x49, 0xdc, 0x5e, 0x70, 0xc4, 0x7a, 0x3e, 0x0b, 0xd2, 0x44,
	0xfb, 0xa1, 0xfe, 0x1e, 0x5c, 0x13, 0x29, 0xa2, 0x1b, 0x4f, 0xb6, 0x31, 0x9f, 0xcb, 0x17, 0xf1,
	0x4e, 0x9f, 0xd9, 0x03, 0xed, 0xc7, 0xb8, 0x7c, 0xa8, 0x6e, 0xda, 0x34, 0xf3, 0x16, 0x6d, 0xe3,
	0x5c, 0x4a, 0x2e, 0x2c, 0x3a, 0xf9, 0xb0, 0x00, 0x14, 0x23, 0xf8, 0x08, 0xd7, 0x14, 0xe6, 0xdf,
	0xb7, 0x4e, 0xbb, 0x62, 0xfc, 0x64, 0x7d, 0xda, 0x63, 0xec, 0x9a, 0xc1, 0x12, 0x16, 0x8f, 0xd8,
	0x21, 0x8b, 0x79, 0xe7, 0xf6, 0x99, 0x1f, 0xc6, 0xa7, 0xda, 0x13, 0x4c, 0x2a, 0x32, 0x72, 0x31,
	0x7d, 0x7b, 0x53, 0x92, 0x44, 0x23, 0x7e, 0x67, 0x4a, 0x92, 0x68, 0xca, 0xd7, 0xd8, 0x15, 0xc2,
	0x3b, 0xf6, 0x77, 0xbb, 0xc4, 0x59, 0x9f, 0x4a, 0x7e, 0x7b, 0x1a, 0xd8, 0x06, 0x8b, 0x1e, 0x06,
	0x68, 0x14, 0x38, 0x28, 0x42, 0x45, 0xe1, 0x87, 0x82, 0x41, 0x14, 0xa0, 0xbb, 0x61, 0xec, 0x5b,
	0x41, 0x7a, 0xec, 0x6b, 0xdf, 0xe0, 0x50, 0x67, 0xdf, 0xca, 0x22, 0x3e, 0x42, 0x3a, 0xca, 0x32,
	0x1a, 0x2c, 0xf2, 0x5c, 0x9b, 0x97, 0xf8, 0x5c, 0xd0, 0x91, 0x48, 0x90, 0x32, 0xe2, 0x85, 0x7e,
	0x13, 0x6e, 0x0c, 0x76, 0xe2, 0x30, 0x49, 0x44, 0x57, 0x0e, 0x63, 0xc6, 0xf5, 0xbc, 0x63, 0xff,
	0xa9, 0x3b, 0x92, 0xa4, 0xa1, 0x1d, 0xeb, 0xef, 0xc2, 0x06, 0xca, 0x9d, 0x1c, 0x51, 0x4d, 0xff,
	0xb9, 0xe8, 0xc5, 0xae, 0x9b, 0xf0, 0x5e, 0x89, 0x5e, 0xfc, 0x2e, 0x16, 0x7e, 0x18, 0x33, 0x9b,
	0xcf, 0x70, 0x32, 0x2b, 0xf3, 0xef, 0xe9, 0x1f, 0xc1, 0xe6, 0x60, 0xc7, 0x63, 0x56, 0xc0, 0x97,
	0xe6, 0x39, 0x4d, 0xf9, 0x16, 0x09, 0xf1, 0xd8, 0xdf, 0xe9, 0x5b, 0x41, 0x8f, 0xd8, 0x5a, 0x18,
	0xa4, 0x96, 0x1b, 0xb0, 0x58, 0x54, 0xfb, 0xfb, 0xb8, 0x36, 0xb2, 0xd1, 0xc1, 0xd1, 0x7f, 0xcc,
	0x52, 0xed, 0x0f, 0x70, 0x50, 0x77, 0xdd, 0x24, 0x8d, 0xdd, 0xee, 0x30, 0x65, 0x4e, 0x71, 0xae,
	0xff, 0x70, 0x46, 0xb2, 0x28, 0xf5, 0x8f, 0x66, 0x24, 0x8b, 0x81, 0x37, 0xf5, 0x5b, 0xd0, 0x19,
	0x88, 0x46, 0x3e, 0x88, 0x5d, 0xa7, 0xc7, 0x9e, 0x87, 0x93, 0xd8, 0xda, 0x2f, 0xc8, 0x84, 0x14,
	0x26, 0xe9, 0xd1, 0x4b, 0x4b, 0x30, 0x54, 0xcd, 0x2a, 0x00, 0x77, 0x19, 0x02, 0xbb, 0xc8, 0x27,
	0xb3, 0x19, 0x23, 0xfe, 0x26, 0x1a, 0x63, 0xeb, 0x37, 0xe0, 0xea, 0x24, 0x67, 0x56, 0x35, 0x0a,
	0x47, 0x64, 0x37, 0x98, 0x1f, 0xa6, 0xac, 0x28, 0x0a, 0x19, 0x32, 0x01, 0x05, 0x5b, 0x2c, 0x16,
	0xae, 0x3a, 0x6a, 0x27, 0xfa, 0xf7, 0xe1, 0xe6, 0xb4, 0xe9, 0x50, 0x66, 0xe1, 0x28, 0x1c, 0xc6,
	0x36, 0xd3, 0x7a, 0x48, 0x87, 0x72, 0x21, 0x3e, 0xb0, 0xf2, 0xd1, 0xea, 0x63, 0x0d, 0x52, 0xd7,
	0xd8, 0x0b, 0x6c, 0x2b, 0x0e, 0x50, 0xb8, 0xed, 0x39, 0x89, 0xe6, 0xe2, 0xd2, 0x29, 0x2e, 0xea,
	0xc7, 0x2c, 0x38, 0x18, 0xfa, 0xda, 0x2f, 0x3b, 0x7f, 0x04, 0x0b, 0x62, 0x27, 0x52, 0x87, 0xc5,
	0xc1, 0x37, 0x43, 0x36, 0x44, 0x1b, 0x1b, 0x57, 0x74, 0x8c, 0x61, 0x10, 0xb8, 0x41, 0x4f, 0x2b,
	0xa3, 0x62, 0x73, 0x34, 0xb4, 0x6d, 0xc6, 0x1c, 0xe6, 0x68, 0x15, 0x4c, 0xdd, 0xee, 0x86, 0x71,
	0xca, 0x1c, 0x6d, 0x0e, 0x33, 0x72, 0xf6, 0xc4, 0x1c, 0x6d, 0x5e, 0xa0, 0x26, 0x11, 0x0b, 0x38,
	0xea, 0x42, 0xe7, 0x0e, 0x40, 0xae, 0x8a, 0xa3, 0xc8, 0xe3, 0xca, 0xab, 0xc0, 0xd0, 0x4a, 0x28,
	0xad, 0x38, 0x64, 0x07, 0xf7, 0x1a, 0x5a, 0xb9, 0xf3, 0x47, 0xb0, 0x3e, 0x4d, 0x21, 0xe1, 0x2a,
	0x5a, 0xd2, 0xd9, 0x86, 0xd5, 0x63, 0xff, 0x20, 0x0c, 0x68, 0x5c, 0x38, 0xed, 0x3f, 0x43, 0xfb,
	0x2d, 0x6a, 0x9f, 0x0f, 0xbc, 0xd0, 0x1e, 0x68, 0x25, 0xfd, 0x1d, 0x58, 0x1b, 0x6c, 0xdb, 0x91,
	0x7b, 0xd4, 0x1f, 0xa6, 0x4e, 0xf8, 0x32, 0xd8, 0x0e, 0x9c, 0x6c, 0x2a, 0xca, 0x9d, 0x9f, 0x82,
	0x76, 0xec, 0x3f, 0x08, 0xb9, 0x4a, 0x32, 0x72, 0x6d, 0x2c, 0xb7, 0xf3, 0xa1, 0x30, 0x37, 0xf2,
	0x52, 0x76, 0x9c, 0x38, 0xf4, 0xb5, 0x12, 0xaa, 0xbc, 0xa8, 0x3d, 0x92, 0xd6, 0x27, 0xb5, 0xd6,
	0x4a, 0xe7, 0x3f, 0x9d, 0x87, 0x06, 0x95, 0x40, 0x34, 0xa2, 0xef, 0xc2, 0x82, 0x83, 0x65, 0x09,
	0x1b, 0xd2, 0x47, 0x53, 0x2d, 0x19, 0x79, 0x86, 0x2d, 0xb5, 0x7e, 0x43, 0xe4, 0xd5, 0x3b, 0x50,
	0x1b, 0xb2, 0x13, 0xd7, 0xec, 0x86, 0x21, 0xd9, 0x0d, 0xf2, 0x7d, 0x18, 0x87, 0xf3, 0x1c, 0xfa,
	0x73, 0x58, 0xe2, 0xc9, 0x26, 0x65, 0x31, 0xc3, 0xd8, 0x61, 0xf1, 0x5a, 0x05, 0x37, 0x42, 0x9b,
	0x33, 0x2b, 0xcd, 0xfb, 0x49, 0x46, 0xbb, 0x76, 0x37, 0x03, 0x3e, 0xe3, 0x05, 0xe8, 0xbf, 0x07,
	0xed, 0x13, 0x37, 0xf6, 0x5f, 0x5a, 0x31, 0xdf, 0xfa, 0xf2, 0x16, 0x0a, 0xdb, 0xe2, 0xdd, 0xf3,
	0x3b, 0xf2, 0x48, 0x64, 0x24, 0x80, 0xd1, 0x3a, 0x29, 0x7c, 0xeb, 0xb7, 0xa0, 0x9e, 0x30, 0x7b,
	0x18, 0x33, 0xea, 0xd6, 0xbc, 0xda, 0x2d, 0xa0, 0x14, 0xec, 0xd8, 0x4f, 0xe0, 0x72, 0xdf, 0x8a,
	0x1d, 0x6c, 0xc2, 0x88, 0x34, 0x77, 0xf7, 0xd7, 0x48, 0xc0, 0x68, 0x85, 0xc8, 0xf2, 0x5c, 0x92,
	0x58, 0xc7, 0x05, 0x24, 0xfd, 0xa7, 0xb0, 0xf6, 0xd2, 0x0d, 0x9c, 0xf0, 0x65, 0x62, 0xda, 0x31,
	0x73, 0xf8, 0x8e, 0xc7, 0xf2, 0xcc, 0xde, 0xd0, 0x8a, 0xc9, 0xc4, 0x95, 0x17, 0x20, 0xd0, 0x76,
	0x32, 0xac, 0xc7, 0x1c, 0x69, 0x83, 0xc9, 0x39, 0xa5, 0x81, 0xd1, 0xef, 0x43, 0xcd, 0x71, 0x93,
	0x81, 0x69, 0x39, 0x8e, 0x3c, 0x02, 0xb8, 0x3a, 0x75, 0x34, 0x38, 0x89, 0x6c, 0x3b, 0x4e, 0x6c,
	0x54, 0x1d, 0xf1, 0x4b, 0x5f, 0x87, 0xaa, 0x6f, 0xd9, 0x94, 0x95, 0x0c, 0x50, 0x8b, 0xbe, 0x65,
	0xf3, 0xa4, 0x8d, 0xbf, 0x5c, 0xe2, 0xd4, 0xf7, 0x68, 0x7c, 0x90, 0xda, 0xc1, 0x28, 0xb6, 0x7c,
	0x13, 0x6b, 0x54, 0xec, 0x56, 0x4d, 0x04, 0xa3, 0x62, 0xc6, 0xb7, 0x87, 0x0f, 0x0b, 0x78, 0x68,
	0x89, 0x9b, 0x3b, 0xa7, 0x65, 0x68, 0x87, 0xcb, 0x8b, 0xe1, 0x9f, 0x9d, 0xff, 0x6b, 0x5e, 0xae,
	0x00, 0xaa, 0x1f, 0xed, 0x68, 0x4f, 0xc7, 0x68, 0xf8, 0xd3, 0x73, 0xa6, 0x9e, 0x67, 0x2a, 0xd0,
	0x17, 0x59, 0xfc, 0xfe, 0xa9, 0xd3, 0xb2, 0x35, 0x8b, 0x96, 0xbf, 0x7c, 0xbd, 0x0e, 0x15, 0xa7,
	0x06, 0x3b, 0xf5, 0x17, 0x96, 0xa6, 0xff, 0x4a, 0xa9, 0xc8, 0xea, 0x70, 0xa2, 0xdf, 0x0e, 0x61,
	0xeb, 0x57, 0xa0, 0x16, 0xb8, 0xb6, 0xe9, 0x06, 0x0e, 0x7b, 0x25, 0x4e, 0x9e, 0xaa, 0x81, 0x6b,
	0xef, 0xf1, 0xef, 0x8d, 0x3f, 0x2e, 0xc1, 0xca, 0xb4, 0xa1, 0x9d, 0x46, 0xd1, 0xa5, 0x8b, 0x53,
	0xf4, 0xeb, 0x2e, 0xa0, 0xce, 0x1f, 0xcf, 0x41, 0x5d, 0xec, 0xde, 0x67, 0x1a, 0x8f, 0xa5, 0xb5,
	0xb7, 0xac, 0x18, 0xab, 0x79, 0xe7, 0x86, 0xbe, 0x39, 0xb2, 0xa3, 0x61, 0x92, 0x75, 0x6e, 0xe8,
	0x1f, 0xf3, 0x6f, 0x9e, 0xe8, 0xa3, 0x62, 0x6b, 0xfa, 0x5d, 0xa4, 0xb5, 0x39, 0xa3, 0x4a, 0x80,
	0xfd, 0xae, 0xfe, 0x39, 0x5c, 0xe6, 0x4a, 0x7b, 0xec, 0x3a, 0xcc, 0x0c, 0x48, 0x82, 0x48, 0xb2,
	0x44, 0xba, 0x31, 0x56, 0x65, 0xb2, 0xdc, 0xc7, 0x10, 0x8d, 0x7d, 0x01, 0x7c, 0xf4, 0xc8, 0xc4,
	0xb7, 0x80, 0x76, 0xd3, 0x77, 0xa6, 0x8e, 0xc8, 0x81, 0x6b, 0xe3, 0x80, 0x2c, 0x06, 0xae, 0x8d,
	0x86, 0xbf, 0x2f, 0x60, 0x0e, 0xa9, 0x72, 0x11, 0x87, 0xf1, 0xbd, 0xd7, 0x20, 0x7a, 0x03, 0x33,
	0xe8, 0x1f, 0x82, 0xce, 0xfb, 0x68, 0x87, 0x31, 0x4b, 0xcc, 0x88, 0xc5, 0xd8, 0xdb, 0xb5, 0x2a,
	0x9d, 0x21, 0x04, 0x43, 0x7f, 0x87, 0x27, 0x1c, 0xb2, 0x98, 0x77, 0x5a, 0xff, 0x08, 0x5a, 0x36,
	0x1f, 0x45, 0xd3, 0x12, 0xfa, 0x3e, 0x9a, 0x65, 0x33, 0x82, 0x6c, 0x62, 0xa2, 0xdc, 0x0b, 0xe8,
	0x77, 0x60, 0x85, 0x17, 0x9d, 0xf6, 0x63, 0x66, 0x39, 0x54, 0x38, 0xaf, 0x06, 0x6d, 0xb0, 0x15,
	0x63, 0x29, 0x18, 0xfa, 0xcf, 0x29, 0xe9, 0x90, 0x6f, 0x6f, 0x62, 0xce, 0x3e, 0x9a, 0xbc, 0x76,
	0x93, 0x2f, 0x0c, 0x33, 0x72, 0x03, 0xb4, 0xc3, 0x56, 0x8d, 0x3a, 0x07, 0x3e, 0xb1, 0x62, 0xe7,
	0xd0, 0x0d, 0x32, 0x3a, 0xc6, 0x21, 0x6a, 0xe0, 0x10, 0x9d, 0x43, 0x34, 0x48, 0xc7, 0x7c, 0x90,
	0x3a, 0xff, 0x5d, 0x0b, 0xaa, 0xc7, 0xbe, 0x18, 0x6a, 0x39, 0xe1, 0x25, 0x65, 0xc2, 0xdf, 0x05,
	0xb0, 0x82, 0x20, 0x4c, 0x69, 0xb5, 0x12, 0x29, 0x28, 0x90, 0xdf, 0x82, 0x20, 0x7e, 0xa4, 0x36,
	0x7b, 0x1e, 0x9b, 0x7d, 0x6d, 0x66, 0xb3, 0x85, 0x50, 0xcd, 0x1a, 0xae, 0x7f, 0x35, 0x41, 0x16,
	0xef, 0xce, 0x22, 0x0b, 0x91, 0x37, 0x23, 0x8c, 0x4f, 0x0a, 0x84, 0x71, 0xed, 0x1c, 0xc2, 0x10,
	0x44, 0xb1, 0x05, 0x5a, 0xff, 0xa5, 0xcd, 0xd5, 0x2a, 0x34, 0x17, 0xfe, 0x3a, 0x0c, 0x18, 0x92,
	0x44, 0xed, 0x7e, 0xe5, 0xc5, 0xf3, 0x1d, 0xa3, 0x2d, 0x12, 0x9f, 0x8b, 0x34, 0xbd, 0x03, 0xf5,
	0xbe, 0x65, 0x46, 0xb1, 0x1b, 0xc6, 0x92, 0x28, 0x2a, 0xf7, 0x4b, 0x77, 0x0d, 0xe8, 0x5b, 0x87,
	0x02, 0xa8, 0x6f, 0x4d, 0x25, 0x34, 0x20, 0xd4, 0x8f, 0x27, 0x69, 0xed, 0x13, 0xb8, 0x64, 0x77,
	0x63, 0x33, 0x08, 0x53, 0x13, 0xed, 0xb8, 0x1e, 0x33, 0x63, 0x66, 0x25, 0x61, 0x20, 0xce, 0x93,
	0x96, 0xed, 0x6e, 0x7c, 0x10, 0xa6, 0x3b, 0x94, 0x66, 0x60, 0x92, 0xfe, 0x0c, 0xb4, 0x84, 0xc5,
	0x9c, 0x5f, 0x46, 0x61, 0x9c, 0xaa, 0x44, 0x72, 0x73, 0x6a, 0xcf, 0x8f, 0x10, 0xf9, 0x30, 0x8c,
	0x65, 0xff, 0x5b, 0x49, 0x06, 0xc1, 0xe1, 0xbb, 0x09, 0xf5, 0x51, 0xcf, 0xe2, 0x6b, 0x37, 0x09,
	0x3d, 0x86, 0x16, 0x7a, 0x69, 0xa9, 0x86, 0x51, 0xcf, 0xda, 0x21, 0x38, 0x5f, 0xb7, 0xd9, 0x92,
	0x68, 0xe1, 0x48, 0x5f, 0x99, 0x76, 0x94, 0x2a, 0xed, 0x0e, 0x19, 0xb2, 0xfe, 0x01, 0xb4, 0x39,
	0xc5, 0x47, 0x56, 0x92, 0xa4, 0xfd, 0x38, 0x1c, 0xf6, 0xfa, 0x64, 0xb2, 0x37, 0x5a, 0x76, 0x34,
	0x3c, 0xcc, 0xa1, 0xfa, 0x63, 0xa8, 0xb3, 0x57, 0x69, 0x6c, 0x99, 0x27, 0x9e, 0xd5, 0x4b, 0xd6,
	0x96, 0xb0, 0x53, 0xb7, 0x66, 0x7b, 0x27, 0xa8, 0x27, 0xdf, 0x06, 0x60, 0xd6, 0x47, 0x3c, 0x27,
	0x2e, 0x32, 0x71, 0x02, 0x47, 0x2c, 0x53, 0x47, 0x2e, 0x58, 0x17, 0x47, 0x6d, 0xa8, 0x71, 0x5c,
	0x87, 0xaa, 0xd5, 0x63, 0x41, 0x6a, 0x8e, 0x7c, 0x61, 0x9c, 0x17, 0x2b, 0x7c, 0x11, 0xc1, 0xc7,
	0xbe, 0x7e, 0x0f, 0x74, 0xcb, 0xf3, 0xc2, 0x97, 0xa6, 0xe7, 0x8e, 0x98, 0xe9, 0xd3, 0x76, 0x65,
	0x6d, 0x45, 0x19, 0x1e, 0x0d, 0xd3, 0x95, 0xcd, 0x8c, 0xfe, 0x08, 0xda, 0xbd, 0x68, 0x28, 0xf8,
	0x20, 0xcd, 0xcd, 0xea, 0x19, 0xc4, 0xfc, 0xf8, 0xf0, 0x85, 0x98, 0x94, 0x66, 0x2f, 0x1a, 0xd2,
	0x4f, 0x9c, 0x13, 0xce, 0xf6, 0xf9, 0x2a, 0x0c, 0x86, 0xbe, 0x65, 0x06, 0xa1, 0xc3, 0x12, 0xb4,
	0xbf, 0xcf, 0x19, 0x4d, 0xbe, 0x16, 0x39, 0xf4, 0x80, 0x03, 0xf5, 0x9b, 0xd0, 0xf0, 0x2d, 0xbb,
	0xef, 0x06, 0x8c, 0xec, 0xea, 0x97, 0x91, 0x82, 0xcb, 0x91, 0x6d, 0xd4, 0x05, 0x1c, 0x95, 0xff,
	0xef, 0xe3, 0x89, 0x04, 0x12, 0x58, 0x37, 0xb6, 0x02, 0xc7, 0x0d, 0x7a, 0x6b, 0x6b, 0x38, 0x07,
	0x6d, 0x01, 0x7f, 0x20, 0xc0, 0xfa, 0x8f, 0xf0, 0x84, 0x11, 0x0b, 0x5b, 0x47, 0x23, 0xfd, 0xfa,
	0xd4, 0x96, 0xf3, 0x62, 0xef, 0x57, 0x07, 0x8f, 0x87, 0x2c, 0x49, 0x8f, 0xf7, 0x8d, 0x85, 0x11,
	0x42, 0xf4, 0x9b, 0xd0, 0x62, 0x68, 0x8d, 0x30, 0x7d, 0x96, 0xc6, 0xae, 0x9d, 0xac, 0x6d, 0x60,
	0x35, 0x4d, 0x82, 0xee, 0x13, 0x50, 0xff, 0x16, 0x56, 0x23, 0xbe, 0x6d, 0xc1, 0xf3, 0x25, 0x8e,
	0x6b, 0xf7, 0xad, 0xc0, 0x4d, 0xfc, 0xb5, 0x2b, 0x33, 0xcf, 0xe8, 0x73, 0xc3, 0xf2, 0xbe, 0xc4,
	0x36, 0x96, 0xa3, 0x49, 0x20, 0x5f, 0x54, 0x41, 0x2f, 0x35, 0x45, 0x33, 0xc8, 0x0d, 0xc6, 0x64,
	0xaf, 0x98, 0xbd, 0xf6, 0x0e, 0x36, 0x65, 0x39, 0xe8, 0xa5, 0x64, 0x31, 0x39, 0xc2, 0xb4, 0x87,
	0xaf, 0x50, 0x75, 0xd8, 0xe0, 0x99, 0x4e, 0x2c, 0xd7, 0x33, 0xc3, 0x40, 0xe6, 0x12, 0xa7, 0x37,
	0x6b, 0x57, 0x31, 0x23, 0x2f, 0x96, 0xef, 0x05, 0x9f, 0x05, 0x94, 0x51, 0x18, 0xb4, 0xf4, 0xf7,
	0xa1, 0x95, 0xe0, 0x26, 0xd6, 0x94, 0x47, 0xb3, 0xef, 0x22, 0xb9, 0x35, 0x08, 0x7a, 0x4c, 0x07,
	0xb4, 0x47, 0xb0, 0x82, 0xc7, 0x29, 0x31, 0x8b, 0x0a, 0xe4, 0x71, 0x0d, 0xc9, 0xa3, 0x33, 0x7d,
	0xe9, 0xaa, 0xfb, 0x75, 0x63, 0x29, 0x51, 0x3f, 0x91, 0x4c, 0xee, 0xcd, 0x10, 0x3f, 0xd7, 0x25,
	0xcb, 0x79, 0x1d, 0x09, 0x74, 0x63, 0x52, 0x02, 0x7d, 0x05, 0xeb, 0x92, 0x5e, 0xe8, 0x34, 0xd4,
	0x7c, 0xd9, 0x77, 0x53, 0x46, 0x2d, 0x7e, 0xef, 0x7a, 0x65, 0xb3, 0x66, 0x5c, 0x72, 0x54, 0x03,
	0xcd, 0xcf, 0x79, 0x32, 0x36, 0xe9, 0x43, 0x58, 0x12, 0x22, 0x82, 0x8b, 0x7f, 0x3b, 0xf4, 0x7d,
	0x37, 0x5d, 0x7b, 0x1f, 0xab, 0xd0, 0x28, 0xe1, 0x59, 0x06, 0xe7, 0x92, 0x99, 0xe8, 0x20, 0x0c,
	0xcc, 0x5c, 0xb0, 0xdc, 0x44, 0x4a, 0x6f, 0x63, 0xca, 0xb3, 0x60, 0x5f, 0xca, 0x97, 0xdb, 0xb0,
	0xe4, 0xbb, 0x81, 0xeb, 0x0f, 0x7d, 0x05, 0xf7, 0x16, 0xe1, 0x8a, 0x04, 0x05, 0xb7, 0x45, 0x6b,
	0xb7, 0x1f, 0xa6, 0x66, 0xe4, 0x0d, 0x7b, 0x6b, 0x1f, 0x28, 0xeb, 0xb6, 0x81, 0x69, 0x4f, 0xc2,
	0xf4, 0xd0, 0x1b, 0xf6, 0xf4, 0xab, 0x00, 0x27, 0x9e, 0x95, 0xf4, 0x4d, 0x3f, 0x74, 0xd8, 0xda,
	0xa6, 0x70, 0x4f, 0xe1, 0x10, 0xbe, 0x39, 0xef, 0xfc, 0x6f, 0x2d, 0xbe, 0x7f, 0xca, 0xcf, 0xfe,
	0xff, 0x9c, 0xa5, 0xea, 0xfd, 0x49, 0xa9, 0xfa, 0xba, 0xca, 0xc0, 0x9b, 0xab, 0x5a, 0x52, 0x7b,
	0x5c, 0x54, 0xb4, 0x47, 0xa9, 0x7e, 0x55, 0x2f, 0xaa, 0x7e, 0x4d, 0x93, 0xb4, 0xb5, 0x33, 0x24,
	0xed, 0xb5, 0xa2, 0xa4, 0x25, 0x55, 0x4a, 0x15, 0xb3, 0xd3, 0xf5, 0xb9, 0xfa, 0x74, 0x7d, 0x6e,
	0xb6, 0x8c, 0x6d, 0x5c, 0x4c, 0xc6, 0x36, 0x7f, 0x1b, 0x19, 0x7b, 0xad, 0x28, 0x63, 0x5b, 0x48,
	0x64, 0xb3, 0xa4, 0x6b, 0xfb, 0xb7, 0x94, 0xae, 0xda, 0x54, 0xe9, 0x3a, 0x21, 0x14, 0x97, 0xde,
	0x44, 0x28, 0x4e, 0x11, 0x70, 0x2b, 0xdf, 0x91, 0x80, 0x5b, 0x9d, 0x26, 0xe0, 0xc6, 0x74, 0x82,
	0x4b, 0x6f, 0xac, 0x13, 0xdc, 0x98, 0x26, 0x29, 0x8b, 0x52, 0xf2, 0xee, 0x2c, 0x29, 0x29, 0x47,
	0xe1, 0xff, 0x17, 0x96, 0xbf, 0xb5, 0xb0, 0x9c, 0xb5, 0x61, 0x7a, 0xf7, 0xb5, 0x37, 0x4c, 0xd7,
	0x26, 0xc5, 0xd5, 0xa4, 0x04, 0xbe, 0x3e, 0x45, 0x02, 0xdf, 0x85, 0x15, 0x81, 0x95, 0x88, 0x93,
	0x5b, 0xc2, 0xbd, 0x81, 0xb8, 0x3a, 0xa5, 0xc9, 0x43, 0x5d, 0xcc, 0x71, 0x0b, 0xda, 0x27, 0x71,
	0xe8, 0x9b, 0x0e, 0x1d, 0x00, 0xf0, 0x55, 0xd1, 0xa1, 0x19, 0xe2, 0xe0, 0xec, 0x58, 0xe0, 0x62,
	0x32, 0x6f, 0x96, 0x22, 0x70, 0xf3, 0xb7, 0x51, 0x04, 0x6e, 0x42, 0xab, 0x28, 0xb0, 0x51, 0x30,
	0x56, 0x8d, 0x66, 0x41, 0x4a, 0xcf, 0x90, 0xb7, 0x1f, 0x5c, 0x40, 0xde, 0x6e, 0xbe, 0xae, 0xbc,
	0xfd, 0xfe, 0x6b, 0xca, 0xdb, 0xdb, 0xe3, 0xf2, 0xf6, 0x53, 0x80, 0xdc, 0x42, 0xa3, 0x6b, 0x50,
	0xe9, 0x0e, 0x13, 0xe9, 0xd0, 0xda, 0x1d, 0x26, 0xfa, 0x0a, 0xcc, 0x93, 0x29, 0x86, 0x4b, 0xd9,
	0xa6, 0x41, 0x1f, 0x9d, 0xff, 0x73, 0x8e, 0x4b, 0xe9, 0x7c, 0x67, 0xa9, 0x7f, 0x0c, 0x73, 0xaf,
	0x6f, 0x07, 0x42, 0x54, 0x5e, 0xb2, 0xed, 0xc4, 0xa1, 0x2f, 0x7c, 0x16, 0xe9, 0x83, 0x43, 0x99,
	0x1f, 0xa5, 0xa7, 0xc2, 0x71, 0x95, 0x3e, 0x90, 0xa1, 0xfb, 0xb9, 0x4d, 0x86, 0x3c, 0x8f, 0x81,
	0x40, 0x48, 0x3b, 0x1f, 0x81, 0x9e, 0xd1, 0x64, 0x8e, 0x37, 0x8f, 0x78, 0x9a, 0xa4, 0xcb, 0x0c,
	0xfb, 0x16, 0xb4, 0x05, 0x76, 0x70, 0x92, 0x98, 0x91, 0x95, 0xf6, 0xd1, 0x90, 0x56, 0x33, 0x9a,
	0x04, 0x3e, 0x38, 0x49, 0x0e, 0xad, 0xb4, 0xcf, 0xb9, 0x98, 0x2d, 0xcf, 0xa8, 0x4c, 0x21, 0xa0,
	0x2b, 0x46, 0x3d, 0x83, 0x91, 0xf7, 0x51, 0x62, 0x27, 0x6e, 0x41, 0x22, 0x54, 0x55, 0xef, 0x23,
	0x9e, 0xaa, 0x0a, 0x86, 0xbc, 0x2b, 0xe8, 0x5d, 0x5a, 0x23, 0x79, 0x4b, 0xa0, 0x23, 0xf7, 0xd7,
	0xe8, 0x8f, 0x9a, 0xf4, 0xad, 0x98, 0x39, 0xc2, 0x58, 0x21, 0xbe, 0x38, 0x81, 0x8c, 0xf0, 0xdc,
	0x48, 0x95, 0x2a, 0x0d, 0xec, 0x61, 0x7b, 0xa4, 0xb8, 0x16, 0x88, 0x0e, 0x8a, 0x4a, 0xb2, 0x0e,
	0x36, 0xa9, 0x83, 0x04, 0x96, 0x1d, 0xbc, 0x06, 0x75, 0x61, 0x35, 0xc5, 0xd2, 0x5a, 0x34, 0xae,
	0x04, 0xc2, 0x82, 0x56, 0x61, 0x21, 0xb0, 0x2c, 0xde, 0xf7, 0x36, 0x39, 0x34, 0x07, 0x96, 0xb5,
	0x87, 0xe5, 0x3b, 0x56, 0x6a, 0x99, 0x62, 0x14, 0x87, 0xb1, 0x87, 0x62, 0xb0, 0x66, 0x34, 0x39,
	0x98, 0x0e, 0x99, 0x5e, 0xc4, 0x1e, 0x67, 0x02, 0xa2, 0x1d, 0x99, 0xf1, 0x0a, 0x1b, 0x43, 0x6e,
	0x5f, 0x3a, 0xa5, 0x3d, 0x13, 0x49, 0xd8, 0xa2, 0x22, 0xb9, 0xea, 0xe3, 0xe4, 0xfa, 0xf7, 0xe6,
	0x25, 0xbd, 0xa2, 0x72, 0xf8, 0x96, 0xc9, 0xee, 0x4b, 0x98, 0x47, 0x03, 0x94, 0xb0, 0xfc, 0x76,
	0xce, 0xd4, 0x04, 0xd1, 0x1a, 0x68, 0x50, 0x06, 0xfd, 0x87, 0xb0, 0x40, 0xfe, 0x92, 0x48, 0x83,
	0xb3, 0x14, 0xb8, 0x2c, 0x2b, 0xa2, 0x1a, 0x22, 0x8b, 0xbe, 0x0d, 0x55, 0xf6, 0xca, 0x4d, 0x52,
	0x2e, 0x11, 0x17, 0x30, 0xfb, 0xcd, 0x33, 0xb3, 0x3f, 0x14, 0xc8, 0x46, 0x96, 0x8d, 0x6f, 0x41,
	0x27, 0xc8, 0x72, 0x91, 0xb6, 0xa0, 0xe3, 0x04, 0x99, 0xd3, 0x5b, 0xb5, 0x40, 0x6f, 0x63, 0xb4,
	0x51, 0x9b, 0xa0, 0x8d, 0x6f, 0xa4, 0xed, 0x8e, 0xbd, 0x22, 0x27, 0x40, 0xe1, 0xce, 0x7b, 0xfb,
	0xfc, 0x61, 0x7a, 0x28, 0x72, 0x08, 0x03, 0x9f, 0xfc, 0x9c, 0x49, 0x2f, 0xf5, 0x99, 0xf4, 0x72,
	0x1b, 0x96, 0x9c, 0xae, 0xe9, 0xe6, 0xe7, 0x94, 0xa6, 0x58, 0x15, 0x73, 0x46, 0xdb, 0xe9, 0x16,
	0xce, 0x2f, 0xf5, 0x6f, 0x61, 0x49, 0x8c, 0xc7, 0x30, 0x6f, 0x73, 0x13, 0xdb, 0xfc, 0x83, 0x33,
	0xdb, 0x2c, 0x86, 0x6b, 0x98, 0x35, 0x5b, 0x8b, 0xc6, 0x20, 0x63, 0x74, 0xdb, 0x1a, 0xa7, 0xdb,
	0xbf, 0x3b, 0x07, 0xed, 0xb1, 0x31, 0x18, 0x67, 0x6a, 0xa5, 0x09, 0xa6, 0xb6, 0x0e, 0xd5, 0x6c,
	0xf9, 0xd2, 0x26, 0x67, 0x31, 0x10, 0x0b, 0x77, 0x1d, 0xaa, 0xbe, 0x1b, 0x10, 0x0b, 0xa1, 0xfb,
	0x2b, 0x8b, 0xbe, 0x1b, 0x20, 0xff, 0x18, 0x67, 0x5a, 0x73, 0x93, 0x4c, 0x6b, 0x0b, 0x96, 0x33,
	0xa1, 0xac, 0x30, 0x13, 0x62, 0x97, 0x4b, 0x32, 0x29, 0x67, 0x27, 0x37, 0xa1, 0x95, 0x17, 0xa9,
	0x6c, 0x55, 0x9a, 0x19, 0x14, 0xd1, 0x7e, 0x08, 0x1b, 0x6e, 0xd0, 0x67, 0xb1, 0x9b, 0x9a, 0x48,
	0x7c, 0x42, 0xa9, 0x0f, 0x86, 0x7e, 0x97, 0xc5, 0x82, 0xba, 0x2e, 0x0b, 0x8c, 0x23, 0x3b, 0x71,
	0x49, 0x8f, 0x3f, 0xc0, 0x64, 0x54, 0x51, 0xd9, 0xcb, 0x02, 0xfb, 0xae, 0x09, 0xd3, 0x3b, 0x7b,
	0xa9, 0xf0, 0xee, 0x4d, 0xd0, 0x64, 0x25, 0x76, 0xdf, 0x72, 0x71, 0xbe, 0x81, 0x54, 0x70, 0x01,
	0xdf, 0xe1, 0xe0, 0x3d, 0xf4, 0x35, 0xb5, 0xe9, 0x00, 0x9c, 0x8a, 0xab, 0x93, 0x06, 0x2e, 0x60,
	0x67, 0x88, 0x8d, 0xc6, 0xeb, 0x8b, 0x8d, 0xe6, 0x34, 0xb1, 0xb1, 0x0d, 0x57, 0xf9, 0x6e, 0x81,
	0xf7, 0x5d, 0x36, 0xc0, 0x0b, 0x6d, 0xa2, 0x4e, 0xc5, 0xd7, 0x76, 0x43, 0x20, 0xc9, 0x53, 0x7a,
	0x81, 0x82, 0x86, 0xe5, 0x7f, 0x0d, 0x4f, 0x5c, 0x8a, 0xfc, 0x21, 0xbb, 0x91, 0x50, 0xca, 0x6f,
	0x24, 0x4c, 0xcc, 0x36, 0xdd, 0x56, 0x28, 0xcc, 0x76, 0x61, 0xf6, 0x14, 0x77, 0xce, 0x7c, 0xf6,
	0xd0, 0xa3, 0x73, 0x72, 0x92, 0xe7, 0xa6, 0x4c, 0x72, 0xe7, 0x5f, 0x2e, 0x83, 0x3e, 0xc9, 0x7a,
	0xce, 0x27, 0xe6, 0x8b, 0x36, 0x14, 0x8b, 0xa9, 0x4c, 0x23, 0xb3, 0xcf, 0x61, 0x6d, 0x98, 0x30,
	0x73, 0xd4, 0x33, 0x5d, 0x24, 0xb3, 0xd4, 0x8a, 0x7b, 0x2c, 0x35, 0x33, 0xd7, 0xfa, 0xaa, 0xb1,
	0x32, 0x4c, 0xd8, 0x71, 0x0f, 0xdd, 0x24, 0x9e, 0x63, 0x22, 0x76, 0xf0, 0xad, 0xe8, 0x08, 0x9d,
	0xff, 0xa2, 0x04, 0x97, 0x67, 0x70, 0xb7, 0xc2, 0x2a, 0xa5, 0x49, 0x9b, 0xb9, 0x4a, 0xdf, 0xf6,
	0xbc, 0xf1, 0xb6, 0x50, 0xa7, 0x63, 0x4f, 0x5c, 0x5b, 0x5b, 0xc4, 0xbe, 0xc6, 0x5e, 0xe7, 0x6f,
	0x95, 0x60, 0x63, 0x36, 0xb3, 0x9b, 0x68, 0x6a, 0xe9, 0x75, 0x9a, 0x5a, 0x7e, 0xbd, 0xa6, 0x56,
	0xce, 0x6b, 0xea, 0x5c, 0xb1, 0xa9, 0x5d, 0xbe, 0x2c, 0xf2, 0x1b, 0x62, 0x78, 0x25, 0xe6, 0x3e,
	0xcc, 0xe1, 0x9e, 0x70, 0xf6, 0x8d, 0xa3, 0xe2, 0x95, 0x32, 0x3a, 0xf0, 0xc5, 0x3c, 0x7c, 0x49,
	0x71, 0x8d, 0x45, 0x9c, 0xf2, 0xe1, 0xef, 0xce, 0x3f, 0x9c, 0x83, 0x85, 0x63, 0xff, 0xbb, 0xba,
	0x6d, 0x53, 0x39, 0xe3, 0xb6, 0xcd, 0x27, 0xb0, 0x50, 0x38, 0x5a, 0xbe, 0x32, 0xfd, 0x22, 0x0c,
	0xed, 0x43, 0x04, 0xaa, 0xbe, 0x03, 0xd0, 0xcf, 0xfa, 0x73, 0xa6, 0x7a, 0x51, 0x1c, 0x27, 0x43,
	0xc9, 0xa6, 0x5f, 0x81, 0x5a, 0x3f, 0x4c, 0xc4, 0x96, 0x6c, 0x81, 0x2e, 0x1d, 0x71, 0x80, 0x58,
	0x60, 0xf3, 0xb8, 0xf9, 0x45, 0x2e, 0xdf, 0x9a, 0x7a, 0xd1, 0x42, 0x78, 0x67, 0xe1, 0x5d, 0x04,
	0x66, 0x10, 0x3a, 0xdf, 0xde, 0xc6, 0xcc, 0x0f, 0x47, 0xcc, 0x31, 0x71, 0x23, 0x97, 0xd7, 0x40,
	0x9c, 0x7c, 0x59, 0xa4, 0x3e, 0x8a, 0x43, 0xff, 0x89, 0xac, 0xec, 0x33, 0xa8, 0xf6, 0xa2, 0x21,
	0xf1, 0x45, 0xc0, 0x4d, 0xd9, 0xb4, 0xfb, 0x3b, 0x07, 0xa1, 0xc3, 0x1e, 0x1f, 0xbe, 0x30, 0x16,
	0x7b, 0xd1, 0x10, 0xb7, 0x60, 0x0c, 0xd6, 0xe8, 0x8c, 0xc0, 0x0d, 0x7a, 0xf9, 0xa1, 0x2f, 0x15,
	0x53, 0xc7, 0x62, 0xa6, 0x3b, 0xcf, 0x4c, 0xf1, 0x3e, 0x43, 0xe3, 0xd9, 0x6a, 0x56, 0x9a, 0x5c,
	0x07, 0x58, 0xcd, 0xd7, 0x70, 0xdd, 0xb6, 0x02, 0xd3, 0xf6, 0x98, 0x15, 0x9b, 0x33, 0x3a, 0xd7,
	0x50, 0xd4, 0xfd, 0x2b, 0xb6, 0x15, 0xec, 0x70, 0x64, 0x63, 0xb2, 0xab, 0x9d, 0x7f, 0xb4, 0x00,
	0x75, 0xe5, 0x48, 0xad, 0x70, 0x0a, 0x5e, 0x2a, 0x9e, 0x82, 0xdf, 0x80, 0x86, 0x3c, 0xe5, 0x55,
	0x4e, 0xa1, 0xeb, 0x02, 0x86, 0x03, 0xb7, 0x02, 0xf3, 0x5c, 0xd7, 0xf0, 0x04, 0x57, 0xa0, 0x0f,
	0xae, 0x87, 0xb8, 0x11, 0x16, 0xc9, 0x92, 0x44, 0x70, 0x82, 0x9a, 0x1b, 0x6d, 0x13, 0x40, 0x7f,
	0x04, 0xb5, 0x91, 0x67, 0x05, 0xa4, 0xa5, 0xcc, 0x9f, 0x31, 0xbd, 0x07, 0xae, 0x7d, 0xec, 0x59,
	0xe8, 0xcf, 0x7e, 0x7f, 0x71, 0xb0, 0x6d, 0xdb, 0x2c, 0x49, 0x8c, 0x2a, 0xcf, 0xcb, 0xf5, 0x19,
	0xae, 0x5f, 0xa6, 0xf1, 0x30, 0x18, 0x30, 0x47, 0x9e, 0x46, 0x27, 0x68, 0xf3, 0x9c, 0x37, 0xda,
	0x02, 0x2e, 0x8e, 0xa1, 0x13, 0xfd, 0x47, 0x62, 0x79, 0x12, 0x31, 0xcd, 0x34, 0x89, 0x62, 0x4d,
	0x30, 0x38, 0xe0, 0xdb, 0x7c, 0xef, 0xc0, 0xb5, 0xc5, 0x02, 0x5d, 0x87, 0x6a, 0x64, 0xbb, 0x66,
	0xe2, 0x85, 0x29, 0x52, 0xd1, 0xbc, 0xb1, 0x18, 0xd9, 0xee, 0x91, 0x17, 0xa6, 0xba, 0x03, 0xeb,
	0x72, 0x8c, 0x4e, 0x86, 0x81, 0x8d, 0xe2, 0x35, 0x70, 0x6d, 0x32, 0x10, 0x01, 0xd6, 0x36, 0xed,
	0x6e, 0xa0, 0x68, 0xd8, 0x23, 0x91, 0x45, 0x54, 0x6d, 0x5c, 0x0a, 0xa6, 0xc2, 0xf5, 0x1f, 0xc3,
	0x95, 0x89, 0x5a, 0x48, 0xf1, 0x50, 0x94, 0x8a, 0xb5, 0xb1, 0xcc, 0xa8, 0x82, 0xe0, 0x2c, 0x3d,
	0x07, 0x5d, 0xaa, 0x9a, 0xa6, 0x95, 0xa6, 0xb1, 0x7a, 0x82, 0xf8, 0xba, 0x86, 0x35, 0x4d, 0x96,
	0xb0, 0x9d, 0xa6, 0x71, 0xc1, 0x62, 0xdc, 0x54, 0xf8, 0xd2, 0x1f, 0xe6, 0x24, 0x83, 0x23, 0xd0,
	0xc2, 0x11, 0xb8, 0x7d, 0xf6, 0xb1, 0xae, 0x1c, 0x0d, 0x1c, 0xfd, 0xd6, 0xe0, 0xc0, 0x4a, 0xdd,
	0x91, 0xf4, 0x20, 0xc8, 0xc8, 0x0d, 0xc7, 0xa1, 0x03, 0x35, 0x3b, 0x0c, 0x02, 0x66, 0x73, 0xc6,
	0xd7, 0x56, 0x48, 0x3e, 0x07, 0xeb, 0xeb, 0xb0, 0xf0, 0xab, 0x21, 0x1b, 0xb2, 0x04, 0x77, 0x83,
	0xcd, 0xfb, 0xa5, 0x8f, 0x0d, 0x01, 0xd0, 0x3f, 0x80, 0x66, 0xfc, 0xca, 0xc4, 0x0f, 0x92, 0x87,
	0x4b, 0x88, 0x51, 0xb9, 0xf7, 0xd9, 0xe7, 0x46, 0x3d, 0x7e, 0x85, 0xee, 0x82, 0x5c, 0x30, 0x76,
	0x3e, 0x85, 0xba, 0xd2, 0x26, 0xf2, 0xb8, 0x56, 0x5b, 0xa5, 0x95, 0xd0, 0x81, 0x7b, 0x3b, 0xf5,
	0xac, 0x44, 0x82, 0xca, 0x9d, 0xbf, 0xb3, 0x00, 0xb5, 0xcc, 0xb2, 0xfe, 0x56, 0x16, 0xd6, 0x5d,
	0x58, 0x11, 0xd7, 0x76, 0x98, 0x63, 0x4e, 0x2c, 0x31, 0x3d, 0x4b, 0xdb, 0xfb, 0xa7, 0xb9, 0xd6,
	0xde, 0x03, 0x90, 0x57, 0x92, 0xdc, 0x48, 0xf8, 0xf6, 0x88, 0x59, 0x12, 0xf0, 0xbd, 0x28, 0x5b,
	0x90, 0xd5, 0x37, 0x5a, 0x90, 0xe7, 0xac, 0x07, 0x38, 0x67, 0x3d, 0xa8, 0xeb, 0xb9, 0x7e, 0x81,
	0xf5, 0xdc, 0xf8, 0xae, 0xd6, 0xf3, 0xf4, 0x05, 0xd9, 0xfc, 0x2d, 0x17, 0xe4, 0x3a, 0x9d, 0xfd,
	0x28, 0x56, 0x94, 0xc5, 0xc0, 0xb5, 0xb1, 0xc7, 0x7f, 0x4e, 0x0b, 0x67, 0xfa, 0x4e, 0x58, 0x9f,
	0xba, 0x13, 0xee, 0xfc, 0xe9, 0x3c, 0xdf, 0x8e, 0x66, 0x17, 0x7a, 0xbe, 0x83, 0x45, 0x73, 0xb5,
	0x40, 0x79, 0xe2, 0xd6, 0x79, 0x4e, 0x73, 0x17, 0x5f, 0x3d, 0x9b, 0xa0, 0xd9, 0x28, 0xab, 0x4d,
	0x5c, 0x44, 0x6e, 0x70, 0x12, 0x0a, 0x4f, 0xa7, 0x16, 0xc1, 0xf9, 0x92, 0x41, 0x25, 0xad, 0xb0,
	0xce, 0x16, 0xbe, 0xdb, 0x75, 0xb6, 0x38, 0x7d, 0x9d, 0x9d, 0xb3, 0x08, 0xaa, 0xe7, 0x2c, 0x82,
	0xdf, 0x81, 0x8e, 0x38, 0xe8, 0x3d, 0xab, 0x14, 0xf4, 0x84, 0x32, 0xde, 0x25, 0xcc, 0x83, 0x8b,
	0x09, 0x18, 0xf8, 0x2d, 0xe9, 0xf9, 0xae, 0xe0, 0x11, 0xf5, 0xf3, 0x79, 0x44, 0x2e, 0xa8, 0xb3,
	0x15, 0xd0, 0x28, 0xae, 0x80, 0x77, 0xd4, 0x15, 0xd0, 0x24, 0xd2, 0x98, 0x46, 0xfb, 0xad, 0x73,
	0x69, 0xbf, 0x3d, 0x43, 0x68, 0xfc, 0x8b, 0x25, 0xbe, 0x29, 0x1d, 0x3f, 0x17, 0xcc, 0x8d, 0xd7,
	0x25, 0xe4, 0x34, 0xf4, 0xa1, 0xff, 0x44, 0xf4, 0xad, 0x7c, 0x86, 0x80, 0x1c, 0x2f, 0x4a, 0xd9,
	0x33, 0x74, 0xde, 0x15, 0x3e, 0xde, 0x78, 0x95, 0x71, 0xe8, 0x79, 0x22, 0x24, 0xc5, 0x11, 0x8b,
	0x47, 0x2c, 0xd6, 0xca, 0x9d, 0xff, 0xb6, 0xc4, 0xd5, 0xbc, 0xec, 0x2c, 0x4e, 0xdf, 0x2a, 0xec,
	0x4f, 0xa6, 0x69, 0xb7, 0x8f, 0x0f, 0x5f, 0x28, 0x23, 0x79, 0x05, 0x6a, 0xc2, 0xf0, 0x26, 0x96,
	0xda, 0xbc, 0x51, 0x25, 0xc0, 0x9e, 0xa3, 0x7f, 0x0a, 0x0b, 0x23, 0x16, 0x38, 0x61, 0x8c, 0x6b,
	0x6c, 0xfa, 0xd4, 0x3c, 0x3e, 0x7c, 0x71, 0x8c, 0x38, 0x86, 0xc0, 0xc5, 0xeb, 0x9c, 0x78, 0xae,
	0x87, 0x11, 0x57, 0xc4, 0xa6, 0x8a, 0xce, 0xeb, 0x0e, 0x39, 0x84, 0xd7, 0x39, 0xe2, 0x6a, 0xb8,
	0xb2, 0x25, 0xae, 0x72, 0x00, 0xea, 0xad, 0xff, 0x79, 0x15, 0x16, 0x85, 0x02, 0xfe, 0xcf, 0x48,
	0x67, 0x44, 0x91, 0xca, 0x6d, 0x7a, 0x61, 0x98, 0xc4, 0x6d, 0xe6, 0x2a, 0x2c, 0xf0, 0x35, 0x94,
	0x90, 0xd4, 0xc5, 0x79, 0x7f, 0x91, 0x90, 0xf9, 0xa4, 0xeb, 0x9c, 0x88, 0x6d, 0x3c, 0xfe, 0x16,
	0x9e, 0x02, 0x74, 0x26, 0x8a, 0xf2, 0x72, 0x1e, 0x3d, 0x05, 0xf0, 0x38, 0x14, 0xdd, 0x0c, 0xf0,
	0x42, 0x94, 0xd5, 0xf5, 0x98, 0xb0, 0x5f, 0x29, 0x90, 0x9c, 0xbc, 0x6a, 0xca, 0xd9, 0x48, 0xa6,
	0x9b, 0xd1, 0xc5, 0x70, 0xd2, 0xcd, 0x5a, 0x50, 0x16, 0xba, 0x62, 0xcd, 0x28, 0xbb, 0x68, 0x80,
	0xc3, 0xf3, 0xd8, 0x5e, 0x34, 0x4c, 0x4c, 0xcb, 0x43, 0xeb, 0x10, 0xa3, 0x75, 0xd3, 0xc4, 0x63,
	0xb9, 0x63, 0x9e, 0xb2, 0x2d, 0x13, 0xf4, 0x0f, 0xa0, 0xed, 0x5b, 0xaf, 0x24, 0x26, 0x36, 0xa7,
	0x89, 0xb8, 0x2d, 0xdf, 0x7a, 0xb5, 0x9d, 0x43, 0xf5, 0x8f, 0x40, 0xe7, 0x88, 0x27, 0xb1, 0xe5,
	0xb3, 0xee, 0xf0, 0xe4, 0x84, 0xc5, 0xa6, 0xdf, 0xa5, 0x85, 0x65, 0x68, 0xbe, 0xf5, 0xea, 0x51,
	0x9e, 0xb0, 0xdf, 0xd5, 0x3b, 0xd0, 0xc4, 0x49, 0x4f, 0xac, 0x1e, 0x33, 0xa3, 0xc8, 0xc7, 0xf5,
	0x55, 0x31, 0xea, 0x7c, 0xe2, 0x39, 0xec, 0x30, 0xf2, 0xf1, 0x24, 0xd7, 0x0d, 0x78, 0x89, 0xc8,
	0x78, 0x48, 0x40, 0x19, 0x75, 0xdf, 0x0d, 0x1e, 0x09, 0x10, 0x97, 0x3c, 0xbc, 0x37, 0xf2, 0x16,
	0x76, 0x9f, 0x59, 0x4e, 0x42, 0x62, 0x0a, 0x1d, 0x04, 0x76, 0x09, 0xfe, 0x84, 0x83, 0x39, 0xe7,
	0x8c, 0x59, 0x12, 0x7a, 0x43, 0xe4, 0x76, 0x11, 0x8b, 0x0b, 0xd9, 0x50, 0x5e, 0xd5, 0x8c, 0xb5,
	0x1c, 0xe5, 0x90, 0xc5, 0x4a, 0x7e, 0x2e, 0x47, 0x7a, 0x28, 0x64, 0x9c, 0xd8, 0x1d, 0xb1, 0xd8,
	0x1c, 0xb1, 0x38, 0xe1, 0xad, 0x5a, 0x26, 0x03, 0x31, 0xa6, 0xed, 0x62, 0xd2, 0x31, 0xa5, 0xe8,
	0xf7, 0x60, 0x55, 0x1d, 0x8d, 0xbc, 0xaf, 0x2b, 0xd8, 0xd7, 0x65, 0x25, 0x31, 0xeb, 0xf3, 0x06,
	0x54, 0x3d, 0xd7, 0x66, 0x41, 0x82, 0xe7, 0xe4, 0x95, 0xcd, 0x9a, 0x91, 0x7d, 0xf3, 0xce, 0xb2,
	0xc0, 0x0e, 0x9d, 0x42, 0x59, 0x97, 0xc8, 0x1b, 0x42, 0x24, 0x64, 0xe5, 0x70, 0x91, 0xcc, 0xc6,
	0x71, 0x2f, 0x13, 0xae, 0x48, 0xc8, 0x70, 0xb7, 0x60, 0x0e, 0x05, 0xd8, 0xda, 0x59, 0x0b, 0x8b,
	0xcb, 0x29, 0x03, 0xf1, 0xf4, 0xeb, 0xd0, 0x10, 0xc7, 0xaf, 0xc4, 0xf1, 0xd7, 0xd1, 0xa6, 0x08,
	0x14, 0xa0, 0x42, 0x7a, 0x41, 0xa8, 0x8b, 0x7e, 0x63, 0x62, 0xd1, 0xdf, 0x81, 0x15, 0x4e, 0x2c,
	0x6e, 0x90, 0xa4, 0x56, 0x60, 0x4b, 0xef, 0x0e, 0x3a, 0xe9, 0x6e, 0x1a, 0x4b, 0xbe, 0xf5, 0x6a,
	0x4f, 0x26, 0x1d, 0xb2, 0xf8, 0x18, 0xc7, 0xc5, 0x67, 0xa9, 0x85, 0x16, 0x93, 0x77, 0xb0, 0xb8,
	0xec, 0xbb, 0xc8, 0x41, 0xae, 0x8e, 0x71, 0x90, 0xff, 0x72, 0x0e, 0x5a, 0x42, 0x82, 0xed, 0x5b,
	0x51, 0xe4, 0x06, 0x3d, 0xfd, 0x1b, 0x00, 0xef, 0x9e, 0xe9, 0xd3, 0x97, 0x38, 0xc0, 0xb9, 0x37,
	0x5b, 0xbd, 0x13, 0xd9, 0xb6, 0x9e, 0xde, 0x2b, 0x02, 0x8c, 0x9a, 0x77, 0x4f, 0x2d, 0xf2, 0x93,
	0xac, 0xc8, 0xf2, 0x6b, 0x17, 0xf9, 0xc9, 0x44, 0x91, 0x9f, 0x88, 0x9f, 0x1b, 0x27, 0xa0, 0x8d,
	0xd7, 0x88, 0x81, 0x16, 0x62, 0xd7, 0x2c, 0x68, 0x44, 0x25, 0x11, 0x68, 0x21, 0x76, 0x0f, 0x14,
	0xa5, 0x68, 0x13, 0xb4, 0x84, 0xd9, 0xe6, 0x14, 0xdd, 0xa9, 0x95, 0x30, 0x5b, 0xc1, 0xdc, 0xf8,
	0xeb, 0x65, 0xd0, 0xc6, 0xdb, 0xa1, 0xff, 0x12, 0xda, 0x42, 0x4f, 0x52, 0xc6, 0x89, 0xcb, 0xf5,
	0xed, 0x8b, 0x77, 0x6a, 0x4b, 0xe8, 0x55, 0xb2, 0x8f, 0x2d, 0xab, 0xf0, 0xbd, 0xf1, 0x9b, 0x12,
	0xb4, 0x8a, 0x28, 0x9c, 0x3c, 0x78, 0x3f, 0x29, 0xd2, 0x87, 0xa2, 0xb3, 0x51, 0x5f, 0x97, 0xa2,
	0xd8, 0xc5, 0x3b, 0xd3, 0xb9, 0xca, 0xf6, 0x21, 0xe8, 0x3c, 0x03, 0x0b, 0x0a, 0x2a, 0x1e, 0x75,
	0xb8, 0x1d, 0xc5, 0xee, 0xc3, 0x40, 0xd1, 0xef, 0xee, 0xc0, 0x0a, 0x1f, 0x9b, 0x89, 0xd2, 0x2b,
	0xe2, 0x10, 0x82, 0xd9, 0xc5, 0xd2, 0x3b, 0xff, 0x46, 0x09, 0xae, 0x88, 0x4b, 0xc1, 0xa7, 0x87,
	0x9e, 0x15, 0x14, 0xfb, 0x97, 0x70, 0xd6, 0x17, 0x8b, 0x64, 0x33, 0xe2, 0xfa, 0xa0, 0x32, 0x31,
	0x5a, 0xac, 0x64, 0xc4, 0xa9, 0x79, 0x0a, 0x9a, 0x9c, 0x16, 0x31, 0xb6, 0xbc, 0xa5, 0x7c, 0x70,
	0x6f, 0x9c, 0x3b, 0xb8, 0x46, 0x3b, 0x28, 0xd6, 0xdd, 0xf9, 0x7d, 0xd0, 0x9e, 0x5b, 0x11, 0x5d,
	0x8e, 0x90, 0xc3, 0x77, 0x0d, 0xea, 0x52, 0x9f, 0xce, 0x47, 0x0d, 0x84, 0x4a, 0xcd, 0x47, 0xe0,
	0x16, 0xb4, 0x53, 0x2b, 0x32, 0x55, 0x59, 0x26, 0xac, 0xa6, 0xa9, 0x2c, 0x8b, 0x8b, 0xb3, 0xce,
	0xbf, 0x57, 0xe6, 0xca, 0x7a, 0xc1, 0x29, 0x41, 0x7f, 0x01, 0x4b, 0xc5, 0x20, 0x6a, 0xd2, 0x30,
	0xab, 0xc6, 0x43, 0x12, 0xb1, 0xd7, 0xc4, 0x85, 0xea, 0x43, 0x0a, 0xb6, 0xf6, 0x22, 0xe0, 0xdc,
	0x31, 0xb1, 0xbc, 0x3d, 0xc7, 0x68, 0x27, 0x6a, 0xd2, 0x9e, 0xa3, 0x1b, 0x20, 0x41, 0x19, 0x67,
	0x2d, 0x5f, 0xb4, 0xd0, 0x96, 0x28, 0x41, 0x32, 0xe0, 0x04, 0xde, 0x2d, 0xce, 0xcb, 0xc4, 0xb8,
	0x57, 0x70, 0xdc, 0xb7, 0xa6, 0x8c, 0xfb, 0x19, 0xf3, 0x6d, 0x5c, 0x89, 0x67, 0x27, 0x76, 0xfe,
	0xa7, 0x12, 0x2c, 0x0a, 0x1b, 0x65, 0xe7, 0x1f, 0x94, 0x60, 0x1e, 0x7f, 0xe1, 0xf5, 0xbb, 0x17,
	0xc1, 0x20, 0x08, 0x5f, 0x06, 0x5a, 0x09, 0x03, 0x86, 0xe1, 0x4d, 0x3e, 0xbc, 0x3a, 0x88, 0x4e,
	0x3c, 0x6e, 0xd0, 0x7b, 0x16, 0x68, 0x15, 0x0c, 0x4d, 0xf1, 0x2c, 0xd0, 0xe6, 0xd0, 0xd4, 0x70,
	0xd4, 0x1f, 0xa6, 0x68, 0x18, 0xe4, 0xd9, 0xe6, 0xf1, 0xe6, 0x61, 0x86, 0x7c, 0x72, 0x22, 0xa2,
	0x4f, 0x1c, 0x5a, 0xc3, 0xc4, 0x0d, 0x7a, 0xda, 0x22, 0xea, 0x82, 0xfc, 0x8b, 0x39, 0x5a, 0x15,
	0x4b, 0x16, 0x57, 0x14, 0x79, 0x6a, 0x6d, 0xec, 0x56, 0x23, 0x60, 0x24, 0x02, 0x83, 0x25, 0x43,
	0x9f, 0x27, 0xd7, 0x31, 0xd9, 0x60, 0x09, 0xc3, 0x0a, 0xb5, 0x06, 0x7e, 0xef, 0x4b, 0xcb, 0xa4,
	0xd6, 0xec, 0xfc, 0x69, 0x09, 0x96, 0x44, 0xbf, 0xf2, 0xbb, 0xe1, 0x9d, 0xff, 0xa8, 0x04, 0x90,
	0x7f, 0x52, 0x7b, 0xc8, 0xbd, 0x44, 0x04, 0x9e, 0xc8, 0x6f, 0x2d, 0xe6, 0x7d, 0xdd, 0x39, 0xb5,
	0x3d, 0x26, 0xc2, 0x6d, 0x60, 0x95, 0xda, 0x1c, 0xfe, 0xc6, 0xb6, 0x6b, 0xf3, 0x58, 0x8a, 0xbc,
	0x5d, 0xb9, 0x80, 0xbd, 0xc2, 0x76, 0x32, 0x11, 0x60, 0x43, 0xbd, 0x17, 0x29, 0x3a, 0xca, 0x41,
	0x06, 0xeb, 0x86, 0x61, 0xaa, 0xd5, 0xd0, 0x70, 0x83, 0x2e, 0x58, 0x19, 0x12, 0xe0, 0xd0, 0x21,
	0x4c, 0x60, 0xd5, 0x3b, 0x7f, 0xa3, 0x82, 0x8a, 0xbb, 0x38, 0x71, 0x7c, 0x1e, 0x33, 0x86, 0x5b,
	0x3a, 0x25, 0xf0, 0x52, 0xa9, 0x10, 0x78, 0xe9, 0x17, 0xa0, 0x67, 0x27, 0x97, 0x9e, 0x1b, 0x08,
	0x47, 0x4d, 0x5a, 0xb8, 0xf7, 0xa6, 0x6b, 0xf2, 0x63, 0x65, 0x6f, 0x49, 0xc0, 0x53, 0x37, 0x18,
	0x18, 0x5a, 0xa2, 0x7c, 0xa1, 0xd4, 0xfc, 0x0c, 0x2e, 0x8f, 0x7c, 0x53, 0x44, 0xd2, 0x29, 0xba,
	0x2e, 0x11, 0x6b, 0x5a, 0x19, 0xf9, 0x87, 0x98, 0x5a, 0x70, 0x5e, 0xba, 0x48, 0x3c, 0x94, 0x8d,
	0xbf, 0xad, 0x04, 0x9f, 0xe2, 0x15, 0x63, 0x3c, 0xbe, 0x42, 0x55, 0x25, 0xe1, 0x51, 0xa5, 0x56,
	0x71, 0x17, 0x56, 0xa6, 0x36, 0x8b, 0x18, 0xac, 0x1e, 0x4d, 0x36, 0x6a, 0x57, 0x29, 0x16, 0x37,
	0xd0, 0xb3, 0x43, 0x41, 0xa9, 0x41, 0xc6, 0xf2, 0x7a, 0xf9, 0x57, 0xe7, 0x9f, 0x9b, 0x87, 0xea,
	0xde, 0xa1, 0x60, 0x3c, 0x1f, 0x80, 0x64, 0x7e, 0x63, 0x9c, 0xad, 0x25, 0xc0, 0x92, 0xbb, 0xbd,
	0x07, 0xcd, 0x28, 0x66, 0x27, 0xee, 0x2b, 0xd3, 0x63, 0x41, 0x4f, 0x9c, 0x60, 0xcf, 0x1b, 0x0d,
	0x02, 0x3e, 0x45, 0x98, 0xfe, 0x33, 0x80, 0x38, 0x1c, 0x4a, 0x57, 0xe7, 0xca, 0x4c, 0xfe, 0x2b,
	0xab, 0xdf, 0x32, 0x38, 0xb6, 0x51, 0xc3, 0x4c, 0x38, 0x5d, 0x87, 0xa0, 0x39, 0x7d, 0x3b, 0x32,
	0xc3, 0x28, 0x3f, 0x5e, 0x5d, 0x98, 0xb9, 0xf9, 0xcd, 0xca, 0xd9, 0x7d, 0xb2, 0x73, 0x48, 0x17,
	0x7e, 0x8d, 0x16, 0xcf, 0x4f, 0xbf, 0x85, 0xc9, 0xbf, 0xe1, 0x46, 0x66, 0x14, 0x86, 0x1e, 0x95,
	0xb6, 0x88, 0xa5, 0x7d, 0xff, 0xac, 0xd2, 0x32, 0x21, 0x75, 0x18, 0x86, 0x9e, 0x01, 0x6e, 0xc4,
	0xff, 0x63, 0x61, 0x5b, 0xb0, 0x8c, 0xcd, 0xc3, 0xe8, 0x05, 0x71, 0x36, 0x64, 0x64, 0x20, 0x58,
	0xe2, 0x49, 0xb4, 0x6d, 0x14, 0xf9, 0x37, 0x42, 0x98, 0xc7, 0x2e, 0x7e, 0xc7, 0xe3, 0xbc, 0x06,
	0x8b, 0x3d, 0x2b, 0x65, 0x2f, 0xad, 0x53, 0x41, 0xc4, 0xf2, 0x73, 0xe3, 0x10, 0x20, 0x1f, 0x0b,
	0x2e, 0xb3, 0xc4, 0x40, 0x66, 0x31, 0xfc, 0xe6, 0x0d, 0x20, 0x90, 0x0c, 0xce, 0x27, 0x10, 0xf2,
	0x30, 0x87, 0x0d, 0x43, 0x64, 0x42, 0x83, 0xc2, 0xc6, 0x0b, 0x68, 0x16, 0xc6, 0x03, 0x89, 0x1b,
	0xa5, 0x7c, 0xb1, 0x23, 0x0d, 0x0a, 0xc9, 0x22, 0xba, 0x81, 0x01, 0x87, 0x9c, 0x31, 0xa5, 0x01,
	0x58, 0xe0, 0x48, 0xf1, 0xff, 0xf7, 0xe7, 0xa0, 0x59, 0xbc, 0xda, 0xf6, 0x16, 0x43, 0x7f, 0xee,
	0x88, 0x5d, 0xee, 0xdc, 0xcc, 0x18, 0x61, 0x85, 0xa6, 0x6c, 0x09, 0x97, 0x53, 0x0a, 0x1f, 0xe0,
	0x88, 0xad, 0xef, 0x0d, 0x00, 0x17, 0xaf, 0x51, 0x9e, 0xb8, 0x8c, 0x0e, 0xea, 0xe6, 0xf1, 0x0a,
	0x53, 0x0e, 0xd4, 0xbf, 0x84, 0x9a, 0x2b, 0xfd, 0x12, 0x85, 0xab, 0xcf, 0x95, 0x33, 0x08, 0xcd,
	0xa8, 0xba, 0x52, 0x01, 0xf8, 0x10, 0x96, 0x44, 0x4c, 0x47, 0xd3, 0x1f, 0x7a, 0xa9, 0x6b, 0x5b,
	0x49, 0x2a, 0x3c, 0x7c, 0x34, 0x91, 0xb0, 0x2f, 0xe1, 0x7c, 0xd6, 0x46, 0x14, 0xc6, 0x80, 0xd4,
	0x8c, 0x2a, 0x79, 0xe3, 0x0a, 0x18, 0xee, 0x99, 0x35, 0xa8, 0xf8, 0xe9, 0x50, 0x1c, 0xb1, 0xf0,
	0x9f, 0x99, 0xe3, 0x3d, 0xcc, 0x74, 0xbc, 0xaf, 0x4f, 0x38, 0xde, 0x9f, 0x63, 0x17, 0x6b, 0x9c,
	0x63, 0x17, 0xdb, 0x82, 0x65, 0x71, 0xbf, 0xd5, 0x14, 0xcd, 0xcd, 0x4e, 0x39, 0x6a, 0xc6, 0xd2,
	0x48, 0x0d, 0xce, 0x84, 0xdb, 0x0a, 0x19, 0x1b, 0x94, 0x8b, 0x2a, 0x31, 0xf6, 0x22, 0xe2, 0xc0,
	0xb3, 0x11, 0x8b, 0x3d, 0xeb, 0x54, 0x04, 0x97, 0x92, 0x47, 0xd9, 0x5a, 0xa5, 0xf3, 0x77, 0x2a,
	0xb0, 0x24, 0x48, 0x8a, 0x82, 0x9d, 0xf8, 0x2c, 0x48, 0xcf, 0xd7, 0xd5, 0x8a, 0xc7, 0x6a, 0xe5,
	0xf1, 0x63, 0xb5, 0x71, 0x03, 0x69, 0x65, 0xd2, 0x40, 0x9a, 0x47, 0xd4, 0x52, 0x5d, 0x18, 0x09,
	0x24, 0x7d, 0x51, 0x42, 0x6a, 0x75, 0xa6, 0x21, 0x09, 0x5b, 0xcc, 0xbc, 0xa1, 0x89, 0x14, 0x41,
	0x75, 0x7b, 0x8e, 0xfe, 0x58, 0x50, 0x28, 0xd9, 0x3b, 0x3f, 0x99, 0xe6, 0xbd, 0x3e, 0xde, 0xcb,
	0xad, 0xfc, 0xa7, 0x62, 0xa0, 0x51, 0x56, 0xcc, 0x62, 0x71, 0xc5, 0x6c, 0x02, 0xa7, 0x24, 0xd3,
	0x4a, 0x3d, 0x2b, 0x31, 0x93, 0x61, 0x37, 0x60, 0xa9, 0x30, 0x82, 0xb4, 0x4e, 0xc2, 0x18, 0x0f,
	0x60, 0x8e, 0x10, 0x8a, 0x31, 0x5e, 0xc3, 0x70, 0xe0, 0x8a, 0x9b, 0x06, 0x86, 0xf8, 0xea, 0xfc,
	0x0c, 0x5a, 0xc5, 0x3a, 0x29, 0xe6, 0x97, 0x2f, 0x42, 0xaf, 0x52, 0x50, 0x17, 0x0a, 0x9d, 0x54,
	0xc6, 0x48, 0x1a, 0x7b, 0xc1, 0x49, 0x6c, 0x25, 0x69, 0x3c, 0xb4, 0xd3, 0x61, 0xcc, 0xb4, 0x4a,
	0xe7, 0x4f, 0x4a, 0x70, 0xf5, 0xa0, 0xc0, 0xf0, 0x94, 0x02, 0xd1, 0xe2, 0x31, 0x3e, 0xf4, 0xa5,
	0xc9, 0xa1, 0xdf, 0x87, 0xb6, 0x95, 0xe5, 0x52, 0x35, 0x86, 0xf7, 0x5f, 0x67, 0xd8, 0x8c, 0x56,
	0x9e, 0x19, 0x7d, 0x73, 0xfe, 0x7e, 0x05, 0xd6, 0x8a, 0x6d, 0xda, 0xb1, 0xec, 0x3e, 0x7b, 0x18,
	0xa4, 0xf1, 0xe9, 0x6b, 0x51, 0x92, 0x32, 0xbd, 0xc4, 0xac, 0x6b, 0x41, 0x36, 0xaf, 0x37, 0x26,
	0xcf, 0x6f, 0x1f, 0x94, 0xd7, 0x4a, 0x2a, 0xb1, 0x6d, 0xc1, 0x12, 0x7b, 0x15, 0xb9, 0xf1, 0xe9,
	0x78, 0x8c, 0xce, 0x05, 0xc4, 0x6c, 0x53, 0x62, 0x1e, 0xa7, 0x53, 0x99, 0xe1, 0x85, 0xe2, 0x0c,
	0xf7, 0xa0, 0x9d, 0x57, 0xa6, 0x4a, 0xbb, 0x9f, 0xce, 0xe6, 0x78, 0x13, 0x5d, 0xde, 0xda, 0x3b,
	0x9c, 0x80, 0x19, 0xcd, 0xac, 0xb9, 0x7c, 0xc8, 0x36, 0xfe, 0xa4, 0x04, 0xcb, 0x53, 0xd0, 0xc6,
	0x96, 0x55, 0x69, 0x7c, 0x59, 0xdd, 0x9e, 0xd6, 0xd3, 0x32, 0xc5, 0x88, 0x1c, 0xef, 0xe5, 0x1d,
	0x58, 0xc1, 0x78, 0x92, 0x09, 0x63, 0x81, 0x8a, 0x5e, 0x41, 0x74, 0x8c, 0x35, 0x79, 0xc4, 0x58,
	0x90, 0x65, 0xe8, 0xfc, 0xdf, 0x00, 0x35, 0x0c, 0x9a, 0x35, 0xd3, 0xd3, 0x63, 0xda, 0x0d, 0xee,
	0x22, 0x07, 0xac, 0x4c, 0x70, 0xc0, 0x87, 0x00, 0x2e, 0x2f, 0xd4, 0x54, 0xe4, 0xc7, 0x54, 0x4d,
	0x44, 0xd6, 0x4c, 0xbf, 0x28, 0x08, 0xae, 0x2b, 0x7f, 0x4e, 0xf8, 0xdc, 0xcc, 0x4f, 0x3a, 0xf1,
	0xcd, 0x9e, 0xd6, 0x03, 0x68, 0x52, 0xe0, 0x9e, 0xa1, 0xb8, 0x2d, 0xb1, 0x38, 0xf3, 0xf0, 0x2c,
	0x6f, 0xc6, 0x8e, 0xc8, 0x81, 0x2d, 0x69, 0xd8, 0xca, 0x17, 0xba, 0xed, 0xc8, 0xf2, 0xba, 0xa7,
	0x29, 0x93, 0xfa, 0x4b, 0x56, 0xcb, 0x03, 0x0e, 0x9c, 0x2e, 0x61, 0x6b, 0x33, 0x24, 0xec, 0x98,
	0xbf, 0x18, 0x4c, 0xf8, 0x8b, 0x7d, 0x03, 0x75, 0x1a, 0x48, 0x72, 0x45, 0xa1, 0x83, 0x88, 0x0f,
	0xce, 0x1f, 0x49, 0xdc, 0x1b, 0xe1, 0xf1, 0x4e, 0xea, 0x8e, 0x98, 0x41, 0xb3, 0x41, 0xdb, 0xbf,
	0xa9, 0xc1, 0x6d, 0x1b, 0x44, 0x4e, 0xe3, 0xc1, 0x6d, 0x6f, 0xc3, 0x92, 0x38, 0xa2, 0x51, 0x70,
	0x9b, 0x84, 0x4b, 0x09, 0x39, 0xee, 0x98, 0x4b, 0x77, 0x6b, 0xc2, 0xa5, 0x7b, 0x8a, 0x3b, 0x76,
	0x7b, 0x9a, 0x3b, 0x36, 0x5f, 0x0e, 0x81, 0x69, 0x5b, 0xa9, 0xe5, 0x85, 0x3d, 0x71, 0xb1, 0xa8,
	0xe6, 0x06, 0x3b, 0x04, 0xd0, 0xaf, 0xc2, 0x42, 0xdf, 0x75, 0x1c, 0x16, 0xa0, 0x71, 0x35, 0xbb,
	0x27, 0x23, 0x80, 0xfa, 0x57, 0xb0, 0x28, 0x37, 0xed, 0xfa, 0x4c, 0x3d, 0x1f, 0xc7, 0x48, 0x6c,
	0xcd, 0x0d, 0x89, 0xaf, 0x6f, 0x43, 0x43, 0x0c, 0x36, 0xfa, 0xb6, 0xa1, 0x39, 0x75, 0xfa, 0x25,
	0x23, 0x1a, 0x63, 0xc4, 0x32, 0x68, 0x82, 0xe8, 0x43, 0xbf, 0x02, 0xb5, 0x13, 0xd7, 0x13, 0xce,
	0xc2, 0x2b, 0x64, 0xff, 0xe3, 0x00, 0x9c, 0x4c, 0x03, 0x1a, 0x56, 0x6c, 0xf7, 0xdd, 0x94, 0x21,
	0x63, 0xc7, 0xcb, 0x47, 0xad, 0xa9, 0x3b, 0xfe, 0xb1, 0xd9, 0xdc, 0x56, 0x72, 0x19, 0x85, 0x32,
	0x50, 0x5e, 0xbe, 0xe4, 0xcb, 0xa3, 0xe0, 0xe4, 0x79, 0x89, 0xec, 0x3d, 0x98, 0xb2, 0xa3, 0x78,
	0x7a, 0xbe, 0x0f, 0xad, 0xd0, 0x73, 0x4c, 0xea, 0x25, 0x62, 0x5e, 0x26, 0x2d, 0x34, 0xf4, 0x1c,
	0x0a, 0x9d, 0x27, 0xb0, 0x02, 0xf6, 0x52, 0xc5, 0x5a, 0x23, 0xac, 0x80, 0xbd, 0xcc, 0xb1, 0x3e,
	0x83, 0x65, 0xe1, 0x1a, 0xe8, 0x06, 0x22, 0x80, 0xc7, 0x30, 0xf6, 0xf0, 0x4e, 0x52, 0x36, 0x29,
	0x4b, 0x84, 0xb1, 0x27, 0x10, 0x5e, 0xc4, 0xde, 0xf9, 0x6e, 0xa1, 0x1b, 0xe7, 0xba, 0x85, 0x7e,
	0x21, 0x58, 0x16, 0x2e, 0x4b, 0xbe, 0x25, 0x3f, 0x08, 0xf9, 0x4f, 0xed, 0x7b, 0x68, 0x28, 0xd8,
	0x75, 0x13, 0x11, 0x38, 0x93, 0x76, 0xfd, 0x7b, 0x49, 0x48, 0x9f, 0xe5, 0xce, 0x2d, 0x68, 0xa8,
	0x0b, 0x9c, 0x0e, 0xac, 0xfa, 0xd6, 0xbd, 0xcf, 0x3e, 0x17, 0x01, 0x8a, 0x8e, 0xfa, 0xd6, 0xc7,
	0x5a, 0xb9, 0xb3, 0x09, 0x90, 0xaf, 0x22, 0xc4, 0xa2, 0x75, 0x24, 0x4b, 0x0c, 0x2c, 0xfa, 0x2c,
	0x77, 0xee, 0xc3, 0xd2, 0xc4, 0x0c, 0x61, 0x86, 0xdf, 0xfd, 0xf2, 0x73, 0xf3, 0xf3, 0x4f, 0xb5,
	0xef, 0x91, 0x31, 0xe1, 0x70, 0xe7, 0xf3, 0x4f, 0x85, 0x4e, 0x86, 0xbf, 0x9f, 0x3e, 0xd4, 0xca,
	0x9d, 0x6f, 0xa1, 0xa1, 0xd2, 0x21, 0xe7, 0x76, 0x51, 0x1c, 0x3a, 0x43, 0x3b, 0x55, 0x03, 0xa2,
	0xd7, 0x05, 0x0c, 0xf5, 0xd3, 0x0f, 0x30, 0x4c, 0x2e, 0xa2, 0xa8, 0x96, 0xa9, 0x1a, 0x86, 0xc1,
	0xe5, 0x60, 0x51, 0x56, 0xe7, 0x5b, 0xa8, 0x2b, 0x34, 0x3a, 0xc3, 0xe9, 0xb3, 0x34, 0xc3, 0xe9,
	0xf3, 0x2a, 0x80, 0x72, 0xa5, 0x81, 0x2a, 0xa8, 0x25, 0xf2, 0x3a, 0x43, 0xe7, 0xcf, 0x2a, 0xd0,
	0x26, 0x02, 0xf5, 0xa3, 0x30, 0xa6, 0xb8, 0xd1, 0x1a, 0x54, 0x38, 0xae, 0xb8, 0x32, 0x33, 0x8c,
	0xbd, 0xa9, 0xae, 0x9d, 0x95, 0x37, 0x72, 0xed, 0x9c, 0x60, 0xe4, 0x73, 0xdf, 0x35, 0x23, 0x9f,
	0x9f, 0xc6, 0xc8, 0x37, 0x41, 0x1b, 0x46, 0x5e, 0x68, 0x39, 0x66, 0xe0, 0x14, 0x7d, 0x5f, 0x5b,
	0x04, 0x3f, 0x70, 0x04, 0xc3, 0x42, 0x2e, 0x89, 0x98, 0x82, 0x7d, 0x70, 0xfe, 0x47, 0xb7, 0x64,
	0xda, 0x94, 0x40, 0x73, 0xc1, 0x99, 0xe0, 0xa4, 0xf3, 0x67, 0x75, 0x9a, 0xf3, 0xe7, 0x27, 0x32,
	0x0e, 0x40, 0x61, 0x6d, 0x15, 0xa2, 0x82, 0x50, 0x20, 0x80, 0x0b, 0x2d, 0x2d, 0x38, 0x77, 0x69,
	0xfd, 0xbf, 0x73, 0x62, 0x6e, 0x8b, 0x77, 0x8f, 0xff, 0x59, 0x52, 0x0a, 0x1e, 0xf0, 0x62, 0x38,
	0xe1, 0x9d, 0xc4, 0xa1, 0x2f, 0x3c, 0x3f, 0x3b, 0x33, 0x8b, 0xc9, 0x48, 0xd4, 0x50, 0x72, 0xe5,
	0x57, 0x5a, 0x16, 0x2e, 0x7a, 0xa5, 0x45, 0xbd, 0x95, 0xb2, 0xf8, 0x66, 0xb7, 0x52, 0x36, 0xa1,
	0x41, 0xb2, 0x8a, 0xc8, 0x45, 0x5c, 0x94, 0x12, 0xb3, 0x5a, 0xa7, 0x24, 0x6c, 0xbc, 0x2a, 0xcb,
	0x6a, 0x17, 0x94, 0x65, 0xe3, 0xb2, 0x06, 0xde, 0x9a, 0xac, 0xa9, 0xcf, 0x90, 0x35, 0x77, 0x61,
	0xc5, 0xb6, 0x52, 0xd6, 0x0b, 0x63, 0x97, 0x25, 0xca, 0x11, 0x5d, 0x03, 0x89, 0x50, 0xcf, 0xd3,
	0xe4, 0x51, 0x5d, 0xe7, 0x6f, 0x96, 0x61, 0x65, 0x3c, 0xdc, 0x2b, 0x52, 0x60, 0xc1, 0x83, 0x21,
	0x3b, 0x62, 0xce, 0x6f, 0x17, 0x95, 0x2f, 0x7e, 0xbb, 0x28, 0xa3, 0x80, 0xca, 0x6f, 0x43, 0x01,
	0x73, 0x6f, 0x46, 0x01, 0xc5, 0x95, 0x32, 0x3f, 0xb1, 0x52, 0x8a, 0xd7, 0x68, 0x16, 0xc6, 0xaf,
	0xd1, 0xfc, 0x4b, 0x25, 0x68, 0x2b, 0xd1, 0x0f, 0x71, 0x88, 0x9e, 0x43, 0xcd, 0xc6, 0xaf, 0xfc,
	0x08, 0xe4, 0x8b, 0xf1, 0xd3, 0x0a, 0x25, 0x8f, 0x38, 0xb1, 0x50, 0x20, 0x7b, 0x99, 0x3d, 0xc6,
	0xa8, 0xda, 0x02, 0x82, 0x31, 0xec, 0xa9, 0xd4, 0x84, 0xd9, 0x31, 0x4b, 0xe5, 0x0b, 0x29, 0x04,
	0x3c, 0x42, 0x58, 0xe7, 0xdf, 0x59, 0x84, 0xd5, 0x89, 0x68, 0xbf, 0xdf, 0x29, 0xe7, 0xd8, 0x55,
	0xe3, 0x11, 0xcc, 0xe1, 0xde, 0x6c, 0x9a, 0x0e, 0x3c, 0x8d, 0x76, 0x94, 0xc8, 0x04, 0x57, 0xb3,
	0x2b, 0x5e, 0x85, 0x18, 0x63, 0xca, 0xcd, 0xc2, 0xc9, 0x9b, 0x14, 0xc4, 0xf0, 0xdb, 0xee, 0xd8,
	0x25, 0x8a, 0x1f, 0xc3, 0x95, 0xcc, 0xdd, 0x88, 0xb8, 0x69, 0x1a, 0xc6, 0xa6, 0xfb, 0xab, 0x20,
	0xdf, 0x3e, 0xd6, 0x8c, 0x35, 0x89, 0xb2, 0x27, 0x31, 0xf6, 0x7e, 0x15, 0x88, 0xe0, 0x41, 0xb3,
	0xe2, 0x03, 0x54, 0x67, 0xc7, 0x07, 0x28, 0x12, 0x45, 0x6d, 0x8c, 0x28, 0xf8, 0x54, 0x89, 0x86,
	0x8b, 0xa9, 0x22, 0x8b, 0x55, 0x83, 0x80, 0x34, 0x55, 0xfa, 0x16, 0x2c, 0x17, 0xfa, 0x48, 0xe6,
	0x51, 0x61, 0xc2, 0x5a, 0x52, 0x7a, 0x79, 0x88, 0x09, 0xfa, 0x09, 0x68, 0x72, 0xfe, 0x33, 0xbf,
	0x72, 0xba, 0x2a, 0xf6, 0xa3, 0x99, 0xe3, 0x3f, 0x46, 0x04, 0x5b, 0x63, 0x94, 0xca, 0x07, 0xc0,
	0x68, 0xd9, 0x85, 0x6f, 0xdd, 0x02, 0x0d, 0xd5, 0xe6, 0xe4, 0x34, 0x49, 0x99, 0xaf, 0x7a, 0xee,
	0x7e, 0xf1, 0xda, 0xf5, 0x3c, 0x72, 0x3d, 0x76, 0x84, 0xf9, 0x51, 0x62, 0xb4, 0x4e, 0x0a, 0xdf,
	0x7c, 0xca, 0x50, 0x44, 0x77, 0x2d, 0xcf, 0x0a, 0xe8, 0xd6, 0xb6, 0x85, 0x51, 0x47, 0x31, 0xc8,
	0xaf, 0x88, 0x0e, 0xb4, 0xc6, 0x51, 0x1e, 0x10, 0x86, 0x0c, 0x0f, 0x8d, 0xe9, 0xea, 0x75, 0xef,
	0x1e, 0xf1, 0x3d, 0xad, 0x70, 0xdd, 0xbb, 0x27, 0x35, 0x27, 0xe2, 0x2f, 0x8e, 0xd9, 0x3d, 0x15,
	0xf7, 0x3b, 0x6b, 0x02, 0xf2, 0xe0, 0x74, 0xe3, 0x18, 0x96, 0xa7, 0x8c, 0x86, 0xfe, 0x53, 0xa8,
	0xe5, 0xc3, 0x5b, 0x9a, 0x79, 0x25, 0x7b, 0x2c, 0xab, 0x51, 0x4d, 0x44, 0x01, 0x9d, 0xef, 0x43,
	0xab, 0xd8, 0xfb, 0xc2, 0x19, 0xdf, 0xf7, 0x50, 0xb5, 0x7d, 0xf8, 0x2a, 0xfd, 0x54, 0x2b, 0x75,
	0xfe, 0x5a, 0xc6, 0x63, 0xf3, 0x48, 0xd4, 0x17, 0x5a, 0xab, 0x53, 0x97, 0x49, 0x65, 0xfa, 0x32,
	0x99, 0xa0, 0xc9, 0xb9, 0xd7, 0xa7, 0xc9, 0xf9, 0x59, 0x34, 0x79, 0xce, 0x44, 0x2e, 0x9d, 0x33,
	0x91, 0xc5, 0x29, 0xd2, 0xc7, 0xa6, 0xa8, 0xf3, 0x7f, 0xcc, 0xd3, 0xb3, 0x49, 0xdf, 0xa9, 0x39,
	0x44, 0x31, 0x52, 0xcc, 0xbd, 0x86, 0x3d, 0x7e, 0x7e, 0x86, 0xb5, 0xa0, 0x03, 0x4d, 0xbb, 0xe0,
	0xa8, 0xb4, 0x20, 0x74, 0x6a, 0xc5, 0x51, 0xa9, 0x03, 0x4d, 0x9f, 0xf9, 0x0a, 0x8e, 0xb8, 0xad,
	0xed, 0x33, 0x3f, 0xc3, 0x79, 0x06, 0xed, 0xfc, 0x12, 0x8c, 0xa9, 0x78, 0x41, 0xbf, 0xee, 0xad,
	0xa1, 0x56, 0xbf, 0x00, 0x44, 0x2f, 0xd5, 0x68, 0x68, 0x9e, 0x30, 0x8b, 0xeb, 0x09, 0x44, 0xc7,
	0x35, 0xe4, 0x81, 0x2d, 0x3b, 0x1a, 0x3e, 0x22, 0xb0, 0x0c, 0xc1, 0x91, 0x37, 0x8f, 0x94, 0x6f,
	0x8a, 0xb5, 0xd2, 0x94, 0x0d, 0x24, 0xe5, 0x5b, 0xbd, 0x0f, 0x53, 0x7f, 0xfd, 0xfb, 0x30, 0x9f,
	0xc1, 0x65, 0xab, 0xd7, 0x8b, 0x59, 0x8f, 0x82, 0x56, 0xa8, 0xe3, 0xd0, 0xc0, 0x6a, 0x56, 0xb2,
	0xe4, 0x7d, 0x65, 0x40, 0x3e, 0x83, 0xcb, 0x31, 0xeb, 0x0d, 0x3d, 0x2b, 0x36, 0x23, 0xa9, 0xc0,
	0x8b, 0xd6, 0x35, 0x29, 0x9b, 0x48, 0x3e, 0x14, 0x6a, 0x7c, 0xb6, 0x43, 0xe8, 0x0f, 0x7b, 0x2c,
	0xcf, 0x32, 0xe8, 0x0a, 0xb3, 0x47, 0x4b, 0xc2, 0x39, 0xf2, 0xd7, 0x5d, 0xce, 0xf0, 0x25, 0x24,
	0x31, 0xf1, 0x8d, 0x2f, 0x6c, 0xdd, 0xa0, 0x2b, 0x7c, 0xcd, 0x96, 0xb3, 0xd4, 0xe7, 0x3c, 0x71,
	0x9f, 0xf9, 0x5f, 0x77, 0xf5, 0x8f, 0x61, 0x35, 0xcf, 0x34, 0x4c, 0x98, 0x23, 0xf3, 0x68, 0x98,
	0x47, 0xcf, 0x12, 0x5f, 0x24, 0xcc, 0xa1, 0x2c, 0x5f, 0xc2, 0xba, 0xda, 0x91, 0x62, 0xb6, 0x25,
	0xcc, 0xb6, 0xaa, 0x74, 0x25, 0xcf, 0xd9, 0xf9, 0xcd, 0x22, 0x2c, 0x72, 0xba, 0x7f, 0x1c, 0x0d,
	0xf5, 0x75, 0x1a, 0xfc, 0xcc, 0xc3, 0xb1, 0x86, 0x03, 0x2c, 0x5f, 0xc4, 0x20, 0xff, 0x43, 0xd5,
	0x53, 0x03, 0x08, 0x74, 0x20, 0x62, 0x3b, 0xe6, 0x9e, 0x8e, 0xb4, 0x12, 0x72, 0x4f, 0xc7, 0x73,
	0x7d, 0x16, 0xa5, 0x73, 0xe2, 0xbc, 0xe2, 0x9c, 0x98, 0xfb, 0x31, 0x12, 0xb9, 0x0b, 0x3f, 0xc6,
	0x09, 0x9f, 0xc5, 0x9a, 0xe2, 0xb3, 0x78, 0x19, 0x16, 0xf1, 0x66, 0x92, 0xd8, 0x5e, 0xd5, 0x8c,
	0x05, 0xfe, 0x49, 0xcf, 0x84, 0x04, 0x52, 0x7c, 0xf2, 0xd5, 0xcb, 0x91, 0xd7, 0x60, 0x51, 0x28,
	0xb4, 0xf2, 0x19, 0x1b, 0xf1, 0xa9, 0xde, 0x9d, 0x55, 0x5e, 0x5c, 0x92, 0x77, 0x67, 0xb1, 0xc5,
	0xb3, 0x5c, 0xf1, 0x1a, 0x33, 0x5d, 0xf1, 0xbe, 0x82, 0x75, 0xf4, 0x7a, 0x14, 0x47, 0x3c, 0x45,
	0x7f, 0x41, 0x22, 0xb7, 0x4b, 0xc1, 0xd0, 0xcf, 0x1f, 0xdc, 0xc8, 0xdd, 0x06, 0x6f, 0x42, 0xcb,
	0xb7, 0x5e, 0x99, 0xb9, 0x5f, 0x20, 0x92, 0x5b, 0xcd, 0x68, 0xfa, 0xd6, 0x2b, 0x23, 0x03, 0xea,
	0x1b, 0x50, 0xcd, 0x1c, 0x15, 0x89, 0xbe, 0xb2, 0x6f, 0x4e, 0xea, 0xe8, 0xeb, 0x67, 0x0a, 0x4f,
	0x40, 0x85, 0xd4, 0x89, 0xac, 0x56, 0x30, 0xf9, 0x01, 0xa6, 0xe6, 0xa4, 0x7e, 0x03, 0x1a, 0xc2,
	0xf7, 0x8f, 0xd6, 0xe4, 0x12, 0xae, 0xee, 0xba, 0x80, 0x49, 0xe7, 0x7f, 0x4e, 0x35, 0x59, 0xc4,
	0x02, 0xa2, 0x9a, 0xfd, 0x49, 0x17, 0xd2, 0x65, 0xb2, 0x0c, 0x2a, 0x2e, 0xa4, 0x33, 0x1c, 0x41,
	0x57, 0xb2, 0xf8, 0x2c, 0xe7, 0x3b, 0x82, 0xae, 0xd2, 0xba, 0x1b, 0x73, 0x04, 0xcd, 0x36, 0x0e,
	0x97, 0x24, 0xe9, 0xf0, 0x8d, 0x03, 0x27, 0x9d, 0xd0, 0x11, 0x44, 0x78, 0x59, 0x90, 0x4e, 0xe8,
	0x10, 0x09, 0x8e, 0x7b, 0x14, 0xae, 0x61, 0x4f, 0x55, 0x8f, 0xc2, 0x1b, 0xd0, 0x40, 0x1f, 0xbf,
	0x28, 0x0e, 0xb9, 0x8e, 0x81, 0x16, 0xaf, 0x9a, 0x51, 0xe7, 0xb0, 0x43, 0x02, 0xe9, 0x37, 0xa0,
	0x69, 0x5a, 0xb1, 0x9b, 0xf6, 0xfd, 0x30, 0x31, 0x5d, 0xc7, 0x94, 0x6e, 0x87, 0xdb, 0x02, 0x86,
	0x21, 0x33, 0x2e, 0xe6, 0x76, 0xd8, 0xf9, 0xab, 0x62, 0x85, 0x1e, 0xb8, 0x36, 0xe7, 0x27, 0xe2,
	0x68, 0xd0, 0xef, 0xf9, 0x13, 0x6e, 0x69, 0x35, 0x63, 0x99, 0x52, 0xf7, 0x7b, 0xbe, 0xe2, 0x98,
	0xf6, 0x25, 0xac, 0x89, 0x4c, 0x59, 0x1c, 0xdd, 0xc8, 0xb3, 0xd2, 0x93, 0x30, 0xf6, 0xc5, 0x42,
	0x16, 0x85, 0x3e, 0x11, 0xc9, 0x87, 0x22, 0x15, 0x95, 0x1f, 0xca, 0x89, 0xa1, 0xa9, 0xb2, 0x95,
	0xdd, 0x20, 0xe8, 0x61, 0x18, 0xf3, 0xb5, 0xd5, 0x81, 0xa6, 0xc0, 0x72, 0xd8, 0x48, 0xde, 0xb9,
	0xaf, 0x19, 0x75, 0x19, 0x68, 0x7e, 0xb4, 0xe7, 0xf0, 0xa1, 0xc7, 0x22, 0x70, 0xe8, 0x69, 0x95,
	0x57, 0x39, 0x00, 0x87, 0x7e, 0xec, 0xd4, 0x68, 0x41, 0x3c, 0x08, 0x98, 0x9f, 0x1a, 0xdd, 0x84,
	0x96, 0x1b, 0x8d, 0x3e, 0x97, 0x18, 0x2c, 0x11, 0x9a, 0x76, 0x93, 0x43, 0xb7, 0x25, 0x50, 0xa0,
	0x7d, 0xaa, 0xa0, 0x55, 0x33, 0xb4, 0x4f, 0x73, 0xb4, 0x1f, 0x80, 0xee, 0xb8, 0x89, 0xf4, 0xc9,
	0x8a, 0xc3, 0x34, 0xb4, 0x43, 0x4f, 0x70, 0x86, 0xa5, 0x2c, 0xe5, 0x50, 0x24, 0xe0, 0xa3, 0x4d,
	0x7d, 0x3b, 0x12, 0x71, 0x8b, 0x1c, 0x21, 0xb7, 0xea, 0x1c, 0x46, 0xd1, 0x8a, 0x1c, 0x65, 0x9c,
	0xe8, 0xb6, 0x86, 0x23, 0x02, 0x84, 0x89, 0x71, 0xc2, 0xbb, 0x1a, 0x39, 0x0f, 0x6a, 0x28, 0x3c,
	0x48, 0x61, 0x58, 0xcd, 0x02, 0xc3, 0x1a, 0x7b, 0x6a, 0xb3, 0x35, 0xf1, 0xd4, 0x26, 0x46, 0x72,
	0x4b, 0x87, 0x62, 0x0d, 0x8b, 0xe5, 0xee, 0xa7, 0x43, 0x5a, 0xb7, 0x97, 0x60, 0x41, 0x3c, 0xa7,
	0x45, 0x91, 0x49, 0xc4, 0x17, 0x97, 0xc3, 0xe8, 0x38, 0x94, 0x44, 0x8c, 0x39, 0xe6, 0xa0, 0x1b,
	0x25, 0x42, 0x3c, 0x34, 0x39, 0xf8, 0x88, 0x43, 0xbf, 0xee, 0x46, 0x68, 0xd4, 0x57, 0x8f, 0xcc,
	0x69, 0x5d, 0x83, 0x72, 0x62, 0x7e, 0x0b, 0xda, 0x92, 0x12, 0xe5, 0xb5, 0x99, 0x65, 0x71, 0x41,
	0x9c, 0x48, 0x50, 0x5c, 0x9e, 0xd9, 0x04, 0x4d, 0x25, 0x21, 0x2c, 0x6d, 0x85, 0xac, 0x69, 0x39,
	0x11, 0x1d, 0x08, 0x05, 0x53, 0xc5, 0xc4, 0xae, 0xe2, 0xf2, 0xae, 0x19, 0xed, 0x1c, 0x75, 0x97,
	0x83, 0xb9, 0x82, 0x89, 0xdd, 0xe0, 0xbb, 0x28, 0xdb, 0x4d, 0x4f, 0xc5, 0x3a, 0x6f, 0x70, 0xe0,
	0x8e, 0x80, 0x65, 0x48, 0x0e, 0x4b, 0xe9, 0xf2, 0xc5, 0x65, 0xbc, 0x0e, 0x84, 0x48, 0xbb, 0x02,
	0xc6, 0xf9, 0x62, 0xb1, 0x7d, 0xa9, 0x3b, 0xa2, 0x4b, 0x37, 0x68, 0xfc, 0xae, 0x19, 0x2b, 0x6a,
	0x33, 0x79, 0x22, 0x9f, 0xcd, 0xce, 0x3f, 0x06, 0x68, 0x15, 0xdf, 0x61, 0xe2, 0x74, 0x82, 0xd4,
	0x27, 0x5d, 0x4d, 0x84, 0x19, 0x97, 0xc3, 0x1e, 0x13, 0x88, 0x8f, 0x2a, 0xa2, 0x88, 0xe3, 0x64,
	0x21, 0x45, 0x39, 0x48, 0x1c, 0x25, 0x5f, 0x86, 0x45, 0x49, 0x41, 0xb4, 0xd2, 0x16, 0x46, 0x39,
	0xed, 0x8c, 0xbf, 0xc6, 0xfa, 0xc1, 0xa4, 0x3a, 0x47, 0x2b, 0x6b, 0x5c, 0x4d, 0x23, 0xff, 0xfb,
	0x85, 0xcc, 0xff, 0x1e, 0xc3, 0x93, 0x05, 0x56, 0x8f, 0x39, 0xf9, 0x01, 0x19, 0x86, 0x27, 0x43,
	0x58, 0x76, 0x02, 0xa7, 0x1a, 0x7b, 0xaa, 0x05, 0x09, 0x98, 0x85, 0x34, 0x50, 0x85, 0x64, 0x6d,
	0x52, 0x48, 0x4e, 0xb0, 0x43, 0x98, 0x60, 0x87, 0x93, 0x4e, 0x0f, 0x8a, 0xc4, 0x2d, 0x3a, 0x3d,
	0x60, 0x91, 0xeb, 0x50, 0x8d, 0x02, 0xd7, 0x36, 0x83, 0xa1, 0x54, 0xed, 0x16, 0xf9, 0xf7, 0xc1,
	0xd0, 0x57, 0x68, 0x56, 0xf1, 0x9b, 0x10, 0x34, 0x2b, 0x9d, 0x10, 0x68, 0xe4, 0xf3, 0x8d, 0x26,
	0x47, 0x40, 0x10, 0xf6, 0xfa, 0x78, 0x8a, 0x3b, 0x55, 0x7b, 0xf6, 0x75, 0xea, 0xc2, 0xfc, 0x9f,
	0xe5, 0x54, 0xf5, 0xcd, 0x98, 0x53, 0x95, 0x86, 0x65, 0xde, 0x39, 0xbf, 0xcc, 0x0b, 0xbb, 0x56,
	0x2d, 0x09, 0x2e, 0x36, 0xee, 0x5a, 0x75, 0x9e, 0x6f, 0x8a, 0xb8, 0x79, 0x30, 0xd3, 0x37, 0xa5,
	0xb8, 0xd3, 0x59, 0x9e, 0xd8, 0xe9, 0xdc, 0x85, 0x95, 0x71, 0xf7, 0x8d, 0xec, 0x28, 0xac, 0x66,
	0xe8, 0x45, 0x07, 0x8e, 0xb1, 0xe0, 0x23, 0x81, 0x95, 0x66, 0xcc, 0x75, 0x95, 0x7c, 0x78, 0x44,
	0x90, 0x09, 0x2b, 0x95, 0x1c, 0xf6, 0xc7, 0x70, 0xc5, 0x1a, 0x59, 0xae, 0x27, 0x1e, 0xc0, 0x30,
	0x7f, 0x1d, 0x06, 0x4c, 0x11, 0xd6, 0x97, 0xc8, 0xf0, 0xa2, 0xa2, 0x7c, 0x1b, 0x06, 0x2c, 0x13,
	0xdd, 0x33, 0x5c, 0x6b, 0x2e, 0xcf, 0x70, 0xad, 0xc1, 0x85, 0x9a, 0xe4, 0x51, 0x72, 0x28, 0x7c,
	0x2d, 0xb8, 0x49, 0x16, 0x15, 0xe2, 0x0e, 0x2c, 0x5b, 0xce, 0x88, 0x4b, 0xe9, 0xec, 0xba, 0x9c,
	0x1b, 0xf4, 0xe8, 0x10, 0xcc, 0xd0, 0x65, 0xd2, 0x41, 0x96, 0xa2, 0x7f, 0x01, 0x6b, 0x31, 0xbd,
	0xe2, 0xa3, 0xba, 0x87, 0xe7, 0x27, 0x5f, 0x35, 0xae, 0xa0, 0x53, 0xfa, 0x5e, 0xc1, 0x79, 0xe0,
	0xdf, 0x2c, 0xcd, 0xf0, 0x51, 0x53, 0x1f, 0xcf, 0x25, 0x10, 0x2e, 0x90, 0x4d, 0xd0, 0x54, 0x1f,
	0x35, 0x33, 0x49, 0x63, 0x79, 0x56, 0xa4, 0xf8, 0xa9, 0x1d, 0xa5, 0xf1, 0xb8, 0xbb, 0x5b, 0xe5,
	0x5c, 0x77, 0xb7, 0xb9, 0x37, 0x75, 0x77, 0xab, 0x9d, 0xef, 0xee, 0x56, 0x2b, 0xb8, 0xbb, 0xfd,
	0xe3, 0x12, 0x34, 0x0b, 0xaf, 0xd1, 0xf1, 0x75, 0x8f, 0x82, 0x32, 0x70, 0x6d, 0x34, 0x95, 0xd4,
	0x0c, 0x14, 0x9c, 0x5c, 0x29, 0x9a, 0xc2, 0x07, 0xcb, 0x53, 0xf9, 0xa0, 0x64, 0xa2, 0x15, 0x85,
	0x89, 0x4a, 0xa1, 0x3c, 0xa7, 0x08, 0xe5, 0x82, 0x64, 0x9d, 0x1f, 0x93, 0xac, 0x1f, 0x40, 0x5b,
	0x92, 0x92, 0x98, 0x78, 0xf4, 0xb8, 0xac, 0x19, 0xad, 0x51, 0x51, 0x1e, 0x88, 0x2b, 0x81, 0x29,
	0xb3, 0x7c, 0xa1, 0xae, 0x2c, 0x06, 0xae, 0xfd, 0x9c, 0x59, 0x7e, 0xe7, 0x7f, 0x2c, 0xc1, 0xe2,
	0x01, 0xfd, 0x3e, 0xab, 0x63, 0xb7, 0xa0, 0x4d, 0x07, 0x8e, 0x66, 0x86, 0x51, 0x26, 0x85, 0x86,
	0xc0, 0x52, 0x2b, 0xc4, 0xb7, 0x2f, 0x93, 0xa4, 0x80, 0x58, 0xa1, 0x36, 0x09, 0xb8, 0xc4, 0xd4,
	0x15, 0xcf, 0xbe, 0x5a, 0x1e, 0x04, 0x44, 0xd1, 0xca, 0x8a, 0xa3, 0xb2, 0xa0, 0x8c, 0xca, 0x35,
	0xa8, 0x7b, 0x16, 0xe7, 0x38, 0xa4, 0x57, 0x90, 0xd0, 0x00, 0x0e, 0xa2, 0x87, 0x6f, 0x3a, 0xff,
	0xc9, 0x02, 0x2c, 0xc9, 0x37, 0xb0, 0x62, 0xbe, 0x1d, 0xfb, 0x8b, 0x6a, 0x4b, 0xe1, 0x33, 0x37,
	0xf4, 0x4d, 0x8c, 0x9f, 0xbb, 0x48, 0x81, 0x6b, 0x82, 0xa1, 0xbf, 0x13, 0x0d, 0xd1, 0x31, 0x42,
	0xc4, 0x27, 0x54, 0x36, 0x50, 0x55, 0x11, 0xa7, 0x10, 0x13, 0xf2, 0xbd, 0xd3, 0x14, 0x9b, 0x47,
	0x8d, 0xc2, 0x8e, 0x16, 0x6d, 0x1e, 0xbc, 0x49, 0x23, 0xdf, 0xcc, 0x63, 0xf6, 0xd6, 0x45, 0x88,
	0x99, 0x91, 0x7f, 0x20, 0xc3, 0xf6, 0x7e, 0x0c, 0xab, 0x1c, 0x67, 0xb2, 0x6e, 0x0a, 0xf6, 0xa5,
	0xdb, 0x23, 0x11, 0x1f, 0x31, 0xaf, 0x7e, 0x1d, 0xaa, 0xb6, 0x74, 0x23, 0xa7, 0x48, 0x09, 0x8b,
	0xb6, 0xf0, 0x23, 0xbf, 0x0e, 0xf5, 0x24, 0x7f, 0xe1, 0x5b, 0xc4, 0xeb, 0x52, 0x41, 0x7c, 0xa3,
	0xc1, 0xdb, 0x9e, 0xd0, 0x5b, 0x68, 0xe3, 0xbb, 0xc5, 0x39, 0x63, 0xd9, 0x67, 0xbe, 0x78, 0x28,
	0x2d, 0xaf, 0x51, 0xec, 0x70, 0x33, 0x3e, 0xa7, 0x94, 0x40, 0x92, 0x69, 0x0e, 0x77, 0xb8, 0xe2,
	0x35, 0x33, 0x67, 0x3f, 0x2b, 0x22, 0xcb, 0x4a, 0x7b, 0xc3, 0xf1, 0xac, 0x7a, 0x96, 0x75, 0x5b,
	0xa4, 0xab, 0x59, 0xbf, 0x84, 0x75, 0xbe, 0xa1, 0xe2, 0x39, 0xfa, 0x56, 0x5e, 0x39, 0xb5, 0x76,
	0x19, 0xb3, 0xae, 0xfa, 0xd6, 0xab, 0x7d, 0xe6, 0x3f, 0xb1, 0x64, 0xd5, 0xd4, 0xde, 0x8f, 0x40,
	0xe7, 0xb9, 0xb2, 0x4a, 0x29, 0xcb, 0x0a, 0x66, 0xd1, 0x7c, 0x96, 0xd5, 0x36, 0x69, 0x9a, 0x5a,
	0x7d, 0x7d, 0xd3, 0xd4, 0x2d, 0x68, 0xa3, 0xe0, 0x57, 0x86, 0x50, 0x44, 0x57, 0xe7, 0xe0, 0x6c,
	0xf0, 0x3a, 0x21, 0x2c, 0xe5, 0x26, 0xb7, 0x63, 0x7f, 0xcf, 0xd9, 0xb7, 0xa2, 0xd9, 0x37, 0x01,
	0x8a, 0x3c, 0x6f, 0xe4, 0xe7, 0x57, 0xab, 0xfa, 0x4a, 0x21, 0x45, 0x97, 0xe0, 0x4a, 0x61, 0xd9,
	0x74, 0xbe, 0x85, 0x1a, 0x05, 0x2b, 0xe5, 0x15, 0x5d, 0x83, 0xba, 0xa2, 0xa8, 0x49, 0xb1, 0x62,
	0xe5, 0x7a, 0x9a, 0x5c, 0xc6, 0xe5, 0xe9, 0xee, 0xc6, 0x63, 0x65, 0xdb, 0xa0, 0x2b, 0x0f, 0x87,
	0xbe, 0xa5, 0x4a, 0xba, 0xb0, 0x24, 0xd5, 0x25, 0xba, 0x6a, 0xfd, 0x56, 0xeb, 0x78, 0x4c, 0x97,
	0xf9, 0xde, 0x52, 0x1d, 0xbe, 0x7a, 0x73, 0xe1, 0x2d, 0xd4, 0x61, 0x42, 0x0b, 0x29, 0xf3, 0xad,
	0x75, 0xa2, 0x07, 0x97, 0x78, 0x05, 0x87, 0xfd, 0xd3, 0x84, 0x33, 0xdc, 0xb7, 0x37, 0x23, 0x27,
	0xb0, 0xca, 0x2b, 0x7a, 0xeb, 0x33, 0x7f, 0x02, 0xab, 0x45, 0x65, 0xfc, 0x2d, 0xd5, 0xc3, 0x60,
	0x45, 0x2e, 0x95, 0x2c, 0xb8, 0xe4, 0x5b, 0xa8, 0xe6, 0x97, 0xd0, 0x30, 0x22, 0xfb, 0x88, 0xfd,
	0x4a, 0x04, 0x1c, 0xbc, 0x01, 0x0d, 0xce, 0x0a, 0x33, 0x9b, 0xac, 0xd8, 0xad, 0x0a, 0x18, 0x6a,
	0x92, 0x57, 0x01, 0x12, 0xf6, 0x2b, 0x19, 0xc0, 0x90, 0xfc, 0x78, 0x6a, 0x49, 0x56, 0xc2, 0xec,
	0xba, 0x02, 0x68, 0xbf, 0x08, 0x28, 0x02, 0x71, 0xca, 0x1c, 0xce, 0x01, 0xd0, 0x3c, 0xec, 0x26,
	0x03, 0xd5, 0xb6, 0x8c, 0x07, 0xb4, 0xa8, 0x97, 0xbd, 0x8f, 0x01, 0x85, 0xd5, 0xe7, 0xb8, 0xcb,
	0xe8, 0x2b, 0xd0, 0x90, 0x9e, 0x49, 0xc8, 0x48, 0x67, 0xd7, 0xf7, 0x37, 0x4b, 0xd0, 0xce, 0x14,
	0x8f, 0xc3, 0xd0, 0x73, 0xed, 0xd3, 0xce, 0xbb, 0x50, 0xfb, 0x66, 0x68, 0x79, 0x74, 0xd1, 0x60,
	0x09, 0x9a, 0x83, 0x47, 0x6e, 0x9a, 0x64, 0xcf, 0x6a, 0x96, 0x3a, 0x31, 0x54, 0xb3, 0x18, 0xef,
	0xeb, 0xb0, 0x3a, 0x78, 0x64, 0x8d, 0xc2, 0xf8, 0x29, 0xb3, 0x92, 0xf4, 0x69, 0x68, 0x39, 0xcc,
	0x11, 0xaf, 0x34, 0xeb, 0xd0, 0xa2, 0xa4, 0x2c, 0x6b, 0x19, 0xdf, 0x8c, 0x44, 0xd8, 0x93, 0xd3,
	0x6e, 0xec, 0x12, 0x66, 0x05, 0x5f, 0x36, 0x24, 0xa8, 0xdb, 0xeb, 0xb3, 0x24, 0x1d, 0x3d, 0x3e,
	0x7c, 0xf1, 0x22, 0x75, 0x3d, 0xf7, 0xd7, 0xa2, 0xb0, 0xb9, 0xce, 0x7f, 0x5c, 0x85, 0x06, 0x3d,
	0x7b, 0x7a, 0xc6, 0x9b, 0x39, 0xaa, 0xf2, 0x51, 0x2e, 0x2a, 0x1f, 0x7c, 0xdf, 0x4e, 0x0a, 0x00,
	0xc9, 0x11, 0x8a, 0xed, 0x5f, 0x27, 0x18, 0x09, 0xa9, 0x9f, 0xc0, 0x02, 0x39, 0xd5, 0x0b, 0x17,
	0x85, 0xa9, 0x01, 0xbb, 0x95, 0x26, 0xc8, 0xd7, 0xaf, 0x45, 0x2e, 0x7d, 0x13, 0x9a, 0xe1, 0xc0,
	0x4c, 0x43, 0x33, 0x66, 0xb6, 0x67, 0xb9, 0xbe, 0x78, 0x62, 0x8b, 0x42, 0xb6, 0xd4, 0xc3, 0xc1,
	0xf3, 0xd0, 0xa0, 0x04, 0xbe, 0xa1, 0x89, 0x62, 0xae, 0x70, 0xa6, 0x91, 0x37, 0xec, 0x99, 0x85,
	0x86, 0x91, 0xd2, 0xb4, 0x1a, 0xc5, 0xec, 0x09, 0x25, 0xef, 0x2b, 0x4d, 0xfc, 0x04, 0x2e, 0xa9,
	0x19, 0x31, 0xe0, 0xb6, 0x1d, 0x0e, 0x83, 0x54, 0xe8, 0x51, 0xcb, 0x79, 0x36, 0xae, 0xfb, 0xec,
	0xf0, 0x24, 0x7d, 0x13, 0x1a, 0xf8, 0x48, 0xb8, 0x54, 0x09, 0x0a, 0x1e, 0x51, 0xf5, 0x61, 0xc2,
	0x32, 0x75, 0x60, 0x4a, 0xd0, 0x78, 0x78, 0x93, 0xa0, 0xf1, 0xbf, 0x03, 0x4d, 0x19, 0xf7, 0x9e,
	0x5e, 0xd4, 0xaa, 0xcf, 0xf4, 0xf9, 0xa0, 0x31, 0x94, 0x14, 0x82, 0x67, 0xb4, 0x0d, 0x4b, 0xf9,
	0xd2, 0x7f, 0x00, 0xba, 0x6c, 0xb9, 0xa2, 0xa2, 0x92, 0xf9, 0x62, 0x49, 0xa6, 0xe4, 0x3a, 0xea,
	0x0d, 0x68, 0xe0, 0xa3, 0x04, 0x61, 0xaa, 0x06, 0x0d, 0xa9, 0xf7, 0xad, 0x43, 0x09, 0xd2, 0xbf,
	0x81, 0x5b, 0x76, 0x1c, 0x26, 0x49, 0xee, 0xf0, 0xa5, 0xbc, 0x1b, 0x63, 0xba, 0x81, 0x29, 0x9f,
	0xc7, 0x17, 0xca, 0xdd, 0x0d, 0x7b, 0xfa, 0x8b, 0x98, 0x7b, 0xc1, 0xa1, 0x40, 0xcc, 0x9e, 0x8d,
	0x08, 0x5c, 0x9b, 0xec, 0x89, 0xe2, 0xd9, 0x08, 0xfe, 0xcd, 0xf5, 0x4f, 0x75, 0xd2, 0x72, 0x44,
	0x52, 0x07, 0xf5, 0x7c, 0xce, 0x0e, 0x64, 0x96, 0xa9, 0x81, 0xca, 0x97, 0x66, 0x04, 0x2a, 0xff,
	0x1c, 0x2e, 0xdb, 0xf2, 0x25, 0x64, 0xa7, 0x48, 0x4c, 0xa4, 0xfd, 0xad, 0xe6, 0xc9, 0x2a, 0x31,
	0x7d, 0xca, 0x89, 0x49, 0x0c, 0x4a, 0x31, 0x1b, 0x69, 0x7e, 0x2b, 0x59, 0xaa, 0x92, 0x6b, 0xe3,
	0x5f, 0xc9, 0x5f, 0x64, 0x9f, 0xb6, 0x3d, 0x39, 0x9c, 0xf6, 0x7e, 0xfc, 0xed, 0xd7, 0x5b, 0x49,
	0x78, 0x17, 0xaa, 0x32, 0x38, 0xde, 0xbf, 0xd0, 0x83, 0xf2, 0x9d, 0xeb, 0x00, 0x79, 0x7e, 0xf9,
	0x36, 0x3c, 0xf9, 0xa6, 0x3e, 0xb5, 0x92, 0x54, 0x2b, 0x77, 0xfe, 0x76, 0x05, 0xaa, 0xd9, 0x53,
	0x60, 0x0f, 0x61, 0x21, 0x42, 0x3e, 0x27, 0x22, 0x91, 0x74, 0xce, 0x78, 0xbf, 0x61, 0x8b, 0x38,
	0xe2, 0xfd, 0x5a, 0xfe, 0x4e, 0xb3, 0xc8, 0xac, 0xef, 0x03, 0xd8, 0x61, 0x90, 0xa4, 0xb1, 0xe5,
	0x06, 0xa9, 0xe8, 0xe7, 0xad, 0xb3, 0x8a, 0xda, 0xc9, 0xb0, 0xef, 0xcf, 0x0f, 0xf6, 0x87, 0x49,
	0x6a, 0x28, 0x05, 0x70, 0x81, 0x91, 0xc5, 0x05, 0xa4, 0x7b, 0xcd, 0x0d, 0xa3, 0x26, 0xe3, 0x2a,
	0x26, 0xbc, 0x36, 0x8f, 0xf5, 0x2c, 0xfb, 0xd4, 0xb4, 0x4f, 0xa4, 0x0b, 0xd5, 0xd6, 0x59, 0xb5,
	0x3d, 0x45, 0x6c, 0xbe, 0x77, 0xcd, 0x5a, 0x5e, 0xa3, 0x12, 0x76, 0x4e, 0x7a, 0x1b, 0x7b, 0xa0,
	0x4f, 0x22, 0x70, 0x2a, 0xce, 0xc5, 0x48, 0x09, 0x9b, 0x50, 0x1d, 0x4a, 0x11, 0x72, 0x09, 0x16,
	0x44, 0xc4, 0x7a, 0xba, 0x1e, 0x27, 0xbe, 0x3a, 0xb7, 0x61, 0x81, 0x06, 0x09, 0xdd, 0x7c, 0x73,
	0x29, 0x41, 0x57, 0x7d, 0x83, 0xd4, 0xcd, 0xb9, 0x7f, 0xe7, 0x7d, 0x80, 0x7c, 0x14, 0x70, 0x82,
	0xf8, 0x38, 0xc8, 0x28, 0x38, 0xfd, 0x70, 0xe8, 0x39, 0x5a, 0xb9, 0xf3, 0xd7, 0xcb, 0x00, 0x44,
	0x1d, 0x33, 0x37, 0xc1, 0x5f, 0x64, 0xe1, 0x2f, 0xcb, 0x33, 0x7d, 0xfc, 0x54, 0x02, 0xcb, 0x42,
	0x60, 0xce, 0x14, 0x84, 0xd3, 0x43, 0x70, 0xce, 0x9d, 0x11, 0x82, 0x53, 0x9e, 0x88, 0xa9, 0x81,
	0x6f, 0x38, 0x60, 0x22, 0x36, 0xe5, 0xc2, 0x85, 0x36, 0x3c, 0xe4, 0x2d, 0x98, 0x5a, 0xd2, 0xe1,
	0x58, 0xc4, 0x4b, 0x46, 0xf0, 0x73, 0x4b, 0xbc, 0x22, 0xf8, 0x6f, 0xcf, 0x83, 0x26, 0xfa, 0x97,
	0x7b, 0x8e, 0xe5, 0x83, 0x52, 0xba, 0xd8, 0xa0, 0x7c, 0x04, 0x3a, 0x7b, 0x65, 0x7b, 0x43, 0x87,
	0x99, 0x59, 0x8f, 0x12, 0xa1, 0x47, 0x68, 0x22, 0xe5, 0x40, 0xf4, 0x2c, 0x29, 0xf6, 0xbb, 0x32,
	0xd6, 0xef, 0xbb, 0x78, 0xf3, 0xcb, 0x66, 0x2a, 0xdf, 0x9a, 0x2b, 0x3c, 0xcd, 0x81, 0xc9, 0x0a,
	0xf7, 0xba, 0x01, 0xd5, 0x13, 0xf1, 0xae, 0x78, 0xd1, 0xc7, 0x2c, 0x03, 0xeb, 0xef, 0x03, 0xf4,
	0x2d, 0xb3, 0xcf, 0x2c, 0x4f, 0x7a, 0x90, 0x66, 0x48, 0xb5, 0xbe, 0xf5, 0x84, 0xe0, 0x93, 0xd6,
	0x89, 0xea, 0xa4, 0x75, 0x62, 0x86, 0x59, 0x61, 0xc2, 0x95, 0xe2, 0x16, 0xd4, 0x25, 0xbb, 0xb6,
	0x1c, 0x11, 0x25, 0x3a, 0x7b, 0x5f, 0x53, 0xa4, 0x6c, 0x3b, 0x68, 0xeb, 0x8c, 0x70, 0x44, 0x55,
	0xb7, 0x4e, 0x20, 0x10, 0x8e, 0xc7, 0x4f, 0xe0, 0x9d, 0x88, 0x2f, 0x6b, 0x45, 0xd4, 0x17, 0x6a,
	0x27, 0x39, 0xb6, 0xc6, 0x71, 0x72, 0x71, 0xaf, 0x34, 0x64, 0x13, 0xb4, 0x13, 0x7c, 0xd6, 0x38,
	0x9f, 0x19, 0x61, 0x90, 0x68, 0x11, 0x5c, 0xce, 0x8b, 0x7e, 0x00, 0x4b, 0x78, 0xc2, 0x2a, 0xe5,
	0x18, 0xca, 0xdd, 0xd6, 0xec, 0xb7, 0x2a, 0x1e, 0x1f, 0xbe, 0x90, 0x2f, 0x3b, 0x73, 0xa1, 0xdb,
	0xe6, 0x99, 0x15, 0x80, 0xfe, 0x10, 0x5a, 0x58, 0x5e, 0xd2, 0x75, 0x4e, 0x54, 0x6b, 0xfe, 0xb5,
	0x19, 0x85, 0x3d, 0x08, 0x43, 0x72, 0xb1, 0xc2, 0x83, 0xde, 0xa3, 0xae, 0x73, 0x82, 0x6e, 0x56,
	0x5f, 0x43, 0x7b, 0xac, 0xaa, 0x62, 0x04, 0xd9, 0xd2, 0x58, 0x04, 0xd9, 0x2b, 0x50, 0xcb, 0x6b,
	0x24, 0x8b, 0x5d, 0x35, 0x91, 0x85, 0xfd, 0x14, 0x1a, 0x6a, 0x55, 0xc5, 0xc8, 0x31, 0xa5, 0x62,
	0xe4, 0x98, 0xcc, 0x2f, 0xa2, 0x9c, 0xfb, 0x45, 0x74, 0xf6, 0xa0, 0x29, 0xc2, 0x4f, 0x9c, 0x71,
	0x13, 0xf8, 0x7d, 0x68, 0x8d, 0x92, 0x34, 0x8c, 0x99, 0xa9, 0xaa, 0xd4, 0x15, 0xa3, 0x41, 0xd0,
	0x3d, 0x72, 0xbc, 0xfd, 0x25, 0x2c, 0x1e, 0xd3, 0x8b, 0x3c, 0x85, 0x42, 0x6a, 0x67, 0x98, 0xe9,
	0xd4, 0xb7, 0x83, 0x2a, 0x17, 0x78, 0x3b, 0xa8, 0xf3, 0x6b, 0xd0, 0x27, 0xf5, 0x24, 0xfd, 0x67,
	0xd0, 0xc4, 0x71, 0xcc, 0xca, 0x2c, 0x9d, 0x5f, 0x66, 0xa3, 0xaf, 0x32, 0xfc, 0x89, 0xa7, 0x86,
	0xca, 0x13, 0x4f, 0x0d, 0x75, 0x1e, 0xc3, 0xfc, 0x6e, 0xf7, 0x6b, 0x76, 0xaa, 0x6f, 0x40, 0x55,
	0xf8, 0x1f, 0xcb, 0xf3, 0xb9, 0xec, 0x5b, 0xd7, 0xa0, 0x12, 0x87, 0x2f, 0x45, 0x67, 0xf9, 0x4f,
	0x0e, 0xb1, 0x43, 0x19, 0x08, 0x93, 0xff, 0xec, 0xfc, 0x1c, 0x16, 0x77, 0xbb, 0x68, 0xf9, 0xd6,
	0xdf, 0x81, 0x5a, 0xce, 0x63, 0x4b, 0xb4, 0x39, 0xca, 0x00, 0x3c, 0xeb, 0xc8, 0xf2, 0x44, 0x5b,
	0xf8, 0x4f, 0xc4, 0x0f, 0xfd, 0x6e, 0x92, 0x4a, 0xe7, 0xe3, 0xaa, 0x91, 0x03, 0x3a, 0x3d, 0x5e,
	0x30, 0xdd, 0x0a, 0xbc, 0x0d, 0x95, 0x01, 0x93, 0x03, 0xb1, 0x36, 0x65, 0x20, 0xb0, 0x2b, 0x06,
	0x47, 0xd2, 0xef, 0xc2, 0x7c, 0x7e, 0x13, 0x7d, 0x3a, 0x7f, 0x16, 0xed, 0x35, 0x08, 0xb1, 0xf3,
	0x1f, 0x94, 0x60, 0x75, 0x3c, 0x9a, 0x1e, 0x91, 0xd1, 0xe3, 0x42, 0x6c, 0xb3, 0x1f, 0x9c, 0x1f,
	0x6b, 0x52, 0xbd, 0xfd, 0x3d, 0x37, 0x78, 0x6e, 0x45, 0xc2, 0xa0, 0x7c, 0x0f, 0x56, 0x27, 0x23,
	0x59, 0xe6, 0x74, 0xb4, 0x3c, 0x1e, 0x9a, 0x92, 0xeb, 0x3f, 0x57, 0xc5, 0x5d, 0x66, 0x2e, 0x44,
	0xf7, 0x02, 0xcf, 0x0d, 0x98, 0x08, 0x51, 0xf2, 0xdc, 0x8a, 0xb4, 0x72, 0xe7, 0xdf, 0xaa, 0xc0,
	0xc6, 0xb4, 0x18, 0x80, 0xa2, 0xe9, 0x3f, 0x83, 0x85, 0x3e, 0xb3, 0x1c, 0x26, 0x9f, 0xc2, 0xd8,
	0x9c, 0x1d, 0xf9, 0x6f, 0xb7, 0xfb, 0xac, 0xfb, 0x4b, 0x66, 0xa7, 0x4f, 0x10, 0xdf, 0x10, 0xf9,
	0xf4, 0x2e, 0xac, 0x4d, 0x1e, 0x8f, 0x61, 0xe1, 0x32, 0x30, 0xce, 0xe6, 0xeb, 0x0e, 0xc8, 0x44,
	0xec, 0x4d, 0x02, 0x27, 0xfa, 0x4f, 0xe1, 0x9d, 0x98, 0xf5, 0x5c, 0xae, 0x81, 0xe7, 0xa7, 0x46,
	0xca, 0xa6, 0x97, 0x14, 0xa6, 0xf5, 0x1c, 0x47, 0x31, 0x3c, 0xa0, 0x64, 0xfd, 0x05, 0xb4, 0xd5,
	0x02, 0xb8, 0xfa, 0x4d, 0x4e, 0xd1, 0x5f, 0xbc, 0x46, 0xdb, 0xf2, 0xe1, 0xa2, 0xe0, 0x85, 0x18,
	0xea, 0xa2, 0xa5, 0x54, 0xe6, 0xda, 0xc9, 0xc6, 0x4f, 0x45, 0x1c, 0xd9, 0xb3, 0xc3, 0x90, 0xcc,
	0x7e, 0xbf, 0xb8, 0xf3, 0xd7, 0xe6, 0xe0, 0x7a, 0xb6, 0x15, 0x17, 0x7b, 0x32, 0xe5, 0x32, 0x31,
	0xb3, 0xc3, 0xd8, 0x99, 0xca, 0xb0, 0x22, 0xd0, 0x50, 0x3a, 0xe4, 0xb7, 0x8d, 0xe5, 0xc0, 0x3f,
	0x9c, 0x16, 0xaf, 0xe3, 0x9c, 0x2a, 0xb6, 0x0e, 0xe9, 0x04, 0x42, 0x81, 0xb7, 0x83, 0xc2, 0x77,
	0x72, 0xc6, 0x81, 0xc2, 0xc6, 0xb8, 0x38, 0x57, 0xe4, 0xf8, 0x15, 0xa8, 0xe5, 0x7a, 0x8d, 0x08,
	0x1d, 0x9e, 0x0a, 0x95, 0x66, 0xe3, 0x37, 0x65, 0x58, 0x9a, 0xa8, 0xb9, 0xa8, 0x6c, 0x94, 0xc6,
	0x94, 0x8d, 0x75, 0xa8, 0x8a, 0x41, 0x96, 0xda, 0xca, 0x22, 0x8d, 0x72, 0x82, 0xeb, 0x48, 0xb5,
	0x89, 0x67, 0x9b, 0x5f, 0x8a, 0xdb, 0xb0, 0xac, 0xd8, 0xc3, 0xb3, 0xdd, 0xef, 0x47, 0xa0, 0x17,
	0x6c, 0xe8, 0x24, 0xa1, 0xe7, 0x90, 0xf7, 0x6b, 0x56, 0x6e, 0x3d, 0x27, 0xc9, 0xfc, 0x14, 0x5a,
	0x85, 0x3d, 0x6e, 0x22, 0x1e, 0xfd, 0x7b, 0xcd, 0x4d, 0x6e, 0x53, 0xdd, 0xe4, 0xe2, 0x39, 0x86,
	0x13, 0x06, 0xd9, 0xbb, 0x58, 0x14, 0xa6, 0xb7, 0x61, 0xd4, 0x39, 0x90, 0x2c, 0xcd, 0x49, 0xe7,
	0x2f, 0x97, 0xe0, 0xf6, 0xec, 0xc9, 0x7b, 0x7a, 0xa6, 0x7e, 0x3a, 0x3e, 0x74, 0x05, 0x0e, 0x5c,
	0x1e, 0xe7, 0xc0, 0xb3, 0xcd, 0x45, 0x03, 0x68, 0x3d, 0xb0, 0x52, 0xbb, 0x4f, 0xd1, 0x5f, 0x1f,
	0xc6, 0xb1, 0x42, 0x90, 0xe5, 0x4c, 0xf8, 0x3d, 0x04, 0x60, 0x71, 0x1c, 0xc6, 0x74, 0x38, 0x5a,
	0xbe, 0x5e, 0x9e, 0xb5, 0x37, 0x92, 0xbf, 0x1e, 0x72, 0x6c, 0xf2, 0x93, 0xad, 0x61, 0xce, 0x9d,
	0xd0, 0x61, 0x9d, 0x5f, 0xc0, 0xe5, 0x7d, 0x97, 0x6f, 0xbe, 0x59, 0x6f, 0x47, 0x48, 0x9a, 0xe7,
	0xe1, 0xb1, 0xbf, 0x6f, 0x45, 0x78, 0xc9, 0x42, 0x80, 0x4c, 0x45, 0xf6, 0x36, 0x24, 0x50, 0x1c,
	0xd5, 0x14, 0xdd, 0xd2, 0xca, 0xe3, 0x6e, 0x69, 0x9d, 0xbf, 0x04, 0x6d, 0x59, 0xc3, 0xbe, 0x45,
	0x2b, 0x77, 0x3c, 0x98, 0x6d, 0x2d, 0x0f, 0x66, 0x7b, 0x09, 0x16, 0xba, 0x18, 0x2b, 0x42, 0x70,
	0x63, 0xf1, 0x85, 0x6a, 0x88, 0x67, 0x05, 0x39, 0x27, 0xaa, 0x51, 0x6c, 0x58, 0x35, 0xbe, 0xaf,
	0x72, 0x74, 0x88, 0x47, 0x99, 0xa7, 0x11, 0xeb, 0xfc, 0x59, 0x09, 0x56, 0x64, 0xf5, 0x0f, 0x47,
	0x2c, 0x48, 0x67, 0xb5, 0xe1, 0x62, 0x01, 0x75, 0x7f, 0xac, 0x46, 0xb5, 0xad, 0xbc, 0x5e, 0x54,
	0xdb, 0x73, 0x82, 0xd9, 0xce, 0x4d, 0x0f, 0x66, 0xab, 0xf6, 0x6d, 0xbe, 0xd8, 0xb7, 0xff, 0xb5,
	0x04, 0x4b, 0xb2, 0x6f, 0xc7, 0xfe, 0xf3, 0x70, 0x2f, 0x9a, 0x72, 0x26, 0x53, 0xcb, 0xd8, 0xe2,
	0xad, 0xc9, 0x78, 0x02, 0x65, 0xe9, 0x7f, 0xa6, 0x9c, 0xe8, 0x73, 0x7d, 0x58, 0x71, 0x77, 0x53,
	0x47, 0xbc, 0x95, 0xfb, 0xbc, 0x21, 0xe6, 0x75, 0x68, 0x08, 0xc7, 0xbb, 0xfc, 0x0a, 0x4c, 0xcd,
	0x80, 0x08, 0xfd, 0xee, 0x10, 0xe3, 0x11, 0x34, 0x79, 0x59, 0x6e, 0x70, 0x12, 0xaa, 0xaf, 0x76,
	0x4e, 0xd3, 0x96, 0xc7, 0x88, 0x04, 0x9f, 0x23, 0xe4, 0x3f, 0xe8, 0x0a, 0xd6, 0x1c, 0x5c, 0xca,
	0xe8, 0x14, 0xa5, 0xc4, 0xbe, 0x0c, 0x6d, 0xf8, 0x07, 0x50, 0x0b, 0x23, 0x16, 0xd3, 0xb9, 0x6c,
	0x69, 0xa6, 0x2d, 0xa4, 0x98, 0xfb, 0x99, 0xcc, 0x71, 0x5f, 0x1f, 0xc8, 0x94, 0x67, 0xd1, 0x5e,
	0x30, 0xb2, 0x3c, 0xd7, 0x31, 0xf2, 0x02, 0xf5, 0x9f, 0xc3, 0x82, 0xb8, 0x02, 0x53, 0x9e, 0x79,
	0xc7, 0xbd, 0x58, 0x34, 0x5d, 0x8b, 0xb9, 0x7f, 0x29, 0x2b, 0x97, 0x00, 0xb2, 0x6c, 0x51, 0x9c,
	0x6e, 0xc2, 0x22, 0xdf, 0x9d, 0x59, 0x81, 0x23, 0xe8, 0x67, 0xf3, 0xdc, 0x92, 0x77, 0x08, 0xff,
	0xfe, 0x95, 0x81, 0xa0, 0x8e, 0x23, 0x66, 0x0f, 0x63, 0xae, 0x72, 0x0e, 0x3d, 0x26, 0xcb, 0x97,
	0xa5, 0xea, 0x03, 0xb8, 0xea, 0x30, 0x2f, 0xb5, 0xcc, 0x6c, 0x11, 0xa7, 0x21, 0xe7, 0x7d, 0xbe,
	0x15, 0xa9, 0x17, 0x96, 0xce, 0x1c, 0xab, 0x22, 0x47, 0x30, 0xd6, 0xb0, 0xc0, 0x31, 0x28, 0xce,
	0xf3, 0xef, 0xc1, 0x65, 0xaa, 0x6c, 0xe4, 0xf3, 0x6a, 0xdc, 0x28, 0xaf, 0x66, 0x7e, 0x66, 0x30,
	0x8f, 0x09, 0xda, 0x35, 0x74, 0x2c, 0x24, 0xfb, 0x16, 0x8f, 0xe8, 0xea, 0x59, 0xd1, 0x39, 0x9f,
	0x21, 0x9f, 0x86, 0xb6, 0xc0, 0xcf, 0x98, 0xcd, 0x9f, 0x95, 0xa1, 0x55, 0x1c, 0x34, 0xfd, 0x11,
	0xd4, 0xe2, 0xa1, 0xc7, 0x28, 0xc4, 0xd6, 0x78, 0x10, 0x3e, 0x5f, 0xe0, 0x6e, 0x4d, 0x1d, 0xd1,
	0x93, 0xd0, 0xa8, 0xc6, 0xe2, 0x97, 0xfe, 0x0b, 0xb8, 0x3c, 0x6b, 0x24, 0xcb, 0x17, 0x1e, 0xc9,
	0x65, 0x7b, 0xca, 0x20, 0xf2, 0xed, 0xe5, 0xc4, 0xf0, 0x55, 0x2e, 0x30, 0x7c, 0xcd, 0x51, 0x61,
	0xe4, 0xc6, 0x79, 0xf3, 0xdc, 0x84, 0xcb, 0xf0, 0x87, 0xb0, 0xd4, 0xe3, 0x7a, 0x27, 0xdd, 0xc5,
	0x15, 0x27, 0x29, 0xc2, 0x35, 0x21, 0x4f, 0xa0, 0x03, 0x95, 0xce, 0x3f, 0x98, 0x87, 0x76, 0x26,
	0x4d, 0xce, 0xd8, 0xdb, 0x7d, 0x0d, 0xef, 0x65, 0x8d, 0xc4, 0x5b, 0x68, 0xe6, 0x08, 0x8f, 0x4f,
	0x46, 0x32, 0x02, 0xb5, 0xc9, 0x25, 0xae, 0x30, 0x71, 0xbd, 0x9b, 0xa1, 0xee, 0x05, 0x6e, 0x7a,
	0xcc, 0x11, 0x8f, 0x45, 0x64, 0xea, 0xdd, 0x30, 0x60, 0xfa, 0x1e, 0x74, 0x94, 0xc2, 0x9c, 0x13,
	0x3e, 0xee, 0xf4, 0xf6, 0xa7, 0x08, 0x00, 0xe1, 0xe4, 0xfb, 0x95, 0xab, 0x79, 0x59, 0xce, 0x89,
	0x88, 0xc3, 0x47, 0x42, 0x14, 0x8b, 0xfa, 0x03, 0xf8, 0x28, 0x2f, 0x2a, 0x66, 0x69, 0xec, 0xf6,
	0x7a, 0x78, 0x07, 0x7c, 0x46, 0xa1, 0xa4, 0x75, 0xdd, 0xca, 0xf2, 0x18, 0x32, 0xcb, 0xd4, 0xd2,
	0x6d, 0xb8, 0x93, 0x97, 0x2e, 0x3d, 0x70, 0xe4, 0xc6, 0x99, 0x8f, 0x83, 0x1d, 0x06, 0x09, 0xd7,
	0x65, 0x03, 0xfb, 0xd4, 0x3c, 0x71, 0x5f, 0xc9, 0xeb, 0x7e, 0xc6, 0xed, 0x2c, 0x5b, 0xf1, 0x24,
	0x37, 0xd9, 0x53, 0xb3, 0x3c, 0xe2, 0x39, 0xf4, 0xe7, 0xb0, 0x39, 0x36, 0xb4, 0xd3, 0x1e, 0x10,
	0xa5, 0xe6, 0xd3, 0xf5, 0xcc, 0x4e, 0x61, 0x7c, 0x0f, 0xc6, 0x9f, 0x14, 0xc5, 0xa6, 0xff, 0x3e,
	0x7c, 0xa8, 0x0e, 0xcc, 0xf8, 0x33, 0x2a, 0xd1, 0xb0, 0xeb, 0xb9, 0x49, 0x1f, 0x9f, 0x72, 0xe1,
	0x05, 0x2f, 0x4e, 0x8c, 0x4b, 0xe1, 0x31, 0x95, 0xc3, 0x0c, 0x1d, 0x0b, 0x3f, 0x82, 0x0f, 0xf2,
	0xc2, 0xe5, 0x0d, 0x27, 0x2b, 0x70, 0x86, 0xb1, 0xeb, 0xf1, 0x71, 0x77, 0xba, 0x26, 0x0b, 0xd2,
	0xd8, 0x15, 0x7e, 0x2a, 0x6a, 0x8b, 0xc9, 0xee, 0xe6, 0x6c, 0x13, 0xf2, 0xb1, 0x4f, 0x3b, 0x50,
	0x97, 0xe1, 0x56, 0x45, 0x29, 0xd4, 0x0b, 0xb9, 0x3a, 0x19, 0x8c, 0x62, 0x0b, 0xc3, 0x1c, 0x0f,
	0xc4, 0xf1, 0x8b, 0xb1, 0x9e, 0x97, 0x84, 0x28, 0x07, 0x1c, 0x63, 0x97, 0x23, 0x74, 0xfe, 0x85,
	0x12, 0xac, 0x66, 0xb4, 0x4c, 0xf7, 0xce, 0xce, 0xa0, 0xe8, 0xdf, 0x07, 0xf1, 0x86, 0x63, 0x52,
	0x08, 0x6f, 0xd0, 0x9a, 0x1a, 0x0d, 0x8f, 0x4a, 0x4b, 0xc4, 0xb5, 0x8a, 0xfb, 0xed, 0x01, 0x5d,
	0xb3, 0xf4, 0xe4, 0x55, 0xe8, 0xd6, 0xa8, 0x80, 0xd0, 0xf9, 0x57, 0xab, 0xb0, 0x22, 0x0e, 0x3e,
	0x8e, 0xc9, 0xf9, 0x4f, 0xb4, 0xe4, 0x2e, 0xac, 0xc8, 0xd3, 0x93, 0x91, 0xea, 0x15, 0x48, 0x2d,
	0xd3, 0xed, 0x42, 0x1e, 0xe9, 0x16, 0x48, 0xea, 0x52, 0xe1, 0x16, 0x0c, 0x81, 0xe4, 0x2d, 0x98,
	0x6e, 0x18, 0x38, 0xaa, 0x95, 0xbf, 0xca, 0x01, 0x98, 0xf8, 0x87, 0xd0, 0x96, 0x0e, 0x61, 0xa6,
	0xb0, 0xde, 0xd3, 0x65, 0xf8, 0xcf, 0xa6, 0xf4, 0x72, 0x5a, 0x8b, 0xb7, 0x84, 0xcf, 0x18, 0xd9,
	0xaa, 0x8d, 0x66, 0xa0, 0x7e, 0xea, 0x47, 0xc2, 0x3f, 0x4b, 0xd8, 0x4f, 0xe7, 0x67, 0x06, 0x00,
	0x9e, 0x5a, 0xf4, 0x53, 0xcb, 0x96, 0x4f, 0xbe, 0xa2, 0x4f, 0x97, 0x18, 0xa3, 0x98, 0xcb, 0x9d,
	0x13, 0x6b, 0xe8, 0xa5, 0xe6, 0x30, 0x42, 0x6f, 0x6a, 0xb4, 0xb4, 0xc8, 0xb7, 0x19, 0x5b, 0xf7,
	0xee, 0xbf, 0x6e, 0x05, 0x2f, 0x30, 0xfb, 0x63, 0x91, 0x1b, 0xf5, 0xb5, 0x55, 0x51, 0x74, 0x31,
	0x49, 0x0f, 0x60, 0x95, 0x6c, 0x6b, 0x54, 0xa1, 0x7c, 0x0b, 0x31, 0x11, 0xd1, 0x99, 0x2e, 0x58,
	0x23, 0x5f, 0x32, 0xf2, 0xcd, 0x44, 0x63, 0x19, 0x6d, 0x74, 0x08, 0x97, 0x30, 0xf4, 0x46, 0x54,
	0x0f, 0xcc, 0x44, 0xa4, 0x73, 0x37, 0x3b, 0x19, 0xdb, 0xf8, 0xd3, 0x12, 0x40, 0x3e, 0x3e, 0x9c,
	0x82, 0xf9, 0x08, 0x21, 0x9d, 0x54, 0x0d, 0xfc, 0xad, 0x5b, 0xd0, 0xc0, 0xc1, 0xe7, 0xfb, 0x8f,
	0x70, 0x28, 0xcf, 0x52, 0x7e, 0x72, 0xf1, 0xd1, 0xc7, 0x9f, 0xcf, 0xa9, 0x14, 0x03, 0x27, 0x54,
	0x7c, 0xa0, 0x3b, 0x3b, 0xaf, 0xe2, 0xc4, 0xf2, 0xbc, 0xae, 0x65, 0x0f, 0x04, 0x53, 0xc6, 0x7a,
	0x1f, 0x09, 0x58, 0xe7, 0x3d, 0xa8, 0x2b, 0x05, 0xe0, 0xf1, 0xc4, 0x23, 0x0b, 0x8f, 0x27, 0x30,
	0xcc, 0x89, 0x17, 0xbe, 0xd4, 0xca, 0x1b, 0x06, 0xe8, 0x93, 0x63, 0x73, 0xb6, 0x49, 0xf3, 0x1a,
	0xd4, 0xc5, 0x74, 0xa8, 0xbb, 0x10, 0x02, 0xa1, 0x62, 0xb0, 0x0b, 0xcd, 0x02, 0x75, 0x8a, 0x28,
	0xa9, 0xa9, 0x3b, 0x62, 0x0f, 0x2c, 0x7b, 0x30, 0x8c, 0xb4, 0x12, 0x46, 0x49, 0x15, 0x77, 0x33,
	0x8f, 0xbc, 0xae, 0x88, 0xc6, 0x2a, 0x00, 0xcf, 0xed, 0x48, 0xab, 0x74, 0x7e, 0x29, 0x5b, 0xa6,
	0xd2, 0x09, 0x3d, 0x35, 0x10, 0x66, 0x26, 0xa1, 0x6d, 0xcf, 0xd3, 0xca, 0x18, 0x5f, 0x65, 0xdb,
	0xf3, 0x3e, 0x7e, 0xac, 0x55, 0x28, 0x52, 0x8b, 0xe7, 0x7d, 0x7c, 0xf7, 0xb1, 0x36, 0x27, 0x3f,
	0xee, 0x7d, 0xf6, 0x58, 0x9b, 0x97, 0x1f, 0x9f, 0xde, 0x7d, 0x2c, 0x22, 0xd5, 0x22, 0xda, 0xdd,
	0xc7, 0xda, 0x62, 0xe7, 0x37, 0x15, 0x58, 0xc9, 0x58, 0x14, 0xc6, 0x73, 0x13, 0xf3, 0x3b, 0xf5,
	0x14, 0xa5, 0x74, 0xc6, 0x29, 0xca, 0xe7, 0x70, 0x59, 0x3c, 0x6a, 0x4d, 0xd1, 0xe2, 0x14, 0x87,
	0x60, 0x12, 0xc2, 0xab, 0x94, 0xac, 0xbe, 0xda, 0xc3, 0x09, 0x1d, 0x63, 0xde, 0x05, 0x28, 0x11,
	0x52, 0x56, 0x08, 0x01, 0x5d, 0x33, 0xb4, 0x70, 0x14, 0x18, 0x98, 0xa0, 0x3c, 0x09, 0xc2, 0xb1,
	0xa3, 0xd8, 0x1d, 0x0d, 0xd8, 0x29, 0xc5, 0x25, 0x99, 0x13, 0x8e, 0xbd, 0xa3, 0xe0, 0x90, 0xc0,
	0x18, 0x97, 0x04, 0x9d, 0xb1, 0x03, 0xd3, 0x66, 0x71, 0xea, 0x9e, 0xb8, 0x5c, 0x13, 0x22, 0xec,
	0x79, 0xe9, 0x8c, 0x1d, 0xec, 0xe4, 0x49, 0x98, 0xe3, 0x16, 0xb4, 0x31, 0x87, 0xc5, 0xf3, 0x14,
	0x9e, 0xfb, 0xe3, 0xc8, 0x08, 0x45, 0xbc, 0x1f, 0xc1, 0x15, 0x2b, 0xb0, 0x4d, 0x27, 0xf4, 0x2d,
	0x97, 0x8c, 0x7a, 0xd2, 0x01, 0x5d, 0xb9, 0xff, 0x7e, 0xd9, 0x0a, 0xec, 0x5d, 0xc4, 0xe0, 0x6c,
	0x8f, 0xdc, 0xd0, 0xa5, 0x17, 0xb6, 0x7c, 0xe4, 0xd9, 0xea, 0x8f, 0x32, 0x56, 0x4f, 0x77, 0x0b,
	0xe4, 0xfb, 0xcf, 0xdb, 0xfd, 0x91, 0xe4, 0xdc, 0xff, 0x4f, 0x09, 0xde, 0x97, 0x4a, 0x98, 0x54,
	0x1c, 0xf7, 0xc3, 0xc0, 0x4d, 0xc3, 0xd8, 0x0d, 0x7a, 0xf9, 0xdb, 0xff, 0xfa, 0x3b, 0xb0, 0x40,
	0x23, 0x4c, 0x6b, 0x52, 0xb8, 0x2b, 0x08, 0x98, 0xfe, 0x15, 0xac, 0xe3, 0x73, 0xbd, 0x76, 0xe8,
	0x79, 0xcc, 0xc6, 0x0b, 0xfb, 0xd1, 0x98, 0xef, 0xf1, 0x25, 0x8e, 0xb0, 0x23, 0xd3, 0xf3, 0xab,
	0x53, 0x3f, 0x84, 0x8d, 0xb1, 0xac, 0x74, 0x4b, 0x84, 0x14, 0x39, 0xf2, 0x98, 0xbe, 0x5c, 0xc8,
	0x8b, 0xf7, 0x44, 0xc8, 0x41, 0xe6, 0x87, 0x70, 0x79, 0x3c, 0xb3, 0xbc, 0x6c, 0x84, 0xf3, 0x76,
	0xbf, 0x92, 0xda, 0x91, 0xb1, 0x5a, 0xcc, 0x2e, 0x30, 0x3a, 0x7f, 0x63, 0x11, 0x6e, 0xee, 0x4c,
	0x3f, 0xb3, 0x3f, 0x8c, 0x19, 0x46, 0xac, 0x31, 0x58, 0x32, 0xf4, 0x52, 0xdd, 0xcc, 0xae, 0xfa,
	0xd0, 0xe6, 0xec, 0xf1, 0x34, 0xa6, 0xf3, 0x3a, 0x25, 0x6d, 0xc9, 0x4f, 0xf2, 0xe7, 0xcd, 0xee,
	0x0c, 0x91, 0x4b, 0x77, 0x3a, 0x4c, 0x4c, 0x87, 0xa5, 0x96, 0x2b, 0x23, 0x03, 0x35, 0x08, 0xb8,
	0x8b, 0xb0, 0xce, 0xff, 0x3e, 0x0f, 0xad, 0x62, 0x7e, 0x0a, 0x23, 0x3d, 0xd0, 0x4a, 0xfa, 0x25,
	0xd0, 0x07, 0xc7, 0x3e, 0x86, 0x5d, 0x66, 0xce, 0xb3, 0x93, 0x13, 0xb4, 0x94, 0x68, 0x65, 0x7d,
	0x0d, 0x56, 0x06, 0xc5, 0xd0, 0xd5, 0x94, 0x52, 0xd1, 0x2f, 0xc3, 0xf2, 0x20, 0x7b, 0xf2, 0x1c,
	0x83, 0x69, 0x60, 0xc2, 0x9c, 0x7e, 0x15, 0xd6, 0x07, 0xc7, 0xfe, 0x41, 0x98, 0xe6, 0xbd, 0xe0,
	0x73, 0x4c, 0xc9, 0xf3, 0x58, 0xd3, 0x13, 0x2b, 0x19, 0x1d, 0x88, 0x0b, 0xa1, 0x04, 0x5f, 0xd0,
	0x37, 0xe0, 0x12, 0x65, 0xdb, 0x0b, 0x8e, 0x4e, 0x03, 0x1b, 0x75, 0x4b, 0x4a, 0x5b, 0xd4, 0xaf,
	0xc3, 0x3b, 0x83, 0xfd, 0x6c, 0xdf, 0xbd, 0xed, 0x71, 0xf5, 0xed, 0x74, 0x2f, 0x78, 0x91, 0x08,
	0x8c, 0x2a, 0xb6, 0x66, 0x27, 0xbb, 0xcf, 0x7c, 0xc4, 0x52, 0x4a, 0xa8, 0xe9, 0xd7, 0xe0, 0xca,
	0xe0, 0x48, 0x44, 0x51, 0x9a, 0x82, 0x00, 0xfa, 0x2d, 0xe8, 0x0c, 0x76, 0x59, 0x92, 0xba, 0xf4,
	0xf6, 0x10, 0xe7, 0xb7, 0x53, 0xf0, 0xea, 0xfa, 0x0f, 0xe0, 0xfb, 0xa2, 0x20, 0x05, 0x3b, 0x5f,
	0x09, 0xfb, 0x6e, 0xe2, 0x5b, 0xa9, 0xdd, 0x27, 0xf4, 0x06, 0x76, 0x87, 0xd0, 0x73, 0x1c, 0x4a,
	0x6b, 0x62, 0x9b, 0xa6, 0x16, 0x42, 0x08, 0x2d, 0x7d, 0x13, 0xde, 0x57, 0x11, 0x30, 0x4e, 0x6a,
	0xe4, 0x29, 0x25, 0x91, 0x25, 0x4b, 0x6b, 0xa3, 0x4b, 0x93, 0x78, 0xcd, 0x3a, 0xea, 0xc5, 0x96,
	0xa3, 0x78, 0x8b, 0x10, 0x8a, 0x36, 0xde, 0xc1, 0x19, 0x78, 0x4b, 0xfa, 0x15, 0xb8, 0x3c, 0xd8,
	0x1f, 0x5f, 0xe0, 0x94, 0xa8, 0xd3, 0xac, 0x29, 0x67, 0x3a, 0x04, 0x5f, 0x16, 0x93, 0x2d, 0x39,
	0x80, 0xcf, 0x02, 0x72, 0x05, 0xa7, 0xe4, 0x15, 0xfd, 0x26, 0xdc, 0x18, 0xec, 0xd0, 0x43, 0x3a,
	0xf8, 0xc8, 0x60, 0xc2, 0x99, 0x42, 0xce, 0xd8, 0x08, 0x6d, 0x75, 0x62, 0x40, 0xc2, 0xa4, 0x50,
	0xfd, 0x25, 0x24, 0x43, 0xea, 0xe6, 0x93, 0x6d, 0x62, 0x2a, 0x94, 0x72, 0x19, 0x1b, 0xa0, 0x4e,
	0x5f, 0x21, 0x79, 0xad, 0xf3, 0x5f, 0x57, 0xa0, 0x79, 0xec, 0x2b, 0x6f, 0x4b, 0xe1, 0x2b, 0xe5,
	0xfe, 0xf8, 0x2b, 0x54, 0xf4, 0x62, 0x68, 0x7b, 0xe4, 0x17, 0xdf, 0x63, 0xfe, 0x43, 0x58, 0xc2,
	0x6d, 0x9b, 0x82, 0x2d, 0x4d, 0xde, 0x77, 0xa7, 0x9a, 0xba, 0x94, 0xec, 0x5b, 0x18, 0xec, 0x2c,
	0xff, 0x36, 0x34, 0xa7, 0x08, 0x48, 0xf4, 0x6f, 0x41, 0xe3, 0xda, 0x66, 0xa1, 0xf4, 0xca, 0xec,
	0x7b, 0x47, 0x85, 0xd2, 0xf1, 0x04, 0x20, 0x2f, 0x9c, 0xab, 0xad, 0x6a, 0xd9, 0x1b, 0x29, 0xb4,
	0xc7, 0x1a, 0xf0, 0x26, 0x6f, 0x91, 0x6f, 0xc1, 0xf2, 0xf8, 0x00, 0xe4, 0x6f, 0xc1, 0x2e, 0x8d,
	0x75, 0x68, 0xcf, 0xd9, 0xf8, 0x3d, 0x68, 0x15, 0x1b, 0x76, 0x96, 0x8d, 0xf1, 0x23, 0xd0, 0xc7,
	0xba, 0x9f, 0x97, 0xad, 0x15, 0xfb, 0xb3, 0xe7, 0x74, 0xfe, 0xab, 0x3a, 0xac, 0xed, 0xba, 0x49,
	0x1a, 0xbb, 0xdd, 0x61, 0xca, 0x9c, 0xe2, 0xd5, 0x13, 0x25, 0x7e, 0xb0, 0x1a, 0x63, 0x75, 0xa4,
	0x6c, 0x0c, 0xa6, 0x9d, 0x94, 0x8e, 0xdd, 0xe0, 0xac, 0x4c, 0xde, 0xe0, 0x44, 0x13, 0x35, 0x6a,
	0xc0, 0xf9, 0x09, 0x04, 0x7e, 0xca, 0x78, 0xc4, 0x64, 0x29, 0xc0, 0x78, 0xc4, 0xd6, 0xe4, 0xe6,
	0x81, 0x14, 0xf0, 0xaf, 0xa6, 0x9d, 0xf9, 0xcd, 0xe8, 0xca, 0xd9, 0x1b, 0x88, 0x9f, 0x17, 0x37,
	0x10, 0x14, 0xe5, 0xea, 0xf3, 0x8b, 0x14, 0x3f, 0x63, 0x13, 0xf1, 0x12, 0x36, 0xe4, 0x46, 0x4b,
	0x7a, 0x71, 0x29, 0xc1, 0xc9, 0xaa, 0x48, 0x94, 0x17, 0xea, 0x86, 0x90, 0x64, 0xa2, 0xaa, 0x35,
	0x5b, 0xfd, 0x14, 0x65, 0xa3, 0xc2, 0x71, 0x13, 0x5a, 0x91, 0x15, 0xf3, 0xcd, 0xa1, 0x77, 0x4a,
	0x7b, 0x6b, 0xda, 0xb8, 0x36, 0x33, 0x28, 0x6e, 0xa1, 0xbf, 0x82, 0x75, 0xe9, 0x3b, 0x92, 0xa4,
	0x61, 0x6c, 0xf5, 0x98, 0x19, 0x06, 0xde, 0x29, 0x85, 0x18, 0xa0, 0xd7, 0xb5, 0x2f, 0x09, 0x84,
	0x23, 0x4a, 0x7f, 0x16, 0x78, 0xa7, 0x18, 0x70, 0x60, 0x1d, 0xd0, 0xbb, 0xc8, 0xec, 0x33, 0x19,
	0x4d, 0x67, 0x91, 0x7f, 0x3f, 0x61, 0xaf, 0x36, 0xfe, 0xfb, 0xf3, 0x77, 0x0d, 0x6c, 0xea, 0xae,
	0xe1, 0xc1, 0x9b, 0x0d, 0xf9, 0x9f, 0xc7, 0xce, 0xe1, 0xbf, 0x99, 0x83, 0x66, 0x61, 0xf0, 0x27,
	0x2e, 0x8a, 0x96, 0x26, 0x2f, 0x8a, 0xfe, 0xf3, 0xa5, 0xd9, 0x9b, 0x48, 0xea, 0xf1, 0xd3, 0x37,
	0x9e, 0xfc, 0x0b, 0x6c, 0x2b, 0xff, 0x12, 0x5c, 0xc6, 0xfd, 0xcd, 0x14, 0x12, 0x24, 0xbe, 0xb8,
	0xfb, 0xe6, 0xad, 0x40, 0xc1, 0x4e, 0xd4, 0x88, 0x7b, 0xd7, 0x09, 0x52, 0xdc, 0xf8, 0xd7, 0x4b,
	0x00, 0x39, 0xd6, 0xe4, 0x66, 0xab, 0xa6, 0x6c, 0xb6, 0x3e, 0x80, 0xb6, 0x1b, 0x88, 0x28, 0x53,
	0x85, 0xc3, 0x9a, 0x96, 0x04, 0x53, 0xb8, 0xef, 0xf1, 0x5d, 0x59, 0x65, 0x7c, 0x57, 0x86, 0x47,
	0x4c, 0xe4, 0x08, 0x4b, 0x9e, 0x36, 0x82, 0xcf, 0x34, 0x08, 0xf8, 0x08, 0x61, 0x9d, 0xd1, 0xd4,
	0x4d, 0x17, 0xdf, 0x5f, 0xed, 0xbb, 0xaf, 0x98, 0x23, 0xe2, 0x08, 0x7d, 0xf7, 0x1b, 0xb0, 0x6f,
	0xc6, 0xb7, 0x8c, 0x14, 0xd2, 0xf3, 0x41, 0x18, 0xf0, 0x3a, 0xdf, 0x68, 0xff, 0xf8, 0x47, 0xb0,
	0x3e, 0xf3, 0x91, 0x63, 0x25, 0x0a, 0x89, 0xfa, 0x48, 0xbb, 0x93, 0x79, 0xdd, 0xeb, 0xd7, 0xa1,
	0x91, 0xf6, 0x52, 0xd3, 0x4e, 0x63, 0xf5, 0x5c, 0x0a, 0xd2, 0x5e, 0xba, 0x93, 0xd2, 0xf3, 0xef,
	0xff, 0x61, 0x19, 0xb4, 0xe3, 0x28, 0x78, 0xda, 0xc5, 0x67, 0x0a, 0xc4, 0x5c, 0xfe, 0x02, 0x56,
	0xbc, 0xae, 0x49, 0x2f, 0x39, 0xa8, 0x6e, 0xc7, 0xa5, 0xd9, 0xd2, 0x76, 0xac, 0x88, 0x2d, 0xe5,
	0xb7, 0xb1, 0xe4, 0xa9, 0x49, 0xd2, 0x8c, 0x3c, 0xb9, 0x23, 0x2d, 0xcf, 0x78, 0x5e, 0xe3, 0xaf,
	0x96, 0xa0, 0xae, 0x36, 0xef, 0x35, 0x56, 0xe8, 0x15, 0xa8, 0x79, 0x5d, 0x19, 0x80, 0x89, 0x48,
	0xad, 0xea, 0x75, 0x45, 0xdc, 0xa5, 0x4d, 0xd0, 0xb2, 0x44, 0xf9, 0xca, 0x02, 0xed, 0x7c, 0x5a,
	0x12, 0x47, 0xbc, 0xb3, 0xb0, 0x0e, 0xd5, 0x80, 0xbd, 0x4a, 0xcd, 0x7e, 0x18, 0x65, 0xc7, 0x84,
	0xec, 0x55, 0xfa, 0x24, 0x8c, 0x3a, 0xbf, 0x0b, 0x3a, 0xa7, 0xfe, 0xa3, 0x97, 0x56, 0x24, 0x26,
	0x86, 0x37, 0xed, 0x8d, 0x9e, 0xcd, 0x2f, 0x06, 0x13, 0xed, 0xfc, 0xfb, 0x25, 0x0a, 0xdc, 0xc4,
	0x8b, 0x3e, 0xdb, 0x86, 0xf1, 0x40, 0x8d, 0x26, 0x57, 0x9e, 0x79, 0xd0, 0x3d, 0xd9, 0x4e, 0x25,
	0x96, 0xdc, 0x85, 0xde, 0x51, 0x98, 0xe9, 0x61, 0xd0, 0xf9, 0x27, 0x25, 0x58, 0x13, 0x0f, 0xdb,
	0x84, 0x01, 0xdf, 0x32, 0x2a, 0xc1, 0xe0, 0x67, 0xfb, 0x5d, 0xdc, 0x83, 0x55, 0x27, 0xd7, 0x46,
	0x95, 0x37, 0xb8, 0x89, 0x50, 0x97, 0x9d, 0xe2, 0x4e, 0x63, 0x66, 0x1e, 0xbe, 0x87, 0x15, 0x97,
	0x07, 0xc6, 0xf3, 0xf0, 0xb6, 0x9c, 0xe1, 0x19, 0x91, 0x47, 0x43, 0xa3, 0xa8, 0x15, 0x91, 0xb0,
	0x29, 0x88, 0x68, 0x68, 0x18, 0x40, 0x0b, 0xef, 0x58, 0xa6, 0xa1, 0xd9, 0x65, 0x66, 0x31, 0x42,
	0x77, 0x3d, 0x0d, 0x1f, 0xb0, 0x5d, 0x31, 0x02, 0xff, 0x4b, 0x09, 0xde, 0xc9, 0x46, 0x80, 0xb4,
	0xef, 0xbd, 0x28, 0xa5, 0xb0, 0x77, 0xe8, 0x24, 0x32, 0x73, 0x14, 0x36, 0x41, 0x53, 0xdb, 0x50,
	0x78, 0x56, 0x2c, 0x6b, 0xc5, 0x1b, 0xf7, 0x9d, 0x2b, 0xa5, 0xe3, 0x79, 0x5c, 0x49, 0xce, 0x4b,
	0x63, 0x39, 0xf6, 0x0a, 0x73, 0x3c, 0x3f, 0x7e, 0x23, 0x6a, 0x35, 0xef, 0xe0, 0xd1, 0x93, 0xaf,
	0xd9, 0xe9, 0x79, 0x3d, 0x2b, 0x50, 0x6f, 0x79, 0x8c, 0x7a, 0x67, 0xfb, 0x33, 0xfc, 0x90, 0x16,
	0xc0, 0xe3, 0x68, 0x98, 0x9c, 0xbd, 0x00, 0x72, 0x6f, 0xc2, 0x4a, 0xe6, 0x4d, 0xf8, 0x57, 0x4a,
	0xb0, 0x72, 0xec, 0xef, 0x84, 0x7e, 0x64, 0xa5, 0x6e, 0xd7, 0x63, 0x59, 0x49, 0x33, 0x5b, 0xf9,
	0xa5, 0xa8, 0xa2, 0x47, 0x37, 0x54, 0x2a, 0x33, 0xdc, 0xf5, 0x64, 0x41, 0x54, 0xbf, 0x6c, 0xdc,
	0xc8, 0x37, 0x31, 0x1a, 0x66, 0x22, 0x3a, 0x51, 0x1d, 0xf9, 0x18, 0x27, 0x33, 0xb9, 0xfd, 0x18,
	0x96, 0x38, 0xeb, 0x76, 0x3d, 0x47, 0x71, 0x84, 0xd7, 0xa0, 0x31, 0x50, 0x2e, 0x12, 0x0a, 0x19,
	0x90, 0xdf, 0xfd, 0x12, 0x32, 0x20, 0x3f, 0xd8, 0xd1, 0x2a, 0xb7, 0x9f, 0xc1, 0xc2, 0x71, 0x1e,
	0x0c, 0x0f, 0x1f, 0x5c, 0x42, 0x5f, 0x7a, 0x2e, 0xb9, 0x76, 0x8e, 0xf7, 0xa5, 0xe4, 0x7a, 0x74,
	0x74, 0xbc, 0xaf, 0x55, 0x50, 0xb4, 0x1d, 0x72, 0x30, 0x3d, 0xff, 0x74, 0x7c, 0x78, 0x70, 0xbc,
	0xaf, 0xcd, 0x93, 0xf4, 0x3b, 0x3a, 0x3c, 0xde, 0xd7, 0x16, 0x6e, 0xdf, 0xe6, 0xbb, 0x3c, 0xc5,
	0xcf, 0x40, 0x04, 0x86, 0xb6, 0x59, 0x92, 0x88, 0xd8, 0xce, 0xcf, 0xc9, 0xa7, 0x40, 0x2b, 0xdf,
	0xde, 0x15, 0x0e, 0x54, 0x22, 0xee, 0x86, 0xf2, 0x80, 0xb4, 0x56, 0x42, 0x3b, 0xc2, 0xe4, 0x7b,
	0xcd, 0x5a, 0x59, 0x84, 0xaf, 0x8e, 0x99, 0x9d, 0xf2, 0xef, 0xca, 0xed, 0x1f, 0xc3, 0xa5, 0xe9,
	0xef, 0x3a, 0x63, 0x6d, 0x7b, 0x01, 0x6e, 0xad, 0x85, 0xcb, 0xf9, 0x43, 0xfa, 0x28, 0x67, 0xde,
	0x72, 0x95, 0xdb, 0xbf, 0x03, 0x8b, 0xe2, 0x19, 0x52, 0xdc, 0xdb, 0x1e, 0x5a, 0x49, 0x92, 0xf6,
	0xe3, 0x70, 0xd8, 0xeb, 0x3f, 0x8e, 0xad, 0xa8, 0xef, 0xda, 0x89, 0x68, 0x8c, 0x92, 0xc2, 0x29,
	0x60, 0x98, 0x32, 0xad, 0x8c, 0x55, 0x88, 0x01, 0xd5, 0x2a, 0xb7, 0xb7, 0xa0, 0x96, 0xbd, 0x41,
	0x4a, 0x02, 0x7a, 0xe4, 0x3a, 0xae, 0xa5, 0x95, 0x70, 0x88, 0xf6, 0x82, 0x94, 0x79, 0xa2, 0xee,
	0x6d, 0xdf, 0xd1, 0x2a, 0xb7, 0x77, 0xb1, 0x6e, 0x74, 0xc2, 0xe0, 0xd8, 0x2f, 0x02, 0x7c, 0x0a,
	0x8c, 0xaa, 0x7b, 0x91, 0x30, 0xe7, 0x51, 0x18, 0x2b, 0xb5, 0x8a, 0x87, 0x2f, 0x44, 0x42, 0x5e,
	0xeb, 0xd7, 0xb0, 0xa6, 0x5c, 0xf5, 0x0d, 0xe3, 0x53, 0x3a, 0x08, 0xc4, 0x2e, 0x35, 0xa1, 0x36,
	0x38, 0x08, 0x49, 0xc8, 0x6b, 0xdf, 0xa3, 0xaa, 0x1d, 0x07, 0xcd, 0x4c, 0xb5, 0xc1, 0xd1, 0xb0,
	0x9b, 0xc6, 0x96, 0x9d, 0x6a, 0xff, 0x44, 0xfe, 0x95, 0x6e, 0x3b, 0x8a, 0x0b, 0x4e, 0xd1, 0x39,
	0x01, 0x2d, 0x0f, 0x13, 0xee, 0x09, 0xc2, 0x62, 0x95, 0xc3, 0x8d, 0xa1, 0xc7, 0x78, 0x15, 0x65,
	0xbc, 0x29, 0x56, 0x84, 0x13, 0x3f, 0xd3, 0x2a, 0xb7, 0xff, 0xb3, 0x72, 0xee, 0x08, 0xa3, 0x3a,
	0x2a, 0xa0, 0xb1, 0x66, 0xaa, 0xab, 0x82, 0x56, 0xc2, 0xab, 0x64, 0x59, 0x5a, 0x56, 0x0b, 0x1f,
	0x2b, 0x15, 0x2a, 0xeb, 0x98, 0x48, 0xa0, 0x51, 0xd1, 0xe6, 0x84, 0x79, 0xa5, 0x78, 0x14, 0x2e,
	0x12, 0xe7, 0x0b, 0x95, 0x1c, 0xfb, 0xdb, 0x8e, 0xb3, 0x17, 0x69, 0x0b, 0x85, 0xb2, 0x8e, 0x7d,
	0xaa, 0x62, 0x2f, 0xd2, 0x16, 0x0b, 0x7d, 0x3f, 0xf6, 0x85, 0xa5, 0x50, 0xab, 0xa2, 0x1d, 0x65,
	0x3c, 0x83, 0xb2, 0x12, 0x6b, 0xfa, 0x3b, 0xb0, 0x56, 0xac, 0x47, 0x49, 0x85, 0xb1, 0xec, 0xd4,
	0x38, 0x05, 0xa1, 0x7e, 0xfb, 0xdf, 0xad, 0x70, 0x86, 0x39, 0xc5, 0x1f, 0x03, 0xb3, 0xce, 0xf6,
	0xc8, 0xd0, 0x4a, 0xfa, 0xbb, 0xb0, 0x31, 0x0d, 0x81, 0xce, 0x37, 0xb5, 0xf2, 0xac, 0xf4, 0x6c,
	0x5c, 0xaf, 0xc2, 0xfa, 0xb4, 0x74, 0x1a, 0xaa, 0x39, 0xb4, 0x10, 0xce, 0xcc, 0xbe, 0x17, 0x69,
	0xf3, 0xb3, 0x5a, 0xb8, 0xe3, 0x31, 0x2b, 0x18, 0xf2, 0xd1, 0x9e, 0x81, 0xb0, 0xeb, 0x26, 0x5c,
	0xe4, 0x69, 0x8b, 0xb8, 0x0c, 0x1e, 0x79, 0xe1, 0x4b, 0xbe, 0x72, 0x04, 0x6d, 0x57, 0x91, 0xd4,
	0x1f, 0x61, 0xb0, 0x6f, 0x37, 0xd5, 0x6a, 0x68, 0xf0, 0x9a, 0xda, 0x0e, 0xdc, 0xee, 0x88, 0xde,
	0xc2, 0x39, 0x68, 0xa2, 0xd3, 0x75, 0xb4, 0xee, 0x4d, 0x41, 0x43, 0x7b, 0xe0, 0xb3, 0x68, 0x2f,
	0xd2, 0x1a, 0xb3, 0xc6, 0x8d, 0x82, 0xb2, 0x68, 0xcd, 0xdb, 0x0f, 0x60, 0x5d, 0xce, 0x18, 0x4d,
	0xa8, 0x41, 0x2f, 0x99, 0xe3, 0x3a, 0xe5, 0x8c, 0x59, 0x21, 0x52, 0x22, 0x76, 0x2e, 0x02, 0x03,
	0xdb, 0xcd, 0xa0, 0xe5, 0xdb, 0x0c, 0x5a, 0xc5, 0x13, 0x5d, 0xf1, 0x14, 0x8e, 0x7a, 0xa6, 0xab,
	0x7d, 0x0f, 0x19, 0x99, 0xc0, 0x3b, 0xdc, 0xd9, 0x8e, 0x5c, 0x99, 0x52, 0xd2, 0xdf, 0x87, 0xeb,
	0x32, 0x45, 0xec, 0xce, 0xf7, 0x31, 0x90, 0x91, 0xcf, 0x02, 0x19, 0x16, 0x5f, 0x2b, 0xdf, 0xfe,
	0x02, 0x96, 0xd1, 0x00, 0x8d, 0xa6, 0xdf, 0x7d, 0x66, 0xf7, 0xad, 0xc0, 0x4d, 0x7c, 0x64, 0xff,
	0x4f, 0xac, 0xd8, 0x11, 0xdb, 0xdc, 0x6d, 0x3b, 0x72, 0x85, 0x80, 0x40, 0xc1, 0xa1, 0x55, 0x1e,
	0x74, 0x60, 0xd5, 0x0e, 0xfd, 0x49, 0x01, 0xf7, 0x6d, 0x2d, 0xfb, 0xf9, 0xff, 0x05, 0x00, 0x00,
	0xff, 0xff, 0xa4, 0xf7, 0xae, 0x67, 0x63, 0xc0, 0x00, 0x00,
}
