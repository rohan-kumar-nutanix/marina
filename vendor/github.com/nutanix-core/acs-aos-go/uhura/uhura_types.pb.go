// Code generated by protoc-gen-go. DO NOT EDIT.
// source: uhura/uhura_types.proto

package uhura

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	hyperint "github.com/nutanix-core/acs-aos-go/hyperint"
	math "math"
	config "github.com/nutanix-core/acs-aos-go/zeus/config"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//-----------------------------------------------------------------------------
type VmChildEntityType int32

const (
	VmChildEntityType_kVirtualDisk VmChildEntityType = 1
	VmChildEntityType_kVirtualNic  VmChildEntityType = 2
	VmChildEntityType_kVirtualGpu  VmChildEntityType = 3
)

var VmChildEntityType_name = map[int32]string{
	1: "kVirtualDisk",
	2: "kVirtualNic",
	3: "kVirtualGpu",
}

var VmChildEntityType_value = map[string]int32{
	"kVirtualDisk": 1,
	"kVirtualNic":  2,
	"kVirtualGpu":  3,
}

func (x VmChildEntityType) Enum() *VmChildEntityType {
	p := new(VmChildEntityType)
	*p = x
	return p
}

func (x VmChildEntityType) String() string {
	return proto.EnumName(VmChildEntityType_name, int32(x))
}

func (x *VmChildEntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmChildEntityType_value, data, "VmChildEntityType")
	if err != nil {
		return err
	}
	*x = VmChildEntityType(value)
	return nil
}

func (VmChildEntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{0}
}

//-----------------------------------------------------------------------------
type VmNicVlanType int32

const (
	VmNicVlanType_kAccess   VmNicVlanType = 1
	VmNicVlanType_kTrunked  VmNicVlanType = 2
	VmNicVlanType_kUntagged VmNicVlanType = 3
)

var VmNicVlanType_name = map[int32]string{
	1: "kAccess",
	2: "kTrunked",
	3: "kUntagged",
}

var VmNicVlanType_value = map[string]int32{
	"kAccess":   1,
	"kTrunked":  2,
	"kUntagged": 3,
}

func (x VmNicVlanType) Enum() *VmNicVlanType {
	p := new(VmNicVlanType)
	*p = x
	return p
}

func (x VmNicVlanType) String() string {
	return proto.EnumName(VmNicVlanType_name, int32(x))
}

func (x *VmNicVlanType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicVlanType_value, data, "VmNicVlanType")
	if err != nil {
		return err
	}
	*x = VmNicVlanType(value)
	return nil
}

func (VmNicVlanType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{1}
}

//-----------------------------------------------------------------------------
type VmNicType int32

const (
	// kNormal NIC's are used for user VM's and will be plugged in to the local
	// bridge in a bridge chain. Traffic from kNormal NIC's will go through
	// security groups and packet processing flows.
	VmNicType_kNormalNic VmNicType = 1
	// kNetworkFunctionNic NIC's are used for Network Function VM's. These NIC's
	// do not belong to any network, and ports are created in trunk-all mode. They
	// will be plugged in to the network function bridge, and will send/receive
	// packets as defined in a service chain.
	VmNicType_kNetworkFunctionNic VmNicType = 2
	// kDirectNic's are used for user VM's that are plugged in to directly to the
	// uplink bridges. Normal-type NIC's plugged in to the local bridge does not
	// suppport dynamic MAC address (needed by nested hypervisors, for example).
	// Packets from Direct NIC's will not go through microseg and network function
	// bridges.
	VmNicType_kDirectNic VmNicType = 3
)

var VmNicType_name = map[int32]string{
	1: "kNormalNic",
	2: "kNetworkFunctionNic",
	3: "kDirectNic",
}

var VmNicType_value = map[string]int32{
	"kNormalNic":          1,
	"kNetworkFunctionNic": 2,
	"kDirectNic":          3,
}

func (x VmNicType) Enum() *VmNicType {
	p := new(VmNicType)
	*p = x
	return p
}

func (x VmNicType) String() string {
	return proto.EnumName(VmNicType_name, int32(x))
}

func (x *VmNicType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicType_value, data, "VmNicType")
	if err != nil {
		return err
	}
	*x = VmNicType(value)
	return nil
}

func (VmNicType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{2}
}

type NetworkFunctionNicType int32

const (
	// Network packets flowing in the uplink direction (UVM->physical network)
	// through a network function chain, will enter the appliance through the
	// ingress nic and exit through the egress nic. Packets flowing in the
	// opposite direction will enter through egress nic and exit through ingress
	// nic. Tap nics on the appliance will receive a copy of all packets flowing
	// through the network function chain.
	NetworkFunctionNicType_kIngress NetworkFunctionNicType = 1
	NetworkFunctionNicType_kEgress  NetworkFunctionNicType = 2
	NetworkFunctionNicType_kTap     NetworkFunctionNicType = 3
)

var NetworkFunctionNicType_name = map[int32]string{
	1: "kIngress",
	2: "kEgress",
	3: "kTap",
}

var NetworkFunctionNicType_value = map[string]int32{
	"kIngress": 1,
	"kEgress":  2,
	"kTap":     3,
}

func (x NetworkFunctionNicType) Enum() *NetworkFunctionNicType {
	p := new(NetworkFunctionNicType)
	*p = x
	return p
}

func (x NetworkFunctionNicType) String() string {
	return proto.EnumName(NetworkFunctionNicType_name, int32(x))
}

func (x *NetworkFunctionNicType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkFunctionNicType_value, data, "NetworkFunctionNicType")
	if err != nil {
		return err
	}
	*x = NetworkFunctionNicType(value)
	return nil
}

func (NetworkFunctionNicType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{3}
}

//----------------------------------------------------------------------------
type DrsBehavior int32

const (
	// Default value.
	DrsBehavior_kUnknown DrsBehavior = 1
	// Specifies that VirtualCenter should automate both the migration of
	// virtual machines and their placement with a host at power on.
	DrsBehavior_kFullEnabled DrsBehavior = 2
	// Specifies that VirtualCenter should generate recommendations for
	// virtual machine migration and for placement with a host, but should
	// automatically implement only the placement at power on.
	DrsBehavior_kOnlyPlacementEnabled DrsBehavior = 3
	// Specifies that VirtualCenter should generate recommendations for virtual
	// machine migration and for placement with a host, but should not
	// implement the recommendations automatically.
	DrsBehavior_kManual DrsBehavior = 4
)

var DrsBehavior_name = map[int32]string{
	1: "kUnknown",
	2: "kFullEnabled",
	3: "kOnlyPlacementEnabled",
	4: "kManual",
}

var DrsBehavior_value = map[string]int32{
	"kUnknown":              1,
	"kFullEnabled":          2,
	"kOnlyPlacementEnabled": 3,
	"kManual":               4,
}

func (x DrsBehavior) Enum() *DrsBehavior {
	p := new(DrsBehavior)
	*p = x
	return p
}

func (x DrsBehavior) String() string {
	return proto.EnumName(DrsBehavior_name, int32(x))
}

func (x *DrsBehavior) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DrsBehavior_value, data, "DrsBehavior")
	if err != nil {
		return err
	}
	*x = DrsBehavior(value)
	return nil
}

func (DrsBehavior) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{4}
}

type GPUType int32

const (
	// GPU in graphics mode.
	GPUType_kPassthroughGraphics GPUType = 1
	// GPU in compute mode.
	GPUType_kPassthroughCompute GPUType = 2
	// Virtual GPU.
	GPUType_kVirtual GPUType = 3
)

var GPUType_name = map[int32]string{
	1: "kPassthroughGraphics",
	2: "kPassthroughCompute",
	3: "kVirtual",
}

var GPUType_value = map[string]int32{
	"kPassthroughGraphics": 1,
	"kPassthroughCompute":  2,
	"kVirtual":             3,
}

func (x GPUType) Enum() *GPUType {
	p := new(GPUType)
	*p = x
	return p
}

func (x GPUType) String() string {
	return proto.EnumName(GPUType_name, int32(x))
}

func (x *GPUType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GPUType_value, data, "GPUType")
	if err != nil {
		return err
	}
	*x = GPUType(value)
	return nil
}

func (GPUType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{5}
}

type GPUVendor int32

const (
	// Nvidia GPU vendor.
	GPUVendor_kNvidia GPUVendor = 1
	// Intel GPU vendor.
	GPUVendor_kIntel GPUVendor = 2
	// AMD GPU Vendor.
	GPUVendor_kAmd GPUVendor = 3
)

var GPUVendor_name = map[int32]string{
	1: "kNvidia",
	2: "kIntel",
	3: "kAmd",
}

var GPUVendor_value = map[string]int32{
	"kNvidia": 1,
	"kIntel":  2,
	"kAmd":    3,
}

func (x GPUVendor) Enum() *GPUVendor {
	p := new(GPUVendor)
	*p = x
	return p
}

func (x GPUVendor) String() string {
	return proto.EnumName(GPUVendor_name, int32(x))
}

func (x *GPUVendor) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GPUVendor_value, data, "GPUVendor")
	if err != nil {
		return err
	}
	*x = GPUVendor(value)
	return nil
}

func (GPUVendor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{6}
}

type GPUMode int32

const (
	// GPU is not being used.
	GPUMode_kUnused GPUMode = 1
	// GPU is being used for passthrough.
	GPUMode_kUsedForPassthrough GPUMode = 2
	// GPU is being used by virtual GPU resources.
	GPUMode_kUsedForVirtual GPUMode = 3
)

var GPUMode_name = map[int32]string{
	1: "kUnused",
	2: "kUsedForPassthrough",
	3: "kUsedForVirtual",
}

var GPUMode_value = map[string]int32{
	"kUnused":             1,
	"kUsedForPassthrough": 2,
	"kUsedForVirtual":     3,
}

func (x GPUMode) Enum() *GPUMode {
	p := new(GPUMode)
	*p = x
	return p
}

func (x GPUMode) String() string {
	return proto.EnumName(GPUMode_name, int32(x))
}

func (x *GPUMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GPUMode_value, data, "GPUMode")
	if err != nil {
		return err
	}
	*x = GPUMode(value)
	return nil
}

func (GPUMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{7}
}

//-----------------------------------------------------------------------------
// Type of the power state mechanism.
type PowerStateMechanism int32

const (
	PowerStateMechanism_kHard  PowerStateMechanism = 1
	PowerStateMechanism_kAcpi  PowerStateMechanism = 2
	PowerStateMechanism_kGuest PowerStateMechanism = 3
)

var PowerStateMechanism_name = map[int32]string{
	1: "kHard",
	2: "kAcpi",
	3: "kGuest",
}

var PowerStateMechanism_value = map[string]int32{
	"kHard":  1,
	"kAcpi":  2,
	"kGuest": 3,
}

func (x PowerStateMechanism) Enum() *PowerStateMechanism {
	p := new(PowerStateMechanism)
	*p = x
	return p
}

func (x PowerStateMechanism) String() string {
	return proto.EnumName(PowerStateMechanism_name, int32(x))
}

func (x *PowerStateMechanism) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PowerStateMechanism_value, data, "PowerStateMechanism")
	if err != nil {
		return err
	}
	*x = PowerStateMechanism(value)
	return nil
}

func (PowerStateMechanism) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{8}
}

type VmStateTransition_Transition int32

const (
	VmStateTransition_kPowerOn    VmStateTransition_Transition = 1
	VmStateTransition_kPowerOff   VmStateTransition_Transition = 2
	VmStateTransition_kPowerCycle VmStateTransition_Transition = 3
	VmStateTransition_kReset      VmStateTransition_Transition = 4
	// Not supported on ESX.
	VmStateTransition_kPause         VmStateTransition_Transition = 5
	VmStateTransition_kSuspend       VmStateTransition_Transition = 6
	VmStateTransition_kResume        VmStateTransition_Transition = 7
	VmStateTransition_kAcpiShutdown  VmStateTransition_Transition = 8
	VmStateTransition_kAcpiReboot    VmStateTransition_Transition = 9
	VmStateTransition_kShutdown      VmStateTransition_Transition = 10
	VmStateTransition_kSave          VmStateTransition_Transition = 11
	VmStateTransition_kDiscardSaved  VmStateTransition_Transition = 12
	VmStateTransition_kGuestShutdown VmStateTransition_Transition = 13
	VmStateTransition_kGuestReboot   VmStateTransition_Transition = 14
)

var VmStateTransition_Transition_name = map[int32]string{
	1:  "kPowerOn",
	2:  "kPowerOff",
	3:  "kPowerCycle",
	4:  "kReset",
	5:  "kPause",
	6:  "kSuspend",
	7:  "kResume",
	8:  "kAcpiShutdown",
	9:  "kAcpiReboot",
	10: "kShutdown",
	11: "kSave",
	12: "kDiscardSaved",
	13: "kGuestShutdown",
	14: "kGuestReboot",
}

var VmStateTransition_Transition_value = map[string]int32{
	"kPowerOn":       1,
	"kPowerOff":      2,
	"kPowerCycle":    3,
	"kReset":         4,
	"kPause":         5,
	"kSuspend":       6,
	"kResume":        7,
	"kAcpiShutdown":  8,
	"kAcpiReboot":    9,
	"kShutdown":      10,
	"kSave":          11,
	"kDiscardSaved":  12,
	"kGuestShutdown": 13,
	"kGuestReboot":   14,
}

func (x VmStateTransition_Transition) Enum() *VmStateTransition_Transition {
	p := new(VmStateTransition_Transition)
	*p = x
	return p
}

func (x VmStateTransition_Transition) String() string {
	return proto.EnumName(VmStateTransition_Transition_name, int32(x))
}

func (x *VmStateTransition_Transition) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmStateTransition_Transition_value, data, "VmStateTransition_Transition")
	if err != nil {
		return err
	}
	*x = VmStateTransition_Transition(value)
	return nil
}

func (VmStateTransition_Transition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{4, 0}
}

type AutomaticStartAction_Action int32

const (
	// When the host is powered on, the VM will do nothing.
	AutomaticStartAction_kNothing AutomaticStartAction_Action = 1
	// This setting will start the VM only if it was running when
	// the host was stopped.
	AutomaticStartAction_kStartIfRunning AutomaticStartAction_Action = 2
	// This will cause the VM to always start up automatically no
	// matter what state the VM was in previously.
	AutomaticStartAction_kStart AutomaticStartAction_Action = 3
)

var AutomaticStartAction_Action_name = map[int32]string{
	1: "kNothing",
	2: "kStartIfRunning",
	3: "kStart",
}

var AutomaticStartAction_Action_value = map[string]int32{
	"kNothing":        1,
	"kStartIfRunning": 2,
	"kStart":          3,
}

func (x AutomaticStartAction_Action) Enum() *AutomaticStartAction_Action {
	p := new(AutomaticStartAction_Action)
	*p = x
	return p
}

func (x AutomaticStartAction_Action) String() string {
	return proto.EnumName(AutomaticStartAction_Action_name, int32(x))
}

func (x *AutomaticStartAction_Action) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AutomaticStartAction_Action_value, data, "AutomaticStartAction_Action")
	if err != nil {
		return err
	}
	*x = AutomaticStartAction_Action(value)
	return nil
}

func (AutomaticStartAction_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{6, 0}
}

type AutomaticStopAction_Action int32

const (
	// To gracefully turn off the virtual machine when the host shuts down.
	AutomaticStopAction_kTurnOff AutomaticStopAction_Action = 1
	// To save the virtual machine state on the local disk when the
	// host shuts down.
	AutomaticStopAction_kSave AutomaticStopAction_Action = 2
	// Shut down the guest operating system.
	// The guest services should be running in the VM for this option to work.
	AutomaticStopAction_kShutDown AutomaticStopAction_Action = 3
)

var AutomaticStopAction_Action_name = map[int32]string{
	1: "kTurnOff",
	2: "kSave",
	3: "kShutDown",
}

var AutomaticStopAction_Action_value = map[string]int32{
	"kTurnOff":  1,
	"kSave":     2,
	"kShutDown": 3,
}

func (x AutomaticStopAction_Action) Enum() *AutomaticStopAction_Action {
	p := new(AutomaticStopAction_Action)
	*p = x
	return p
}

func (x AutomaticStopAction_Action) String() string {
	return proto.EnumName(AutomaticStopAction_Action_name, int32(x))
}

func (x *AutomaticStopAction_Action) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AutomaticStopAction_Action_value, data, "AutomaticStopAction_Action")
	if err != nil {
		return err
	}
	*x = AutomaticStopAction_Action(value)
	return nil
}

func (AutomaticStopAction_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{7, 0}
}

type VmDiskAddress_AdapterType int32

const (
	// Virtual disk is attached to a SCSI controller.
	VmDiskAddress_kSCSI VmDiskAddress_AdapterType = 0
	// Virtual disk is attached to an IDE controller.
	VmDiskAddress_kIDE VmDiskAddress_AdapterType = 1
	// Virtual disk is attached to a PCI controller.
	// Not applicable for AWS / ESX / Hyper-V.
	VmDiskAddress_kPCI VmDiskAddress_AdapterType = 2
	// Virtual disk is attached to a SATA controller.
	// Not applicable for AWS / ESX / Hyper-V.
	VmDiskAddress_kSATA VmDiskAddress_AdapterType = 3
	// Virtual disk is attached to a sPAPR controller.
	// Only applicable for AHV running on PowerPC platform.
	VmDiskAddress_kSPAPR VmDiskAddress_AdapterType = 4
	// Virtual disk is attached to an NVME controller.
	// Only applicable for ESXi.
	VmDiskAddress_kNVME VmDiskAddress_AdapterType = 5
)

var VmDiskAddress_AdapterType_name = map[int32]string{
	0: "kSCSI",
	1: "kIDE",
	2: "kPCI",
	3: "kSATA",
	4: "kSPAPR",
	5: "kNVME",
}

var VmDiskAddress_AdapterType_value = map[string]int32{
	"kSCSI":  0,
	"kIDE":   1,
	"kPCI":   2,
	"kSATA":  3,
	"kSPAPR": 4,
	"kNVME":  5,
}

func (x VmDiskAddress_AdapterType) Enum() *VmDiskAddress_AdapterType {
	p := new(VmDiskAddress_AdapterType)
	*p = x
	return p
}

func (x VmDiskAddress_AdapterType) String() string {
	return proto.EnumName(VmDiskAddress_AdapterType_name, int32(x))
}

func (x *VmDiskAddress_AdapterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmDiskAddress_AdapterType_value, data, "VmDiskAddress_AdapterType")
	if err != nil {
		return err
	}
	*x = VmDiskAddress_AdapterType(value)
	return nil
}

func (VmDiskAddress_AdapterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{15, 0}
}

// The type of file. This indicates how the file is used by the VM.
type VmNfsFileConfig_Type int32

const (
	VmNfsFileConfig_kConfig   VmNfsFileConfig_Type = 1
	VmNfsFileConfig_kLog      VmNfsFileConfig_Type = 2
	VmNfsFileConfig_kDisk     VmNfsFileConfig_Type = 3
	VmNfsFileConfig_kTmpDisk  VmNfsFileConfig_Type = 4
	VmNfsFileConfig_kSnapshot VmNfsFileConfig_Type = 5
	VmNfsFileConfig_kISO      VmNfsFileConfig_Type = 6
)

var VmNfsFileConfig_Type_name = map[int32]string{
	1: "kConfig",
	2: "kLog",
	3: "kDisk",
	4: "kTmpDisk",
	5: "kSnapshot",
	6: "kISO",
}

var VmNfsFileConfig_Type_value = map[string]int32{
	"kConfig":   1,
	"kLog":      2,
	"kDisk":     3,
	"kTmpDisk":  4,
	"kSnapshot": 5,
	"kISO":      6,
}

func (x VmNfsFileConfig_Type) Enum() *VmNfsFileConfig_Type {
	p := new(VmNfsFileConfig_Type)
	*p = x
	return p
}

func (x VmNfsFileConfig_Type) String() string {
	return proto.EnumName(VmNfsFileConfig_Type_name, int32(x))
}

func (x *VmNfsFileConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNfsFileConfig_Type_value, data, "VmNfsFileConfig_Type")
	if err != nil {
		return err
	}
	*x = VmNfsFileConfig_Type(value)
	return nil
}

func (VmNfsFileConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{18, 0}
}

// Type of the network adapter. Applicable only for ESX.
type VmNicConfig_AdapterType int32

const (
	VmNicConfig_kE1000       VmNicConfig_AdapterType = 1
	VmNicConfig_kPCNet32     VmNicConfig_AdapterType = 2
	VmNicConfig_kVmxnet      VmNicConfig_AdapterType = 3
	VmNicConfig_kVmxnet2     VmNicConfig_AdapterType = 4
	VmNicConfig_kVmxnet3     VmNicConfig_AdapterType = 5
	VmNicConfig_kE1000e      VmNicConfig_AdapterType = 6
	VmNicConfig_kUnSupported VmNicConfig_AdapterType = 100
)

var VmNicConfig_AdapterType_name = map[int32]string{
	1:   "kE1000",
	2:   "kPCNet32",
	3:   "kVmxnet",
	4:   "kVmxnet2",
	5:   "kVmxnet3",
	6:   "kE1000e",
	100: "kUnSupported",
}

var VmNicConfig_AdapterType_value = map[string]int32{
	"kE1000":       1,
	"kPCNet32":     2,
	"kVmxnet":      3,
	"kVmxnet2":     4,
	"kVmxnet3":     5,
	"kE1000e":      6,
	"kUnSupported": 100,
}

func (x VmNicConfig_AdapterType) Enum() *VmNicConfig_AdapterType {
	p := new(VmNicConfig_AdapterType)
	*p = x
	return p
}

func (x VmNicConfig_AdapterType) String() string {
	return proto.EnumName(VmNicConfig_AdapterType_name, int32(x))
}

func (x *VmNicConfig_AdapterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicConfig_AdapterType_value, data, "VmNicConfig_AdapterType")
	if err != nil {
		return err
	}
	*x = VmNicConfig_AdapterType(value)
	return nil
}

func (VmNicConfig_AdapterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{19, 0}
}

type VmNicConfig_MacAddressType int32

const (
	// Static MAC address.
	VmNicConfig_kStatic VmNicConfig_MacAddressType = 1
	// MAC address assigned by Hypervisor.
	VmNicConfig_kAssigned VmNicConfig_MacAddressType = 2
	// MAC address assigned by Management Server.
	VmNicConfig_kMSAssigned VmNicConfig_MacAddressType = 3
)

var VmNicConfig_MacAddressType_name = map[int32]string{
	1: "kStatic",
	2: "kAssigned",
	3: "kMSAssigned",
}

var VmNicConfig_MacAddressType_value = map[string]int32{
	"kStatic":     1,
	"kAssigned":   2,
	"kMSAssigned": 3,
}

func (x VmNicConfig_MacAddressType) Enum() *VmNicConfig_MacAddressType {
	p := new(VmNicConfig_MacAddressType)
	*p = x
	return p
}

func (x VmNicConfig_MacAddressType) String() string {
	return proto.EnumName(VmNicConfig_MacAddressType_name, int32(x))
}

func (x *VmNicConfig_MacAddressType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicConfig_MacAddressType_value, data, "VmNicConfig_MacAddressType")
	if err != nil {
		return err
	}
	*x = VmNicConfig_MacAddressType(value)
	return nil
}

func (VmNicConfig_MacAddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{19, 1}
}

type VmNicConfig_IpAddress_NetworkIpType int32

const (
	VmNicConfig_IpAddress_kLearned  VmNicConfig_IpAddress_NetworkIpType = 1
	VmNicConfig_IpAddress_kAssigned VmNicConfig_IpAddress_NetworkIpType = 2
)

var VmNicConfig_IpAddress_NetworkIpType_name = map[int32]string{
	1: "kLearned",
	2: "kAssigned",
}

var VmNicConfig_IpAddress_NetworkIpType_value = map[string]int32{
	"kLearned":  1,
	"kAssigned": 2,
}

func (x VmNicConfig_IpAddress_NetworkIpType) Enum() *VmNicConfig_IpAddress_NetworkIpType {
	p := new(VmNicConfig_IpAddress_NetworkIpType)
	*p = x
	return p
}

func (x VmNicConfig_IpAddress_NetworkIpType) String() string {
	return proto.EnumName(VmNicConfig_IpAddress_NetworkIpType_name, int32(x))
}

func (x *VmNicConfig_IpAddress_NetworkIpType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmNicConfig_IpAddress_NetworkIpType_value, data, "VmNicConfig_IpAddress_NetworkIpType")
	if err != nil {
		return err
	}
	*x = VmNicConfig_IpAddress_NetworkIpType(value)
	return nil
}

func (VmNicConfig_IpAddress_NetworkIpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{19, 0, 0}
}

type VmBootDeviceType_Type int32

const (
	VmBootDeviceType_kCdrom   VmBootDeviceType_Type = 1
	VmBootDeviceType_kDisk    VmBootDeviceType_Type = 2
	VmBootDeviceType_kNetwork VmBootDeviceType_Type = 3
)

var VmBootDeviceType_Type_name = map[int32]string{
	1: "kCdrom",
	2: "kDisk",
	3: "kNetwork",
}

var VmBootDeviceType_Type_value = map[string]int32{
	"kCdrom":   1,
	"kDisk":    2,
	"kNetwork": 3,
}

func (x VmBootDeviceType_Type) Enum() *VmBootDeviceType_Type {
	p := new(VmBootDeviceType_Type)
	*p = x
	return p
}

func (x VmBootDeviceType_Type) String() string {
	return proto.EnumName(VmBootDeviceType_Type_name, int32(x))
}

func (x *VmBootDeviceType_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmBootDeviceType_Type_value, data, "VmBootDeviceType_Type")
	if err != nil {
		return err
	}
	*x = VmBootDeviceType_Type(value)
	return nil
}

func (VmBootDeviceType_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{21, 0}
}

// Type of the network.
type NetworkConfig_Type int32

const (
	// A VLAN-backed network. The identifier field is the VLAN tag associated
	// with the virtual switch port. The port inserts this VLAN tag for
	// untagged packets ingressed from VMs to the bridge, and strips this VLAN
	// tag from packets egressed from the bridge to the VM.
	NetworkConfig_kBridged NetworkConfig_Type = 1
	// An overlay network. The identifier field is the VNI. Currently unused.
	NetworkConfig_kOverlay NetworkConfig_Type = 2
	// An externally managed network. This indicates that acropolis is not
	// responsible for network management; it is only responsible for plugging
	// ports into the bridge, and associating these ports with an port
	// identifier that is known to the external network controller.
	//
	// Networks of this type do not have an identifier.
	NetworkConfig_kExternallyManaged NetworkConfig_Type = 3
)

var NetworkConfig_Type_name = map[int32]string{
	1: "kBridged",
	2: "kOverlay",
	3: "kExternallyManaged",
}

var NetworkConfig_Type_value = map[string]int32{
	"kBridged":           1,
	"kOverlay":           2,
	"kExternallyManaged": 3,
}

func (x NetworkConfig_Type) Enum() *NetworkConfig_Type {
	p := new(NetworkConfig_Type)
	*p = x
	return p
}

func (x NetworkConfig_Type) String() string {
	return proto.EnumName(NetworkConfig_Type_name, int32(x))
}

func (x *NetworkConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkConfig_Type_value, data, "NetworkConfig_Type")
	if err != nil {
		return err
	}
	*x = NetworkConfig_Type(value)
	return nil
}

func (NetworkConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{25, 0}
}

// Managed type. For ESX only.
type NetworkConfig_ManagedType int32

const (
	// Networks managed by a Standard Switch.
	NetworkConfig_kLocal NetworkConfig_ManagedType = 1
	// Networks managed by a Distributed Virtual Switch.
	NetworkConfig_kGlobal NetworkConfig_ManagedType = 2
	// Networks managed by an appliance such as NSXT which are reported by
	// vCenter as opaque networks.
	NetworkConfig_kOpaque NetworkConfig_ManagedType = 3
)

var NetworkConfig_ManagedType_name = map[int32]string{
	1: "kLocal",
	2: "kGlobal",
	3: "kOpaque",
}

var NetworkConfig_ManagedType_value = map[string]int32{
	"kLocal":  1,
	"kGlobal": 2,
	"kOpaque": 3,
}

func (x NetworkConfig_ManagedType) Enum() *NetworkConfig_ManagedType {
	p := new(NetworkConfig_ManagedType)
	*p = x
	return p
}

func (x NetworkConfig_ManagedType) String() string {
	return proto.EnumName(NetworkConfig_ManagedType_name, int32(x))
}

func (x *NetworkConfig_ManagedType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkConfig_ManagedType_value, data, "NetworkConfig_ManagedType")
	if err != nil {
		return err
	}
	*x = NetworkConfig_ManagedType(value)
	return nil
}

func (NetworkConfig_ManagedType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{25, 1}
}

// Type of the network. Either external or internal. A network which has
// uplinks configured is marked as kExternal.
// Currently set only for ESX networks.
type NetworkConfig_NetworkType int32

const (
	NetworkConfig_kExternal NetworkConfig_NetworkType = 0
	NetworkConfig_kInternal NetworkConfig_NetworkType = 1
)

var NetworkConfig_NetworkType_name = map[int32]string{
	0: "kExternal",
	1: "kInternal",
}

var NetworkConfig_NetworkType_value = map[string]int32{
	"kExternal": 0,
	"kInternal": 1,
}

func (x NetworkConfig_NetworkType) Enum() *NetworkConfig_NetworkType {
	p := new(NetworkConfig_NetworkType)
	*p = x
	return p
}

func (x NetworkConfig_NetworkType) String() string {
	return proto.EnumName(NetworkConfig_NetworkType_name, int32(x))
}

func (x *NetworkConfig_NetworkType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NetworkConfig_NetworkType_value, data, "NetworkConfig_NetworkType")
	if err != nil {
		return err
	}
	*x = NetworkConfig_NetworkType(value)
	return nil
}

func (NetworkConfig_NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{25, 2}
}

// A datasource is a source of configuration data for cloud-init that
// typically comes from the user (aka userdata) or come from the stack that
// created the configuration drive (aka metadata). Typical userdata would
// include files, yaml, and shell scripts while typical metadata would
// include server name, instance id, display name and other cloud specific
// details. Cloudinit supports various datsources to inject the configuration
// data, some of them are iso based, packaged in a specific format.
// Following enum describes iso based datasources supported by Uhura.
type CloudInitConfig_DatasourceType int32

const (
	CloudInitConfig_kConfigDriveV2 CloudInitConfig_DatasourceType = 0
)

var CloudInitConfig_DatasourceType_name = map[int32]string{
	0: "kConfigDriveV2",
}

var CloudInitConfig_DatasourceType_value = map[string]int32{
	"kConfigDriveV2": 0,
}

func (x CloudInitConfig_DatasourceType) Enum() *CloudInitConfig_DatasourceType {
	p := new(CloudInitConfig_DatasourceType)
	*p = x
	return p
}

func (x CloudInitConfig_DatasourceType) String() string {
	return proto.EnumName(CloudInitConfig_DatasourceType_name, int32(x))
}

func (x *CloudInitConfig_DatasourceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CloudInitConfig_DatasourceType_value, data, "CloudInitConfig_DatasourceType")
	if err != nil {
		return err
	}
	*x = CloudInitConfig_DatasourceType(value)
	return nil
}

func (CloudInitConfig_DatasourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{27, 0}
}

// The backing type for this serial port.
type VmSerialPortConfig_Type int32

const (
	// The serial device is present, but has no backing.
	VmSerialPortConfig_kNull VmSerialPortConfig_Type = 1
	// The serial device is accessible through Prism via a websocket.
	VmSerialPortConfig_kServer VmSerialPortConfig_Type = 2
)

var VmSerialPortConfig_Type_name = map[int32]string{
	1: "kNull",
	2: "kServer",
}

var VmSerialPortConfig_Type_value = map[string]int32{
	"kNull":   1,
	"kServer": 2,
}

func (x VmSerialPortConfig_Type) Enum() *VmSerialPortConfig_Type {
	p := new(VmSerialPortConfig_Type)
	*p = x
	return p
}

func (x VmSerialPortConfig_Type) String() string {
	return proto.EnumName(VmSerialPortConfig_Type_name, int32(x))
}

func (x *VmSerialPortConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmSerialPortConfig_Type_value, data, "VmSerialPortConfig_Type")
	if err != nil {
		return err
	}
	*x = VmSerialPortConfig_Type(value)
	return nil
}

func (VmSerialPortConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{30, 0}
}

// Type of VM.
type VmConfig_VmType int32

const (
	VmConfig_kGuestVM VmConfig_VmType = 1
	VmConfig_kCVM     VmConfig_VmType = 2
	VmConfig_kAFSVM   VmConfig_VmType = 3
	VmConfig_kPCVM    VmConfig_VmType = 4
	VmConfig_kVPNVM   VmConfig_VmType = 5
	VmConfig_kMSPVM   VmConfig_VmType = 6
)

var VmConfig_VmType_name = map[int32]string{
	1: "kGuestVM",
	2: "kCVM",
	3: "kAFSVM",
	4: "kPCVM",
	5: "kVPNVM",
	6: "kMSPVM",
}

var VmConfig_VmType_value = map[string]int32{
	"kGuestVM": 1,
	"kCVM":     2,
	"kAFSVM":   3,
	"kPCVM":    4,
	"kVPNVM":   5,
	"kMSPVM":   6,
}

func (x VmConfig_VmType) Enum() *VmConfig_VmType {
	p := new(VmConfig_VmType)
	*p = x
	return p
}

func (x VmConfig_VmType) String() string {
	return proto.EnumName(VmConfig_VmType_name, int32(x))
}

func (x *VmConfig_VmType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmConfig_VmType_value, data, "VmConfig_VmType")
	if err != nil {
		return err
	}
	*x = VmConfig_VmType(value)
	return nil
}

func (VmConfig_VmType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{33, 0}
}

type Affinity_Policy int32

const (
	Affinity_kAffinity     Affinity_Policy = 1
	Affinity_kAntiAffinity Affinity_Policy = 2
)

var Affinity_Policy_name = map[int32]string{
	1: "kAffinity",
	2: "kAntiAffinity",
}

var Affinity_Policy_value = map[string]int32{
	"kAffinity":     1,
	"kAntiAffinity": 2,
}

func (x Affinity_Policy) Enum() *Affinity_Policy {
	p := new(Affinity_Policy)
	*p = x
	return p
}

func (x Affinity_Policy) String() string {
	return proto.EnumName(Affinity_Policy_name, int32(x))
}

func (x *Affinity_Policy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Affinity_Policy_value, data, "Affinity_Policy")
	if err != nil {
		return err
	}
	*x = Affinity_Policy(value)
	return nil
}

func (Affinity_Policy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{34, 0}
}

type Affinity_Constraint int32

const (
	Affinity_kMust   Affinity_Constraint = 1
	Affinity_kShould Affinity_Constraint = 2
)

var Affinity_Constraint_name = map[int32]string{
	1: "kMust",
	2: "kShould",
}

var Affinity_Constraint_value = map[string]int32{
	"kMust":   1,
	"kShould": 2,
}

func (x Affinity_Constraint) Enum() *Affinity_Constraint {
	p := new(Affinity_Constraint)
	*p = x
	return p
}

func (x Affinity_Constraint) String() string {
	return proto.EnumName(Affinity_Constraint_name, int32(x))
}

func (x *Affinity_Constraint) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Affinity_Constraint_value, data, "Affinity_Constraint")
	if err != nil {
		return err
	}
	*x = Affinity_Constraint(value)
	return nil
}

func (Affinity_Constraint) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{34, 1}
}

type ManagedEntityStatus_Status int32

const (
	ManagedEntityStatus_kNotSet           ManagedEntityStatus_Status = 1
	ManagedEntityStatus_kUnknown          ManagedEntityStatus_Status = 2
	ManagedEntityStatus_kOk               ManagedEntityStatus_Status = 3
	ManagedEntityStatus_kHasProblem       ManagedEntityStatus_Status = 4
	ManagedEntityStatus_kMightHaveProblem ManagedEntityStatus_Status = 5
)

var ManagedEntityStatus_Status_name = map[int32]string{
	1: "kNotSet",
	2: "kUnknown",
	3: "kOk",
	4: "kHasProblem",
	5: "kMightHaveProblem",
}

var ManagedEntityStatus_Status_value = map[string]int32{
	"kNotSet":           1,
	"kUnknown":          2,
	"kOk":               3,
	"kHasProblem":       4,
	"kMightHaveProblem": 5,
}

func (x ManagedEntityStatus_Status) Enum() *ManagedEntityStatus_Status {
	p := new(ManagedEntityStatus_Status)
	*p = x
	return p
}

func (x ManagedEntityStatus_Status) String() string {
	return proto.EnumName(ManagedEntityStatus_Status_name, int32(x))
}

func (x *ManagedEntityStatus_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ManagedEntityStatus_Status_value, data, "ManagedEntityStatus_Status")
	if err != nil {
		return err
	}
	*x = ManagedEntityStatus_Status(value)
	return nil
}

func (ManagedEntityStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{36, 0}
}

type VmState_State int32

const (
	VmState_kUnknown      VmState_State = 1
	VmState_kOff          VmState_State = 2
	VmState_kPoweringOn   VmState_State = 3
	VmState_kOn           VmState_State = 4
	VmState_kShuttingDown VmState_State = 5
	VmState_kPoweringOff  VmState_State = 6
	VmState_kPausing      VmState_State = 7
	VmState_kPaused       VmState_State = 8
	VmState_kSuspending   VmState_State = 9
	VmState_kSuspended    VmState_State = 10
	VmState_kResuming     VmState_State = 11
	VmState_kResetting    VmState_State = 12
	VmState_kMigrating    VmState_State = 13
	VmState_kSaved        VmState_State = 14
)

var VmState_State_name = map[int32]string{
	1:  "kUnknown",
	2:  "kOff",
	3:  "kPoweringOn",
	4:  "kOn",
	5:  "kShuttingDown",
	6:  "kPoweringOff",
	7:  "kPausing",
	8:  "kPaused",
	9:  "kSuspending",
	10: "kSuspended",
	11: "kResuming",
	12: "kResetting",
	13: "kMigrating",
	14: "kSaved",
}

var VmState_State_value = map[string]int32{
	"kUnknown":      1,
	"kOff":          2,
	"kPoweringOn":   3,
	"kOn":           4,
	"kShuttingDown": 5,
	"kPoweringOff":  6,
	"kPausing":      7,
	"kPaused":       8,
	"kSuspending":   9,
	"kSuspended":    10,
	"kResuming":     11,
	"kResetting":    12,
	"kMigrating":    13,
	"kSaved":        14,
}

func (x VmState_State) Enum() *VmState_State {
	p := new(VmState_State)
	*p = x
	return p
}

func (x VmState_State) String() string {
	return proto.EnumName(VmState_State_name, int32(x))
}

func (x *VmState_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmState_State_value, data, "VmState_State")
	if err != nil {
		return err
	}
	*x = VmState_State(value)
	return nil
}

func (VmState_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{39, 0}
}

type GuestToolsOperation_Operation int32

const (
	GuestToolsOperation_kMount   GuestToolsOperation_Operation = 1
	GuestToolsOperation_kUnmount GuestToolsOperation_Operation = 2
)

var GuestToolsOperation_Operation_name = map[int32]string{
	1: "kMount",
	2: "kUnmount",
}

var GuestToolsOperation_Operation_value = map[string]int32{
	"kMount":   1,
	"kUnmount": 2,
}

func (x GuestToolsOperation_Operation) Enum() *GuestToolsOperation_Operation {
	p := new(GuestToolsOperation_Operation)
	*p = x
	return p
}

func (x GuestToolsOperation_Operation) String() string {
	return proto.EnumName(GuestToolsOperation_Operation_name, int32(x))
}

func (x *GuestToolsOperation_Operation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GuestToolsOperation_Operation_value, data, "GuestToolsOperation_Operation")
	if err != nil {
		return err
	}
	*x = GuestToolsOperation_Operation(value)
	return nil
}

func (GuestToolsOperation_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{40, 0}
}

type VmToolsRunningStatus_Status int32

const (
	VmToolsRunningStatus_kUnknown                    VmToolsRunningStatus_Status = 1
	VmToolsRunningStatus_kGuestToolsExecutingScripts VmToolsRunningStatus_Status = 2
	VmToolsRunningStatus_kGuestToolsNotRunning       VmToolsRunningStatus_Status = 3
	VmToolsRunningStatus_kGuestToolsRunning          VmToolsRunningStatus_Status = 4
)

var VmToolsRunningStatus_Status_name = map[int32]string{
	1: "kUnknown",
	2: "kGuestToolsExecutingScripts",
	3: "kGuestToolsNotRunning",
	4: "kGuestToolsRunning",
}

var VmToolsRunningStatus_Status_value = map[string]int32{
	"kUnknown":                    1,
	"kGuestToolsExecutingScripts": 2,
	"kGuestToolsNotRunning":       3,
	"kGuestToolsRunning":          4,
}

func (x VmToolsRunningStatus_Status) Enum() *VmToolsRunningStatus_Status {
	p := new(VmToolsRunningStatus_Status)
	*p = x
	return p
}

func (x VmToolsRunningStatus_Status) String() string {
	return proto.EnumName(VmToolsRunningStatus_Status_name, int32(x))
}

func (x *VmToolsRunningStatus_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmToolsRunningStatus_Status_value, data, "VmToolsRunningStatus_Status")
	if err != nil {
		return err
	}
	*x = VmToolsRunningStatus_Status(value)
	return nil
}

func (VmToolsRunningStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{41, 0}
}

type VmToolsVersionStatus_Status int32

const (
	// Unknown status.
	VmToolsVersionStatus_kUnknown VmToolsVersionStatus_Status = 1
	// VMware Tools is installed, but the installed version is known to
	// have a grave bug and should be immediately upgraded.
	VmToolsVersionStatus_kGuestToolsBlacklisted VmToolsVersionStatus_Status = 2
	// VMware Tools is installed, and the version is current.
	VmToolsVersionStatus_kGuestToolsCurrent VmToolsVersionStatus_Status = 3
	// VMware Tools is installed, but the version is not current.
	VmToolsVersionStatus_kGuestToolsNeedUpgrade VmToolsVersionStatus_Status = 4
	// VMware Tools has never been installed.
	VmToolsVersionStatus_kGuestToolsNotInstalled VmToolsVersionStatus_Status = 5
	// VMware Tools is installed, supported, and newer than the version
	// available on the host.
	VmToolsVersionStatus_kGuestToolsSupportedNew VmToolsVersionStatus_Status = 6
	// VMware Tools is installed, supported, but a newer version is available.
	VmToolsVersionStatus_kGuestToolsSupportedOld VmToolsVersionStatus_Status = 7
	// VMware Tools is installed, and the version is known to be too new
	// to work correctly with this virtual machine.
	VmToolsVersionStatus_kGuestToolsTooNew VmToolsVersionStatus_Status = 8
	// VMware Tools is installed, but the version is too old.
	VmToolsVersionStatus_kGuestToolsTooOld VmToolsVersionStatus_Status = 9
	// VMware Tools is installed, but it is not managed by VMWare.
	VmToolsVersionStatus_kGuestToolsUnmanaged VmToolsVersionStatus_Status = 10
)

var VmToolsVersionStatus_Status_name = map[int32]string{
	1:  "kUnknown",
	2:  "kGuestToolsBlacklisted",
	3:  "kGuestToolsCurrent",
	4:  "kGuestToolsNeedUpgrade",
	5:  "kGuestToolsNotInstalled",
	6:  "kGuestToolsSupportedNew",
	7:  "kGuestToolsSupportedOld",
	8:  "kGuestToolsTooNew",
	9:  "kGuestToolsTooOld",
	10: "kGuestToolsUnmanaged",
}

var VmToolsVersionStatus_Status_value = map[string]int32{
	"kUnknown":                1,
	"kGuestToolsBlacklisted":  2,
	"kGuestToolsCurrent":      3,
	"kGuestToolsNeedUpgrade":  4,
	"kGuestToolsNotInstalled": 5,
	"kGuestToolsSupportedNew": 6,
	"kGuestToolsSupportedOld": 7,
	"kGuestToolsTooNew":       8,
	"kGuestToolsTooOld":       9,
	"kGuestToolsUnmanaged":    10,
}

func (x VmToolsVersionStatus_Status) Enum() *VmToolsVersionStatus_Status {
	p := new(VmToolsVersionStatus_Status)
	*p = x
	return p
}

func (x VmToolsVersionStatus_Status) String() string {
	return proto.EnumName(VmToolsVersionStatus_Status_name, int32(x))
}

func (x *VmToolsVersionStatus_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmToolsVersionStatus_Status_value, data, "VmToolsVersionStatus_Status")
	if err != nil {
		return err
	}
	*x = VmToolsVersionStatus_Status(value)
	return nil
}

func (VmToolsVersionStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{42, 0}
}

type MappingType_Type int32

const (
	MappingType_kVM              MappingType_Type = 1
	MappingType_kVNIC            MappingType_Type = 2
	MappingType_kVDisk           MappingType_Type = 3
	MappingType_kVGPU            MappingType_Type = 4
	MappingType_kVMSnapshot      MappingType_Type = 5
	MappingType_kNodePhysicalNIC MappingType_Type = 6
	MappingType_kNodeGPU         MappingType_Type = 7
	MappingType_kNodeVNIC        MappingType_Type = 8
	MappingType_kVNetwork        MappingType_Type = 9
	MappingType_kVDevice         MappingType_Type = 10
)

var MappingType_Type_name = map[int32]string{
	1:  "kVM",
	2:  "kVNIC",
	3:  "kVDisk",
	4:  "kVGPU",
	5:  "kVMSnapshot",
	6:  "kNodePhysicalNIC",
	7:  "kNodeGPU",
	8:  "kNodeVNIC",
	9:  "kVNetwork",
	10: "kVDevice",
}

var MappingType_Type_value = map[string]int32{
	"kVM":              1,
	"kVNIC":            2,
	"kVDisk":           3,
	"kVGPU":            4,
	"kVMSnapshot":      5,
	"kNodePhysicalNIC": 6,
	"kNodeGPU":         7,
	"kNodeVNIC":        8,
	"kVNetwork":        9,
	"kVDevice":         10,
}

func (x MappingType_Type) Enum() *MappingType_Type {
	p := new(MappingType_Type)
	*p = x
	return p
}

func (x MappingType_Type) String() string {
	return proto.EnumName(MappingType_Type_name, int32(x))
}

func (x *MappingType_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MappingType_Type_value, data, "MappingType_Type")
	if err != nil {
		return err
	}
	*x = MappingType_Type(value)
	return nil
}

func (MappingType_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{63, 0}
}

type MetaRequest struct {
	// Method name.
	MethodName *string `protobuf:"bytes,1,opt,name=method_name,json=methodName" json:"method_name,omitempty"`
	// Serialized argument.
	Arg *PayloadOrEmbeddedValue `protobuf:"bytes,2,opt,name=arg" json:"arg,omitempty"`
	// Whether the RPC was forwarded from another Uhura instance.
	Forwarded            *bool    `protobuf:"varint,3,opt,name=forwarded" json:"forwarded,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetaRequest) Reset()         { *m = MetaRequest{} }
func (m *MetaRequest) String() string { return proto.CompactTextString(m) }
func (*MetaRequest) ProtoMessage()    {}
func (*MetaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{0}
}

func (m *MetaRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaRequest.Unmarshal(m, b)
}
func (m *MetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaRequest.Marshal(b, m, deterministic)
}
func (m *MetaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaRequest.Merge(m, src)
}
func (m *MetaRequest) XXX_Size() int {
	return xxx_messageInfo_MetaRequest.Size(m)
}
func (m *MetaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetaRequest proto.InternalMessageInfo

func (m *MetaRequest) GetMethodName() string {
	if m != nil && m.MethodName != nil {
		return *m.MethodName
	}
	return ""
}

func (m *MetaRequest) GetArg() *PayloadOrEmbeddedValue {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *MetaRequest) GetForwarded() bool {
	if m != nil && m.Forwarded != nil {
		return *m.Forwarded
	}
	return false
}

type MetaResponse struct {
	// An error code indicating whether the RPC was successful.
	ErrorCode *UhuraError_Type `protobuf:"varint,1,opt,name=error_code,json=errorCode,enum=nutanix.uhura.UhuraError_Type" json:"error_code,omitempty"`
	// An optional additional string describing the error, if the RPC was not
	// successful.
	ErrorDetail *string `protobuf:"bytes,2,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	// The serialized response, if any.
	Ret                  *PayloadOrEmbeddedValue `protobuf:"bytes,3,opt,name=ret" json:"ret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *MetaResponse) Reset()         { *m = MetaResponse{} }
func (m *MetaResponse) String() string { return proto.CompactTextString(m) }
func (*MetaResponse) ProtoMessage()    {}
func (*MetaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{1}
}

func (m *MetaResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetaResponse.Unmarshal(m, b)
}
func (m *MetaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetaResponse.Marshal(b, m, deterministic)
}
func (m *MetaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaResponse.Merge(m, src)
}
func (m *MetaResponse) XXX_Size() int {
	return xxx_messageInfo_MetaResponse.Size(m)
}
func (m *MetaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MetaResponse proto.InternalMessageInfo

func (m *MetaResponse) GetErrorCode() UhuraError_Type {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return UhuraError_kNoError
}

func (m *MetaResponse) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

func (m *MetaResponse) GetRet() *PayloadOrEmbeddedValue {
	if m != nil {
		return m.Ret
	}
	return nil
}

type PayloadValue struct {
	// The offset of the value in the payload.
	Offset *uint64 `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	// The size of the value in the payload.
	Size                 *uint64  `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayloadValue) Reset()         { *m = PayloadValue{} }
func (m *PayloadValue) String() string { return proto.CompactTextString(m) }
func (*PayloadValue) ProtoMessage()    {}
func (*PayloadValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{2}
}

func (m *PayloadValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadValue.Unmarshal(m, b)
}
func (m *PayloadValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadValue.Marshal(b, m, deterministic)
}
func (m *PayloadValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadValue.Merge(m, src)
}
func (m *PayloadValue) XXX_Size() int {
	return xxx_messageInfo_PayloadValue.Size(m)
}
func (m *PayloadValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadValue.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadValue proto.InternalMessageInfo

func (m *PayloadValue) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *PayloadValue) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

type PayloadOrEmbeddedValue struct {
	Payload              *PayloadValue `protobuf:"bytes,1,opt,name=payload" json:"payload,omitempty"`
	Embedded             []byte        `protobuf:"bytes,2,opt,name=embedded" json:"embedded,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PayloadOrEmbeddedValue) Reset()         { *m = PayloadOrEmbeddedValue{} }
func (m *PayloadOrEmbeddedValue) String() string { return proto.CompactTextString(m) }
func (*PayloadOrEmbeddedValue) ProtoMessage()    {}
func (*PayloadOrEmbeddedValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{3}
}

func (m *PayloadOrEmbeddedValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Unmarshal(m, b)
}
func (m *PayloadOrEmbeddedValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Marshal(b, m, deterministic)
}
func (m *PayloadOrEmbeddedValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayloadOrEmbeddedValue.Merge(m, src)
}
func (m *PayloadOrEmbeddedValue) XXX_Size() int {
	return xxx_messageInfo_PayloadOrEmbeddedValue.Size(m)
}
func (m *PayloadOrEmbeddedValue) XXX_DiscardUnknown() {
	xxx_messageInfo_PayloadOrEmbeddedValue.DiscardUnknown(m)
}

var xxx_messageInfo_PayloadOrEmbeddedValue proto.InternalMessageInfo

func (m *PayloadOrEmbeddedValue) GetPayload() *PayloadValue {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PayloadOrEmbeddedValue) GetEmbedded() []byte {
	if m != nil {
		return m.Embedded
	}
	return nil
}

type VmStateTransition struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmStateTransition) Reset()         { *m = VmStateTransition{} }
func (m *VmStateTransition) String() string { return proto.CompactTextString(m) }
func (*VmStateTransition) ProtoMessage()    {}
func (*VmStateTransition) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{4}
}

func (m *VmStateTransition) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmStateTransition.Unmarshal(m, b)
}
func (m *VmStateTransition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmStateTransition.Marshal(b, m, deterministic)
}
func (m *VmStateTransition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmStateTransition.Merge(m, src)
}
func (m *VmStateTransition) XXX_Size() int {
	return xxx_messageInfo_VmStateTransition.Size(m)
}
func (m *VmStateTransition) XXX_DiscardUnknown() {
	xxx_messageInfo_VmStateTransition.DiscardUnknown(m)
}

var xxx_messageInfo_VmStateTransition proto.InternalMessageInfo

//-----------------------------------------------------------------------------
type GenericKeyValuePair struct {
	Key                  *string  `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenericKeyValuePair) Reset()         { *m = GenericKeyValuePair{} }
func (m *GenericKeyValuePair) String() string { return proto.CompactTextString(m) }
func (*GenericKeyValuePair) ProtoMessage()    {}
func (*GenericKeyValuePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{5}
}

func (m *GenericKeyValuePair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericKeyValuePair.Unmarshal(m, b)
}
func (m *GenericKeyValuePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericKeyValuePair.Marshal(b, m, deterministic)
}
func (m *GenericKeyValuePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericKeyValuePair.Merge(m, src)
}
func (m *GenericKeyValuePair) XXX_Size() int {
	return xxx_messageInfo_GenericKeyValuePair.Size(m)
}
func (m *GenericKeyValuePair) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericKeyValuePair.DiscardUnknown(m)
}

var xxx_messageInfo_GenericKeyValuePair proto.InternalMessageInfo

func (m *GenericKeyValuePair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *GenericKeyValuePair) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

//-----------------------------------------------------------------------------
type AutomaticStartAction struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutomaticStartAction) Reset()         { *m = AutomaticStartAction{} }
func (m *AutomaticStartAction) String() string { return proto.CompactTextString(m) }
func (*AutomaticStartAction) ProtoMessage()    {}
func (*AutomaticStartAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{6}
}

func (m *AutomaticStartAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AutomaticStartAction.Unmarshal(m, b)
}
func (m *AutomaticStartAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AutomaticStartAction.Marshal(b, m, deterministic)
}
func (m *AutomaticStartAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutomaticStartAction.Merge(m, src)
}
func (m *AutomaticStartAction) XXX_Size() int {
	return xxx_messageInfo_AutomaticStartAction.Size(m)
}
func (m *AutomaticStartAction) XXX_DiscardUnknown() {
	xxx_messageInfo_AutomaticStartAction.DiscardUnknown(m)
}

var xxx_messageInfo_AutomaticStartAction proto.InternalMessageInfo

//-----------------------------------------------------------------------------
type AutomaticStopAction struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutomaticStopAction) Reset()         { *m = AutomaticStopAction{} }
func (m *AutomaticStopAction) String() string { return proto.CompactTextString(m) }
func (*AutomaticStopAction) ProtoMessage()    {}
func (*AutomaticStopAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{7}
}

func (m *AutomaticStopAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AutomaticStopAction.Unmarshal(m, b)
}
func (m *AutomaticStopAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AutomaticStopAction.Marshal(b, m, deterministic)
}
func (m *AutomaticStopAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutomaticStopAction.Merge(m, src)
}
func (m *AutomaticStopAction) XXX_Size() int {
	return xxx_messageInfo_AutomaticStopAction.Size(m)
}
func (m *AutomaticStopAction) XXX_DiscardUnknown() {
	xxx_messageInfo_AutomaticStopAction.DiscardUnknown(m)
}

var xxx_messageInfo_AutomaticStopAction proto.InternalMessageInfo

// Uhura-wise configurations.
type UhuraConfig struct {
	// UUID for this config.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Indicates whether uhura has updated vm_state attribute in IDF for all the
	// VMs.
	UhuraIdfVmStateUpdateDone *bool `protobuf:"varint,2,opt,name=uhura_idf_vm_state_update_done,json=uhuraIdfVmStateUpdateDone" json:"uhura_idf_vm_state_update_done,omitempty"`
	// Indicates whether Uhura has updated flash mode disabled disks attribute
	// in IDF for all the VMs.
	UhuraIdfFlashModeUpdateDone *bool `protobuf:"varint,3,opt,name=uhura_idf_flash_mode_update_done,json=uhuraIdfFlashModeUpdateDone" json:"uhura_idf_flash_mode_update_done,omitempty"`
	// NOT IN USE YET
	// Indicates whether Uhura has reconciled flash mode updates after cluster
	// upgrade. After upgrading to 5.17 or further, the flash mode updates are
	// done in sync path and Flash Mode Watcher is deprecated. To maintain
	// consistency, flash mode status of all the VMs needs to be reconciled
	// once after cluster upgrade. After reconciliation is done, this flag is set
	// True, so that reconciliation is not done again.
	UhuraFlashModeReconcileDone *bool `protobuf:"varint,4,opt,name=uhura_flash_mode_reconcile_done,json=uhuraFlashModeReconcileDone" json:"uhura_flash_mode_reconcile_done,omitempty"`
	// Indicates whether Uhura has removed duplicates from disabled disks
	// attribute in IDF for all VMs.
	UhuraFlashModeDisabledDisksDuplicatesRemoved *bool    `protobuf:"varint,5,opt,name=uhura_flash_mode_disabled_disks_duplicates_removed,json=uhuraFlashModeDisabledDisksDuplicatesRemoved" json:"uhura_flash_mode_disabled_disks_duplicates_removed,omitempty"`
	XXX_NoUnkeyedLiteral                         struct{} `json:"-"`
	XXX_unrecognized                             []byte   `json:"-"`
	XXX_sizecache                                int32    `json:"-"`
}

func (m *UhuraConfig) Reset()         { *m = UhuraConfig{} }
func (m *UhuraConfig) String() string { return proto.CompactTextString(m) }
func (*UhuraConfig) ProtoMessage()    {}
func (*UhuraConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{8}
}

func (m *UhuraConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UhuraConfig.Unmarshal(m, b)
}
func (m *UhuraConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UhuraConfig.Marshal(b, m, deterministic)
}
func (m *UhuraConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UhuraConfig.Merge(m, src)
}
func (m *UhuraConfig) XXX_Size() int {
	return xxx_messageInfo_UhuraConfig.Size(m)
}
func (m *UhuraConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_UhuraConfig.DiscardUnknown(m)
}

var xxx_messageInfo_UhuraConfig proto.InternalMessageInfo

func (m *UhuraConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *UhuraConfig) GetUhuraIdfVmStateUpdateDone() bool {
	if m != nil && m.UhuraIdfVmStateUpdateDone != nil {
		return *m.UhuraIdfVmStateUpdateDone
	}
	return false
}

func (m *UhuraConfig) GetUhuraIdfFlashModeUpdateDone() bool {
	if m != nil && m.UhuraIdfFlashModeUpdateDone != nil {
		return *m.UhuraIdfFlashModeUpdateDone
	}
	return false
}

func (m *UhuraConfig) GetUhuraFlashModeReconcileDone() bool {
	if m != nil && m.UhuraFlashModeReconcileDone != nil {
		return *m.UhuraFlashModeReconcileDone
	}
	return false
}

func (m *UhuraConfig) GetUhuraFlashModeDisabledDisksDuplicatesRemoved() bool {
	if m != nil && m.UhuraFlashModeDisabledDisksDuplicatesRemoved != nil {
		return *m.UhuraFlashModeDisabledDisksDuplicatesRemoved
	}
	return false
}

// TODO: Add ESX specific fields.
// Currently only has AHV VM create fields supported by Uhura.
type VmCreateConfig struct {
	// The VM's human-readable name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An arbitrary string describing the VM.
	Annotation *string `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
	// Number of vCPUs (sockets).
	NumVcpus *uint64 `protobuf:"varint,3,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// Number of cores per vCPU.
	NumCoresPerVcpu *int64 `protobuf:"varint,4,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// The amount of RAM, in megabytes.
	MemorySizeMb *uint64 `protobuf:"varint,5,opt,name=memory_size_mb,json=memorySizeMb" json:"memory_size_mb,omitempty"`
	// Virtual disks.
	DiskList []*VmDiskConfig `protobuf:"bytes,6,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// Virtual NICs.
	NicList []*VmNicConfig `protobuf:"bytes,7,rep,name=nic_list,json=nicList" json:"nic_list,omitempty"`
	// The boot configuration.
	BootConfig *VmBootConfig `protobuf:"bytes,8,opt,name=boot_config,json=bootConfig" json:"boot_config,omitempty"`
	// The timezone for the VM's hardware clock.
	HwclockTimezone *string `protobuf:"bytes,9,opt,name=hwclock_timezone,json=hwclockTimezone,def=UTC" json:"hwclock_timezone,omitempty"`
	// Priority for restarting in case of HA event. Applicable only for AHV.
	HaPriority *int64 `protobuf:"varint,10,opt,name=ha_priority,json=haPriority" json:"ha_priority,omitempty"`
	// If set to a non-empty string, this VM should be considered incompatible
	// with DR workflows.
	//
	// This field is deprecated. It should be exposed in the REST API, but as a
	// hidden parameter. In the future, it will be removed in favor of using tags
	// for identifying service VMs.
	CbrNotCapableReason *string `protobuf:"bytes,11,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Virtual serial ports.
	SerialPortList []*VmSerialPortConfig `protobuf:"bytes,12,rep,name=serial_port_list,json=serialPortList" json:"serial_port_list,omitempty"`
	// VM to Host affinity setting.
	Affinity *Affinity `protobuf:"bytes,13,opt,name=affinity" json:"affinity,omitempty"`
	// Whether this is an agent VM.
	AgentVm *bool `protobuf:"varint,14,opt,name=agent_vm,json=agentVm,def=0" json:"agent_vm,omitempty"`
	// GPU resources.
	GpuConfigList []*VmGPUConfig `protobuf:"bytes,15,rep,name=gpu_config_list,json=gpuConfigList" json:"gpu_config_list,omitempty"`
	// Number of threads per core.
	NumThreadsPerCore *int64 `protobuf:"varint,16,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	// Whether to hard pin vcpus to vcpus.
	VcpuHardPin *bool `protobuf:"varint,17,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// The number of vNUMA nodes.
	NumVnumaNodes *uint64 `protobuf:"varint,18,opt,name=num_vnuma_nodes,json=numVnumaNodes" json:"num_vnuma_nodes,omitempty"`
	// AHV only: whether to pass through the host's CPU features.
	CpuPassthrough *bool `protobuf:"varint,19,opt,name=cpu_passthrough,json=cpuPassthrough,def=0" json:"cpu_passthrough,omitempty"`
	// Whether to disable Nutanix branding.
	DisableBranding *bool `protobuf:"varint,20,opt,name=disable_branding,json=disableBranding,def=0" json:"disable_branding,omitempty"`
	// Machine type of the VM: PC or PPC
	MachineType *string `protobuf:"bytes,21,opt,name=machine_type,json=machineType,def=pc" json:"machine_type,omitempty"`
	// If False, it will prevent users from hot plugging and unplugging of
	// PCI based devices from within VMs and from the hypervisor stack. Although
	// this applies equally for all VMs, it is primarily applicable for Windows
	// based VMs. By default, we allow hot-plugging and unplugging of devices.
	// Valid only for AHV.
	AllowHotPlug         *bool    `protobuf:"varint,22,opt,name=allow_hot_plug,json=allowHotPlug,def=1" json:"allow_hot_plug,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmCreateConfig) Reset()         { *m = VmCreateConfig{} }
func (m *VmCreateConfig) String() string { return proto.CompactTextString(m) }
func (*VmCreateConfig) ProtoMessage()    {}
func (*VmCreateConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{9}
}

func (m *VmCreateConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCreateConfig.Unmarshal(m, b)
}
func (m *VmCreateConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCreateConfig.Marshal(b, m, deterministic)
}
func (m *VmCreateConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCreateConfig.Merge(m, src)
}
func (m *VmCreateConfig) XXX_Size() int {
	return xxx_messageInfo_VmCreateConfig.Size(m)
}
func (m *VmCreateConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCreateConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmCreateConfig proto.InternalMessageInfo

const Default_VmCreateConfig_HwclockTimezone string = "UTC"
const Default_VmCreateConfig_AgentVm bool = false
const Default_VmCreateConfig_CpuPassthrough bool = false
const Default_VmCreateConfig_DisableBranding bool = false
const Default_VmCreateConfig_MachineType string = "pc"
const Default_VmCreateConfig_AllowHotPlug bool = true

func (m *VmCreateConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmCreateConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VmCreateConfig) GetNumVcpus() uint64 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmCreateConfig) GetNumCoresPerVcpu() int64 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *VmCreateConfig) GetMemorySizeMb() uint64 {
	if m != nil && m.MemorySizeMb != nil {
		return *m.MemorySizeMb
	}
	return 0
}

func (m *VmCreateConfig) GetDiskList() []*VmDiskConfig {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *VmCreateConfig) GetNicList() []*VmNicConfig {
	if m != nil {
		return m.NicList
	}
	return nil
}

func (m *VmCreateConfig) GetBootConfig() *VmBootConfig {
	if m != nil {
		return m.BootConfig
	}
	return nil
}

func (m *VmCreateConfig) GetHwclockTimezone() string {
	if m != nil && m.HwclockTimezone != nil {
		return *m.HwclockTimezone
	}
	return Default_VmCreateConfig_HwclockTimezone
}

func (m *VmCreateConfig) GetHaPriority() int64 {
	if m != nil && m.HaPriority != nil {
		return *m.HaPriority
	}
	return 0
}

func (m *VmCreateConfig) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VmCreateConfig) GetSerialPortList() []*VmSerialPortConfig {
	if m != nil {
		return m.SerialPortList
	}
	return nil
}

func (m *VmCreateConfig) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *VmCreateConfig) GetAgentVm() bool {
	if m != nil && m.AgentVm != nil {
		return *m.AgentVm
	}
	return Default_VmCreateConfig_AgentVm
}

func (m *VmCreateConfig) GetGpuConfigList() []*VmGPUConfig {
	if m != nil {
		return m.GpuConfigList
	}
	return nil
}

func (m *VmCreateConfig) GetNumThreadsPerCore() int64 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

func (m *VmCreateConfig) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *VmCreateConfig) GetNumVnumaNodes() uint64 {
	if m != nil && m.NumVnumaNodes != nil {
		return *m.NumVnumaNodes
	}
	return 0
}

func (m *VmCreateConfig) GetCpuPassthrough() bool {
	if m != nil && m.CpuPassthrough != nil {
		return *m.CpuPassthrough
	}
	return Default_VmCreateConfig_CpuPassthrough
}

func (m *VmCreateConfig) GetDisableBranding() bool {
	if m != nil && m.DisableBranding != nil {
		return *m.DisableBranding
	}
	return Default_VmCreateConfig_DisableBranding
}

func (m *VmCreateConfig) GetMachineType() string {
	if m != nil && m.MachineType != nil {
		return *m.MachineType
	}
	return Default_VmCreateConfig_MachineType
}

func (m *VmCreateConfig) GetAllowHotPlug() bool {
	if m != nil && m.AllowHotPlug != nil {
		return *m.AllowHotPlug
	}
	return Default_VmCreateConfig_AllowHotPlug
}

// Configuration for creating a virtual disk.
type VmDiskCreateConfig struct {
	// The disk's size in megabytes.
	DiskSizeMb *uint64 `protobuf:"varint,1,opt,name=disk_size_mb,json=diskSizeMb" json:"disk_size_mb,omitempty"`
	// Container associated with the disk.
	ContainerUuid []byte `protobuf:"bytes,2,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// 2: Linux Path Notation
	// The path should begin with `/` followed by Container Name and then each
	// subsequent folders should be separated by `/`.
	// Ex 1: "/SelfServiceContainer/path/to/disk.vhdx"
	// Ex 2: "///SelfServiceContainer/path/to//disk.vhdx"
	DiskPath *string `protobuf:"bytes,3,opt,name=disk_path,json=diskPath" json:"disk_path,omitempty"`
	// The UUID to be assigned to the newly created disk.
	VmdiskUuid []byte `protobuf:"bytes,4,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// The disk's size in bytes.
	DiskSizeBytes        *uint64  `protobuf:"varint,5,opt,name=disk_size_bytes,json=diskSizeBytes" json:"disk_size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskCreateConfig) Reset()         { *m = VmDiskCreateConfig{} }
func (m *VmDiskCreateConfig) String() string { return proto.CompactTextString(m) }
func (*VmDiskCreateConfig) ProtoMessage()    {}
func (*VmDiskCreateConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{10}
}

func (m *VmDiskCreateConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskCreateConfig.Unmarshal(m, b)
}
func (m *VmDiskCreateConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskCreateConfig.Marshal(b, m, deterministic)
}
func (m *VmDiskCreateConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskCreateConfig.Merge(m, src)
}
func (m *VmDiskCreateConfig) XXX_Size() int {
	return xxx_messageInfo_VmDiskCreateConfig.Size(m)
}
func (m *VmDiskCreateConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskCreateConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskCreateConfig proto.InternalMessageInfo

func (m *VmDiskCreateConfig) GetDiskSizeMb() uint64 {
	if m != nil && m.DiskSizeMb != nil {
		return *m.DiskSizeMb
	}
	return 0
}

func (m *VmDiskCreateConfig) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskCreateConfig) GetDiskPath() string {
	if m != nil && m.DiskPath != nil {
		return *m.DiskPath
	}
	return ""
}

func (m *VmDiskCreateConfig) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VmDiskCreateConfig) GetDiskSizeBytes() uint64 {
	if m != nil && m.DiskSizeBytes != nil {
		return *m.DiskSizeBytes
	}
	return 0
}

// Configuration for attaching an existing disk.
type VmDiskSpecExisting struct {
	// 2: Linux Path Notation
	// The path should begin with `/` followed by Container Name and then each
	// subsequent folders should be separated by `/`.
	// Ex 1: "/SelfServiceContainer/path/to/disk.vhdx"
	// Ex 2: "///SelfServiceContainer/path/to//disk.vhdx"
	DiskPath *string `protobuf:"bytes,1,opt,name=disk_path,json=diskPath" json:"disk_path,omitempty"`
	// The rest are for AHV to attach an existing VM disk to a VM.
	// The existing vmdisk to use.
	VmdiskUuid []byte `protobuf:"bytes,2,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// The container in which the specified vmdisk is provisioned. This parameter
	// is recommended, but optional.
	ContainerId   *uint64 `protobuf:"varint,3,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	ContainerUuid []byte  `protobuf:"bytes,4,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// This flag must be interpreted only during VG disk creations. If true, the
	// disk will derive the iscsi target name of the VG. If false, the disk's
	// iscsi target will use the "vmdisk-<uuid>" format - this is used for
	// non-disruptive migration of shared VMDisks from shell VMs into VGs.
	UseVgIscsiTargetName *bool `protobuf:"varint,5,opt,name=use_vg_iscsi_target_name,json=useVgIscsiTargetName" json:"use_vg_iscsi_target_name,omitempty"`
	// The UUID of the source VM disk from which to clone the virtual disk.
	SourceVmdiskUuid []byte `protobuf:"bytes,6,opt,name=source_vmdisk_uuid,json=sourceVmdiskUuid" json:"source_vmdisk_uuid,omitempty"`
	// The NFS path from which to clone the virtual disk.
	SourceNfsPath        *string  `protobuf:"bytes,7,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecExisting) Reset()         { *m = VmDiskSpecExisting{} }
func (m *VmDiskSpecExisting) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecExisting) ProtoMessage()    {}
func (*VmDiskSpecExisting) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{11}
}

func (m *VmDiskSpecExisting) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecExisting.Unmarshal(m, b)
}
func (m *VmDiskSpecExisting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecExisting.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecExisting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecExisting.Merge(m, src)
}
func (m *VmDiskSpecExisting) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecExisting.Size(m)
}
func (m *VmDiskSpecExisting) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecExisting.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecExisting proto.InternalMessageInfo

func (m *VmDiskSpecExisting) GetDiskPath() string {
	if m != nil && m.DiskPath != nil {
		return *m.DiskPath
	}
	return ""
}

func (m *VmDiskSpecExisting) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecExisting) GetContainerId() uint64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskSpecExisting) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecExisting) GetUseVgIscsiTargetName() bool {
	if m != nil && m.UseVgIscsiTargetName != nil {
		return *m.UseVgIscsiTargetName
	}
	return false
}

func (m *VmDiskSpecExisting) GetSourceVmdiskUuid() []byte {
	if m != nil {
		return m.SourceVmdiskUuid
	}
	return nil
}

func (m *VmDiskSpecExisting) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

// Configuration for cloning an existing virtual disk.
type VmDiskCloneConfig struct {
	// Required. Address of the source disk or image from which to clone.
	DiskAddr *VmDiskAddress `protobuf:"bytes,1,opt,name=disk_addr,json=diskAddr" json:"disk_addr,omitempty"`
	// The container in which the specified image or vmdisk is stored.
	//
	// If the source is a vmdisk, this field is recommended, but optional.
	// If the source is a snapshot vmdisk, this field is required.
	// If the source is an absolute image path, this field is prohibited.
	// If the source is a relative image path, this field is required.
	ContainerUuid []byte `protobuf:"bytes,2,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// UUID of the snapshot consistency group from which to clone a snapshot
	// vmdisk.
	SnapshotGroupUuid []byte `protobuf:"bytes,3,opt,name=snapshot_group_uuid,json=snapshotGroupUuid" json:"snapshot_group_uuid,omitempty"`
	// The minimum size of the resulting clone in bytes.
	// Applicable only for AHV.
	MinSizeBytes *int64 `protobuf:"varint,4,opt,name=min_size_bytes,json=minSizeBytes" json:"min_size_bytes,omitempty"`
	// The UUID to be assigned to the cloned disk.
	NewVmdiskUuid []byte `protobuf:"bytes,5,opt,name=new_vmdisk_uuid,json=newVmdiskUuid" json:"new_vmdisk_uuid,omitempty"`
	// The UUID of the source VM disk from which to clone the virtual disk.
	SourceVmdiskUuid []byte `protobuf:"bytes,6,opt,name=source_vmdisk_uuid,json=sourceVmdiskUuid" json:"source_vmdisk_uuid,omitempty"`
	// The NFS path from which to clone the virtual disk.
	SourceNfsPath        *string  `protobuf:"bytes,7,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskCloneConfig) Reset()         { *m = VmDiskCloneConfig{} }
func (m *VmDiskCloneConfig) String() string { return proto.CompactTextString(m) }
func (*VmDiskCloneConfig) ProtoMessage()    {}
func (*VmDiskCloneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{12}
}

func (m *VmDiskCloneConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskCloneConfig.Unmarshal(m, b)
}
func (m *VmDiskCloneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskCloneConfig.Marshal(b, m, deterministic)
}
func (m *VmDiskCloneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskCloneConfig.Merge(m, src)
}
func (m *VmDiskCloneConfig) XXX_Size() int {
	return xxx_messageInfo_VmDiskCloneConfig.Size(m)
}
func (m *VmDiskCloneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskCloneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskCloneConfig proto.InternalMessageInfo

func (m *VmDiskCloneConfig) GetDiskAddr() *VmDiskAddress {
	if m != nil {
		return m.DiskAddr
	}
	return nil
}

func (m *VmDiskCloneConfig) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskCloneConfig) GetSnapshotGroupUuid() []byte {
	if m != nil {
		return m.SnapshotGroupUuid
	}
	return nil
}

func (m *VmDiskCloneConfig) GetMinSizeBytes() int64 {
	if m != nil && m.MinSizeBytes != nil {
		return *m.MinSizeBytes
	}
	return 0
}

func (m *VmDiskCloneConfig) GetNewVmdiskUuid() []byte {
	if m != nil {
		return m.NewVmdiskUuid
	}
	return nil
}

func (m *VmDiskCloneConfig) GetSourceVmdiskUuid() []byte {
	if m != nil {
		return m.SourceVmdiskUuid
	}
	return nil
}

func (m *VmDiskCloneConfig) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

// This message encapsulates the parameters that are required for cloning a
// vmdisk in AOS from a datasource outside an AOS cluster.
type VmDiskSpecCloneExternal struct {
	// The disk's size in bytes. If not specified, the vmdisk provisioned in
	// AOS will have the same size as the external datasource. If specified,
	// the value will be honored only if it is at least as large as the size of
	// the datasource.
	MinSizeBytes *uint64 `protobuf:"varint,1,opt,name=min_size_bytes,json=minSizeBytes" json:"min_size_bytes,omitempty"`
	// Required. The container associated with the disk.
	ContainerUuid []byte `protobuf:"bytes,2,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Required. URL of the external datasource. It should be a hierarchical URL
	// of the form "scheme://server:<port>/path". Only NFS-based datasources
	// are supported today.
	// Example: "nfs://10.45.131.7/export1/sql_server/data_disk1"
	DiskUrl              *string  `protobuf:"bytes,3,opt,name=disk_url,json=diskUrl" json:"disk_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecCloneExternal) Reset()         { *m = VmDiskSpecCloneExternal{} }
func (m *VmDiskSpecCloneExternal) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecCloneExternal) ProtoMessage()    {}
func (*VmDiskSpecCloneExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{13}
}

func (m *VmDiskSpecCloneExternal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecCloneExternal.Unmarshal(m, b)
}
func (m *VmDiskSpecCloneExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecCloneExternal.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecCloneExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecCloneExternal.Merge(m, src)
}
func (m *VmDiskSpecCloneExternal) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecCloneExternal.Size(m)
}
func (m *VmDiskSpecCloneExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecCloneExternal.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecCloneExternal proto.InternalMessageInfo

func (m *VmDiskSpecCloneExternal) GetMinSizeBytes() uint64 {
	if m != nil && m.MinSizeBytes != nil {
		return *m.MinSizeBytes
	}
	return 0
}

func (m *VmDiskSpecCloneExternal) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecCloneExternal) GetDiskUrl() string {
	if m != nil && m.DiskUrl != nil {
		return *m.DiskUrl
	}
	return ""
}

// This message encapsulates the parameters that are required for provisioning
// a passthrough vmdisk in AOS. A passthrough vmdisk forwards both reads and
// writes to the backing datasource.
type VmDiskSpecPassthruExternal struct {
	// Container ID, name or UUID. Specifying a container is completely optional
	// while provisioning a passthrough vmdisk because no data is stored in AOS.
	// In this case, the default container provisioned in an AOS cluster will
	// be used for the vmdisk.
	ContainerUuid []byte `protobuf:"bytes,1,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Required. URL of the external datasource. It should be a hierarchical URL
	// of the form "scheme://server:<port>/path". Only NFS-based datasources
	// are supported today.
	// Example: "nfs://10.45.131.7/export1/sql_server/data_disk1"
	DiskUrl              *string  `protobuf:"bytes,2,opt,name=disk_url,json=diskUrl" json:"disk_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskSpecPassthruExternal) Reset()         { *m = VmDiskSpecPassthruExternal{} }
func (m *VmDiskSpecPassthruExternal) String() string { return proto.CompactTextString(m) }
func (*VmDiskSpecPassthruExternal) ProtoMessage()    {}
func (*VmDiskSpecPassthruExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{14}
}

func (m *VmDiskSpecPassthruExternal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskSpecPassthruExternal.Unmarshal(m, b)
}
func (m *VmDiskSpecPassthruExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskSpecPassthruExternal.Marshal(b, m, deterministic)
}
func (m *VmDiskSpecPassthruExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskSpecPassthruExternal.Merge(m, src)
}
func (m *VmDiskSpecPassthruExternal) XXX_Size() int {
	return xxx_messageInfo_VmDiskSpecPassthruExternal.Size(m)
}
func (m *VmDiskSpecPassthruExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskSpecPassthruExternal.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskSpecPassthruExternal proto.InternalMessageInfo

func (m *VmDiskSpecPassthruExternal) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *VmDiskSpecPassthruExternal) GetDiskUrl() string {
	if m != nil && m.DiskUrl != nil {
		return *m.DiskUrl
	}
	return ""
}

// Virtual disk address information.
type VmDiskAddress struct {
	// Adapter type of the virtual disk device.
	AdapterType *VmDiskAddress_AdapterType `protobuf:"varint,1,opt,name=adapter_type,json=adapterType,enum=nutanix.uhura.VmDiskAddress_AdapterType" json:"adapter_type,omitempty"`
	// Index of the device specific to the adapter type.
	DeviceIndex *int32 `protobuf:"varint,2,opt,name=device_index,json=deviceIndex" json:"device_index,omitempty"`
	// Virtual disk identifier.
	VmdiskUuid []byte `protobuf:"bytes,3,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// NFS path to existing virtual disk.
	NfsPath *string `protobuf:"bytes,4,opt,name=nfs_path,json=nfsPath" json:"nfs_path,omitempty"`
	// Whether this is a CD-ROM drive.
	// NOTE: This field is deprecated now. This has been replaced with is_cdrom
	// field in VmDiskInfo message.
	IsCdrom *bool `protobuf:"varint,5,opt,name=is_cdrom,json=isCdrom" json:"is_cdrom,omitempty"` // Deprecated: Do not use.
	// Information about attached disk.
	// Disk label (for example, scsi0:0) where the virtual disk was attached.
	// This indicates the location of the virtual disk within the VM.
	DiskLabel *string `protobuf:"bytes,6,opt,name=disk_label,json=diskLabel" json:"disk_label,omitempty"`
	// Whether this is a raw disk. This can be false for ESX in case this disk is a
	// descriptor vmdk file. Note that cloning from a vmdk file is not supported
	// currently.
	RawDisk *bool `protobuf:"varint,7,opt,name=raw_disk,json=rawDisk,def=1" json:"raw_disk,omitempty"`
	// The volume group identifier. If this field is set, this disk object
	// represents a volume group and the vmdisk_uuid field must be unset.
	// Applicable for AHV only.
	VolumeGroupUuid []byte `protobuf:"bytes,8,opt,name=volume_group_uuid,json=volumeGroupUuid" json:"volume_group_uuid,omitempty"`
	// VHD path to existing virtual disk.
	// Applicable only for HyperV.
	DiskPath *string `protobuf:"bytes,9,opt,name=disk_path,json=diskPath" json:"disk_path,omitempty"`
	// The device UUID that uniquely identifies a disk.
	DeviceUuid           []byte   `protobuf:"bytes,10,opt,name=device_uuid,json=deviceUuid" json:"device_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskAddress) Reset()         { *m = VmDiskAddress{} }
func (m *VmDiskAddress) String() string { return proto.CompactTextString(m) }
func (*VmDiskAddress) ProtoMessage()    {}
func (*VmDiskAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{15}
}

func (m *VmDiskAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskAddress.Unmarshal(m, b)
}
func (m *VmDiskAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskAddress.Marshal(b, m, deterministic)
}
func (m *VmDiskAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskAddress.Merge(m, src)
}
func (m *VmDiskAddress) XXX_Size() int {
	return xxx_messageInfo_VmDiskAddress.Size(m)
}
func (m *VmDiskAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskAddress.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskAddress proto.InternalMessageInfo

const Default_VmDiskAddress_RawDisk bool = true

func (m *VmDiskAddress) GetAdapterType() VmDiskAddress_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return VmDiskAddress_kSCSI
}

func (m *VmDiskAddress) GetDeviceIndex() int32 {
	if m != nil && m.DeviceIndex != nil {
		return *m.DeviceIndex
	}
	return 0
}

func (m *VmDiskAddress) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VmDiskAddress) GetNfsPath() string {
	if m != nil && m.NfsPath != nil {
		return *m.NfsPath
	}
	return ""
}

// Deprecated: Do not use.
func (m *VmDiskAddress) GetIsCdrom() bool {
	if m != nil && m.IsCdrom != nil {
		return *m.IsCdrom
	}
	return false
}

func (m *VmDiskAddress) GetDiskLabel() string {
	if m != nil && m.DiskLabel != nil {
		return *m.DiskLabel
	}
	return ""
}

func (m *VmDiskAddress) GetRawDisk() bool {
	if m != nil && m.RawDisk != nil {
		return *m.RawDisk
	}
	return Default_VmDiskAddress_RawDisk
}

func (m *VmDiskAddress) GetVolumeGroupUuid() []byte {
	if m != nil {
		return m.VolumeGroupUuid
	}
	return nil
}

func (m *VmDiskAddress) GetDiskPath() string {
	if m != nil && m.DiskPath != nil {
		return *m.DiskPath
	}
	return ""
}

func (m *VmDiskAddress) GetDeviceUuid() []byte {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

// Information about a virtual disk.
type VmDiskInfo struct {
	// Address of the virtual disk.
	DiskAddr *VmDiskAddress `protobuf:"bytes,1,opt,name=disk_addr,json=diskAddr" json:"disk_addr,omitempty"`
	// Whether the drive should be empty. Only applicable for CD-ROM drives.
	IsEmpty *bool `protobuf:"varint,2,opt,name=is_empty,json=isEmpty" json:"is_empty,omitempty"`
	// Whether the disk is thin provisioned.
	// Note: This field applies to only ESX managed VMs.
	IsThinProvisioned *bool `protobuf:"varint,3,opt,name=is_thin_provisioned,json=isThinProvisioned" json:"is_thin_provisioned,omitempty"`
	// Address of the source virtual disk from which this disk was cloned.
	SourceVmdiskAddr *VmDiskAddress `protobuf:"bytes,4,opt,name=source_vmdisk_addr,json=sourceVmdiskAddr" json:"source_vmdisk_addr,omitempty"`
	// Whether the disk is shared with another VM. Shared disks are not
	// included in snapshots.
	Shared *bool `protobuf:"varint,5,opt,name=shared" json:"shared,omitempty"`
	// The container in which the backing vmdisk is provisioned. This field is
	// unset when drive is empty.
	ContainerId *int64 `protobuf:"varint,6,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Whether this disk has been attached through passthrough mode to pass all
	// SCSI commands directly to Stargate via iSCSI. Only applicable when
	// 'disk_addr.adater_type' is 'kSCSI'.
	ScsiPassthroughEnabled *bool `protobuf:"varint,7,opt,name=scsi_passthrough_enabled,json=scsiPassthroughEnabled" json:"scsi_passthrough_enabled,omitempty"`
	// Whether flash mode is enabled on this virutal disk. This is a Nutanix
	// specific attribute.
	FlashModeEnabled *bool `protobuf:"varint,8,opt,name=flash_mode_enabled,json=flashModeEnabled,def=0" json:"flash_mode_enabled,omitempty"`
	// Disk size in bytes.
	SizeBytes *int64 `protobuf:"varint,9,opt,name=size_bytes,json=sizeBytes" json:"size_bytes,omitempty"`
	// Whether this is a CD-ROM drive.
	IsCdrom *bool `protobuf:"varint,10,opt,name=is_cdrom,json=isCdrom" json:"is_cdrom,omitempty"`
	// NFS file pathnames of the disk extents that back the virtual disk.
	// Since the disk extents can themselves come from different datastores/
	// containers, the following list entries include the container name
	// in the pathname. Read only field. Format: /container-name/file-path
	DiskExtentFilePathNameList []string `protobuf:"bytes,11,rep,name=disk_extent_file_path_name_list,json=diskExtentFilePathNameList" json:"disk_extent_file_path_name_list,omitempty"`
	// Whether the device is connected to the VM. Applicable only for Virtual CD.
	IsConnected *bool `protobuf:"varint,12,opt,name=is_connected,json=isConnected" json:"is_connected,omitempty"`
	// To support instantly recovering workload on AHV, it is possible to create
	// a virtual disk attached to a virtual machine that's backed partially or
	// fully by a data source outside the underlying AOS cluster. The following
	// read-only property gives the URL address of the data source that's backing
	// the virtual machine disk. Note that this property is dynamic -- once AOS
	// ingests the data and seeds the AOS cluster, this property will be unset.
	DataSourceUrl        *string  `protobuf:"bytes,13,opt,name=data_source_url,json=dataSourceUrl" json:"data_source_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskInfo) Reset()         { *m = VmDiskInfo{} }
func (m *VmDiskInfo) String() string { return proto.CompactTextString(m) }
func (*VmDiskInfo) ProtoMessage()    {}
func (*VmDiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{16}
}

func (m *VmDiskInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskInfo.Unmarshal(m, b)
}
func (m *VmDiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskInfo.Marshal(b, m, deterministic)
}
func (m *VmDiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskInfo.Merge(m, src)
}
func (m *VmDiskInfo) XXX_Size() int {
	return xxx_messageInfo_VmDiskInfo.Size(m)
}
func (m *VmDiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskInfo proto.InternalMessageInfo

const Default_VmDiskInfo_FlashModeEnabled bool = false

func (m *VmDiskInfo) GetDiskAddr() *VmDiskAddress {
	if m != nil {
		return m.DiskAddr
	}
	return nil
}

func (m *VmDiskInfo) GetIsEmpty() bool {
	if m != nil && m.IsEmpty != nil {
		return *m.IsEmpty
	}
	return false
}

func (m *VmDiskInfo) GetIsThinProvisioned() bool {
	if m != nil && m.IsThinProvisioned != nil {
		return *m.IsThinProvisioned
	}
	return false
}

func (m *VmDiskInfo) GetSourceVmdiskAddr() *VmDiskAddress {
	if m != nil {
		return m.SourceVmdiskAddr
	}
	return nil
}

func (m *VmDiskInfo) GetShared() bool {
	if m != nil && m.Shared != nil {
		return *m.Shared
	}
	return false
}

func (m *VmDiskInfo) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VmDiskInfo) GetScsiPassthroughEnabled() bool {
	if m != nil && m.ScsiPassthroughEnabled != nil {
		return *m.ScsiPassthroughEnabled
	}
	return false
}

func (m *VmDiskInfo) GetFlashModeEnabled() bool {
	if m != nil && m.FlashModeEnabled != nil {
		return *m.FlashModeEnabled
	}
	return Default_VmDiskInfo_FlashModeEnabled
}

func (m *VmDiskInfo) GetSizeBytes() int64 {
	if m != nil && m.SizeBytes != nil {
		return *m.SizeBytes
	}
	return 0
}

func (m *VmDiskInfo) GetIsCdrom() bool {
	if m != nil && m.IsCdrom != nil {
		return *m.IsCdrom
	}
	return false
}

func (m *VmDiskInfo) GetDiskExtentFilePathNameList() []string {
	if m != nil {
		return m.DiskExtentFilePathNameList
	}
	return nil
}

func (m *VmDiskInfo) GetIsConnected() bool {
	if m != nil && m.IsConnected != nil {
		return *m.IsConnected
	}
	return false
}

func (m *VmDiskInfo) GetDataSourceUrl() string {
	if m != nil && m.DataSourceUrl != nil {
		return *m.DataSourceUrl
	}
	return ""
}

// Configuration parameters for a virtual disk.
type VmDiskConfig struct {
	// Adapter type of the virtual disk device.
	AdapterType *VmDiskAddress_AdapterType `protobuf:"varint,1,opt,name=adapter_type,json=adapterType,enum=nutanix.uhura.VmDiskAddress_AdapterType" json:"adapter_type,omitempty"`
	// Index of the device on the adapter type. If left unspecified, the system
	// will allocate the next available slot on the default bus.
	DeviceIndex *int32 `protobuf:"varint,2,opt,name=device_index,json=deviceIndex" json:"device_index,omitempty"`
	// Whether this is a CD-ROM drive. Note: SCSI Virtual CD is not supported for
	// ESX.
	IsCdrom *bool `protobuf:"varint,3,opt,name=is_cdrom,json=isCdrom" json:"is_cdrom,omitempty"`
	// Whether the drive should be empty. Only applicable for CD-ROM drives.
	IsEmpty *bool `protobuf:"varint,4,opt,name=is_empty,json=isEmpty" json:"is_empty,omitempty"`
	// Whether the disk is thin provisioned.
	// Note: This field applies to only ESX managed VMs.
	IsThinProvisioned *bool `protobuf:"varint,5,opt,name=is_thin_provisioned,json=isThinProvisioned" json:"is_thin_provisioned,omitempty"`
	// Disk creation style. Exactly one among `clone`, `create`, `existing`,
	// `clone_external` and `passthru_external` must be provided (if this is not
	// an empty CD-ROM drive). `existing` is currently supported only for HyperV.
	Clone    *VmDiskCloneConfig  `protobuf:"bytes,6,opt,name=clone" json:"clone,omitempty"`
	Create   *VmDiskCreateConfig `protobuf:"bytes,7,opt,name=create" json:"create,omitempty"`
	Existing *VmDiskSpecExisting `protobuf:"bytes,10,opt,name=existing" json:"existing,omitempty"`
	// NFS path to existing virtual disk.
	// Note: This field applies to only ESX managed VMs.
	NfsPath *string `protobuf:"bytes,8,opt,name=nfs_path,json=nfsPath" json:"nfs_path,omitempty"`
	// Whether this disk has been attached through passthrough mode to pass all
	// SCSI commands directly to Stargate via iSCSI. Only applicable when
	// 'disk_addr.adater_type' is 'kSCSI'.
	ScsiPassthroughEnabled *bool `protobuf:"varint,9,opt,name=scsi_passthrough_enabled,json=scsiPassthroughEnabled" json:"scsi_passthrough_enabled,omitempty"`
	// ISO Disk Path for HyperV used while VmDiskUpdate
	DiskPath *string `protobuf:"bytes,11,opt,name=disk_path,json=diskPath" json:"disk_path,omitempty"`
	// The device UUID of newly created/cloned disk.
	DeviceUuid []byte `protobuf:"bytes,12,opt,name=device_uuid,json=deviceUuid" json:"device_uuid,omitempty"`
	// Disk creation style to be used for provisioning a vmdisk cloned from
	// an external datastore. This disk creation style, today, applies only to
	// AHV.
	CloneExternal *VmDiskSpecCloneExternal `protobuf:"bytes,13,opt,name=clone_external,json=cloneExternal" json:"clone_external,omitempty"`
	// Disk creation style to be used for provisioning a vmdisk that passes
	// through both reads and writes to the external datasource. This disk
	// creation style, today, applies only to AHV.
	PassthruExternal     *VmDiskSpecPassthruExternal `protobuf:"bytes,14,opt,name=passthru_external,json=passthruExternal" json:"passthru_external,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *VmDiskConfig) Reset()         { *m = VmDiskConfig{} }
func (m *VmDiskConfig) String() string { return proto.CompactTextString(m) }
func (*VmDiskConfig) ProtoMessage()    {}
func (*VmDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{17}
}

func (m *VmDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskConfig.Unmarshal(m, b)
}
func (m *VmDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskConfig.Marshal(b, m, deterministic)
}
func (m *VmDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskConfig.Merge(m, src)
}
func (m *VmDiskConfig) XXX_Size() int {
	return xxx_messageInfo_VmDiskConfig.Size(m)
}
func (m *VmDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskConfig proto.InternalMessageInfo

func (m *VmDiskConfig) GetAdapterType() VmDiskAddress_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return VmDiskAddress_kSCSI
}

func (m *VmDiskConfig) GetDeviceIndex() int32 {
	if m != nil && m.DeviceIndex != nil {
		return *m.DeviceIndex
	}
	return 0
}

func (m *VmDiskConfig) GetIsCdrom() bool {
	if m != nil && m.IsCdrom != nil {
		return *m.IsCdrom
	}
	return false
}

func (m *VmDiskConfig) GetIsEmpty() bool {
	if m != nil && m.IsEmpty != nil {
		return *m.IsEmpty
	}
	return false
}

func (m *VmDiskConfig) GetIsThinProvisioned() bool {
	if m != nil && m.IsThinProvisioned != nil {
		return *m.IsThinProvisioned
	}
	return false
}

func (m *VmDiskConfig) GetClone() *VmDiskCloneConfig {
	if m != nil {
		return m.Clone
	}
	return nil
}

func (m *VmDiskConfig) GetCreate() *VmDiskCreateConfig {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *VmDiskConfig) GetExisting() *VmDiskSpecExisting {
	if m != nil {
		return m.Existing
	}
	return nil
}

func (m *VmDiskConfig) GetNfsPath() string {
	if m != nil && m.NfsPath != nil {
		return *m.NfsPath
	}
	return ""
}

func (m *VmDiskConfig) GetScsiPassthroughEnabled() bool {
	if m != nil && m.ScsiPassthroughEnabled != nil {
		return *m.ScsiPassthroughEnabled
	}
	return false
}

func (m *VmDiskConfig) GetDiskPath() string {
	if m != nil && m.DiskPath != nil {
		return *m.DiskPath
	}
	return ""
}

func (m *VmDiskConfig) GetDeviceUuid() []byte {
	if m != nil {
		return m.DeviceUuid
	}
	return nil
}

func (m *VmDiskConfig) GetCloneExternal() *VmDiskSpecCloneExternal {
	if m != nil {
		return m.CloneExternal
	}
	return nil
}

func (m *VmDiskConfig) GetPassthruExternal() *VmDiskSpecPassthruExternal {
	if m != nil {
		return m.PassthruExternal
	}
	return nil
}

type VmNfsFileConfig struct {
	// NFS file path. The file must exist on a Nutanix datastore and the paths
	// must be absolute, i.e., have format: "/<container>/path/to/file".
	NfsFilePath          *string               `protobuf:"bytes,1,opt,name=nfs_file_path,json=nfsFilePath" json:"nfs_file_path,omitempty"`
	Type                 *VmNfsFileConfig_Type `protobuf:"varint,2,opt,name=type,enum=nutanix.uhura.VmNfsFileConfig_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *VmNfsFileConfig) Reset()         { *m = VmNfsFileConfig{} }
func (m *VmNfsFileConfig) String() string { return proto.CompactTextString(m) }
func (*VmNfsFileConfig) ProtoMessage()    {}
func (*VmNfsFileConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{18}
}

func (m *VmNfsFileConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNfsFileConfig.Unmarshal(m, b)
}
func (m *VmNfsFileConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNfsFileConfig.Marshal(b, m, deterministic)
}
func (m *VmNfsFileConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNfsFileConfig.Merge(m, src)
}
func (m *VmNfsFileConfig) XXX_Size() int {
	return xxx_messageInfo_VmNfsFileConfig.Size(m)
}
func (m *VmNfsFileConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNfsFileConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmNfsFileConfig proto.InternalMessageInfo

func (m *VmNfsFileConfig) GetNfsFilePath() string {
	if m != nil && m.NfsFilePath != nil {
		return *m.NfsFilePath
	}
	return ""
}

func (m *VmNfsFileConfig) GetType() VmNfsFileConfig_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VmNfsFileConfig_kConfig
}

// Virtual NIC config.
type VmNicConfig struct {
	// The MAC address of the NIC.
	MacAddr []byte `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// Required. L2 network configuration.
	// DEPRECATED: This field is deprecated in favor of `network_uuid` field in
	// this proto.
	L2Config *hyperint.VmL2NetworkConfig `protobuf:"bytes,2,opt,name=l2_config,json=l2Config" json:"l2_config,omitempty"` // Deprecated: Do not use.
	// The model string.
	Model *string `protobuf:"bytes,3,opt,name=model" json:"model,omitempty"`
	// The requested IP address. In create mode, only valid if 'request_ip' is
	// true.
	// DEPRECATED: This field is deprecated in favor of `ipv4_address` and
	// 'ipv6_address' in 'ip_address_list' of this proto
	RequestedIpAddress []byte `protobuf:"bytes,4,opt,name=requested_ip_address,json=requestedIpAddress" json:"requested_ip_address,omitempty"` // Deprecated: Do not use.
	// Vlan mode.
	VlanMode *VmNicVlanType `protobuf:"varint,5,opt,name=vlan_mode,json=vlanMode,enum=nutanix.uhura.VmNicVlanType,def=1" json:"vlan_mode,omitempty"`
	// List of networks to trunk. Only valid if vlan_mode = kTrunked.
	// If trunked_network is empty, then it will trunk all vlan's.
	TrunkedNetworks []int32 `protobuf:"varint,6,rep,name=trunked_networks,json=trunkedNetworks" json:"trunked_networks,omitempty"`
	// If request_ip is true
	//   If 'ip_address_list' is set, then request that IP from the network.
	//   If it's a managed network then request a dynamic IP from the network.
	//   Otherwise don't request an IP
	// If request_ip is false, then don't request an IP at all, regardless of
	// whether or not the ip_address is set and whether or the network
	// is managed or not.
	RequestIp *bool `protobuf:"varint,7,opt,name=request_ip,json=requestIp,def=1" json:"request_ip,omitempty"`
	// Port Id or name of the NIC. Applicable only for ESX.
	PortId *string `protobuf:"bytes,8,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	// Description about the network adapter. Applicable only for ESX.
	Label       *string                  `protobuf:"bytes,9,opt,name=label" json:"label,omitempty"`
	AdapterType *VmNicConfig_AdapterType `protobuf:"varint,10,opt,name=adapter_type,json=adapterType,enum=nutanix.uhura.VmNicConfig_AdapterType,def=5" json:"adapter_type,omitempty"`
	// Required. Network UUID for which this NIC belongs to. In create mode, the
	// NIC will be linked to this network.
	NetworkUuid []byte `protobuf:"bytes,11,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// The IP address. In create mode, only valid if 'request_ip'
	// is true.
	// DEPRECATED: This field is deprecated in favor of `ipv4_address` and
	// `ipv6_address` fields in 'ip_address_list' of this proto.
	IpAddress []byte `protobuf:"bytes,12,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"` // Deprecated: Do not use.
	// Optional. Only for AHV.
	Type *VmNicType `protobuf:"varint,13,opt,name=type,enum=nutanix.uhura.VmNicType,def=1" json:"type,omitempty"`
	// This is valid only if the nic type is kNetworkFunctionNic. Only for AHV.
	NetworkFunctionNicType *NetworkFunctionNicType `protobuf:"varint,14,opt,name=network_function_nic_type,json=networkFunctionNicType,enum=nutanix.uhura.NetworkFunctionNicType" json:"network_function_nic_type,omitempty"`
	// This is valid only if the nic type is kNormalNic.
	// UUID of the network function chain to use for this NIC. Only for AHV.
	NetworkFunctionChainUuid []byte `protobuf:"bytes,15,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// Type of MAC address.
	MacAddressType *VmNicConfig_MacAddressType `protobuf:"varint,18,opt,name=mac_address_type,json=macAddressType,enum=nutanix.uhura.VmNicConfig_MacAddressType" json:"mac_address_type,omitempty"`
	// Indicates if this adapter is connected to the VM.
	Connected *bool `protobuf:"varint,19,opt,name=connected" json:"connected,omitempty"`
	// In create mode, only valid if 'request_ip' is true
	IpAddressList []*VmNicConfig_IpAddress `protobuf:"bytes,22,rep,name=ip_address_list,json=ipAddressList" json:"ip_address_list,omitempty"`
	// If this port is managed by an external controller, these are the external
	// attributes for the port. Applicable only for AHV.
	ExternalAttrList []*GenericKeyValuePair `protobuf:"bytes,23,rep,name=external_attr_list,json=externalAttrList" json:"external_attr_list,omitempty"`
	// Virtual NIC UUID.
	Uuid []byte `protobuf:"bytes,24,opt,name=uuid" json:"uuid,omitempty"`
	// Vlan Id of the network adapter. Valid values inclue [1-4094]
	// Applicable only for HyperV.
	VlanId *uint32 `protobuf:"varint,25,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// Maximum number of Tx/Rx queue pairs for this NIC.
	Queues *uint32 `protobuf:"varint,26,opt,name=queues,def=1" json:"queues,omitempty"`
	// Network name for which this NIC belongs to. Valid only for ESX.
	NetworkName          *string  `protobuf:"bytes,27,opt,name=network_name,json=networkName" json:"network_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmNicConfig) Reset()         { *m = VmNicConfig{} }
func (m *VmNicConfig) String() string { return proto.CompactTextString(m) }
func (*VmNicConfig) ProtoMessage()    {}
func (*VmNicConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{19}
}

func (m *VmNicConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNicConfig.Unmarshal(m, b)
}
func (m *VmNicConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNicConfig.Marshal(b, m, deterministic)
}
func (m *VmNicConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNicConfig.Merge(m, src)
}
func (m *VmNicConfig) XXX_Size() int {
	return xxx_messageInfo_VmNicConfig.Size(m)
}
func (m *VmNicConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNicConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmNicConfig proto.InternalMessageInfo

const Default_VmNicConfig_VlanMode VmNicVlanType = VmNicVlanType_kAccess
const Default_VmNicConfig_RequestIp bool = true
const Default_VmNicConfig_AdapterType VmNicConfig_AdapterType = VmNicConfig_kVmxnet3
const Default_VmNicConfig_Type VmNicType = VmNicType_kNormalNic
const Default_VmNicConfig_Queues uint32 = 1

func (m *VmNicConfig) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

// Deprecated: Do not use.
func (m *VmNicConfig) GetL2Config() *hyperint.VmL2NetworkConfig {
	if m != nil {
		return m.L2Config
	}
	return nil
}

func (m *VmNicConfig) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

// Deprecated: Do not use.
func (m *VmNicConfig) GetRequestedIpAddress() []byte {
	if m != nil {
		return m.RequestedIpAddress
	}
	return nil
}

func (m *VmNicConfig) GetVlanMode() VmNicVlanType {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return Default_VmNicConfig_VlanMode
}

func (m *VmNicConfig) GetTrunkedNetworks() []int32 {
	if m != nil {
		return m.TrunkedNetworks
	}
	return nil
}

func (m *VmNicConfig) GetRequestIp() bool {
	if m != nil && m.RequestIp != nil {
		return *m.RequestIp
	}
	return Default_VmNicConfig_RequestIp
}

func (m *VmNicConfig) GetPortId() string {
	if m != nil && m.PortId != nil {
		return *m.PortId
	}
	return ""
}

func (m *VmNicConfig) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *VmNicConfig) GetAdapterType() VmNicConfig_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return Default_VmNicConfig_AdapterType
}

func (m *VmNicConfig) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

// Deprecated: Do not use.
func (m *VmNicConfig) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *VmNicConfig) GetType() VmNicType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_VmNicConfig_Type
}

func (m *VmNicConfig) GetNetworkFunctionNicType() NetworkFunctionNicType {
	if m != nil && m.NetworkFunctionNicType != nil {
		return *m.NetworkFunctionNicType
	}
	return NetworkFunctionNicType_kIngress
}

func (m *VmNicConfig) GetNetworkFunctionChainUuid() []byte {
	if m != nil {
		return m.NetworkFunctionChainUuid
	}
	return nil
}

func (m *VmNicConfig) GetMacAddressType() VmNicConfig_MacAddressType {
	if m != nil && m.MacAddressType != nil {
		return *m.MacAddressType
	}
	return VmNicConfig_kStatic
}

func (m *VmNicConfig) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return false
}

func (m *VmNicConfig) GetIpAddressList() []*VmNicConfig_IpAddress {
	if m != nil {
		return m.IpAddressList
	}
	return nil
}

func (m *VmNicConfig) GetExternalAttrList() []*GenericKeyValuePair {
	if m != nil {
		return m.ExternalAttrList
	}
	return nil
}

func (m *VmNicConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmNicConfig) GetVlanId() uint32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *VmNicConfig) GetQueues() uint32 {
	if m != nil && m.Queues != nil {
		return *m.Queues
	}
	return Default_VmNicConfig_Queues
}

func (m *VmNicConfig) GetNetworkName() string {
	if m != nil && m.NetworkName != nil {
		return *m.NetworkName
	}
	return ""
}

type VmNicConfig_IpAddress struct {
	// This field is ignored when used in Nic create.
	IpAssignmentType *VmNicConfig_IpAddress_NetworkIpType `protobuf:"varint,1,opt,name=ip_assignment_type,json=ipAssignmentType,enum=nutanix.uhura.VmNicConfig_IpAddress_NetworkIpType" json:"ip_assignment_type,omitempty"`
	// Either one of ipv4_address or ipv6_address should be/is set.
	Ipv4Address          []byte   `protobuf:"bytes,2,opt,name=ipv4_address,json=ipv4Address" json:"ipv4_address,omitempty"`
	Ipv6Address          []byte   `protobuf:"bytes,3,opt,name=ipv6_address,json=ipv6Address" json:"ipv6_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmNicConfig_IpAddress) Reset()         { *m = VmNicConfig_IpAddress{} }
func (m *VmNicConfig_IpAddress) String() string { return proto.CompactTextString(m) }
func (*VmNicConfig_IpAddress) ProtoMessage()    {}
func (*VmNicConfig_IpAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{19, 0}
}

func (m *VmNicConfig_IpAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNicConfig_IpAddress.Unmarshal(m, b)
}
func (m *VmNicConfig_IpAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNicConfig_IpAddress.Marshal(b, m, deterministic)
}
func (m *VmNicConfig_IpAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNicConfig_IpAddress.Merge(m, src)
}
func (m *VmNicConfig_IpAddress) XXX_Size() int {
	return xxx_messageInfo_VmNicConfig_IpAddress.Size(m)
}
func (m *VmNicConfig_IpAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNicConfig_IpAddress.DiscardUnknown(m)
}

var xxx_messageInfo_VmNicConfig_IpAddress proto.InternalMessageInfo

func (m *VmNicConfig_IpAddress) GetIpAssignmentType() VmNicConfig_IpAddress_NetworkIpType {
	if m != nil && m.IpAssignmentType != nil {
		return *m.IpAssignmentType
	}
	return VmNicConfig_IpAddress_kLearned
}

func (m *VmNicConfig_IpAddress) GetIpv4Address() []byte {
	if m != nil {
		return m.Ipv4Address
	}
	return nil
}

func (m *VmNicConfig_IpAddress) GetIpv6Address() []byte {
	if m != nil {
		return m.Ipv6Address
	}
	return nil
}

// Virtual NIC update config.
type VmNicUpdateConfig struct {
	// The MAC address of the NIC to update.
	MacAddr []byte `protobuf:"bytes,1,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	// Network UUID configuration to be changed.
	// If this field is empty, then don't change the network.
	NetworkUuid []byte `protobuf:"bytes,2,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	// If true, then request either a dynamic or static ip address depending on
	// whether or not the 'ip_address' field is set. If false, then
	// don't request a new IP address and use the old one.
	// If this NIC is moved to a different network (network_uuid is changed to a
	// different one) then 'request_ip' is always treated as true.
	RequestIp *bool `protobuf:"varint,3,opt,name=request_ip,json=requestIp" json:"request_ip,omitempty"`
	// The requested IP address. Only valid if request_ip = True. If this field is
	// empty then request a dynamic IP address from Acropolis server instead.
	IpAddress []byte `protobuf:"bytes,4,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// If this is true, then change the vlan_mode and trunked_networks. Otherwise
	// these remain unchanged.
	ChangeVlanInfo *bool `protobuf:"varint,5,opt,name=change_vlan_info,json=changeVlanInfo" json:"change_vlan_info,omitempty"`
	// Vlan mode.
	VlanMode *VmNicVlanType `protobuf:"varint,6,opt,name=vlan_mode,json=vlanMode,enum=nutanix.uhura.VmNicVlanType,def=1" json:"vlan_mode,omitempty"`
	// List of networks to trunk. Only valid if vlan_mode = kTrunked.
	// If trunked_network is empty, then it will trunk all vlan's.
	TrunkedNetworks []int32 `protobuf:"varint,7,rep,name=trunked_networks,json=trunkedNetworks" json:"trunked_networks,omitempty"`
	// UUID of the network function chain to use for this NIC. Only for AHV.
	NetworkFunctionChainUuid []byte `protobuf:"bytes,8,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// If this is true then update the network_function_chain_uuid field. Only for AHV.
	UpdateNetworkFunctionChainUuid *bool `protobuf:"varint,9,opt,name=update_network_function_chain_uuid,json=updateNetworkFunctionChainUuid" json:"update_network_function_chain_uuid,omitempty"`
	// If this port is managed by an external controller, these are the external
	// attributes for the port. A particular identifier may be cleared by
	// specifying its key with an unset value. Applicable only for AHV.
	ExternalAttrList []*GenericKeyValuePair `protobuf:"bytes,10,rep,name=external_attr_list,json=externalAttrList" json:"external_attr_list,omitempty"`
	// Virtual NIC UUID.
	Uuid []byte `protobuf:"bytes,11,opt,name=uuid" json:"uuid,omitempty"`
	// Whether or not the nic is connected. True by default
	Connected *bool `protobuf:"varint,12,opt,name=connected,def=1" json:"connected,omitempty"`
	// Maximum number of Tx/Rx queue pairs for this NIC.
	Queues               *uint32  `protobuf:"varint,13,opt,name=queues,def=1" json:"queues,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmNicUpdateConfig) Reset()         { *m = VmNicUpdateConfig{} }
func (m *VmNicUpdateConfig) String() string { return proto.CompactTextString(m) }
func (*VmNicUpdateConfig) ProtoMessage()    {}
func (*VmNicUpdateConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{20}
}

func (m *VmNicUpdateConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNicUpdateConfig.Unmarshal(m, b)
}
func (m *VmNicUpdateConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNicUpdateConfig.Marshal(b, m, deterministic)
}
func (m *VmNicUpdateConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNicUpdateConfig.Merge(m, src)
}
func (m *VmNicUpdateConfig) XXX_Size() int {
	return xxx_messageInfo_VmNicUpdateConfig.Size(m)
}
func (m *VmNicUpdateConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNicUpdateConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmNicUpdateConfig proto.InternalMessageInfo

const Default_VmNicUpdateConfig_VlanMode VmNicVlanType = VmNicVlanType_kAccess
const Default_VmNicUpdateConfig_Connected bool = true
const Default_VmNicUpdateConfig_Queues uint32 = 1

func (m *VmNicUpdateConfig) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

func (m *VmNicUpdateConfig) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

func (m *VmNicUpdateConfig) GetRequestIp() bool {
	if m != nil && m.RequestIp != nil {
		return *m.RequestIp
	}
	return false
}

func (m *VmNicUpdateConfig) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *VmNicUpdateConfig) GetChangeVlanInfo() bool {
	if m != nil && m.ChangeVlanInfo != nil {
		return *m.ChangeVlanInfo
	}
	return false
}

func (m *VmNicUpdateConfig) GetVlanMode() VmNicVlanType {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return Default_VmNicUpdateConfig_VlanMode
}

func (m *VmNicUpdateConfig) GetTrunkedNetworks() []int32 {
	if m != nil {
		return m.TrunkedNetworks
	}
	return nil
}

func (m *VmNicUpdateConfig) GetNetworkFunctionChainUuid() []byte {
	if m != nil {
		return m.NetworkFunctionChainUuid
	}
	return nil
}

func (m *VmNicUpdateConfig) GetUpdateNetworkFunctionChainUuid() bool {
	if m != nil && m.UpdateNetworkFunctionChainUuid != nil {
		return *m.UpdateNetworkFunctionChainUuid
	}
	return false
}

func (m *VmNicUpdateConfig) GetExternalAttrList() []*GenericKeyValuePair {
	if m != nil {
		return m.ExternalAttrList
	}
	return nil
}

func (m *VmNicUpdateConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmNicUpdateConfig) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_VmNicUpdateConfig_Connected
}

func (m *VmNicUpdateConfig) GetQueues() uint32 {
	if m != nil && m.Queues != nil {
		return *m.Queues
	}
	return Default_VmNicUpdateConfig_Queues
}

type VmBootDeviceType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmBootDeviceType) Reset()         { *m = VmBootDeviceType{} }
func (m *VmBootDeviceType) String() string { return proto.CompactTextString(m) }
func (*VmBootDeviceType) ProtoMessage()    {}
func (*VmBootDeviceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{21}
}

func (m *VmBootDeviceType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootDeviceType.Unmarshal(m, b)
}
func (m *VmBootDeviceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootDeviceType.Marshal(b, m, deterministic)
}
func (m *VmBootDeviceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootDeviceType.Merge(m, src)
}
func (m *VmBootDeviceType) XXX_Size() int {
	return xxx_messageInfo_VmBootDeviceType.Size(m)
}
func (m *VmBootDeviceType) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootDeviceType.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootDeviceType proto.InternalMessageInfo

// VM boot device configuration.
type VmBootConfig struct {
	// The device from which to boot. This must refer to a valid device
	// configured on the VM.
	BootDevice *VmBootConfig_VmBootDevice `protobuf:"bytes,1,opt,name=boot_device,json=bootDevice" json:"boot_device,omitempty"`
	// Boot device order.
	BootDeviceOrder []VmBootDeviceType_Type `protobuf:"varint,2,rep,name=boot_device_order,json=bootDeviceOrder,enum=nutanix.uhura.VmBootDeviceType_Type" json:"boot_device_order,omitempty"`
	// UEFI or legacy boot.
	UefiBoot *bool `protobuf:"varint,3,opt,name=uefi_boot,json=uefiBoot,def=0" json:"uefi_boot,omitempty"`
	// The firmware config for UEFI or legacy boot. If UEFI boot, the NVRAM disk
	// spec (create/clone) is given within this firmware config.
	FirmwareConfig *VmBootConfig_VmFirmwareConfig `protobuf:"bytes,4,opt,name=firmware_config,json=firmwareConfig" json:"firmware_config,omitempty"`
	// Secure boot.
	SecureBoot *bool `protobuf:"varint,5,opt,name=secure_boot,json=secureBoot" json:"secure_boot,omitempty"`
	// Expose hardware virtualization support to guest.
	HardwareVirtualization *bool    `protobuf:"varint,6,opt,name=hardware_virtualization,json=hardwareVirtualization,def=0" json:"hardware_virtualization,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *VmBootConfig) Reset()         { *m = VmBootConfig{} }
func (m *VmBootConfig) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig) ProtoMessage()    {}
func (*VmBootConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{22}
}

func (m *VmBootConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig.Unmarshal(m, b)
}
func (m *VmBootConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig.Marshal(b, m, deterministic)
}
func (m *VmBootConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig.Merge(m, src)
}
func (m *VmBootConfig) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig.Size(m)
}
func (m *VmBootConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig proto.InternalMessageInfo

const Default_VmBootConfig_UefiBoot bool = false
const Default_VmBootConfig_HardwareVirtualization bool = false

func (m *VmBootConfig) GetBootDevice() *VmBootConfig_VmBootDevice {
	if m != nil {
		return m.BootDevice
	}
	return nil
}

func (m *VmBootConfig) GetBootDeviceOrder() []VmBootDeviceType_Type {
	if m != nil {
		return m.BootDeviceOrder
	}
	return nil
}

func (m *VmBootConfig) GetUefiBoot() bool {
	if m != nil && m.UefiBoot != nil {
		return *m.UefiBoot
	}
	return Default_VmBootConfig_UefiBoot
}

func (m *VmBootConfig) GetFirmwareConfig() *VmBootConfig_VmFirmwareConfig {
	if m != nil {
		return m.FirmwareConfig
	}
	return nil
}

func (m *VmBootConfig) GetSecureBoot() bool {
	if m != nil && m.SecureBoot != nil {
		return *m.SecureBoot
	}
	return false
}

func (m *VmBootConfig) GetHardwareVirtualization() bool {
	if m != nil && m.HardwareVirtualization != nil {
		return *m.HardwareVirtualization
	}
	return Default_VmBootConfig_HardwareVirtualization
}

type VmBootConfig_VmBootDevice struct {
	// Exactly one of the following must be set.
	DiskAddr             *VmDiskAddress `protobuf:"bytes,1,opt,name=disk_addr,json=diskAddr" json:"disk_addr,omitempty"`
	MacAddr              []byte         `protobuf:"bytes,2,opt,name=mac_addr,json=macAddr" json:"mac_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *VmBootConfig_VmBootDevice) Reset()         { *m = VmBootConfig_VmBootDevice{} }
func (m *VmBootConfig_VmBootDevice) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig_VmBootDevice) ProtoMessage()    {}
func (*VmBootConfig_VmBootDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{22, 0}
}

func (m *VmBootConfig_VmBootDevice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig_VmBootDevice.Unmarshal(m, b)
}
func (m *VmBootConfig_VmBootDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig_VmBootDevice.Marshal(b, m, deterministic)
}
func (m *VmBootConfig_VmBootDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig_VmBootDevice.Merge(m, src)
}
func (m *VmBootConfig_VmBootDevice) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig_VmBootDevice.Size(m)
}
func (m *VmBootConfig_VmBootDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig_VmBootDevice.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig_VmBootDevice proto.InternalMessageInfo

func (m *VmBootConfig_VmBootDevice) GetDiskAddr() *VmDiskAddress {
	if m != nil {
		return m.DiskAddr
	}
	return nil
}

func (m *VmBootConfig_VmBootDevice) GetMacAddr() []byte {
	if m != nil {
		return m.MacAddr
	}
	return nil
}

type VmBootConfig_VmFirmwareConfig struct {
	// Disk config for NVRAM disk.
	NvramDiskConfig *VmDiskConfig `protobuf:"bytes,1,opt,name=nvram_disk_config,json=nvramDiskConfig" json:"nvram_disk_config,omitempty"`
	// The uuid of the NVRAM disk backed by stargate, to support EFI guests.
	NvramDiskUuid        []byte   `protobuf:"bytes,2,opt,name=nvram_disk_uuid,json=nvramDiskUuid" json:"nvram_disk_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmBootConfig_VmFirmwareConfig) Reset()         { *m = VmBootConfig_VmFirmwareConfig{} }
func (m *VmBootConfig_VmFirmwareConfig) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig_VmFirmwareConfig) ProtoMessage()    {}
func (*VmBootConfig_VmFirmwareConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{22, 1}
}

func (m *VmBootConfig_VmFirmwareConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Unmarshal(m, b)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Marshal(b, m, deterministic)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Merge(m, src)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig_VmFirmwareConfig.Size(m)
}
func (m *VmBootConfig_VmFirmwareConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig_VmFirmwareConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig_VmFirmwareConfig proto.InternalMessageInfo

func (m *VmBootConfig_VmFirmwareConfig) GetNvramDiskConfig() *VmDiskConfig {
	if m != nil {
		return m.NvramDiskConfig
	}
	return nil
}

func (m *VmBootConfig_VmFirmwareConfig) GetNvramDiskUuid() []byte {
	if m != nil {
		return m.NvramDiskUuid
	}
	return nil
}

// Configuration parameters for VM clones.
type VmCloneConfig struct {
	// Clone name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// VM UUID that the client may specify.
	Uuid []byte `protobuf:"bytes,8,opt,name=uuid" json:"uuid,omitempty"`
	// VM placement parameters.
	// Only one of 'hypervisor_type' or 'host_uuid' should be specified.
	// The hypervisor type for VM placement.
	HypervisorType *config.ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,10,opt,name=hypervisor_type,json=hypervisorType,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType" json:"hypervisor_type,omitempty"`
	// Host where the cloned VM needs to be placed.
	// Supported only on AHV and ESXi.
	HostUuid []byte `protobuf:"bytes,9,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// Field to override the number of vCPUs (sockets) assigned to the
	// clone.
	NumVcpus *uint32 `protobuf:"varint,2,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// Field to override the amount of RAM assigned to the clone.
	MemorySizeMb *uint64 `protobuf:"varint,3,opt,name=memory_size_mb,json=memorySizeMb" json:"memory_size_mb,omitempty"`
	// AHV only: Whether to override the source VM's/snapshot's network
	// configuration with the one specified in the nic_list field. If false, the
	// clone will inherit its basic network configuration from the source, minus
	// MAC and IP address assignments.
	OverrideNetworkConfig *bool `protobuf:"varint,4,opt,name=override_network_config,json=overrideNetworkConfig" json:"override_network_config,omitempty"`
	// AHV only: Explicit network configuration, when override_network_config
	// is true.
	NicList []*VmNicConfig `protobuf:"bytes,5,rep,name=nic_list,json=nicList" json:"nic_list,omitempty"`
	// AHV only: Field to override the boot configuration for the clone.
	BootConfig *VmBootConfig `protobuf:"bytes,6,opt,name=boot_config,json=bootConfig" json:"boot_config,omitempty"`
	// Field to override the number of cores per vCPU.
	NumCoresPerVcpu *int64 `protobuf:"varint,7,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// AHV only: Whether to clone source VM's affinity rules.
	CloneAffinity *bool `protobuf:"varint,11,opt,name=clone_affinity,json=cloneAffinity,def=0" json:"clone_affinity,omitempty"`
	// Unused field.
	// Path where cloned files need to be copied.
	Path *string `protobuf:"bytes,12,opt,name=path" json:"path,omitempty"`
	// AHV only: Field to override the number of threads per core.
	NumThreadsPerCore *int64 `protobuf:"varint,13,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	// AHV only: Indicates whether the vcpus are hard pinned to specific pcpus.
	VcpuHardPin *bool `protobuf:"varint,14,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// AHV only: whether to pass through the host's CPU features.
	CpuPassthrough *bool `protobuf:"varint,15,opt,name=cpu_passthrough,json=cpuPassthrough" json:"cpu_passthrough,omitempty"`
	// AHV only: Whether to disable Nutanix branding.
	DisableBranding *bool `protobuf:"varint,16,opt,name=disable_branding,json=disableBranding" json:"disable_branding,omitempty"`
	// AHV only: Machine type - PC or PPC.
	MachineType *string `protobuf:"bytes,17,opt,name=machine_type,json=machineType" json:"machine_type,omitempty"`
	// If False, it will prevent users from hot plugging and unplugging of
	// PCI based devices from within VMs and from the hypervisor stack. Although
	// this applies equally for all VMs, it is primarily applicable for Windows
	// based VMs. By default, we allow hot-plugging and unplugging of devices.
	// Valid only for AHV.
	AllowHotPlug         *bool    `protobuf:"varint,18,opt,name=allow_hot_plug,json=allowHotPlug,def=1" json:"allow_hot_plug,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmCloneConfig) Reset()         { *m = VmCloneConfig{} }
func (m *VmCloneConfig) String() string { return proto.CompactTextString(m) }
func (*VmCloneConfig) ProtoMessage()    {}
func (*VmCloneConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{23}
}

func (m *VmCloneConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCloneConfig.Unmarshal(m, b)
}
func (m *VmCloneConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCloneConfig.Marshal(b, m, deterministic)
}
func (m *VmCloneConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCloneConfig.Merge(m, src)
}
func (m *VmCloneConfig) XXX_Size() int {
	return xxx_messageInfo_VmCloneConfig.Size(m)
}
func (m *VmCloneConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCloneConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmCloneConfig proto.InternalMessageInfo

const Default_VmCloneConfig_CloneAffinity bool = false
const Default_VmCloneConfig_AllowHotPlug bool = true

func (m *VmCloneConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmCloneConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmCloneConfig) GetHypervisorType() config.ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return config.ConfigurationProto_ManagementServer_kVMware
}

func (m *VmCloneConfig) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *VmCloneConfig) GetNumVcpus() uint32 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmCloneConfig) GetMemorySizeMb() uint64 {
	if m != nil && m.MemorySizeMb != nil {
		return *m.MemorySizeMb
	}
	return 0
}

func (m *VmCloneConfig) GetOverrideNetworkConfig() bool {
	if m != nil && m.OverrideNetworkConfig != nil {
		return *m.OverrideNetworkConfig
	}
	return false
}

func (m *VmCloneConfig) GetNicList() []*VmNicConfig {
	if m != nil {
		return m.NicList
	}
	return nil
}

func (m *VmCloneConfig) GetBootConfig() *VmBootConfig {
	if m != nil {
		return m.BootConfig
	}
	return nil
}

func (m *VmCloneConfig) GetNumCoresPerVcpu() int64 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *VmCloneConfig) GetCloneAffinity() bool {
	if m != nil && m.CloneAffinity != nil {
		return *m.CloneAffinity
	}
	return Default_VmCloneConfig_CloneAffinity
}

func (m *VmCloneConfig) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *VmCloneConfig) GetNumThreadsPerCore() int64 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

func (m *VmCloneConfig) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *VmCloneConfig) GetCpuPassthrough() bool {
	if m != nil && m.CpuPassthrough != nil {
		return *m.CpuPassthrough
	}
	return false
}

func (m *VmCloneConfig) GetDisableBranding() bool {
	if m != nil && m.DisableBranding != nil {
		return *m.DisableBranding
	}
	return false
}

func (m *VmCloneConfig) GetMachineType() string {
	if m != nil && m.MachineType != nil {
		return *m.MachineType
	}
	return ""
}

func (m *VmCloneConfig) GetAllowHotPlug() bool {
	if m != nil && m.AllowHotPlug != nil {
		return *m.AllowHotPlug
	}
	return Default_VmCloneConfig_AllowHotPlug
}

type VmDiskCloneConfigDetails struct {
	// Does the disk exist? If false, other fields should not be set.
	Exists *bool `protobuf:"varint,1,opt,name=exists,def=0" json:"exists,omitempty"`
	// The size of the disk, in bytes.
	SizeBytes            *uint64  `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes" json:"size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmDiskCloneConfigDetails) Reset()         { *m = VmDiskCloneConfigDetails{} }
func (m *VmDiskCloneConfigDetails) String() string { return proto.CompactTextString(m) }
func (*VmDiskCloneConfigDetails) ProtoMessage()    {}
func (*VmDiskCloneConfigDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{24}
}

func (m *VmDiskCloneConfigDetails) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmDiskCloneConfigDetails.Unmarshal(m, b)
}
func (m *VmDiskCloneConfigDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmDiskCloneConfigDetails.Marshal(b, m, deterministic)
}
func (m *VmDiskCloneConfigDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmDiskCloneConfigDetails.Merge(m, src)
}
func (m *VmDiskCloneConfigDetails) XXX_Size() int {
	return xxx_messageInfo_VmDiskCloneConfigDetails.Size(m)
}
func (m *VmDiskCloneConfigDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_VmDiskCloneConfigDetails.DiscardUnknown(m)
}

var xxx_messageInfo_VmDiskCloneConfigDetails proto.InternalMessageInfo

const Default_VmDiskCloneConfigDetails_Exists bool = false

func (m *VmDiskCloneConfigDetails) GetExists() bool {
	if m != nil && m.Exists != nil {
		return *m.Exists
	}
	return Default_VmDiskCloneConfigDetails_Exists
}

func (m *VmDiskCloneConfigDetails) GetSizeBytes() uint64 {
	if m != nil && m.SizeBytes != nil {
		return *m.SizeBytes
	}
	return 0
}

type NetworkConfig struct {
	// UUID of the network.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Whether the network has been deleted.
	Deleted *bool `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
	// Logical timestamp of the network configuration.
	LogicalTimestamp *int64              `protobuf:"varint,3,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	Type             *NetworkConfig_Type `protobuf:"varint,4,opt,name=type,enum=nutanix.uhura.NetworkConfig_Type,def=1" json:"type,omitempty"`
	// The network identifier, whose semantics depend on network type. This field
	// should not be set for networks of type kExternalManaged.
	Identifier *int32 `protobuf:"varint,5,opt,name=identifier,def=0" json:"identifier,omitempty"`
	// For managed networks, this is the IP address database.
	IpConfig *IPConfig `protobuf:"bytes,6,opt,name=ip_config,json=ipConfig" json:"ip_config,omitempty"`
	// For overlay networks, whether to forward multicast traffic.
	ForwardMulticast *bool `protobuf:"varint,7,opt,name=forward_multicast,json=forwardMulticast" json:"forward_multicast,omitempty"`
	// Name of the vSwitch to attach to. We assume that all hypervisors in the
	// cluster has same way (e.g. a vSwitch named "foo" on one host has L2
	// connectivity to vSwitch named "foo" on every other host, and all VLANs
	// are truncked the same way).
	//
	// It is strongly recommended, but not enforced, that each externally-managed
	// network use a unique vswitch name.
	VswitchName *string `protobuf:"bytes,8,opt,name=vswitch_name,json=vswitchName" json:"vswitch_name,omitempty"`
	// MTU setting of a network.
	// User can overwrite MTU setting in NIC level inside guest VM.
	Mtu *int32 `protobuf:"varint,9,opt,name=mtu" json:"mtu,omitempty"`
	// The network's human-readable name.
	Name *string `protobuf:"bytes,10,opt,name=name" json:"name,omitempty"`
	// An arbitrary string describing the network.
	Annotation  *string                    `protobuf:"bytes,11,opt,name=annotation" json:"annotation,omitempty"`
	ManagedType *NetworkConfig_ManagedType `protobuf:"varint,12,opt,name=managed_type,json=managedType,enum=nutanix.uhura.NetworkConfig_ManagedType" json:"managed_type,omitempty"`
	NetworkType *NetworkConfig_NetworkType `protobuf:"varint,13,opt,name=network_type,json=networkType,enum=nutanix.uhura.NetworkConfig_NetworkType" json:"network_type,omitempty"`
	// Distributed vswitch reference (UUID in hex string)
	VirtualSwitchUuid    *string  `protobuf:"bytes,14,opt,name=virtual_switch_uuid,json=virtualSwitchUuid" json:"virtual_switch_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkConfig) Reset()         { *m = NetworkConfig{} }
func (m *NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*NetworkConfig) ProtoMessage()    {}
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{25}
}

func (m *NetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkConfig.Unmarshal(m, b)
}
func (m *NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkConfig.Marshal(b, m, deterministic)
}
func (m *NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkConfig.Merge(m, src)
}
func (m *NetworkConfig) XXX_Size() int {
	return xxx_messageInfo_NetworkConfig.Size(m)
}
func (m *NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkConfig proto.InternalMessageInfo

const Default_NetworkConfig_Type NetworkConfig_Type = NetworkConfig_kBridged
const Default_NetworkConfig_Identifier int32 = 0

func (m *NetworkConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NetworkConfig) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *NetworkConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *NetworkConfig) GetType() NetworkConfig_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_NetworkConfig_Type
}

func (m *NetworkConfig) GetIdentifier() int32 {
	if m != nil && m.Identifier != nil {
		return *m.Identifier
	}
	return Default_NetworkConfig_Identifier
}

func (m *NetworkConfig) GetIpConfig() *IPConfig {
	if m != nil {
		return m.IpConfig
	}
	return nil
}

func (m *NetworkConfig) GetForwardMulticast() bool {
	if m != nil && m.ForwardMulticast != nil {
		return *m.ForwardMulticast
	}
	return false
}

func (m *NetworkConfig) GetVswitchName() string {
	if m != nil && m.VswitchName != nil {
		return *m.VswitchName
	}
	return ""
}

func (m *NetworkConfig) GetMtu() int32 {
	if m != nil && m.Mtu != nil {
		return *m.Mtu
	}
	return 0
}

func (m *NetworkConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetworkConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *NetworkConfig) GetManagedType() NetworkConfig_ManagedType {
	if m != nil && m.ManagedType != nil {
		return *m.ManagedType
	}
	return NetworkConfig_kLocal
}

func (m *NetworkConfig) GetNetworkType() NetworkConfig_NetworkType {
	if m != nil && m.NetworkType != nil {
		return *m.NetworkType
	}
	return NetworkConfig_kExternal
}

func (m *NetworkConfig) GetVirtualSwitchUuid() string {
	if m != nil && m.VirtualSwitchUuid != nil {
		return *m.VirtualSwitchUuid
	}
	return ""
}

type IPConfig struct {
	// Network address.
	NetworkAddress []byte `protobuf:"bytes,1,opt,name=network_address,json=networkAddress" json:"network_address,omitempty"`
	// Length of network prefix in number of bits.
	PrefixLength   *int32                    `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	RouteList      []*IPConfig_Route         `protobuf:"bytes,3,rep,name=route_list,json=routeList" json:"route_list,omitempty"`
	DhcpOptionList []*IPConfig_DHCPOption    `protobuf:"bytes,6,rep,name=dhcp_option_list,json=dhcpOptionList" json:"dhcp_option_list,omitempty"`
	IpPoolList     []*IPConfig_IpAddressPool `protobuf:"bytes,7,rep,name=ip_pool_list,json=ipPoolList" json:"ip_pool_list,omitempty"`
	// IP address of the DHCP server.
	DhcpServerAddress    []byte   `protobuf:"bytes,8,opt,name=dhcp_server_address,json=dhcpServerAddress" json:"dhcp_server_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig) Reset()         { *m = IPConfig{} }
func (m *IPConfig) String() string { return proto.CompactTextString(m) }
func (*IPConfig) ProtoMessage()    {}
func (*IPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{26}
}

func (m *IPConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig.Unmarshal(m, b)
}
func (m *IPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig.Marshal(b, m, deterministic)
}
func (m *IPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig.Merge(m, src)
}
func (m *IPConfig) XXX_Size() int {
	return xxx_messageInfo_IPConfig.Size(m)
}
func (m *IPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig proto.InternalMessageInfo

func (m *IPConfig) GetNetworkAddress() []byte {
	if m != nil {
		return m.NetworkAddress
	}
	return nil
}

func (m *IPConfig) GetPrefixLength() int32 {
	if m != nil && m.PrefixLength != nil {
		return *m.PrefixLength
	}
	return 0
}

func (m *IPConfig) GetRouteList() []*IPConfig_Route {
	if m != nil {
		return m.RouteList
	}
	return nil
}

func (m *IPConfig) GetDhcpOptionList() []*IPConfig_DHCPOption {
	if m != nil {
		return m.DhcpOptionList
	}
	return nil
}

func (m *IPConfig) GetIpPoolList() []*IPConfig_IpAddressPool {
	if m != nil {
		return m.IpPoolList
	}
	return nil
}

func (m *IPConfig) GetDhcpServerAddress() []byte {
	if m != nil {
		return m.DhcpServerAddress
	}
	return nil
}

// List of static routes, including the default gateway.
type IPConfig_Route struct {
	// IP address of desination.
	NetworkAddress []byte `protobuf:"bytes,1,opt,name=network_address,json=networkAddress" json:"network_address,omitempty"`
	// Length of network prefix in number of bits.
	PrefixLength *int32 `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength" json:"prefix_length,omitempty"`
	// Gateway IP address.
	Gateway              []byte   `protobuf:"bytes,3,opt,name=gateway" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig_Route) Reset()         { *m = IPConfig_Route{} }
func (m *IPConfig_Route) String() string { return proto.CompactTextString(m) }
func (*IPConfig_Route) ProtoMessage()    {}
func (*IPConfig_Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{26, 0}
}

func (m *IPConfig_Route) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig_Route.Unmarshal(m, b)
}
func (m *IPConfig_Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig_Route.Marshal(b, m, deterministic)
}
func (m *IPConfig_Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig_Route.Merge(m, src)
}
func (m *IPConfig_Route) XXX_Size() int {
	return xxx_messageInfo_IPConfig_Route.Size(m)
}
func (m *IPConfig_Route) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig_Route.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig_Route proto.InternalMessageInfo

func (m *IPConfig_Route) GetNetworkAddress() []byte {
	if m != nil {
		return m.NetworkAddress
	}
	return nil
}

func (m *IPConfig_Route) GetPrefixLength() int32 {
	if m != nil && m.PrefixLength != nil {
		return *m.PrefixLength
	}
	return 0
}

func (m *IPConfig_Route) GetGateway() []byte {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// Options passed along to client via DHCP. Consult RFC 2132 for how to
// encode and decode these.
type IPConfig_DHCPOption struct {
	// DHCP option code.
	OptionCode *int32 `protobuf:"varint,1,opt,name=option_code,json=optionCode" json:"option_code,omitempty"`
	// DHCP option value in network byte order.
	OptionValue          []byte   `protobuf:"bytes,2,opt,name=option_value,json=optionValue" json:"option_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig_DHCPOption) Reset()         { *m = IPConfig_DHCPOption{} }
func (m *IPConfig_DHCPOption) String() string { return proto.CompactTextString(m) }
func (*IPConfig_DHCPOption) ProtoMessage()    {}
func (*IPConfig_DHCPOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{26, 1}
}

func (m *IPConfig_DHCPOption) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig_DHCPOption.Unmarshal(m, b)
}
func (m *IPConfig_DHCPOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig_DHCPOption.Marshal(b, m, deterministic)
}
func (m *IPConfig_DHCPOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig_DHCPOption.Merge(m, src)
}
func (m *IPConfig_DHCPOption) XXX_Size() int {
	return xxx_messageInfo_IPConfig_DHCPOption.Size(m)
}
func (m *IPConfig_DHCPOption) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig_DHCPOption.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig_DHCPOption proto.InternalMessageInfo

func (m *IPConfig_DHCPOption) GetOptionCode() int32 {
	if m != nil && m.OptionCode != nil {
		return *m.OptionCode
	}
	return 0
}

func (m *IPConfig_DHCPOption) GetOptionValue() []byte {
	if m != nil {
		return m.OptionValue
	}
	return nil
}

// Dynamic IP address pools.
type IPConfig_IpAddressPool struct {
	StartAddress         []byte   `protobuf:"bytes,1,opt,name=start_address,json=startAddress" json:"start_address,omitempty"`
	EndAddress           []byte   `protobuf:"bytes,2,opt,name=end_address,json=endAddress" json:"end_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPConfig_IpAddressPool) Reset()         { *m = IPConfig_IpAddressPool{} }
func (m *IPConfig_IpAddressPool) String() string { return proto.CompactTextString(m) }
func (*IPConfig_IpAddressPool) ProtoMessage()    {}
func (*IPConfig_IpAddressPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{26, 2}
}

func (m *IPConfig_IpAddressPool) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPConfig_IpAddressPool.Unmarshal(m, b)
}
func (m *IPConfig_IpAddressPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPConfig_IpAddressPool.Marshal(b, m, deterministic)
}
func (m *IPConfig_IpAddressPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPConfig_IpAddressPool.Merge(m, src)
}
func (m *IPConfig_IpAddressPool) XXX_Size() int {
	return xxx_messageInfo_IPConfig_IpAddressPool.Size(m)
}
func (m *IPConfig_IpAddressPool) XXX_DiscardUnknown() {
	xxx_messageInfo_IPConfig_IpAddressPool.DiscardUnknown(m)
}

var xxx_messageInfo_IPConfig_IpAddressPool proto.InternalMessageInfo

func (m *IPConfig_IpAddressPool) GetStartAddress() []byte {
	if m != nil {
		return m.StartAddress
	}
	return nil
}

func (m *IPConfig_IpAddressPool) GetEndAddress() []byte {
	if m != nil {
		return m.EndAddress
	}
	return nil
}

// CloudInit config given by user to customize a VM(Linux) at boot time.
type CloudInitConfig struct {
	// Type of datasource.
	Datasource *CloudInitConfig_DatasourceType `protobuf:"varint,1,opt,name=datasource,enum=nutanix.uhura.CloudInitConfig_DatasourceType,def=0" json:"datasource,omitempty"`
	// Metadata in string format. Metadata format usually depends on datasource.
	// It is a yaml or json file containing hostname, instance id, etc.
	//
	// This field can be one of the following values:
	// -adsf path: begins with "adsf://"
	// -local path: begins with "file://"
	// -url path: begins with "http://" or "https://"
	// If the string does not match any of the above three conditions, the string
	// will be treated as data instead of a handle.
	Metadata *string `protobuf:"bytes,2,opt,name=metadata" json:"metadata,omitempty"`
	// Userdata in string format. Usually a cloud-config yaml file or shell
	// script.
	// This field will of the same format as CloudInitConfig.metadata.
	Userdata             *string  `protobuf:"bytes,3,opt,name=userdata" json:"userdata,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloudInitConfig) Reset()         { *m = CloudInitConfig{} }
func (m *CloudInitConfig) String() string { return proto.CompactTextString(m) }
func (*CloudInitConfig) ProtoMessage()    {}
func (*CloudInitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{27}
}

func (m *CloudInitConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloudInitConfig.Unmarshal(m, b)
}
func (m *CloudInitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloudInitConfig.Marshal(b, m, deterministic)
}
func (m *CloudInitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudInitConfig.Merge(m, src)
}
func (m *CloudInitConfig) XXX_Size() int {
	return xxx_messageInfo_CloudInitConfig.Size(m)
}
func (m *CloudInitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudInitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CloudInitConfig proto.InternalMessageInfo

const Default_CloudInitConfig_Datasource CloudInitConfig_DatasourceType = CloudInitConfig_kConfigDriveV2

func (m *CloudInitConfig) GetDatasource() CloudInitConfig_DatasourceType {
	if m != nil && m.Datasource != nil {
		return *m.Datasource
	}
	return Default_CloudInitConfig_Datasource
}

func (m *CloudInitConfig) GetMetadata() string {
	if m != nil && m.Metadata != nil {
		return *m.Metadata
	}
	return ""
}

func (m *CloudInitConfig) GetUserdata() string {
	if m != nil && m.Userdata != nil {
		return *m.Userdata
	}
	return ""
}

// Sysprep config given by user to customize a Windows VM at boot time. It is
// expected that the VM has already been generalized (with the shutdown option
// selected) so that sysprep will get invoked at boot time.
type SysprepConfig struct {
	// Required Xml representation of an unattend file. An unattend file is an
	// "answer file" that contains setting definitions and values to use during
	// Windows setup and we can specify various options. See
	// https://technet.microsoft.com/en-us/library/cc732280(v=ws.10).aspx for
	// examples of such a file. Answer files are created using Windows System
	// Image Manager (Windows SIM).
	//
	// This field will of the same format as CloudInitConfig.metadata.
	UnattendData *string `protobuf:"bytes,1,opt,name=unattend_data,json=unattendData" json:"unattend_data,omitempty"`
	// Whether the VM to be customized is meant to be freshly installed via
	// Windows Setup from a Windows OS DVD or whether the VM will be configured
	// from a 'Sysprepped' image in which case the setup was already complete.
	FreshInstall         *bool    `protobuf:"varint,2,opt,name=fresh_install,json=freshInstall,def=0" json:"fresh_install,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SysprepConfig) Reset()         { *m = SysprepConfig{} }
func (m *SysprepConfig) String() string { return proto.CompactTextString(m) }
func (*SysprepConfig) ProtoMessage()    {}
func (*SysprepConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{28}
}

func (m *SysprepConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SysprepConfig.Unmarshal(m, b)
}
func (m *SysprepConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SysprepConfig.Marshal(b, m, deterministic)
}
func (m *SysprepConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysprepConfig.Merge(m, src)
}
func (m *SysprepConfig) XXX_Size() int {
	return xxx_messageInfo_SysprepConfig.Size(m)
}
func (m *SysprepConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SysprepConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SysprepConfig proto.InternalMessageInfo

const Default_SysprepConfig_FreshInstall bool = false

func (m *SysprepConfig) GetUnattendData() string {
	if m != nil && m.UnattendData != nil {
		return *m.UnattendData
	}
	return ""
}

func (m *SysprepConfig) GetFreshInstall() bool {
	if m != nil && m.FreshInstall != nil {
		return *m.FreshInstall
	}
	return Default_SysprepConfig_FreshInstall
}

// Vm customization configuration. At boot time, this config will be replayed
// by VM custimzation tool(cloudinit/sysprep) installed in the VM to bring
// VM to the stated defined by this config.
type VmCustomizationConfig struct {
	// Only one of the cloudinit_config or sysprep_config must be provided.
	// CloudInit configuration.
	CloudinitConfig *CloudInitConfig `protobuf:"bytes,1,opt,name=cloudinit_config,json=cloudinitConfig" json:"cloudinit_config,omitempty"`
	// Sysprep configuration.
	SysprepConfig        *SysprepConfig                        `protobuf:"bytes,2,opt,name=sysprep_config,json=sysprepConfig" json:"sysprep_config,omitempty"`
	FilesToInjectList    []*VmCustomizationConfig_FileToInject `protobuf:"bytes,3,rep,name=files_to_inject_list,json=filesToInjectList" json:"files_to_inject_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *VmCustomizationConfig) Reset()         { *m = VmCustomizationConfig{} }
func (m *VmCustomizationConfig) String() string { return proto.CompactTextString(m) }
func (*VmCustomizationConfig) ProtoMessage()    {}
func (*VmCustomizationConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{29}
}

func (m *VmCustomizationConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCustomizationConfig.Unmarshal(m, b)
}
func (m *VmCustomizationConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCustomizationConfig.Marshal(b, m, deterministic)
}
func (m *VmCustomizationConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCustomizationConfig.Merge(m, src)
}
func (m *VmCustomizationConfig) XXX_Size() int {
	return xxx_messageInfo_VmCustomizationConfig.Size(m)
}
func (m *VmCustomizationConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCustomizationConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmCustomizationConfig proto.InternalMessageInfo

func (m *VmCustomizationConfig) GetCloudinitConfig() *CloudInitConfig {
	if m != nil {
		return m.CloudinitConfig
	}
	return nil
}

func (m *VmCustomizationConfig) GetSysprepConfig() *SysprepConfig {
	if m != nil {
		return m.SysprepConfig
	}
	return nil
}

func (m *VmCustomizationConfig) GetFilesToInjectList() []*VmCustomizationConfig_FileToInject {
	if m != nil {
		return m.FilesToInjectList
	}
	return nil
}

// Details about file to inject in the VM.
type VmCustomizationConfig_FileToInject struct {
	// ADSF path of the source file to inject in the VM. Must be of form:
	// adsf:///<ctr>/...
	SourcePath *string `protobuf:"bytes,1,opt,name=source_path,json=sourcePath" json:"source_path,omitempty"`
	// Destination path in the VM at which the file specified by source_path
	// should be copied to.
	DestinationPath      *string  `protobuf:"bytes,2,opt,name=destination_path,json=destinationPath" json:"destination_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmCustomizationConfig_FileToInject) Reset()         { *m = VmCustomizationConfig_FileToInject{} }
func (m *VmCustomizationConfig_FileToInject) String() string { return proto.CompactTextString(m) }
func (*VmCustomizationConfig_FileToInject) ProtoMessage()    {}
func (*VmCustomizationConfig_FileToInject) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{29, 0}
}

func (m *VmCustomizationConfig_FileToInject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmCustomizationConfig_FileToInject.Unmarshal(m, b)
}
func (m *VmCustomizationConfig_FileToInject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmCustomizationConfig_FileToInject.Marshal(b, m, deterministic)
}
func (m *VmCustomizationConfig_FileToInject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmCustomizationConfig_FileToInject.Merge(m, src)
}
func (m *VmCustomizationConfig_FileToInject) XXX_Size() int {
	return xxx_messageInfo_VmCustomizationConfig_FileToInject.Size(m)
}
func (m *VmCustomizationConfig_FileToInject) XXX_DiscardUnknown() {
	xxx_messageInfo_VmCustomizationConfig_FileToInject.DiscardUnknown(m)
}

var xxx_messageInfo_VmCustomizationConfig_FileToInject proto.InternalMessageInfo

func (m *VmCustomizationConfig_FileToInject) GetSourcePath() string {
	if m != nil && m.SourcePath != nil {
		return *m.SourcePath
	}
	return ""
}

func (m *VmCustomizationConfig_FileToInject) GetDestinationPath() string {
	if m != nil && m.DestinationPath != nil {
		return *m.DestinationPath
	}
	return ""
}

type VmSerialPortConfig struct {
	// The serial port index. Generally limited to the range [0..3],
	// coresponding to COM1 through COM4.
	Index                *int32                   `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	Type                 *VmSerialPortConfig_Type `protobuf:"varint,2,opt,name=type,enum=nutanix.uhura.VmSerialPortConfig_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *VmSerialPortConfig) Reset()         { *m = VmSerialPortConfig{} }
func (m *VmSerialPortConfig) String() string { return proto.CompactTextString(m) }
func (*VmSerialPortConfig) ProtoMessage()    {}
func (*VmSerialPortConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{30}
}

func (m *VmSerialPortConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSerialPortConfig.Unmarshal(m, b)
}
func (m *VmSerialPortConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSerialPortConfig.Marshal(b, m, deterministic)
}
func (m *VmSerialPortConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSerialPortConfig.Merge(m, src)
}
func (m *VmSerialPortConfig) XXX_Size() int {
	return xxx_messageInfo_VmSerialPortConfig.Size(m)
}
func (m *VmSerialPortConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSerialPortConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmSerialPortConfig proto.InternalMessageInfo

func (m *VmSerialPortConfig) GetIndex() int32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *VmSerialPortConfig) GetType() VmSerialPortConfig_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VmSerialPortConfig_kNull
}

type VmGPUConfig struct {
	// Type of the GPU resource.
	Type *GPUType `protobuf:"varint,1,opt,name=type,enum=nutanix.uhura.GPUType" json:"type,omitempty"`
	// Device ID of GPU resource.
	DeviceId *int32 `protobuf:"varint,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Vendor of GPU resource.
	Vendor               *GPUVendor `protobuf:"varint,3,opt,name=vendor,enum=nutanix.uhura.GPUVendor" json:"vendor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VmGPUConfig) Reset()         { *m = VmGPUConfig{} }
func (m *VmGPUConfig) String() string { return proto.CompactTextString(m) }
func (*VmGPUConfig) ProtoMessage()    {}
func (*VmGPUConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{31}
}

func (m *VmGPUConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmGPUConfig.Unmarshal(m, b)
}
func (m *VmGPUConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmGPUConfig.Marshal(b, m, deterministic)
}
func (m *VmGPUConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmGPUConfig.Merge(m, src)
}
func (m *VmGPUConfig) XXX_Size() int {
	return xxx_messageInfo_VmGPUConfig.Size(m)
}
func (m *VmGPUConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmGPUConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmGPUConfig proto.InternalMessageInfo

func (m *VmGPUConfig) GetType() GPUType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return GPUType_kPassthroughGraphics
}

func (m *VmGPUConfig) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return 0
}

func (m *VmGPUConfig) GetVendor() GPUVendor {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return GPUVendor_kNvidia
}

type NodeGPU struct {
	// GPU type.
	Type *GPUType `protobuf:"varint,1,opt,name=type,enum=nutanix.uhura.GPUType" json:"type,omitempty"`
	// Device ID of GPU.
	DeviceId *int32 `protobuf:"varint,2,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Vendor of GPU.
	Vendor *GPUVendor `protobuf:"varint,3,opt,name=vendor,enum=nutanix.uhura.GPUVendor" json:"vendor,omitempty"`
	// Vendor Device string.
	DeviceName *string `protobuf:"bytes,4,opt,name=device_name,json=deviceName" json:"device_name,omitempty"`
	// Whether the GPU resource is in use or not.
	InUse *int32 `protobuf:"varint,5,opt,name=in_use,json=inUse" json:"in_use,omitempty"`
	// Physical device location in host.
	// SBDF string must be in format: ffff:ff:ff.f
	Sbdf *string `protobuf:"bytes,6,opt,name=sbdf" json:"sbdf,omitempty"`
	// NUMA node GPU belongs to.
	NumaNode *int32 `protobuf:"varint,7,opt,name=numa_node,json=numaNode" json:"numa_node,omitempty"`
	// Whether this GPU can be assigned to a VM.
	Assignable *bool `protobuf:"varint,8,opt,name=assignable" json:"assignable,omitempty"`
	// Index of GPU if part of a set, field not valid on pGPU.
	Index *uint32 `protobuf:"varint,9,opt,name=index" json:"index,omitempty"`
	// UUID of GPU.
	Uuid *string `protobuf:"bytes,10,opt,name=uuid" json:"uuid,omitempty"`
	// Unique ID string, SBDF is not unique when vGPU resources are available.
	Id *string `protobuf:"bytes,11,opt,name=id" json:"id,omitempty"`
	// Number of allocated vGPUs for a particular pGPU, field not valid on vGPU.
	NumVgpusAllocated *uint32 `protobuf:"varint,12,opt,name=num_vgpus_allocated,json=numVgpusAllocated" json:"num_vgpus_allocated,omitempty"`
	// Maximum potential vGPUs for a particular pGPU, field not valid on vGPU.
	MaxAllocatable *uint32 `protobuf:"varint,13,opt,name=max_allocatable,json=maxAllocatable" json:"max_allocatable,omitempty"`
	// Maximum framebuffer GPU in MiB.
	MaxFramebufferMb *uint32 `protobuf:"varint,14,opt,name=max_framebuffer_mb,json=maxFramebufferMb" json:"max_framebuffer_mb,omitempty"`
	// GPU compute usage in PPM.
	GpuUsagePpm *int64 `protobuf:"varint,15,opt,name=gpu_usage_ppm,json=gpuUsagePpm" json:"gpu_usage_ppm,omitempty"`
	// Minimum fraction this GPU resource has of physical GPU.
	MinFraction *uint32 `protobuf:"varint,16,opt,name=min_fraction,json=minFraction" json:"min_fraction,omitempty"`
	// Number of display heads available supported.
	NumDisplayHeads *uint32 `protobuf:"varint,17,opt,name=num_display_heads,json=numDisplayHeads" json:"num_display_heads,omitempty"`
	// Resolution per display head (X by Y).
	ResolutionPerDisplayHead *string `protobuf:"bytes,18,opt,name=resolution_per_display_head,json=resolutionPerDisplayHead" json:"resolution_per_display_head,omitempty"`
	// Detected guest GPU driver version, field not valid on pGPU.
	GuestDriverVersion *string `protobuf:"bytes,19,opt,name=guest_driver_version,json=guestDriverVersion" json:"guest_driver_version,omitempty"`
	// Current framebuffer usage in PPM.
	FramebufferUsagePpm *int64 `protobuf:"varint,20,opt,name=framebuffer_usage_ppm,json=framebufferUsagePpm" json:"framebuffer_usage_ppm,omitempty"`
	// List of licenses which can be used for this GPU resource.
	LicenseList []string `protobuf:"bytes,21,rep,name=license_list,json=licenseList" json:"license_list,omitempty"`
	// Current Video Encoder usage in PPM.
	EncoderUsagePpm *int64 `protobuf:"varint,22,opt,name=encoder_usage_ppm,json=encoderUsagePpm" json:"encoder_usage_ppm,omitempty"`
	// Current Video Decoder usage in PPM.
	DecoderUsagePpm *int64 `protobuf:"varint,23,opt,name=decoder_usage_ppm,json=decoderUsagePpm" json:"decoder_usage_ppm,omitempty"`
	// Current mode of pGPU, field not valid on vGPU resources.
	Mode                 *GPUMode `protobuf:"varint,24,opt,name=mode,enum=nutanix.uhura.GPUMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeGPU) Reset()         { *m = NodeGPU{} }
func (m *NodeGPU) String() string { return proto.CompactTextString(m) }
func (*NodeGPU) ProtoMessage()    {}
func (*NodeGPU) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{32}
}

func (m *NodeGPU) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeGPU.Unmarshal(m, b)
}
func (m *NodeGPU) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeGPU.Marshal(b, m, deterministic)
}
func (m *NodeGPU) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeGPU.Merge(m, src)
}
func (m *NodeGPU) XXX_Size() int {
	return xxx_messageInfo_NodeGPU.Size(m)
}
func (m *NodeGPU) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeGPU.DiscardUnknown(m)
}

var xxx_messageInfo_NodeGPU proto.InternalMessageInfo

func (m *NodeGPU) GetType() GPUType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return GPUType_kPassthroughGraphics
}

func (m *NodeGPU) GetDeviceId() int32 {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return 0
}

func (m *NodeGPU) GetVendor() GPUVendor {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return GPUVendor_kNvidia
}

func (m *NodeGPU) GetDeviceName() string {
	if m != nil && m.DeviceName != nil {
		return *m.DeviceName
	}
	return ""
}

func (m *NodeGPU) GetInUse() int32 {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return 0
}

func (m *NodeGPU) GetSbdf() string {
	if m != nil && m.Sbdf != nil {
		return *m.Sbdf
	}
	return ""
}

func (m *NodeGPU) GetNumaNode() int32 {
	if m != nil && m.NumaNode != nil {
		return *m.NumaNode
	}
	return 0
}

func (m *NodeGPU) GetAssignable() bool {
	if m != nil && m.Assignable != nil {
		return *m.Assignable
	}
	return false
}

func (m *NodeGPU) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *NodeGPU) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *NodeGPU) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *NodeGPU) GetNumVgpusAllocated() uint32 {
	if m != nil && m.NumVgpusAllocated != nil {
		return *m.NumVgpusAllocated
	}
	return 0
}

func (m *NodeGPU) GetMaxAllocatable() uint32 {
	if m != nil && m.MaxAllocatable != nil {
		return *m.MaxAllocatable
	}
	return 0
}

func (m *NodeGPU) GetMaxFramebufferMb() uint32 {
	if m != nil && m.MaxFramebufferMb != nil {
		return *m.MaxFramebufferMb
	}
	return 0
}

func (m *NodeGPU) GetGpuUsagePpm() int64 {
	if m != nil && m.GpuUsagePpm != nil {
		return *m.GpuUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetMinFraction() uint32 {
	if m != nil && m.MinFraction != nil {
		return *m.MinFraction
	}
	return 0
}

func (m *NodeGPU) GetNumDisplayHeads() uint32 {
	if m != nil && m.NumDisplayHeads != nil {
		return *m.NumDisplayHeads
	}
	return 0
}

func (m *NodeGPU) GetResolutionPerDisplayHead() string {
	if m != nil && m.ResolutionPerDisplayHead != nil {
		return *m.ResolutionPerDisplayHead
	}
	return ""
}

func (m *NodeGPU) GetGuestDriverVersion() string {
	if m != nil && m.GuestDriverVersion != nil {
		return *m.GuestDriverVersion
	}
	return ""
}

func (m *NodeGPU) GetFramebufferUsagePpm() int64 {
	if m != nil && m.FramebufferUsagePpm != nil {
		return *m.FramebufferUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetLicenseList() []string {
	if m != nil {
		return m.LicenseList
	}
	return nil
}

func (m *NodeGPU) GetEncoderUsagePpm() int64 {
	if m != nil && m.EncoderUsagePpm != nil {
		return *m.EncoderUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetDecoderUsagePpm() int64 {
	if m != nil && m.DecoderUsagePpm != nil {
		return *m.DecoderUsagePpm
	}
	return 0
}

func (m *NodeGPU) GetMode() GPUMode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return GPUMode_kUnused
}

type VmConfig struct {
	// The VM's human-readable name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An arbitrary string describing the VM.
	Annotation *string `protobuf:"bytes,2,opt,name=annotation" json:"annotation,omitempty"`
	// Number of processors in the VM.
	NumCpu *uint32 `protobuf:"varint,3,opt,name=num_cpu,json=numCpu" json:"num_cpu,omitempty"`
	// Number of vCPUs (sockets).
	NumVcpus *uint32 `protobuf:"varint,4,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// Number of cores per vCPU.
	NumCoresPerVcpu *uint32 `protobuf:"varint,5,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// The amount of RAM, in megabytes.
	MemorySizeMb *uint64 `protobuf:"varint,6,opt,name=memory_size_mb,json=memorySizeMb" json:"memory_size_mb,omitempty"`
	// Virtual disks.
	DiskList []*VmDiskInfo `protobuf:"bytes,7,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// Virtual NICs.
	NicList []*VmNicConfig `protobuf:"bytes,8,rep,name=nic_list,json=nicList" json:"nic_list,omitempty"`
	// The boot configuration.
	BootConfig *VmBootConfig `protobuf:"bytes,9,opt,name=boot_config,json=bootConfig" json:"boot_config,omitempty"`
	// Virtual serial ports.
	SerialPortList []*VmSerialPortConfig `protobuf:"bytes,10,rep,name=serial_port_list,json=serialPortList" json:"serial_port_list,omitempty"`
	// The timezone for the VM's hardware clock.
	HwclockTimezone *string `protobuf:"bytes,11,opt,name=hwclock_timezone,json=hwclockTimezone,def=UTC" json:"hwclock_timezone,omitempty"`
	// Priority for restarting in case of HA event. Applicable only for AHV.
	HaPriority *int64 `protobuf:"varint,12,opt,name=ha_priority,json=haPriority,def=0" json:"ha_priority,omitempty"`
	// If set to a non-empty string, this VM should be considered incompatible
	// with DR workflows. Applicable only for AHV, ESX.
	//
	// This field is deprecated. It should be exposed in the REST API, but as a
	// hidden parameter. In the future, it will be removed in favor of using tags
	// for identifying service VMs.
	CbrNotCapableReason *string `protobuf:"bytes,13,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Guest OS ID for VMWare. Applicable only for ESX. This has to be one of the
	// values mentioned in http://pubs.vmware.com/vsphere-60/index.jsp?topic=%2Fcom.vmware.wssdk.apiref.doc%2Fvim.vm.GuestOsDescriptor.GuestOsIdentifier.html.
	GuestOsId *string `protobuf:"bytes,14,opt,name=guest_os_id,json=guestOsId" json:"guest_os_id,omitempty"`
	// VM to host affinity setting.
	Affinity *Affinity `protobuf:"bytes,15,opt,name=affinity" json:"affinity,omitempty"`
	// Whether flash mode is enabled for this VM. This is a Nutanix specific
	// attribute.
	FlashModeEnabled *bool `protobuf:"varint,16,opt,name=flash_mode_enabled,json=flashModeEnabled,def=0" json:"flash_mode_enabled,omitempty"`
	// List of uuids of virtual disks attached to this VM for which flash mode is
	// disabled. This is a Nutanix specific attribute.
	VirtualDiskUuidsDisabledForFlashMode [][]byte `protobuf:"bytes,17,rep,name=virtual_disk_uuids_disabled_for_flash_mode,json=virtualDiskUuidsDisabledForFlashMode" json:"virtual_disk_uuids_disabled_for_flash_mode,omitempty"`
	// Marks VM as an agent. Applicable only for AHV.
	AgentVm *bool `protobuf:"varint,18,opt,name=agent_vm,json=agentVm" json:"agent_vm,omitempty"`
	// Hypervisor agnostic UUID of VM to VM affinity rule that VM is part of.
	VmToVmAffinityUuids []string `protobuf:"bytes,19,rep,name=vm_to_vm_affinity_uuids,json=vmToVmAffinityUuids" json:"vm_to_vm_affinity_uuids,omitempty"`
	// Memory reservation size in megabytes.
	MemoryReservationMb *uint64 `protobuf:"varint,20,opt,name=memory_reservation_mb,json=memoryReservationMb" json:"memory_reservation_mb,omitempty"`
	// vCPU reservation in hertz.
	VcpuReservationHz *uint64 `protobuf:"varint,21,opt,name=vcpu_reservation_hz,json=vcpuReservationHz" json:"vcpu_reservation_hz,omitempty"`
	// Container on which the VM configuration files should be created.
	// Applicable only for ESX, Hyper-V.
	HomeContainerUuid []byte `protobuf:"bytes,22,opt,name=home_container_uuid,json=homeContainerUuid" json:"home_container_uuid,omitempty"`
	// GPU resources.
	GpuConfigList []*VmGPUConfig `protobuf:"bytes,23,rep,name=gpu_config_list,json=gpuConfigList" json:"gpu_config_list,omitempty"`
	// Additional VM specific flags. Only for AHV.
	ExtraFlags []*GenericKeyValuePair `protobuf:"bytes,24,rep,name=extra_flags,json=extraFlags" json:"extra_flags,omitempty"`
	VmType     *VmConfig_VmType       `protobuf:"varint,26,opt,name=vm_type,json=vmType,enum=nutanix.uhura.VmConfig_VmType,def=1" json:"vm_type,omitempty"`
	// Nutanix Containers associated with this VM.
	ContainerNameList []string `protobuf:"bytes,27,rep,name=container_name_list,json=containerNameList" json:"container_name_list,omitempty"`
	// Reason why app consistent snapshot is not required.
	AppConsistentSnapshotNotRequiredReason *string `protobuf:"bytes,28,opt,name=app_consistent_snapshot_not_required_reason,json=appConsistentSnapshotNotRequiredReason" json:"app_consistent_snapshot_not_required_reason,omitempty"`
	// Virtual hardware version. Valid only for ESX.
	VirtualHardwareVersion *string `protobuf:"bytes,29,opt,name=virtual_hardware_version,json=virtualHardwareVersion" json:"virtual_hardware_version,omitempty"`
	// Configuration path of the VM configuration file (.vmx file)
	// Valid only for ESX, HyperV.
	ConfigFilePath *string `protobuf:"bytes,30,opt,name=config_file_path,json=configFilePath" json:"config_file_path,omitempty"`
	// Location of the hypervisor snapshot directory. All the hypervisor snapshot
	// related files are placed here. Usually, this value is same as that of
	// the location of 'config_file_path', but can be modified by user. This is
	// not related to the location of Nutanix CBR snapshots.
	// Valid only for ESX, HyperV.
	SnapshotDirPath *string `protobuf:"bytes,31,opt,name=snapshot_dir_path,json=snapshotDirPath" json:"snapshot_dir_path,omitempty"`
	// Whether virtual disk uuids are reported to the guest operating system as
	// uuids/serial numbers. For ESX, this property is true if disk.enableUUID
	// advanced configuration option is enabled for this VM. Valid only for ESX.
	VirtualDiskUuidReportedToGuest *bool `protobuf:"varint,32,opt,name=virtual_disk_uuid_reported_to_guest,json=virtualDiskUuidReportedToGuest" json:"virtual_disk_uuid_reported_to_guest,omitempty"`
	// Requires UEFI firmware.
	UefiFirmware *bool `protobuf:"varint,33,opt,name=uefi_firmware,json=uefiFirmware,def=0" json:"uefi_firmware,omitempty"`
	// The files that compose this virtual machine. Note that only files that
	// reside on the Nutanix datastore are included.
	VmNfsFileConfigList []*VmNfsFileConfig `protobuf:"bytes,34,rep,name=vm_nfs_file_config_list,json=vmNfsFileConfigList" json:"vm_nfs_file_config_list,omitempty"`
	// Opaque metadata to be restored during VmRegister. Applicable only for AHV.
	VmOpaqueData []byte `protobuf:"bytes,35,opt,name=vm_opaque_data,json=vmOpaqueData" json:"vm_opaque_data,omitempty"`
	// BIOS uuid for the VM. Applicable only for ESX and HyperV.
	BiosUuid *string `protobuf:"bytes,36,opt,name=bios_uuid,json=biosUuid" json:"bios_uuid,omitempty"`
	// Whether or not to have a VGA console.
	VgaConsole *bool `protobuf:"varint,37,opt,name=vga_console,json=vgaConsole" json:"vga_console,omitempty"`
	// UUID of VmGroup that VM belongs to. Applicable only for AHV.
	VmGroupUuid []byte `protobuf:"bytes,38,opt,name=vm_group_uuid,json=vmGroupUuid" json:"vm_group_uuid,omitempty"`
	// Hyperv only.
	// Action when Host starts.
	StartAction *AutomaticStartAction_Action `protobuf:"varint,39,opt,name=start_action,json=startAction,enum=nutanix.uhura.AutomaticStartAction_Action" json:"start_action,omitempty"`
	// Hyperv only.
	// Action when Host shuts down.
	StopAction *AutomaticStopAction_Action `protobuf:"varint,40,opt,name=stop_action,json=stopAction,enum=nutanix.uhura.AutomaticStopAction_Action" json:"stop_action,omitempty"`
	// HyperV only.
	// Boolean to denote if dynamic memory is enabled.
	EnableDynamicMemory *bool `protobuf:"varint,41,opt,name=enable_dynamic_memory,json=enableDynamicMemory" json:"enable_dynamic_memory,omitempty"`
	// The number of vNUMA nodes.
	NumVnumaNodes *uint64 `protobuf:"varint,42,opt,name=num_vnuma_nodes,json=numVnumaNodes" json:"num_vnuma_nodes,omitempty"`
	// Indicates how the power state changes.
	PowerStateMechanism *PowerStateMechanism `protobuf:"varint,43,opt,name=power_state_mechanism,json=powerStateMechanism,enum=nutanix.uhura.PowerStateMechanism" json:"power_state_mechanism,omitempty"`
	// Indicates whether to execute set script before ngt shutdown/reboot.
	NgtEnableScriptExec *bool `protobuf:"varint,44,opt,name=ngt_enable_script_exec,json=ngtEnableScriptExec" json:"ngt_enable_script_exec,omitempty"`
	// Indicates whether to abort ngt shutdown/reboot if script fails.
	NgtFailOnScriptFailure *bool `protobuf:"varint,45,opt,name=ngt_fail_on_script_failure,json=ngtFailOnScriptFailure" json:"ngt_fail_on_script_failure,omitempty"`
	// HyperV only.
	// The generation of VM.
	VmGeneration *uint64 `protobuf:"varint,46,opt,name=vm_generation,json=vmGeneration" json:"vm_generation,omitempty"`
	// Number of threads per core.
	NumThreadsPerCore *uint32 `protobuf:"varint,47,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	// Whether to hard pin vcpus to vcpus.
	VcpuHardPin *bool `protobuf:"varint,48,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// AHV only: whether to pass through the host's CPU features.
	CpuPassthrough *bool `protobuf:"varint,49,opt,name=cpu_passthrough,json=cpuPassthrough" json:"cpu_passthrough,omitempty"`
	// The machine type of this VM.
	MachineType *string `protobuf:"bytes,50,opt,name=machine_type,json=machineType,def=pc" json:"machine_type,omitempty"`
	// Whether to disable Nutanix branding.
	DisableBranding *bool `protobuf:"varint,51,opt,name=disable_branding,json=disableBranding" json:"disable_branding,omitempty"`
	// If False, it will prevent users from hot plugging and unplugging of
	// PCI based devices from within VMs and from the hypervisor stack. Although
	// this applies equally for all VMs, it is primarily applicable for Windows
	// based VMs. By default, we allow hot-plugging and unplugging of devices.
	// Valid only for AHV.
	AllowHotPlug         *bool    `protobuf:"varint,52,opt,name=allow_hot_plug,json=allowHotPlug,def=1" json:"allow_hot_plug,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmConfig) Reset()         { *m = VmConfig{} }
func (m *VmConfig) String() string { return proto.CompactTextString(m) }
func (*VmConfig) ProtoMessage()    {}
func (*VmConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{33}
}

func (m *VmConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmConfig.Unmarshal(m, b)
}
func (m *VmConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmConfig.Marshal(b, m, deterministic)
}
func (m *VmConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmConfig.Merge(m, src)
}
func (m *VmConfig) XXX_Size() int {
	return xxx_messageInfo_VmConfig.Size(m)
}
func (m *VmConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmConfig proto.InternalMessageInfo

const Default_VmConfig_HwclockTimezone string = "UTC"
const Default_VmConfig_HaPriority int64 = 0
const Default_VmConfig_FlashModeEnabled bool = false
const Default_VmConfig_VmType VmConfig_VmType = VmConfig_kGuestVM
const Default_VmConfig_UefiFirmware bool = false
const Default_VmConfig_MachineType string = "pc"
const Default_VmConfig_AllowHotPlug bool = true

func (m *VmConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VmConfig) GetNumCpu() uint32 {
	if m != nil && m.NumCpu != nil {
		return *m.NumCpu
	}
	return 0
}

func (m *VmConfig) GetNumVcpus() uint32 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmConfig) GetNumCoresPerVcpu() uint32 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *VmConfig) GetMemorySizeMb() uint64 {
	if m != nil && m.MemorySizeMb != nil {
		return *m.MemorySizeMb
	}
	return 0
}

func (m *VmConfig) GetDiskList() []*VmDiskInfo {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *VmConfig) GetNicList() []*VmNicConfig {
	if m != nil {
		return m.NicList
	}
	return nil
}

func (m *VmConfig) GetBootConfig() *VmBootConfig {
	if m != nil {
		return m.BootConfig
	}
	return nil
}

func (m *VmConfig) GetSerialPortList() []*VmSerialPortConfig {
	if m != nil {
		return m.SerialPortList
	}
	return nil
}

func (m *VmConfig) GetHwclockTimezone() string {
	if m != nil && m.HwclockTimezone != nil {
		return *m.HwclockTimezone
	}
	return Default_VmConfig_HwclockTimezone
}

func (m *VmConfig) GetHaPriority() int64 {
	if m != nil && m.HaPriority != nil {
		return *m.HaPriority
	}
	return Default_VmConfig_HaPriority
}

func (m *VmConfig) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VmConfig) GetGuestOsId() string {
	if m != nil && m.GuestOsId != nil {
		return *m.GuestOsId
	}
	return ""
}

func (m *VmConfig) GetAffinity() *Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *VmConfig) GetFlashModeEnabled() bool {
	if m != nil && m.FlashModeEnabled != nil {
		return *m.FlashModeEnabled
	}
	return Default_VmConfig_FlashModeEnabled
}

func (m *VmConfig) GetVirtualDiskUuidsDisabledForFlashMode() [][]byte {
	if m != nil {
		return m.VirtualDiskUuidsDisabledForFlashMode
	}
	return nil
}

func (m *VmConfig) GetAgentVm() bool {
	if m != nil && m.AgentVm != nil {
		return *m.AgentVm
	}
	return false
}

func (m *VmConfig) GetVmToVmAffinityUuids() []string {
	if m != nil {
		return m.VmToVmAffinityUuids
	}
	return nil
}

func (m *VmConfig) GetMemoryReservationMb() uint64 {
	if m != nil && m.MemoryReservationMb != nil {
		return *m.MemoryReservationMb
	}
	return 0
}

func (m *VmConfig) GetVcpuReservationHz() uint64 {
	if m != nil && m.VcpuReservationHz != nil {
		return *m.VcpuReservationHz
	}
	return 0
}

func (m *VmConfig) GetHomeContainerUuid() []byte {
	if m != nil {
		return m.HomeContainerUuid
	}
	return nil
}

func (m *VmConfig) GetGpuConfigList() []*VmGPUConfig {
	if m != nil {
		return m.GpuConfigList
	}
	return nil
}

func (m *VmConfig) GetExtraFlags() []*GenericKeyValuePair {
	if m != nil {
		return m.ExtraFlags
	}
	return nil
}

func (m *VmConfig) GetVmType() VmConfig_VmType {
	if m != nil && m.VmType != nil {
		return *m.VmType
	}
	return Default_VmConfig_VmType
}

func (m *VmConfig) GetContainerNameList() []string {
	if m != nil {
		return m.ContainerNameList
	}
	return nil
}

func (m *VmConfig) GetAppConsistentSnapshotNotRequiredReason() string {
	if m != nil && m.AppConsistentSnapshotNotRequiredReason != nil {
		return *m.AppConsistentSnapshotNotRequiredReason
	}
	return ""
}

func (m *VmConfig) GetVirtualHardwareVersion() string {
	if m != nil && m.VirtualHardwareVersion != nil {
		return *m.VirtualHardwareVersion
	}
	return ""
}

func (m *VmConfig) GetConfigFilePath() string {
	if m != nil && m.ConfigFilePath != nil {
		return *m.ConfigFilePath
	}
	return ""
}

func (m *VmConfig) GetSnapshotDirPath() string {
	if m != nil && m.SnapshotDirPath != nil {
		return *m.SnapshotDirPath
	}
	return ""
}

func (m *VmConfig) GetVirtualDiskUuidReportedToGuest() bool {
	if m != nil && m.VirtualDiskUuidReportedToGuest != nil {
		return *m.VirtualDiskUuidReportedToGuest
	}
	return false
}

func (m *VmConfig) GetUefiFirmware() bool {
	if m != nil && m.UefiFirmware != nil {
		return *m.UefiFirmware
	}
	return Default_VmConfig_UefiFirmware
}

func (m *VmConfig) GetVmNfsFileConfigList() []*VmNfsFileConfig {
	if m != nil {
		return m.VmNfsFileConfigList
	}
	return nil
}

func (m *VmConfig) GetVmOpaqueData() []byte {
	if m != nil {
		return m.VmOpaqueData
	}
	return nil
}

func (m *VmConfig) GetBiosUuid() string {
	if m != nil && m.BiosUuid != nil {
		return *m.BiosUuid
	}
	return ""
}

func (m *VmConfig) GetVgaConsole() bool {
	if m != nil && m.VgaConsole != nil {
		return *m.VgaConsole
	}
	return false
}

func (m *VmConfig) GetVmGroupUuid() []byte {
	if m != nil {
		return m.VmGroupUuid
	}
	return nil
}

func (m *VmConfig) GetStartAction() AutomaticStartAction_Action {
	if m != nil && m.StartAction != nil {
		return *m.StartAction
	}
	return AutomaticStartAction_kNothing
}

func (m *VmConfig) GetStopAction() AutomaticStopAction_Action {
	if m != nil && m.StopAction != nil {
		return *m.StopAction
	}
	return AutomaticStopAction_kTurnOff
}

func (m *VmConfig) GetEnableDynamicMemory() bool {
	if m != nil && m.EnableDynamicMemory != nil {
		return *m.EnableDynamicMemory
	}
	return false
}

func (m *VmConfig) GetNumVnumaNodes() uint64 {
	if m != nil && m.NumVnumaNodes != nil {
		return *m.NumVnumaNodes
	}
	return 0
}

func (m *VmConfig) GetPowerStateMechanism() PowerStateMechanism {
	if m != nil && m.PowerStateMechanism != nil {
		return *m.PowerStateMechanism
	}
	return PowerStateMechanism_kHard
}

func (m *VmConfig) GetNgtEnableScriptExec() bool {
	if m != nil && m.NgtEnableScriptExec != nil {
		return *m.NgtEnableScriptExec
	}
	return false
}

func (m *VmConfig) GetNgtFailOnScriptFailure() bool {
	if m != nil && m.NgtFailOnScriptFailure != nil {
		return *m.NgtFailOnScriptFailure
	}
	return false
}

func (m *VmConfig) GetVmGeneration() uint64 {
	if m != nil && m.VmGeneration != nil {
		return *m.VmGeneration
	}
	return 0
}

func (m *VmConfig) GetNumThreadsPerCore() uint32 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

func (m *VmConfig) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *VmConfig) GetCpuPassthrough() bool {
	if m != nil && m.CpuPassthrough != nil {
		return *m.CpuPassthrough
	}
	return false
}

func (m *VmConfig) GetMachineType() string {
	if m != nil && m.MachineType != nil {
		return *m.MachineType
	}
	return Default_VmConfig_MachineType
}

func (m *VmConfig) GetDisableBranding() bool {
	if m != nil && m.DisableBranding != nil {
		return *m.DisableBranding
	}
	return false
}

func (m *VmConfig) GetAllowHotPlug() bool {
	if m != nil && m.AllowHotPlug != nil {
		return *m.AllowHotPlug
	}
	return Default_VmConfig_AllowHotPlug
}

type Affinity struct {
	Policy     *Affinity_Policy     `protobuf:"varint,1,opt,name=policy,enum=nutanix.uhura.Affinity_Policy,def=1" json:"policy,omitempty"`
	Constraint *Affinity_Constraint `protobuf:"varint,2,opt,name=constraint,enum=nutanix.uhura.Affinity_Constraint,def=1" json:"constraint,omitempty"`
	// List of binding hosts.
	HostUuids            [][]byte `protobuf:"bytes,3,rep,name=host_uuids,json=hostUuids" json:"host_uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Affinity) Reset()         { *m = Affinity{} }
func (m *Affinity) String() string { return proto.CompactTextString(m) }
func (*Affinity) ProtoMessage()    {}
func (*Affinity) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{34}
}

func (m *Affinity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Affinity.Unmarshal(m, b)
}
func (m *Affinity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Affinity.Marshal(b, m, deterministic)
}
func (m *Affinity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Affinity.Merge(m, src)
}
func (m *Affinity) XXX_Size() int {
	return xxx_messageInfo_Affinity.Size(m)
}
func (m *Affinity) XXX_DiscardUnknown() {
	xxx_messageInfo_Affinity.DiscardUnknown(m)
}

var xxx_messageInfo_Affinity proto.InternalMessageInfo

const Default_Affinity_Policy Affinity_Policy = Affinity_kAffinity
const Default_Affinity_Constraint Affinity_Constraint = Affinity_kMust

func (m *Affinity) GetPolicy() Affinity_Policy {
	if m != nil && m.Policy != nil {
		return *m.Policy
	}
	return Default_Affinity_Policy
}

func (m *Affinity) GetConstraint() Affinity_Constraint {
	if m != nil && m.Constraint != nil {
		return *m.Constraint
	}
	return Default_Affinity_Constraint
}

func (m *Affinity) GetHostUuids() [][]byte {
	if m != nil {
		return m.HostUuids
	}
	return nil
}

// Affinity config used during create/update of vm-vm affinity rules.
type VmToVmAffinityConfig struct {
	// Affinity constraint.
	// Default value during create operation is Affinity.kShould.
	// In case of update operation, this value will be considered only when
	// explicitly set.
	Constraint *Affinity_Constraint `protobuf:"varint,1,opt,name=constraint,enum=nutanix.uhura.Affinity_Constraint,def=2" json:"constraint,omitempty"`
	// Affinity policy.
	// Defalut value during create operation is Affinity.kAntiAffinity.
	// In case of update operation, this value will be considered only when
	// explicitly set.
	Policy *Affinity_Policy `protobuf:"varint,2,opt,name=policy,enum=nutanix.uhura.Affinity_Policy,def=2" json:"policy,omitempty"`
	// Name of the group.
	// Recommendation: component followed by affinity rule name.
	// Examples:
	//   minerva_vm_vm_anti_affinity
	//   minerva_vm_vm_affinity.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// List of VMs to be part of this Rule.
	VmUuidList           [][]byte `protobuf:"bytes,4,rep,name=vm_uuid_list,json=vmUuidList" json:"vm_uuid_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmToVmAffinityConfig) Reset()         { *m = VmToVmAffinityConfig{} }
func (m *VmToVmAffinityConfig) String() string { return proto.CompactTextString(m) }
func (*VmToVmAffinityConfig) ProtoMessage()    {}
func (*VmToVmAffinityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{35}
}

func (m *VmToVmAffinityConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmToVmAffinityConfig.Unmarshal(m, b)
}
func (m *VmToVmAffinityConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmToVmAffinityConfig.Marshal(b, m, deterministic)
}
func (m *VmToVmAffinityConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmToVmAffinityConfig.Merge(m, src)
}
func (m *VmToVmAffinityConfig) XXX_Size() int {
	return xxx_messageInfo_VmToVmAffinityConfig.Size(m)
}
func (m *VmToVmAffinityConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmToVmAffinityConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmToVmAffinityConfig proto.InternalMessageInfo

const Default_VmToVmAffinityConfig_Constraint Affinity_Constraint = Affinity_kShould
const Default_VmToVmAffinityConfig_Policy Affinity_Policy = Affinity_kAntiAffinity

func (m *VmToVmAffinityConfig) GetConstraint() Affinity_Constraint {
	if m != nil && m.Constraint != nil {
		return *m.Constraint
	}
	return Default_VmToVmAffinityConfig_Constraint
}

func (m *VmToVmAffinityConfig) GetPolicy() Affinity_Policy {
	if m != nil && m.Policy != nil {
		return *m.Policy
	}
	return Default_VmToVmAffinityConfig_Policy
}

func (m *VmToVmAffinityConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmToVmAffinityConfig) GetVmUuidList() [][]byte {
	if m != nil {
		return m.VmUuidList
	}
	return nil
}

// The Status enumeration defines a general "health" value for a managed entity.
// ESX Specific - https://github.com/vmware/pyvmomi/blob/master/docs/vim/ManagedEntity/Status.rst
type ManagedEntityStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ManagedEntityStatus) Reset()         { *m = ManagedEntityStatus{} }
func (m *ManagedEntityStatus) String() string { return proto.CompactTextString(m) }
func (*ManagedEntityStatus) ProtoMessage()    {}
func (*ManagedEntityStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{36}
}

func (m *ManagedEntityStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ManagedEntityStatus.Unmarshal(m, b)
}
func (m *ManagedEntityStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ManagedEntityStatus.Marshal(b, m, deterministic)
}
func (m *ManagedEntityStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManagedEntityStatus.Merge(m, src)
}
func (m *ManagedEntityStatus) XXX_Size() int {
	return xxx_messageInfo_ManagedEntityStatus.Size(m)
}
func (m *ManagedEntityStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ManagedEntityStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ManagedEntityStatus proto.InternalMessageInfo

// Affinity info returned during get call. This info is not stored in
// EntityDB and fetched runtime as required.
type VmToVmAffinityInfo struct {
	// UUID of the VM Affinity rule.
	AffinityUuid *string `protobuf:"bytes,1,opt,name=affinity_uuid,json=affinityUuid" json:"affinity_uuid,omitempty"`
	// Name of the Affinity rule.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Affinity policy.
	Policy *Affinity_Policy `protobuf:"varint,3,opt,name=policy,enum=nutanix.uhura.Affinity_Policy" json:"policy,omitempty"`
	// Affinity constraint.
	Constraint *Affinity_Constraint `protobuf:"varint,4,opt,name=constraint,enum=nutanix.uhura.Affinity_Constraint" json:"constraint,omitempty"`
	// ESX specific. Flag to indicate whether or not the rule is enabled.
	// Set this property when you configure the rule.
	// The default value is false (disabled). If there is a rule conflict,
	// the Server can override the setting to disable a rule.
	Enabled *bool `protobuf:"varint,5,opt,name=enabled" json:"enabled,omitempty"`
	// ESX specific.
	// Flag to indicate whether or not the rule is currently satisfied.
	// This field is set by VC and is used only for get calls.
	Status *ManagedEntityStatus_Status `protobuf:"varint,6,opt,name=status,enum=nutanix.uhura.ManagedEntityStatus_Status" json:"status,omitempty"`
	// ESX specific. Unique ID for rules assigned by VC.
	Key                  *string  `protobuf:"bytes,7,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmToVmAffinityInfo) Reset()         { *m = VmToVmAffinityInfo{} }
func (m *VmToVmAffinityInfo) String() string { return proto.CompactTextString(m) }
func (*VmToVmAffinityInfo) ProtoMessage()    {}
func (*VmToVmAffinityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{37}
}

func (m *VmToVmAffinityInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmToVmAffinityInfo.Unmarshal(m, b)
}
func (m *VmToVmAffinityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmToVmAffinityInfo.Marshal(b, m, deterministic)
}
func (m *VmToVmAffinityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmToVmAffinityInfo.Merge(m, src)
}
func (m *VmToVmAffinityInfo) XXX_Size() int {
	return xxx_messageInfo_VmToVmAffinityInfo.Size(m)
}
func (m *VmToVmAffinityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmToVmAffinityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmToVmAffinityInfo proto.InternalMessageInfo

func (m *VmToVmAffinityInfo) GetAffinityUuid() string {
	if m != nil && m.AffinityUuid != nil {
		return *m.AffinityUuid
	}
	return ""
}

func (m *VmToVmAffinityInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmToVmAffinityInfo) GetPolicy() Affinity_Policy {
	if m != nil && m.Policy != nil {
		return *m.Policy
	}
	return Affinity_kAffinity
}

func (m *VmToVmAffinityInfo) GetConstraint() Affinity_Constraint {
	if m != nil && m.Constraint != nil {
		return *m.Constraint
	}
	return Affinity_kMust
}

func (m *VmToVmAffinityInfo) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return false
}

func (m *VmToVmAffinityInfo) GetStatus() ManagedEntityStatus_Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ManagedEntityStatus_kNotSet
}

func (m *VmToVmAffinityInfo) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

type VmHypervisorInfo struct {
	// The hypervisor type.
	HypervisorType *config.ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,1,opt,name=hypervisor_type,json=hypervisorType,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType" json:"hypervisor_type,omitempty"`
	// The VM's hypervisor-specific data.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmHypervisorInfo) Reset()         { *m = VmHypervisorInfo{} }
func (m *VmHypervisorInfo) String() string { return proto.CompactTextString(m) }
func (*VmHypervisorInfo) ProtoMessage()    {}
func (*VmHypervisorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{38}
}

func (m *VmHypervisorInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmHypervisorInfo.Unmarshal(m, b)
}
func (m *VmHypervisorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmHypervisorInfo.Marshal(b, m, deterministic)
}
func (m *VmHypervisorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmHypervisorInfo.Merge(m, src)
}
func (m *VmHypervisorInfo) XXX_Size() int {
	return xxx_messageInfo_VmHypervisorInfo.Size(m)
}
func (m *VmHypervisorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmHypervisorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmHypervisorInfo proto.InternalMessageInfo

func (m *VmHypervisorInfo) GetHypervisorType() config.ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return config.ConfigurationProto_ManagementServer_kVMware
}

func (m *VmHypervisorInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type VmState struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmState) Reset()         { *m = VmState{} }
func (m *VmState) String() string { return proto.CompactTextString(m) }
func (*VmState) ProtoMessage()    {}
func (*VmState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{39}
}

func (m *VmState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmState.Unmarshal(m, b)
}
func (m *VmState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmState.Marshal(b, m, deterministic)
}
func (m *VmState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmState.Merge(m, src)
}
func (m *VmState) XXX_Size() int {
	return xxx_messageInfo_VmState.Size(m)
}
func (m *VmState) XXX_DiscardUnknown() {
	xxx_messageInfo_VmState.DiscardUnknown(m)
}

var xxx_messageInfo_VmState proto.InternalMessageInfo

// Enum to define the supported guest tools operation.
// Currently these operations are supported only on ESX.
type GuestToolsOperation struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuestToolsOperation) Reset()         { *m = GuestToolsOperation{} }
func (m *GuestToolsOperation) String() string { return proto.CompactTextString(m) }
func (*GuestToolsOperation) ProtoMessage()    {}
func (*GuestToolsOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{40}
}

func (m *GuestToolsOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GuestToolsOperation.Unmarshal(m, b)
}
func (m *GuestToolsOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GuestToolsOperation.Marshal(b, m, deterministic)
}
func (m *GuestToolsOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuestToolsOperation.Merge(m, src)
}
func (m *GuestToolsOperation) XXX_Size() int {
	return xxx_messageInfo_GuestToolsOperation.Size(m)
}
func (m *GuestToolsOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_GuestToolsOperation.DiscardUnknown(m)
}

var xxx_messageInfo_GuestToolsOperation proto.InternalMessageInfo

// Enum to denote the current running status of guest tools.
// Valid for ESX only.
type VmToolsRunningStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmToolsRunningStatus) Reset()         { *m = VmToolsRunningStatus{} }
func (m *VmToolsRunningStatus) String() string { return proto.CompactTextString(m) }
func (*VmToolsRunningStatus) ProtoMessage()    {}
func (*VmToolsRunningStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{41}
}

func (m *VmToolsRunningStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmToolsRunningStatus.Unmarshal(m, b)
}
func (m *VmToolsRunningStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmToolsRunningStatus.Marshal(b, m, deterministic)
}
func (m *VmToolsRunningStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmToolsRunningStatus.Merge(m, src)
}
func (m *VmToolsRunningStatus) XXX_Size() int {
	return xxx_messageInfo_VmToolsRunningStatus.Size(m)
}
func (m *VmToolsRunningStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VmToolsRunningStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VmToolsRunningStatus proto.InternalMessageInfo

// Enum to denote the current version status of guest tools.
// Valid for ESX only.
type VmToolsVersionStatus struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmToolsVersionStatus) Reset()         { *m = VmToolsVersionStatus{} }
func (m *VmToolsVersionStatus) String() string { return proto.CompactTextString(m) }
func (*VmToolsVersionStatus) ProtoMessage()    {}
func (*VmToolsVersionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{42}
}

func (m *VmToolsVersionStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmToolsVersionStatus.Unmarshal(m, b)
}
func (m *VmToolsVersionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmToolsVersionStatus.Marshal(b, m, deterministic)
}
func (m *VmToolsVersionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmToolsVersionStatus.Merge(m, src)
}
func (m *VmToolsVersionStatus) XXX_Size() int {
	return xxx_messageInfo_VmToolsVersionStatus.Size(m)
}
func (m *VmToolsVersionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VmToolsVersionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VmToolsVersionStatus proto.InternalMessageInfo

// Only contains fields used by V3 APIs.
// To be extended when required.
type VmSnapshotInfo struct {
	// The snapshot identifier.
	SnapshotUuid []byte `protobuf:"bytes,1,opt,name=snapshot_uuid,json=snapshotUuid" json:"snapshot_uuid,omitempty"`
	// A specification for creating VMs from this snapshot.
	VmConfig *VmCreateConfig `protobuf:"bytes,2,opt,name=vm_config,json=vmConfig" json:"vm_config,omitempty"`
	// Name of the snapshot.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Small description of the snapshot.
	Annotation *string `protobuf:"bytes,4,opt,name=annotation" json:"annotation,omitempty"`
	// Timestamp at which snapshot was taken.
	CreateTimestamp *int64 `protobuf:"varint,5,opt,name=create_timestamp,json=createTimestamp,def=-1" json:"create_timestamp,omitempty"`
	// Hypervisor agnostic id of the VM.
	VmUuid               []byte   `protobuf:"bytes,6,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmSnapshotInfo) Reset()         { *m = VmSnapshotInfo{} }
func (m *VmSnapshotInfo) String() string { return proto.CompactTextString(m) }
func (*VmSnapshotInfo) ProtoMessage()    {}
func (*VmSnapshotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{43}
}

func (m *VmSnapshotInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSnapshotInfo.Unmarshal(m, b)
}
func (m *VmSnapshotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSnapshotInfo.Marshal(b, m, deterministic)
}
func (m *VmSnapshotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSnapshotInfo.Merge(m, src)
}
func (m *VmSnapshotInfo) XXX_Size() int {
	return xxx_messageInfo_VmSnapshotInfo.Size(m)
}
func (m *VmSnapshotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSnapshotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmSnapshotInfo proto.InternalMessageInfo

const Default_VmSnapshotInfo_CreateTimestamp int64 = -1

func (m *VmSnapshotInfo) GetSnapshotUuid() []byte {
	if m != nil {
		return m.SnapshotUuid
	}
	return nil
}

func (m *VmSnapshotInfo) GetVmConfig() *VmCreateConfig {
	if m != nil {
		return m.VmConfig
	}
	return nil
}

func (m *VmSnapshotInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmSnapshotInfo) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VmSnapshotInfo) GetCreateTimestamp() int64 {
	if m != nil && m.CreateTimestamp != nil {
		return *m.CreateTimestamp
	}
	return Default_VmSnapshotInfo_CreateTimestamp
}

func (m *VmSnapshotInfo) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

type VmInfo struct {
	// The VM identifier.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// The VM's logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// The VM's configuration.
	Config *VmConfig `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
	// The VM's hypervisor information.
	Hypervisor *VmHypervisorInfo `protobuf:"bytes,4,opt,name=hypervisor" json:"hypervisor,omitempty"`
	// The VM's current host.
	HostUuid []byte `protobuf:"bytes,5,opt,name=host_uuid,json=hostUuid" json:"host_uuid,omitempty"`
	// The VM's current power state.
	State *VmState_State `protobuf:"varint,6,opt,name=state,enum=nutanix.uhura.VmState_State" json:"state,omitempty"`
	// Hypervisor assigned identifier for the VM.
	//
	// For AHV, it is a 16 bytes UUID.
	// For ESX, it is a 16 byte string in hexadecimal format.
	// Other hypervisors are not supported as yet.
	HypervisorSpecificId []byte `protobuf:"bytes,7,opt,name=hypervisor_specific_id,json=hypervisorSpecificId" json:"hypervisor_specific_id,omitempty"`
	// The VM's current tools installer mount status.
	ToolsInstallerMounted *bool `protobuf:"varint,8,opt,name=tools_installer_mounted,json=toolsInstallerMounted" json:"tools_installer_mounted,omitempty"`
	// VM's guest tools installer running status.
	ToolsRunningStatus *VmToolsRunningStatus_Status `protobuf:"varint,9,opt,name=tools_running_status,json=toolsRunningStatus,enum=nutanix.uhura.VmToolsRunningStatus_Status" json:"tools_running_status,omitempty"`
	// Vm's guest tools version status.
	ToolsVersionStatus *VmToolsVersionStatus_Status `protobuf:"varint,10,opt,name=tools_version_status,json=toolsVersionStatus,enum=nutanix.uhura.VmToolsVersionStatus_Status" json:"tools_version_status,omitempty"`
	// Can VM be live migrated.
	AllowLiveMigrate *bool `protobuf:"varint,11,opt,name=allow_live_migrate,json=allowLiveMigrate,def=1" json:"allow_live_migrate,omitempty"`
	// GPUs currently assigned to VM.
	GpuList []*NodeGPU `protobuf:"bytes,12,rep,name=gpu_list,json=gpuList" json:"gpu_list,omitempty"`
	// Last known Guest driver version for the VM.
	GuestDriverVersion *string `protobuf:"bytes,13,opt,name=guest_driver_version,json=guestDriverVersion" json:"guest_driver_version,omitempty"`
	// Applicable only for ESX.
	// Whether guest time synchronization by host is enabled or not.
	TimeSyncEnabled *bool `protobuf:"varint,14,opt,name=time_sync_enabled,json=timeSyncEnabled,def=1" json:"time_sync_enabled,omitempty"`
	// Path of VM files.
	VmPath *string `protobuf:"bytes,15,opt,name=vm_path,json=vmPath" json:"vm_path,omitempty"`
	// Raw hypervisor format info of VM's entities. As of now valid only for ESX.
	HypervisorVmInfo *VmInfo_HypervisorVmInfo `protobuf:"bytes,16,opt,name=hypervisor_vm_info,json=hypervisorVmInfo" json:"hypervisor_vm_info,omitempty"`
	// Applicable only for ESX.
	// Whether some task in the VM is in progress or is pending.
	IsVmTaskInProgress   *bool    `protobuf:"varint,17,opt,name=is_vm_task_in_progress,json=isVmTaskInProgress" json:"is_vm_task_in_progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmInfo) Reset()         { *m = VmInfo{} }
func (m *VmInfo) String() string { return proto.CompactTextString(m) }
func (*VmInfo) ProtoMessage()    {}
func (*VmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{44}
}

func (m *VmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmInfo.Unmarshal(m, b)
}
func (m *VmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmInfo.Marshal(b, m, deterministic)
}
func (m *VmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmInfo.Merge(m, src)
}
func (m *VmInfo) XXX_Size() int {
	return xxx_messageInfo_VmInfo.Size(m)
}
func (m *VmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmInfo proto.InternalMessageInfo

const Default_VmInfo_LogicalTimestamp int64 = -1
const Default_VmInfo_AllowLiveMigrate bool = true
const Default_VmInfo_TimeSyncEnabled bool = true

func (m *VmInfo) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *VmInfo) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_VmInfo_LogicalTimestamp
}

func (m *VmInfo) GetConfig() *VmConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *VmInfo) GetHypervisor() *VmHypervisorInfo {
	if m != nil {
		return m.Hypervisor
	}
	return nil
}

func (m *VmInfo) GetHostUuid() []byte {
	if m != nil {
		return m.HostUuid
	}
	return nil
}

func (m *VmInfo) GetState() VmState_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return VmState_kUnknown
}

func (m *VmInfo) GetHypervisorSpecificId() []byte {
	if m != nil {
		return m.HypervisorSpecificId
	}
	return nil
}

func (m *VmInfo) GetToolsInstallerMounted() bool {
	if m != nil && m.ToolsInstallerMounted != nil {
		return *m.ToolsInstallerMounted
	}
	return false
}

func (m *VmInfo) GetToolsRunningStatus() VmToolsRunningStatus_Status {
	if m != nil && m.ToolsRunningStatus != nil {
		return *m.ToolsRunningStatus
	}
	return VmToolsRunningStatus_kUnknown
}

func (m *VmInfo) GetToolsVersionStatus() VmToolsVersionStatus_Status {
	if m != nil && m.ToolsVersionStatus != nil {
		return *m.ToolsVersionStatus
	}
	return VmToolsVersionStatus_kUnknown
}

func (m *VmInfo) GetAllowLiveMigrate() bool {
	if m != nil && m.AllowLiveMigrate != nil {
		return *m.AllowLiveMigrate
	}
	return Default_VmInfo_AllowLiveMigrate
}

func (m *VmInfo) GetGpuList() []*NodeGPU {
	if m != nil {
		return m.GpuList
	}
	return nil
}

func (m *VmInfo) GetGuestDriverVersion() string {
	if m != nil && m.GuestDriverVersion != nil {
		return *m.GuestDriverVersion
	}
	return ""
}

func (m *VmInfo) GetTimeSyncEnabled() bool {
	if m != nil && m.TimeSyncEnabled != nil {
		return *m.TimeSyncEnabled
	}
	return Default_VmInfo_TimeSyncEnabled
}

func (m *VmInfo) GetVmPath() string {
	if m != nil && m.VmPath != nil {
		return *m.VmPath
	}
	return ""
}

func (m *VmInfo) GetHypervisorVmInfo() *VmInfo_HypervisorVmInfo {
	if m != nil {
		return m.HypervisorVmInfo
	}
	return nil
}

func (m *VmInfo) GetIsVmTaskInProgress() bool {
	if m != nil && m.IsVmTaskInProgress != nil {
		return *m.IsVmTaskInProgress
	}
	return false
}

type VmInfo_HypervisorVmInfo struct {
	// The configuration of VM in raw hypervisor-format, populated when
	// include_raw_vm_config is set to true. The string value stored in this
	// variable "raw_vm_config" is delimited by "\n".
	RawVmConfig          *string  `protobuf:"bytes,1,opt,name=raw_vm_config,json=rawVmConfig" json:"raw_vm_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmInfo_HypervisorVmInfo) Reset()         { *m = VmInfo_HypervisorVmInfo{} }
func (m *VmInfo_HypervisorVmInfo) String() string { return proto.CompactTextString(m) }
func (*VmInfo_HypervisorVmInfo) ProtoMessage()    {}
func (*VmInfo_HypervisorVmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{44, 0}
}

func (m *VmInfo_HypervisorVmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmInfo_HypervisorVmInfo.Unmarshal(m, b)
}
func (m *VmInfo_HypervisorVmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmInfo_HypervisorVmInfo.Marshal(b, m, deterministic)
}
func (m *VmInfo_HypervisorVmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmInfo_HypervisorVmInfo.Merge(m, src)
}
func (m *VmInfo_HypervisorVmInfo) XXX_Size() int {
	return xxx_messageInfo_VmInfo_HypervisorVmInfo.Size(m)
}
func (m *VmInfo_HypervisorVmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmInfo_HypervisorVmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmInfo_HypervisorVmInfo proto.InternalMessageInfo

func (m *VmInfo_HypervisorVmInfo) GetRawVmConfig() string {
	if m != nil && m.RawVmConfig != nil {
		return *m.RawVmConfig
	}
	return ""
}

type ServerInfo struct {
	// IP address of the management server.
	MgmtServerIpAddress *string `protobuf:"bytes,1,opt,name=mgmt_server_ip_address,json=mgmtServerIpAddress" json:"mgmt_server_ip_address,omitempty"`
	// Boolean to denote if server is registered with Nutanix or not.
	IsRegistered *bool `protobuf:"varint,2,opt,name=is_registered,json=isRegistered,def=0" json:"is_registered,omitempty"`
	// Boolean to denote if drs is enabled or not. Applicable only for vCenter.
	DrsEnabled *bool `protobuf:"varint,3,opt,name=drs_enabled,json=drsEnabled" json:"drs_enabled,omitempty"`
	// Default DRS behaviour for VM.
	DrsDefaultVmBehavior *DrsBehavior `protobuf:"varint,4,opt,name=drs_default_vm_behavior,json=drsDefaultVmBehavior,enum=nutanix.uhura.DrsBehavior,def=1" json:"drs_default_vm_behavior,omitempty"`
	// Boolean to denote if ha is enabled or not.
	HaEnabled *bool `protobuf:"varint,5,opt,name=ha_enabled,json=haEnabled" json:"ha_enabled,omitempty"`
	// Boolean to denote if strict admission control is enabled.
	AdmissionControlEnabled *bool `protobuf:"varint,6,opt,name=admission_control_enabled,json=admissionControlEnabled,def=0" json:"admission_control_enabled,omitempty"`
	// Boolean to denote if server is actually managing any of the
	// hosts in the current Nutanix cluster.
	InUse *bool `protobuf:"varint,7,opt,name=in_use,json=inUse" json:"in_use,omitempty"`
	// Certificate file contents for the management server.
	CertFileStr *string `protobuf:"bytes,8,opt,name=cert_file_str,json=certFileStr" json:"cert_file_str,omitempty"`
	// Private key file contents for the management server.
	KeyFileStr           *string  `protobuf:"bytes,9,opt,name=key_file_str,json=keyFileStr" json:"key_file_str,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfo) Reset()         { *m = ServerInfo{} }
func (m *ServerInfo) String() string { return proto.CompactTextString(m) }
func (*ServerInfo) ProtoMessage()    {}
func (*ServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{45}
}

func (m *ServerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerInfo.Unmarshal(m, b)
}
func (m *ServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerInfo.Marshal(b, m, deterministic)
}
func (m *ServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfo.Merge(m, src)
}
func (m *ServerInfo) XXX_Size() int {
	return xxx_messageInfo_ServerInfo.Size(m)
}
func (m *ServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfo proto.InternalMessageInfo

const Default_ServerInfo_IsRegistered bool = false
const Default_ServerInfo_DrsDefaultVmBehavior DrsBehavior = DrsBehavior_kUnknown
const Default_ServerInfo_AdmissionControlEnabled bool = false

func (m *ServerInfo) GetMgmtServerIpAddress() string {
	if m != nil && m.MgmtServerIpAddress != nil {
		return *m.MgmtServerIpAddress
	}
	return ""
}

func (m *ServerInfo) GetIsRegistered() bool {
	if m != nil && m.IsRegistered != nil {
		return *m.IsRegistered
	}
	return Default_ServerInfo_IsRegistered
}

func (m *ServerInfo) GetDrsEnabled() bool {
	if m != nil && m.DrsEnabled != nil {
		return *m.DrsEnabled
	}
	return false
}

func (m *ServerInfo) GetDrsDefaultVmBehavior() DrsBehavior {
	if m != nil && m.DrsDefaultVmBehavior != nil {
		return *m.DrsDefaultVmBehavior
	}
	return Default_ServerInfo_DrsDefaultVmBehavior
}

func (m *ServerInfo) GetHaEnabled() bool {
	if m != nil && m.HaEnabled != nil {
		return *m.HaEnabled
	}
	return false
}

func (m *ServerInfo) GetAdmissionControlEnabled() bool {
	if m != nil && m.AdmissionControlEnabled != nil {
		return *m.AdmissionControlEnabled
	}
	return Default_ServerInfo_AdmissionControlEnabled
}

func (m *ServerInfo) GetInUse() bool {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return false
}

func (m *ServerInfo) GetCertFileStr() string {
	if m != nil && m.CertFileStr != nil {
		return *m.CertFileStr
	}
	return ""
}

func (m *ServerInfo) GetKeyFileStr() string {
	if m != nil && m.KeyFileStr != nil {
		return *m.KeyFileStr
	}
	return ""
}

type Vm struct {
	// This is the arithmos id in the VM stats report.
	XArithmosId_ *string `protobuf:"bytes,1,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// The VM ID assigned by the hypervisor, e.g. Acropolis, ESX, and Hyper-V.
	HypervisorSpecificId *string `protobuf:"bytes,2,opt,name=hypervisor_specific_id,json=hypervisorSpecificId" json:"hypervisor_specific_id,omitempty"`
	// The VM name.
	VmName *string `protobuf:"bytes,3,opt,name=vm_name,json=vmName" json:"vm_name,omitempty"`
	// The name of the guest OS running on the VM.
	GuestOsName *string `protobuf:"bytes,4,opt,name=guest_os_name,json=guestOsName" json:"guest_os_name,omitempty"`
	// The number of virtual CPUs that the VM has.
	NumVcpus *int64 `protobuf:"varint,5,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// The number of cores per each socket.
	NumCoresPerSocket *int64 `protobuf:"varint,6,opt,name=num_cores_per_socket,json=numCoresPerSocket" json:"num_cores_per_socket,omitempty"`
	// The configured reserved CPU in Hz.
	CpuReservationHz *int64 `protobuf:"varint,7,opt,name=cpu_reservation_hz,json=cpuReservationHz" json:"cpu_reservation_hz,omitempty"`
	// Size of the configured memory for the virtual machine in bytes.
	MemorySizeBytes *int64 `protobuf:"varint,8,opt,name=memory_size_bytes,json=memorySizeBytes" json:"memory_size_bytes,omitempty"`
	// Configured memory reservation in bytes.
	MemoryReservedBytes *int64 `protobuf:"varint,9,opt,name=memory_reserved_bytes,json=memoryReservedBytes" json:"memory_reserved_bytes,omitempty"`
	// VM power state as reported by Arithmos: "on", "off", or "suspended".
	PowerState *string `protobuf:"bytes,10,opt,name=power_state,json=powerState" json:"power_state,omitempty"`
	// Whether the VM is a Nutanix CVM.
	IsCvm *int64 `protobuf:"varint,11,opt,name=is_cvm,json=isCvm" json:"is_cvm,omitempty"`
	// Whether the VM is CBR capable. CBR capable VMs have all files on Nutanix
	// containers and are eligible for Nutanix DR protection.
	IsCbrCapable *int64 `protobuf:"varint,12,opt,name=is_cbr_capable,json=isCbrCapable" json:"is_cbr_capable,omitempty"`
	// Whether this is an Acropolis VM.
	IsAcropolisVm *int64 `protobuf:"varint,13,opt,name=is_acropolis_vm,json=isAcropolisVm" json:"is_acropolis_vm,omitempty"`
	// The reason the VM is not CBR capable. This is not set if the VM is CBR
	// capable.
	CbrNotCapableReason *string `protobuf:"bytes,14,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// The hypervisor type of the VM.
	HypervisorType *string `protobuf:"bytes,15,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// The ID of the node on which the VM is running.
	NodeId *string `protobuf:"bytes,16,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The service VM UUID corresponds to the node on which the VM is running.
	// Please note that the node entity's id is service VM UUID, not node UUID.
	Node *string `protobuf:"bytes,17,opt,name=node" json:"node,omitempty"`
	// The name of the node on which the VM is running.
	NodeName *string `protobuf:"bytes,18,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	// Node IPv4 address.
	NodeIpv4Address *string `protobuf:"bytes,19,opt,name=node_ipv4_address,json=nodeIpv4Address" json:"node_ipv4_address,omitempty"`
	// The list of container IDs associated with the VM.
	ContainerIds []string `protobuf:"bytes,20,rep,name=container_ids,json=containerIds" json:"container_ids,omitempty"`
	// The VM logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,21,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// The list of VM tag UUIDs.
	TagList []string `protobuf:"bytes,22,rep,name=tag_list,json=tagList" json:"tag_list,omitempty"`
	// Service UUID. One VM belongs to at most one service (or workload type).
	ServiceId *string `protobuf:"bytes,23,opt,name=service_id,json=serviceId" json:"service_id,omitempty"`
	// Number of Ethernet adapters configured.
	NumNetworkAdapters *int64 `protobuf:"varint,24,opt,name=num_network_adapters,json=numNetworkAdapters" json:"num_network_adapters,omitempty"`
	// IP addresses assigned to all the configured network adapters.
	// This list can include v4 and v6 IP addresses.
	IpAddresses []string `protobuf:"bytes,25,rep,name=ip_addresses,json=ipAddresses" json:"ip_addresses,omitempty"`
	// Virtual NICs id stored in this field.
	VirtualNicIds []string `protobuf:"bytes,26,rep,name=virtual_nic_ids,json=virtualNicIds" json:"virtual_nic_ids,omitempty"`
	// Virtual hardware version.
	VirtualHardwareVersion *int64 `protobuf:"varint,27,opt,name=virtual_hardware_version,json=virtualHardwareVersion" json:"virtual_hardware_version,omitempty"`
	// BIOS UUID.
	BiosUuid *string `protobuf:"bytes,28,opt,name=bios_uuid,json=biosUuid" json:"bios_uuid,omitempty"`
	// The display address to the console, only available on AHV.
	DisplayAddress *string `protobuf:"bytes,29,opt,name=display_address,json=displayAddress" json:"display_address,omitempty"`
	// The protection domain UUID where this VM belongs to.
	ProtectionDomain *string `protobuf:"bytes,30,opt,name=protection_domain,json=protectionDomain" json:"protection_domain,omitempty"`
	// The protection domain name where this VM belongs to.
	ProtectionDomainName *string `protobuf:"bytes,31,opt,name=protection_domain_name,json=protectionDomainName" json:"protection_domain_name,omitempty"`
	// The consistency group UUID where this VM belongs to.
	ConsistencyGroup *string `protobuf:"bytes,32,opt,name=consistency_group,json=consistencyGroup" json:"consistency_group,omitempty"`
	// The consistency group name where this VM belongs to.
	ConsistencyGroupName *string `protobuf:"bytes,33,opt,name=consistency_group_name,json=consistencyGroupName" json:"consistency_group_name,omitempty"`
	// List of all the virtual disks that are based on Nutanix NFS and
	// providing storage to the VM. Eg. /nutanix-ctr-name/my-uvm/my-uvm.vmdk.
	NutanixNfsBasedVirtualDisks []string `protobuf:"bytes,34,rep,name=nutanix_nfs_based_virtual_disks,json=nutanixNfsBasedVirtualDisks" json:"nutanix_nfs_based_virtual_disks,omitempty"`
	// List of all the virtual disks uuids that are based on Nutanix NFS and
	// providing storage to the VM. There exists a 1-1 mapping of
	// 'nutanix_nfs_based_virtual_disks' to
	// 'nutanix_nfs_based_virtual_diks_uuids'.
	NutanixNfsBasedVirtualDiskUuids []string `protobuf:"bytes,35,rep,name=nutanix_nfs_based_virtual_disk_uuids,json=nutanixNfsBasedVirtualDiskUuids" json:"nutanix_nfs_based_virtual_disk_uuids,omitempty"`
	// List of iSCSI targets of all the virtual disks that are
	// based on Nutanix iSCSI and providing storage to the VM.
	// Eg. iqn.2010-06.com.nutanix:<disk-name>-<random>
	NutanixIscsiBasedVirtualDisks []string `protobuf:"bytes,36,rep,name=nutanix_iscsi_based_virtual_disks,json=nutanixIscsiBasedVirtualDisks" json:"nutanix_iscsi_based_virtual_disks,omitempty"`
	// List of all the virtual disks uuids that are based on Nutanix iSCSI and
	// providing storage to the VM. There exists a 1-1 mapping of
	// 'nutanix_iscsi_based_virtual_disks' to
	// 'nutanix_iscsi_based_virtual_diks_uuids'.
	NutanixIscsiBasedVirtualDiskUuids []string `protobuf:"bytes,37,rep,name=nutanix_iscsi_based_virtual_disk_uuids,json=nutanixIscsiBasedVirtualDiskUuids" json:"nutanix_iscsi_based_virtual_disk_uuids,omitempty"`
	// The cluster UUID.
	Cluster *string `protobuf:"bytes,38,opt,name=cluster" json:"cluster,omitempty"`
	// The cluster name.
	ClusterName *string `protobuf:"bytes,39,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// NGT enabled, i.e. "ngt.enabled" in Arithmos.
	NgtEnabled *int64 `protobuf:"varint,40,opt,name=ngt_enabled,json=ngtEnabled" json:"ngt_enabled,omitempty"`
	// NGT ISO mounted, i.e. "ngt.iso_mounted" in Arithmos.
	NgtIsoMounted *int64 `protobuf:"varint,41,opt,name=ngt_iso_mounted,json=ngtIsoMounted" json:"ngt_iso_mounted,omitempty"`
	// Total pinned bytes configured for this vm on cloud tier, i.e.
	// "controller.storage_tier.cloud.configured_pinned_bytes" in Arithmos.
	ControllerStorageTierCloudConfiguredPinnedBytes *int64 `protobuf:"varint,42,opt,name=controller_storage_tier_cloud_configured_pinned_bytes,json=controllerStorageTierCloudConfiguredPinnedBytes" json:"controller_storage_tier_cloud_configured_pinned_bytes,omitempty"`
	// Total pinned bytes configured for this vm on hdd tier, i.e.
	// "controller.storage_tier.das-sata.configured_pinned_bytes" in Arithmos.
	ControllerStorageTierDasSataConfiguredPinnedBytes *int64 `protobuf:"varint,43,opt,name=controller_storage_tier_das_sata_configured_pinned_bytes,json=controllerStorageTierDasSataConfiguredPinnedBytes" json:"controller_storage_tier_das_sata_configured_pinned_bytes,omitempty"`
	// Total pinned bytes configured for this vm on ssd tier, i.e.
	// "controller.storage_tier.ssd.configured_pinned_bytes" in Arithmos.
	ControllerStorageTierSsdConfiguredPinnedBytes *int64 `protobuf:"varint,44,opt,name=controller_storage_tier_ssd_configured_pinned_bytes,json=controllerStorageTierSsdConfiguredPinnedBytes" json:"controller_storage_tier_ssd_configured_pinned_bytes,omitempty"`
	// Capacity bytes.
	CapacityBytes *int64 `protobuf:"varint,45,opt,name=capacity_bytes,json=capacityBytes" json:"capacity_bytes,omitempty"`
	// The state of the VM. Currently it takes one of the these values: "normal",
	// "transient", "deleted" and "uhura_deleted".
	// - When a VM on non-AHV hypervisor is not found, this attribute is set to
	//   "deleted" to indicate that the VM may or may not be being migrated to
	//   another host. After a certain gflag configurable duration, if the VM is
	//   still not appear in any host, then we delete the VM entity from Insights
	//   DB. If the VM appear again, we will reset this back to "normal".
	// - During certain Cerebro VM migration workflows such as in-place revert a
	//   VM, it needs to first delete the VM but still want to leave the VM entity
	//   in Insights DB. In this case the VM state is set to "transient". This
	//   way, the VM entity can remain in Insights DB during the whole Cerebro VM
	//   revert workflow. When the VM revert is completed, this attribute is reset
	//   to "normal" again. In case the VM revert operation never complete, we can
	//   clean up the VM entity after certain gflag configurable time duration.
	VmState *string `protobuf:"bytes,47,opt,name=vm_state,json=vmState" json:"vm_state,omitempty"`
	// VM's guest tools installer mount status.
	ToolsInstallerMounted *bool `protobuf:"varint,49,opt,name=tools_installer_mounted,json=toolsInstallerMounted" json:"tools_installer_mounted,omitempty"`
	// VM's guest tools installer running status.
	// Status can be one of these three:
	// "guestToolsExecutingScripts", "guestToolsNotRunning", "guestToolsRunning"
	ToolsRunningStatus *string `protobuf:"bytes,50,opt,name=tools_running_status,json=toolsRunningStatus" json:"tools_running_status,omitempty"`
	// Hypervisor agnostic UUID of VM to VM affinity rule that VM is part of.
	VmToVmAffinityUuids []string `protobuf:"bytes,51,rep,name=vm_to_vm_affinity_uuids,json=vmToVmAffinityUuids" json:"vm_to_vm_affinity_uuids,omitempty"`
	// Vm's guest tools version status.
	// Status can be one of the following:
	//    guestToolsBlacklisted
	//    guestToolsCurrent
	//    guestToolsNeedUpgrade
	//    guestToolsNotInstalled
	//    guestToolsSupportedNew
	//    guestToolsSupportedOld
	//    guestToolsTooNew
	//    guestToolsTooOld
	//    guestToolsUnmanaged
	ToolsVersionStatus *string `protobuf:"bytes,52,opt,name=tools_version_status,json=toolsVersionStatus" json:"tools_version_status,omitempty"`
	// VM description.
	VmAnnotation *string `protobuf:"bytes,53,opt,name=vm_annotation,json=vmAnnotation" json:"vm_annotation,omitempty"`
	// A list of empty CD-ROM disk addresses.
	EmptyCdromDiskAddresses []string `protobuf:"bytes,54,rep,name=empty_cdrom_disk_addresses,json=emptyCdromDiskAddresses" json:"empty_cdrom_disk_addresses,omitempty"`
	// VM backup policy which contains the frequency of the snapshot of this VM and
	// where to replicate these snapshots.
	BackupPolicy []byte `protobuf:"bytes,55,opt,name=backup_policy,json=backupPolicy" json:"backup_policy,omitempty"` // Deprecated: Do not use.
	// The list of container UUIDs associated with the VM.
	ContainerUuids []string `protobuf:"bytes,56,rep,name=container_uuids,json=containerUuids" json:"container_uuids,omitempty"`
	// Whether the VM is a Migratable.
	IsLiveMigratable *int64 `protobuf:"varint,57,opt,name=is_live_migratable,json=isLiveMigratable,def=-1" json:"is_live_migratable,omitempty"`
	// The list of GPUs configured for this VM.
	ConfiguredGpuList []string `protobuf:"bytes,58,rep,name=configured_gpu_list,json=configuredGpuList" json:"configured_gpu_list,omitempty"`
	// Number of GPUs in use.
	GpusInUse *int64 `protobuf:"varint,59,opt,name=gpus_in_use,json=gpusInUse" json:"gpus_in_use,omitempty"`
	// UUID of the protection rule which is protecting this VM.
	ProtectionRuleUuid *string `protobuf:"bytes,60,opt,name=protection_rule_uuid,json=protectionRuleUuid" json:"protection_rule_uuid,omitempty"`
	// Type of protection applied on this VM.
	ProtectionType *string `protobuf:"bytes,61,opt,name=protection_type,json=protectionType" json:"protection_type,omitempty"`
	// The timezone for the VM's hardware clock.
	HardwareClockTimezone *string `protobuf:"bytes,62,opt,name=hardware_clock_timezone,json=hardwareClockTimezone,def=UTC" json:"hardware_clock_timezone,omitempty"`
	// NGT communication active, i.e. "ngt.communication_active" in Arithmos.
	// This field indicates whether the cvm is reachable from the uvm.
	NgtCommunicationActive *int64 `protobuf:"varint,63,opt,name=ngt_communication_active,json=ngtCommunicationActive" json:"ngt_communication_active,omitempty"`
	// NGT installed version, i.e. "ngt.installed_version" in Arithmos.
	// Version of ngt installed on the uvm.
	NgtInstalledVersion *string `protobuf:"bytes,64,opt,name=ngt_installed_version,json=ngtInstalledVersion" json:"ngt_installed_version,omitempty"`
	// NGT cluster version, i.e. "ngt.cluster_version" in Arithmos.
	// Version og ngt available on the cluster, this will be useful in upgrade.
	NgtClusterVersion *string `protobuf:"bytes,65,opt,name=ngt_cluster_version,json=ngtClusterVersion" json:"ngt_cluster_version,omitempty"`
	// NGT vss enabled, i.e. "ngt.vm_vss_enabled" in Arithmos.
	NgtVmVssEnabled *int64 `protobuf:"varint,66,opt,name=ngt_vm_vss_enabled,json=ngtVmVssEnabled" json:"ngt_vm_vss_enabled,omitempty"`
	// NGT enabled applications, i.e. "ngt.enabled_applications" in Arithmos.
	// Various applications supported by NGT, like file level restore will
	// be captured here.
	NgtEnabledApplications []string `protobuf:"bytes,67,rep,name=ngt_enabled_applications,json=ngtEnabledApplications" json:"ngt_enabled_applications,omitempty"`
	// NGT File level restore enabled, i.e. "ngt.flr_enabled" in Arithmos.
	NgtFlrEnabled *int64 `protobuf:"varint,68,opt,name=ngt_flr_enabled,json=ngtFlrEnabled" json:"ngt_flr_enabled,omitempty"`
	// NGT Guest OS information, i.e. "ngt.guest_os" in Arithmos.
	NgtGuestOs *string `protobuf:"bytes,69,opt,name=ngt_guest_os,json=ngtGuestOs" json:"ngt_guest_os,omitempty"`
	// NGT iSCSI qualified name of the VM , i.e. "ngt.iscsi_iqn" in Arithmos.
	NgtIscsiIqn *string `protobuf:"bytes,70,opt,name=ngt_iscsi_iqn,json=ngtIscsiIqn" json:"ngt_iscsi_iqn,omitempty"`
	// Platform type.
	PlatformType *string `protobuf:"bytes,71,opt,name=platform_type,json=platformType" json:"platform_type,omitempty"`
	// UUID of the manangement server account this VM belongs to.
	ManagementServerAccount *string `protobuf:"bytes,72,opt,name=management_server_account,json=managementServerAccount" json:"management_server_account,omitempty"`
	// Instance ID of the cloud VM.
	InstanceId *string `protobuf:"bytes,73,opt,name=instance_id,json=instanceId" json:"instance_id,omitempty"`
	// Image ID of the cloud VM.
	ImageId *string `protobuf:"bytes,74,opt,name=image_id,json=imageId" json:"image_id,omitempty"`
	// Type of the cloud VM.
	InstanceType *string `protobuf:"bytes,75,opt,name=instance_type,json=instanceType" json:"instance_type,omitempty"`
	// Public DNS name of the cloud VM.
	PublicDnsName *string `protobuf:"bytes,76,opt,name=public_dns_name,json=publicDnsName" json:"public_dns_name,omitempty"`
	// Public IP address of the cloud VM.
	PublicIpAddress *string `protobuf:"bytes,77,opt,name=public_ip_address,json=publicIpAddress" json:"public_ip_address,omitempty"`
	// Private DNS name of the cloud VM.
	PrivateDnsName *string `protobuf:"bytes,78,opt,name=private_dns_name,json=privateDnsName" json:"private_dns_name,omitempty"`
	// Private IP address of the cloud VM.
	PrivateIpAddress *string `protobuf:"bytes,79,opt,name=private_ip_address,json=privateIpAddress" json:"private_ip_address,omitempty"`
	// Region to which the cloud VM belongs to.
	Region *string `protobuf:"bytes,80,opt,name=region" json:"region,omitempty"`
	// Launch time of the cloud VM.
	LaunchTime *string `protobuf:"bytes,81,opt,name=launch_time,json=launchTime" json:"launch_time,omitempty"`
	// Root device type of the cloud VM.
	RootDeviceType *string `protobuf:"bytes,82,opt,name=root_device_type,json=rootDeviceType" json:"root_device_type,omitempty"`
	// Name of the cloud VM.
	InstanceName *string `protobuf:"bytes,83,opt,name=instance_name,json=instanceName" json:"instance_name,omitempty"`
	// Value to identify the source of the VM Ex. "github.com/nutanix-core/acs-aos-go/uhura".
	CreatedBy *string `protobuf:"bytes,84,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	// Availability zone to which the cloud VM belongs to.
	AvailabilityZone *string `protobuf:"bytes,85,opt,name=availability_zone,json=availabilityZone" json:"availability_zone,omitempty"`
	// Applicable only for AHV.
	// Type of the GPU assigned to the current VM.
	// Virtual, PassthroughCompute, PassthroughGraphics.
	GpuType *string `protobuf:"bytes,86,opt,name=gpu_type,json=gpuType" json:"gpu_type,omitempty"`
	// Applicable only for AHV.
	// Last determined guest driver version of GPU.
	GuestDriverVersion *string `protobuf:"bytes,87,opt,name=guest_driver_version,json=guestDriverVersion" json:"guest_driver_version,omitempty"`
	// Legacy affinities.
	LegacyHostAffinityList []string `protobuf:"bytes,88,rep,name=legacy_host_affinity_list,json=legacyHostAffinityList" json:"legacy_host_affinity_list,omitempty"`
	// Category based affinities.
	CategoryHostAffinityList []string `protobuf:"bytes,89,rep,name=category_host_affinity_list,json=categoryHostAffinityList" json:"category_host_affinity_list,omitempty"`
	// VM snapshot ID's attached to the VM.
	VmSnapshot []string `protobuf:"bytes,90,rep,name=vm_snapshot,json=vmSnapshot" json:"vm_snapshot,omitempty"`
	// NGT is deleted, i.e. "ngt.is_deleted" in Arithmos.
	NgtIsDeleted *int64 `protobuf:"varint,91,opt,name=ngt_is_deleted,json=ngtIsDeleted" json:"ngt_is_deleted,omitempty"`
	// The version of the protection rule which is protecting the VM.
	// The PR version gets incremented every time the PR is updated.
	ProtectionRuleVersion *int64 `protobuf:"varint,92,opt,name=protection_rule_version,json=protectionRuleVersion" json:"protection_rule_version,omitempty"`
	// The type of the VM.
	VmType *string `protobuf:"bytes,93,opt,name=vm_type,json=vmType" json:"vm_type,omitempty"`
	// NGT ESX mobility drivers are installed. "ngt.esx_drivers_installed" in
	// Arithmos.
	NgtEsxDriversInstalled *int64 `protobuf:"varint,94,opt,name=ngt_esx_drivers_installed,json=ngtEsxDriversInstalled" json:"ngt_esx_drivers_installed,omitempty"`
	// NGT KVM mobility drivers are installed. "ngt.kvm_drivers_installed" in
	// Arithmos.
	NgtKvmDriversInstalled *int64 `protobuf:"varint,95,opt,name=ngt_kvm_drivers_installed,json=ngtKvmDriversInstalled" json:"ngt_kvm_drivers_installed,omitempty"`
	// NGT multipathing enabled for devices.
	// "ngt.multipathing_enabled_for_devices" in Arithmos.
	NgtMultipathingEnabledForDevices *int64 `protobuf:"varint,96,opt,name=ngt_multipathing_enabled_for_devices,json=ngtMultipathingEnabledForDevices" json:"ngt_multipathing_enabled_for_devices,omitempty"`
	// The number of vNUMA nodes.
	NumVnumaNodes *uint64 `protobuf:"varint,97,opt,name=num_vnuma_nodes,json=numVnumaNodes" json:"num_vnuma_nodes,omitempty"`
	// Whether VGA console is enabled.
	VgaConsoleEnabled *int64 `protobuf:"varint,98,opt,name=vga_console_enabled,json=vgaConsoleEnabled" json:"vga_console_enabled,omitempty"`
	// The boot configuration.
	BootDeviceConfig []string `protobuf:"bytes,99,rep,name=boot_device_config,json=bootDeviceConfig" json:"boot_device_config,omitempty"`
	// The boot device order.
	BootDeviceOrder []string `protobuf:"bytes,100,rep,name=boot_device_order,json=bootDeviceOrder" json:"boot_device_order,omitempty"`
	// Serial port configuration of the VM.
	SerialPorts     []string `protobuf:"bytes,101,rep,name=serial_ports,json=serialPorts" json:"serial_ports,omitempty"`
	SerialPortUrls  []string `protobuf:"bytes,102,rep,name=serial_port_urls,json=serialPortUrls" json:"serial_port_urls,omitempty"`
	SerialPortTypes []string `protobuf:"bytes,103,rep,name=serial_port_types,json=serialPortTypes" json:"serial_port_types,omitempty"`
	// Indicates how the power state changes.
	PowerStateMechanism *string `protobuf:"bytes,104,opt,name=power_state_mechanism,json=powerStateMechanism" json:"power_state_mechanism,omitempty"`
	// Indicates whether to execute set script before ngt shutdown/reboot.
	NgtEnableScriptExec *int64 `protobuf:"varint,105,opt,name=ngt_enable_script_exec,json=ngtEnableScriptExec" json:"ngt_enable_script_exec,omitempty"`
	// Indicates whether to abort ngt shutdown/reboot if script fails.
	NgtFailOnScriptFailure *int64 `protobuf:"varint,106,opt,name=ngt_fail_on_script_failure,json=ngtFailOnScriptFailure" json:"ngt_fail_on_script_failure,omitempty"`
	// A list of empty CD-ROM device UUIDs.
	EmptyCdromDeviceUuidList []string `protobuf:"bytes,107,rep,name=empty_cdrom_device_uuid_list,json=emptyCdromDeviceUuidList" json:"empty_cdrom_device_uuid_list,omitempty"`
	// Guest os id of the VM(relevant only for ESX).
	GuestOsId *string `protobuf:"bytes,108,opt,name=guest_os_id,json=guestOsId" json:"guest_os_id,omitempty"`
	// List of volume groups UUIDs on which VM is attached.
	VolumeGroup []string `protobuf:"bytes,109,rep,name=volume_group,json=volumeGroup" json:"volume_group,omitempty"`
	// Information about the NGT network interfaces i.e. "ngt.network_interfaces"
	// in Arithmos.
	NgtNetworkInterfaces []string `protobuf:"bytes,110,rep,name=ngt_network_interfaces,json=ngtNetworkInterfaces" json:"ngt_network_interfaces,omitempty"`
	// Config file path of the VM.
	ConfigNutanixNfsFilePath *string `protobuf:"bytes,111,opt,name=config_nutanix_nfs_file_path,json=configNutanixNfsFilePath" json:"config_nutanix_nfs_file_path,omitempty"`
	// Indicates whether virtual disk UUID reporting is enabled for the VM.
	IsVirtualDiskUuidReportingEnabled *int64 `protobuf:"varint,112,opt,name=is_virtual_disk_uuid_reporting_enabled,json=isVirtualDiskUuidReportingEnabled" json:"is_virtual_disk_uuid_reporting_enabled,omitempty"`
	// Indicate whether the VM has delta disks.
	HasVirtualDiskChains *int64 `protobuf:"varint,113,opt,name=has_virtual_disk_chains,json=hasVirtualDiskChains" json:"has_virtual_disk_chains,omitempty"`
	// Timestamp at which VM is fetched from the hypervisor.
	HypervisorFetchTimestampUsecs *int64 `protobuf:"varint,114,opt,name=hypervisor_fetch_timestamp_usecs,json=hypervisorFetchTimestampUsecs" json:"hypervisor_fetch_timestamp_usecs,omitempty"`
	// Whether flash mode is enabled for this VM. This is a Nutanix specific
	// attribute.
	FlashModeEnabled *bool `protobuf:"varint,115,opt,name=flash_mode_enabled,json=flashModeEnabled" json:"flash_mode_enabled,omitempty"`
	// List of uuids of virtual disks attached to this VM for which flash mode is
	// disabled. This is a Nutanix specific attribute.
	VirtualDiskUuidsDisabledForFlashMode []string `protobuf:"bytes,116,rep,name=virtual_disk_uuids_disabled_for_flash_mode,json=virtualDiskUuidsDisabledForFlashMode" json:"virtual_disk_uuids_disabled_for_flash_mode,omitempty"`
	// Source VM uuid of which this VM is clone of.
	SourceVmUuid *string `protobuf:"bytes,117,opt,name=source_vm_uuid,json=sourceVmUuid" json:"source_vm_uuid,omitempty"`
	// Whether the VM is a Dom0 control domain.
	IsControlDomain *bool `protobuf:"varint,118,opt,name=is_control_domain,json=isControlDomain" json:"is_control_domain,omitempty"`
	// The qos group policy acting on a vm.
	QosPolicy *string `protobuf:"bytes,119,opt,name=qos_policy,json=qosPolicy" json:"qos_policy,omitempty"`
	// Provisioned iops set on a vm.
	ProvisionedIops *int64 `protobuf:"varint,120,opt,name=provisioned_iops,json=provisionedIops" json:"provisioned_iops,omitempty"`
	// Throttled iops set on a vm.
	ThrottledIops *int64 `protobuf:"varint,121,opt,name=throttled_iops,json=throttledIops" json:"throttled_iops,omitempty"`
	// Priority for restarting in case of HA event. Applicable only for AHV.
	HaPriority *int64 `protobuf:"varint,122,opt,name=ha_priority,json=haPriority" json:"ha_priority,omitempty"`
	// Whether this is an agent VM.
	IsAgentVm *int64 `protobuf:"varint,123,opt,name=is_agent_vm,json=isAgentVm" json:"is_agent_vm,omitempty"`
	// The number of threads per core.
	NumThreadsPerCore *int64 `protobuf:"varint,124,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	// List of Virtual NIC UUIDs.
	VirtualNicUuids []string `protobuf:"bytes,125,rep,name=virtual_nic_uuids,json=virtualNicUuids" json:"virtual_nic_uuids,omitempty"`
	// List of Virtual GPU UUIDs.
	VirtualGpuUuids []string `protobuf:"bytes,126,rep,name=virtual_gpu_uuids,json=virtualGpuUuids" json:"virtual_gpu_uuids,omitempty"`
	// Whether to hard pin vcpus to vcpus.
	VcpuHardPin *bool `protobuf:"varint,127,opt,name=vcpu_hard_pin,json=vcpuHardPin" json:"vcpu_hard_pin,omitempty"`
	// Automatic Stop Action for the VM.
	AutoStopAction *string `protobuf:"bytes,128,opt,name=auto_stop_action,json=autoStopAction" json:"auto_stop_action,omitempty"`
	// AHV only: whether to pass through the host's CPU features.
	EnableCpuPassthrough *bool `protobuf:"varint,129,opt,name=enable_cpu_passthrough,json=enableCpuPassthrough" json:"enable_cpu_passthrough,omitempty"`
	// The machine type of this VM.
	MachineType *string `protobuf:"bytes,130,opt,name=machine_type,json=machineType,def=pc" json:"machine_type,omitempty"`
	// Whether to disable Nutanix branding.
	DisableBranding *bool `protobuf:"varint,131,opt,name=disable_branding,json=disableBranding" json:"disable_branding,omitempty"`
	// UEFI or legacy boot.
	UefiBoot *bool `protobuf:"varint,132,opt,name=uefi_boot,json=uefiBoot" json:"uefi_boot,omitempty"`
	// UUID of the NVRAM disk backed by stargate, to support UEFI guests.
	UefiNvramDiskUuid *string `protobuf:"bytes,133,opt,name=uefi_nvram_disk_uuid,json=uefiNvramDiskUuid" json:"uefi_nvram_disk_uuid,omitempty"`
	// Vm-level storage container UUID.
	DefaultContainerUuid *string `protobuf:"bytes,134,opt,name=default_container_uuid,json=defaultContainerUuid" json:"default_container_uuid,omitempty"`
	// Vm-level storage container name.
	DefaultContainerName *string `protobuf:"bytes,135,opt,name=default_container_name,json=defaultContainerName" json:"default_container_name,omitempty"`
	// Last host uuid that VM was removed from.
	// We need to maintain this information for two cases:
	//   a) VM was removed from a host for temporary maintenance_mode/upgrade.
	//   b) VM was moved to a host in HA failover.
	//   c) VM gets shutdown unexpectedly (i.e. qemu crashes)
	// In either case, it is desired to implicilty migrate VM back to previous
	// host, where most of its data is assumed to reside.
	//
	// Note any explicit administrative VM operations before host returns to a
	// schedulable state will nullify this field. Also, this field is only
	// applicable for AHV VMs.
	RemovedFromHostUuid *string `protobuf:"bytes,136,opt,name=removed_from_host_uuid,json=removedFromHostUuid" json:"removed_from_host_uuid,omitempty"`
	// Secure boot.
	SecureBoot *bool `protobuf:"varint,137,opt,name=secure_boot,json=secureBoot" json:"secure_boot,omitempty"`
	// A boolean marker to denote if the VM was created, cloned, or registered by
	// uhura vCenter workflow. Valid only for ESX.
	OriginatedByUhuraVcenter *bool `protobuf:"varint,138,opt,name=originated_by_uhura_vcenter,json=originatedByUhuraVcenter,def=0" json:"originated_by_uhura_vcenter,omitempty"`
	// The list of UUIDs of virtual disks that are possibly flash mode pinned.
	PossibleFlashModePinnedVirtualDiskList []string `protobuf:"bytes,139,rep,name=possible_flash_mode_pinned_virtual_disk_list,json=possibleFlashModePinnedVirtualDiskList" json:"possible_flash_mode_pinned_virtual_disk_list,omitempty"`
	// Expose hardware virtualization support to guest.
	HardwareVirtualization *bool `protobuf:"varint,140,opt,name=hardware_virtualization,json=hardwareVirtualization,def=0" json:"hardware_virtualization,omitempty"`
	// If non-empty, fail all VM tasks except for those tasks whose RPC names are
	// found in this list. If this list is empty, allow all tasks. One use case is
	// to disallow VM changes during cross cluster live migration.
	DisableUpdateWhiteList []string `protobuf:"bytes,141,rep,name=disable_update_white_list,json=disableUpdateWhiteList" json:"disable_update_white_list,omitempty"`
	// If False, it will prevent users from hot plugging and unplugging of
	// PCI based devices from within VMs and from the hypervisor stack. Although
	// this applies equally for all VMs, it is primarily applicable for Windows
	// based VMs. By default, we allow hot-plugging and unplugging of devices.
	// Valid only for AHV.
	AllowHotPlug *bool `protobuf:"varint,142,opt,name=allow_hot_plug,json=allowHotPlug,def=1" json:"allow_hot_plug,omitempty"`
	// If True, the memory that belongs to the VM may reside outside of physical
	// memory. Otherwise, Acropolis will ensure that amount of memory the VM is
	// configured with resides completely in physical memory.
	MemoryOvercommit *bool `protobuf:"varint,143,opt,name=memory_overcommit,json=memoryOvercommit" json:"memory_overcommit,omitempty"`
	// Determines the initial memory allocation for this overcommitted VM. This
	// value should be >= to minimum_memory_bytes if configured.
	PowerOnMemoryBytes *uint64 `protobuf:"varint,144,opt,name=power_on_memory_bytes,json=powerOnMemoryBytes" json:"power_on_memory_bytes,omitempty"`
	// Determines the squeeze limit and also the minimum protection guarantee for
	// this overcommitted VM. This value should be <= power_on_memory_bytes if
	// configured.
	MinimumMemoryBytes   *uint64  `protobuf:"varint,145,opt,name=minimum_memory_bytes,json=minimumMemoryBytes" json:"minimum_memory_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vm) Reset()         { *m = Vm{} }
func (m *Vm) String() string { return proto.CompactTextString(m) }
func (*Vm) ProtoMessage()    {}
func (*Vm) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{46}
}

func (m *Vm) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Vm.Unmarshal(m, b)
}
func (m *Vm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Vm.Marshal(b, m, deterministic)
}
func (m *Vm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vm.Merge(m, src)
}
func (m *Vm) XXX_Size() int {
	return xxx_messageInfo_Vm.Size(m)
}
func (m *Vm) XXX_DiscardUnknown() {
	xxx_messageInfo_Vm.DiscardUnknown(m)
}

var xxx_messageInfo_Vm proto.InternalMessageInfo

const Default_Vm_IsLiveMigratable int64 = -1
const Default_Vm_HardwareClockTimezone string = "UTC"
const Default_Vm_MachineType string = "pc"
const Default_Vm_OriginatedByUhuraVcenter bool = false
const Default_Vm_HardwareVirtualization bool = false
const Default_Vm_AllowHotPlug bool = true

func (m *Vm) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *Vm) GetHypervisorSpecificId() string {
	if m != nil && m.HypervisorSpecificId != nil {
		return *m.HypervisorSpecificId
	}
	return ""
}

func (m *Vm) GetVmName() string {
	if m != nil && m.VmName != nil {
		return *m.VmName
	}
	return ""
}

func (m *Vm) GetGuestOsName() string {
	if m != nil && m.GuestOsName != nil {
		return *m.GuestOsName
	}
	return ""
}

func (m *Vm) GetNumVcpus() int64 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *Vm) GetNumCoresPerSocket() int64 {
	if m != nil && m.NumCoresPerSocket != nil {
		return *m.NumCoresPerSocket
	}
	return 0
}

func (m *Vm) GetCpuReservationHz() int64 {
	if m != nil && m.CpuReservationHz != nil {
		return *m.CpuReservationHz
	}
	return 0
}

func (m *Vm) GetMemorySizeBytes() int64 {
	if m != nil && m.MemorySizeBytes != nil {
		return *m.MemorySizeBytes
	}
	return 0
}

func (m *Vm) GetMemoryReservedBytes() int64 {
	if m != nil && m.MemoryReservedBytes != nil {
		return *m.MemoryReservedBytes
	}
	return 0
}

func (m *Vm) GetPowerState() string {
	if m != nil && m.PowerState != nil {
		return *m.PowerState
	}
	return ""
}

func (m *Vm) GetIsCvm() int64 {
	if m != nil && m.IsCvm != nil {
		return *m.IsCvm
	}
	return 0
}

func (m *Vm) GetIsCbrCapable() int64 {
	if m != nil && m.IsCbrCapable != nil {
		return *m.IsCbrCapable
	}
	return 0
}

func (m *Vm) GetIsAcropolisVm() int64 {
	if m != nil && m.IsAcropolisVm != nil {
		return *m.IsAcropolisVm
	}
	return 0
}

func (m *Vm) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *Vm) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *Vm) GetNodeId() string {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return ""
}

func (m *Vm) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *Vm) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

func (m *Vm) GetNodeIpv4Address() string {
	if m != nil && m.NodeIpv4Address != nil {
		return *m.NodeIpv4Address
	}
	return ""
}

func (m *Vm) GetContainerIds() []string {
	if m != nil {
		return m.ContainerIds
	}
	return nil
}

func (m *Vm) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *Vm) GetTagList() []string {
	if m != nil {
		return m.TagList
	}
	return nil
}

func (m *Vm) GetServiceId() string {
	if m != nil && m.ServiceId != nil {
		return *m.ServiceId
	}
	return ""
}

func (m *Vm) GetNumNetworkAdapters() int64 {
	if m != nil && m.NumNetworkAdapters != nil {
		return *m.NumNetworkAdapters
	}
	return 0
}

func (m *Vm) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *Vm) GetVirtualNicIds() []string {
	if m != nil {
		return m.VirtualNicIds
	}
	return nil
}

func (m *Vm) GetVirtualHardwareVersion() int64 {
	if m != nil && m.VirtualHardwareVersion != nil {
		return *m.VirtualHardwareVersion
	}
	return 0
}

func (m *Vm) GetBiosUuid() string {
	if m != nil && m.BiosUuid != nil {
		return *m.BiosUuid
	}
	return ""
}

func (m *Vm) GetDisplayAddress() string {
	if m != nil && m.DisplayAddress != nil {
		return *m.DisplayAddress
	}
	return ""
}

func (m *Vm) GetProtectionDomain() string {
	if m != nil && m.ProtectionDomain != nil {
		return *m.ProtectionDomain
	}
	return ""
}

func (m *Vm) GetProtectionDomainName() string {
	if m != nil && m.ProtectionDomainName != nil {
		return *m.ProtectionDomainName
	}
	return ""
}

func (m *Vm) GetConsistencyGroup() string {
	if m != nil && m.ConsistencyGroup != nil {
		return *m.ConsistencyGroup
	}
	return ""
}

func (m *Vm) GetConsistencyGroupName() string {
	if m != nil && m.ConsistencyGroupName != nil {
		return *m.ConsistencyGroupName
	}
	return ""
}

func (m *Vm) GetNutanixNfsBasedVirtualDisks() []string {
	if m != nil {
		return m.NutanixNfsBasedVirtualDisks
	}
	return nil
}

func (m *Vm) GetNutanixNfsBasedVirtualDiskUuids() []string {
	if m != nil {
		return m.NutanixNfsBasedVirtualDiskUuids
	}
	return nil
}

func (m *Vm) GetNutanixIscsiBasedVirtualDisks() []string {
	if m != nil {
		return m.NutanixIscsiBasedVirtualDisks
	}
	return nil
}

func (m *Vm) GetNutanixIscsiBasedVirtualDiskUuids() []string {
	if m != nil {
		return m.NutanixIscsiBasedVirtualDiskUuids
	}
	return nil
}

func (m *Vm) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *Vm) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *Vm) GetNgtEnabled() int64 {
	if m != nil && m.NgtEnabled != nil {
		return *m.NgtEnabled
	}
	return 0
}

func (m *Vm) GetNgtIsoMounted() int64 {
	if m != nil && m.NgtIsoMounted != nil {
		return *m.NgtIsoMounted
	}
	return 0
}

func (m *Vm) GetControllerStorageTierCloudConfiguredPinnedBytes() int64 {
	if m != nil && m.ControllerStorageTierCloudConfiguredPinnedBytes != nil {
		return *m.ControllerStorageTierCloudConfiguredPinnedBytes
	}
	return 0
}

func (m *Vm) GetControllerStorageTierDasSataConfiguredPinnedBytes() int64 {
	if m != nil && m.ControllerStorageTierDasSataConfiguredPinnedBytes != nil {
		return *m.ControllerStorageTierDasSataConfiguredPinnedBytes
	}
	return 0
}

func (m *Vm) GetControllerStorageTierSsdConfiguredPinnedBytes() int64 {
	if m != nil && m.ControllerStorageTierSsdConfiguredPinnedBytes != nil {
		return *m.ControllerStorageTierSsdConfiguredPinnedBytes
	}
	return 0
}

func (m *Vm) GetCapacityBytes() int64 {
	if m != nil && m.CapacityBytes != nil {
		return *m.CapacityBytes
	}
	return 0
}

func (m *Vm) GetVmState() string {
	if m != nil && m.VmState != nil {
		return *m.VmState
	}
	return ""
}

func (m *Vm) GetToolsInstallerMounted() bool {
	if m != nil && m.ToolsInstallerMounted != nil {
		return *m.ToolsInstallerMounted
	}
	return false
}

func (m *Vm) GetToolsRunningStatus() string {
	if m != nil && m.ToolsRunningStatus != nil {
		return *m.ToolsRunningStatus
	}
	return ""
}

func (m *Vm) GetVmToVmAffinityUuids() []string {
	if m != nil {
		return m.VmToVmAffinityUuids
	}
	return nil
}

func (m *Vm) GetToolsVersionStatus() string {
	if m != nil && m.ToolsVersionStatus != nil {
		return *m.ToolsVersionStatus
	}
	return ""
}

func (m *Vm) GetVmAnnotation() string {
	if m != nil && m.VmAnnotation != nil {
		return *m.VmAnnotation
	}
	return ""
}

func (m *Vm) GetEmptyCdromDiskAddresses() []string {
	if m != nil {
		return m.EmptyCdromDiskAddresses
	}
	return nil
}

// Deprecated: Do not use.
func (m *Vm) GetBackupPolicy() []byte {
	if m != nil {
		return m.BackupPolicy
	}
	return nil
}

func (m *Vm) GetContainerUuids() []string {
	if m != nil {
		return m.ContainerUuids
	}
	return nil
}

func (m *Vm) GetIsLiveMigratable() int64 {
	if m != nil && m.IsLiveMigratable != nil {
		return *m.IsLiveMigratable
	}
	return Default_Vm_IsLiveMigratable
}

func (m *Vm) GetConfiguredGpuList() []string {
	if m != nil {
		return m.ConfiguredGpuList
	}
	return nil
}

func (m *Vm) GetGpusInUse() int64 {
	if m != nil && m.GpusInUse != nil {
		return *m.GpusInUse
	}
	return 0
}

func (m *Vm) GetProtectionRuleUuid() string {
	if m != nil && m.ProtectionRuleUuid != nil {
		return *m.ProtectionRuleUuid
	}
	return ""
}

func (m *Vm) GetProtectionType() string {
	if m != nil && m.ProtectionType != nil {
		return *m.ProtectionType
	}
	return ""
}

func (m *Vm) GetHardwareClockTimezone() string {
	if m != nil && m.HardwareClockTimezone != nil {
		return *m.HardwareClockTimezone
	}
	return Default_Vm_HardwareClockTimezone
}

func (m *Vm) GetNgtCommunicationActive() int64 {
	if m != nil && m.NgtCommunicationActive != nil {
		return *m.NgtCommunicationActive
	}
	return 0
}

func (m *Vm) GetNgtInstalledVersion() string {
	if m != nil && m.NgtInstalledVersion != nil {
		return *m.NgtInstalledVersion
	}
	return ""
}

func (m *Vm) GetNgtClusterVersion() string {
	if m != nil && m.NgtClusterVersion != nil {
		return *m.NgtClusterVersion
	}
	return ""
}

func (m *Vm) GetNgtVmVssEnabled() int64 {
	if m != nil && m.NgtVmVssEnabled != nil {
		return *m.NgtVmVssEnabled
	}
	return 0
}

func (m *Vm) GetNgtEnabledApplications() []string {
	if m != nil {
		return m.NgtEnabledApplications
	}
	return nil
}

func (m *Vm) GetNgtFlrEnabled() int64 {
	if m != nil && m.NgtFlrEnabled != nil {
		return *m.NgtFlrEnabled
	}
	return 0
}

func (m *Vm) GetNgtGuestOs() string {
	if m != nil && m.NgtGuestOs != nil {
		return *m.NgtGuestOs
	}
	return ""
}

func (m *Vm) GetNgtIscsiIqn() string {
	if m != nil && m.NgtIscsiIqn != nil {
		return *m.NgtIscsiIqn
	}
	return ""
}

func (m *Vm) GetPlatformType() string {
	if m != nil && m.PlatformType != nil {
		return *m.PlatformType
	}
	return ""
}

func (m *Vm) GetManagementServerAccount() string {
	if m != nil && m.ManagementServerAccount != nil {
		return *m.ManagementServerAccount
	}
	return ""
}

func (m *Vm) GetInstanceId() string {
	if m != nil && m.InstanceId != nil {
		return *m.InstanceId
	}
	return ""
}

func (m *Vm) GetImageId() string {
	if m != nil && m.ImageId != nil {
		return *m.ImageId
	}
	return ""
}

func (m *Vm) GetInstanceType() string {
	if m != nil && m.InstanceType != nil {
		return *m.InstanceType
	}
	return ""
}

func (m *Vm) GetPublicDnsName() string {
	if m != nil && m.PublicDnsName != nil {
		return *m.PublicDnsName
	}
	return ""
}

func (m *Vm) GetPublicIpAddress() string {
	if m != nil && m.PublicIpAddress != nil {
		return *m.PublicIpAddress
	}
	return ""
}

func (m *Vm) GetPrivateDnsName() string {
	if m != nil && m.PrivateDnsName != nil {
		return *m.PrivateDnsName
	}
	return ""
}

func (m *Vm) GetPrivateIpAddress() string {
	if m != nil && m.PrivateIpAddress != nil {
		return *m.PrivateIpAddress
	}
	return ""
}

func (m *Vm) GetRegion() string {
	if m != nil && m.Region != nil {
		return *m.Region
	}
	return ""
}

func (m *Vm) GetLaunchTime() string {
	if m != nil && m.LaunchTime != nil {
		return *m.LaunchTime
	}
	return ""
}

func (m *Vm) GetRootDeviceType() string {
	if m != nil && m.RootDeviceType != nil {
		return *m.RootDeviceType
	}
	return ""
}

func (m *Vm) GetInstanceName() string {
	if m != nil && m.InstanceName != nil {
		return *m.InstanceName
	}
	return ""
}

func (m *Vm) GetCreatedBy() string {
	if m != nil && m.CreatedBy != nil {
		return *m.CreatedBy
	}
	return ""
}

func (m *Vm) GetAvailabilityZone() string {
	if m != nil && m.AvailabilityZone != nil {
		return *m.AvailabilityZone
	}
	return ""
}

func (m *Vm) GetGpuType() string {
	if m != nil && m.GpuType != nil {
		return *m.GpuType
	}
	return ""
}

func (m *Vm) GetGuestDriverVersion() string {
	if m != nil && m.GuestDriverVersion != nil {
		return *m.GuestDriverVersion
	}
	return ""
}

func (m *Vm) GetLegacyHostAffinityList() []string {
	if m != nil {
		return m.LegacyHostAffinityList
	}
	return nil
}

func (m *Vm) GetCategoryHostAffinityList() []string {
	if m != nil {
		return m.CategoryHostAffinityList
	}
	return nil
}

func (m *Vm) GetVmSnapshot() []string {
	if m != nil {
		return m.VmSnapshot
	}
	return nil
}

func (m *Vm) GetNgtIsDeleted() int64 {
	if m != nil && m.NgtIsDeleted != nil {
		return *m.NgtIsDeleted
	}
	return 0
}

func (m *Vm) GetProtectionRuleVersion() int64 {
	if m != nil && m.ProtectionRuleVersion != nil {
		return *m.ProtectionRuleVersion
	}
	return 0
}

func (m *Vm) GetVmType() string {
	if m != nil && m.VmType != nil {
		return *m.VmType
	}
	return ""
}

func (m *Vm) GetNgtEsxDriversInstalled() int64 {
	if m != nil && m.NgtEsxDriversInstalled != nil {
		return *m.NgtEsxDriversInstalled
	}
	return 0
}

func (m *Vm) GetNgtKvmDriversInstalled() int64 {
	if m != nil && m.NgtKvmDriversInstalled != nil {
		return *m.NgtKvmDriversInstalled
	}
	return 0
}

func (m *Vm) GetNgtMultipathingEnabledForDevices() int64 {
	if m != nil && m.NgtMultipathingEnabledForDevices != nil {
		return *m.NgtMultipathingEnabledForDevices
	}
	return 0
}

func (m *Vm) GetNumVnumaNodes() uint64 {
	if m != nil && m.NumVnumaNodes != nil {
		return *m.NumVnumaNodes
	}
	return 0
}

func (m *Vm) GetVgaConsoleEnabled() int64 {
	if m != nil && m.VgaConsoleEnabled != nil {
		return *m.VgaConsoleEnabled
	}
	return 0
}

func (m *Vm) GetBootDeviceConfig() []string {
	if m != nil {
		return m.BootDeviceConfig
	}
	return nil
}

func (m *Vm) GetBootDeviceOrder() []string {
	if m != nil {
		return m.BootDeviceOrder
	}
	return nil
}

func (m *Vm) GetSerialPorts() []string {
	if m != nil {
		return m.SerialPorts
	}
	return nil
}

func (m *Vm) GetSerialPortUrls() []string {
	if m != nil {
		return m.SerialPortUrls
	}
	return nil
}

func (m *Vm) GetSerialPortTypes() []string {
	if m != nil {
		return m.SerialPortTypes
	}
	return nil
}

func (m *Vm) GetPowerStateMechanism() string {
	if m != nil && m.PowerStateMechanism != nil {
		return *m.PowerStateMechanism
	}
	return ""
}

func (m *Vm) GetNgtEnableScriptExec() int64 {
	if m != nil && m.NgtEnableScriptExec != nil {
		return *m.NgtEnableScriptExec
	}
	return 0
}

func (m *Vm) GetNgtFailOnScriptFailure() int64 {
	if m != nil && m.NgtFailOnScriptFailure != nil {
		return *m.NgtFailOnScriptFailure
	}
	return 0
}

func (m *Vm) GetEmptyCdromDeviceUuidList() []string {
	if m != nil {
		return m.EmptyCdromDeviceUuidList
	}
	return nil
}

func (m *Vm) GetGuestOsId() string {
	if m != nil && m.GuestOsId != nil {
		return *m.GuestOsId
	}
	return ""
}

func (m *Vm) GetVolumeGroup() []string {
	if m != nil {
		return m.VolumeGroup
	}
	return nil
}

func (m *Vm) GetNgtNetworkInterfaces() []string {
	if m != nil {
		return m.NgtNetworkInterfaces
	}
	return nil
}

func (m *Vm) GetConfigNutanixNfsFilePath() string {
	if m != nil && m.ConfigNutanixNfsFilePath != nil {
		return *m.ConfigNutanixNfsFilePath
	}
	return ""
}

func (m *Vm) GetIsVirtualDiskUuidReportingEnabled() int64 {
	if m != nil && m.IsVirtualDiskUuidReportingEnabled != nil {
		return *m.IsVirtualDiskUuidReportingEnabled
	}
	return 0
}

func (m *Vm) GetHasVirtualDiskChains() int64 {
	if m != nil && m.HasVirtualDiskChains != nil {
		return *m.HasVirtualDiskChains
	}
	return 0
}

func (m *Vm) GetHypervisorFetchTimestampUsecs() int64 {
	if m != nil && m.HypervisorFetchTimestampUsecs != nil {
		return *m.HypervisorFetchTimestampUsecs
	}
	return 0
}

func (m *Vm) GetFlashModeEnabled() bool {
	if m != nil && m.FlashModeEnabled != nil {
		return *m.FlashModeEnabled
	}
	return false
}

func (m *Vm) GetVirtualDiskUuidsDisabledForFlashMode() []string {
	if m != nil {
		return m.VirtualDiskUuidsDisabledForFlashMode
	}
	return nil
}

func (m *Vm) GetSourceVmUuid() string {
	if m != nil && m.SourceVmUuid != nil {
		return *m.SourceVmUuid
	}
	return ""
}

func (m *Vm) GetIsControlDomain() bool {
	if m != nil && m.IsControlDomain != nil {
		return *m.IsControlDomain
	}
	return false
}

func (m *Vm) GetQosPolicy() string {
	if m != nil && m.QosPolicy != nil {
		return *m.QosPolicy
	}
	return ""
}

func (m *Vm) GetProvisionedIops() int64 {
	if m != nil && m.ProvisionedIops != nil {
		return *m.ProvisionedIops
	}
	return 0
}

func (m *Vm) GetThrottledIops() int64 {
	if m != nil && m.ThrottledIops != nil {
		return *m.ThrottledIops
	}
	return 0
}

func (m *Vm) GetHaPriority() int64 {
	if m != nil && m.HaPriority != nil {
		return *m.HaPriority
	}
	return 0
}

func (m *Vm) GetIsAgentVm() int64 {
	if m != nil && m.IsAgentVm != nil {
		return *m.IsAgentVm
	}
	return 0
}

func (m *Vm) GetNumThreadsPerCore() int64 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

func (m *Vm) GetVirtualNicUuids() []string {
	if m != nil {
		return m.VirtualNicUuids
	}
	return nil
}

func (m *Vm) GetVirtualGpuUuids() []string {
	if m != nil {
		return m.VirtualGpuUuids
	}
	return nil
}

func (m *Vm) GetVcpuHardPin() bool {
	if m != nil && m.VcpuHardPin != nil {
		return *m.VcpuHardPin
	}
	return false
}

func (m *Vm) GetAutoStopAction() string {
	if m != nil && m.AutoStopAction != nil {
		return *m.AutoStopAction
	}
	return ""
}

func (m *Vm) GetEnableCpuPassthrough() bool {
	if m != nil && m.EnableCpuPassthrough != nil {
		return *m.EnableCpuPassthrough
	}
	return false
}

func (m *Vm) GetMachineType() string {
	if m != nil && m.MachineType != nil {
		return *m.MachineType
	}
	return Default_Vm_MachineType
}

func (m *Vm) GetDisableBranding() bool {
	if m != nil && m.DisableBranding != nil {
		return *m.DisableBranding
	}
	return false
}

func (m *Vm) GetUefiBoot() bool {
	if m != nil && m.UefiBoot != nil {
		return *m.UefiBoot
	}
	return false
}

func (m *Vm) GetUefiNvramDiskUuid() string {
	if m != nil && m.UefiNvramDiskUuid != nil {
		return *m.UefiNvramDiskUuid
	}
	return ""
}

func (m *Vm) GetDefaultContainerUuid() string {
	if m != nil && m.DefaultContainerUuid != nil {
		return *m.DefaultContainerUuid
	}
	return ""
}

func (m *Vm) GetDefaultContainerName() string {
	if m != nil && m.DefaultContainerName != nil {
		return *m.DefaultContainerName
	}
	return ""
}

func (m *Vm) GetRemovedFromHostUuid() string {
	if m != nil && m.RemovedFromHostUuid != nil {
		return *m.RemovedFromHostUuid
	}
	return ""
}

func (m *Vm) GetSecureBoot() bool {
	if m != nil && m.SecureBoot != nil {
		return *m.SecureBoot
	}
	return false
}

func (m *Vm) GetOriginatedByUhuraVcenter() bool {
	if m != nil && m.OriginatedByUhuraVcenter != nil {
		return *m.OriginatedByUhuraVcenter
	}
	return Default_Vm_OriginatedByUhuraVcenter
}

func (m *Vm) GetPossibleFlashModePinnedVirtualDiskList() []string {
	if m != nil {
		return m.PossibleFlashModePinnedVirtualDiskList
	}
	return nil
}

func (m *Vm) GetHardwareVirtualization() bool {
	if m != nil && m.HardwareVirtualization != nil {
		return *m.HardwareVirtualization
	}
	return Default_Vm_HardwareVirtualization
}

func (m *Vm) GetDisableUpdateWhiteList() []string {
	if m != nil {
		return m.DisableUpdateWhiteList
	}
	return nil
}

func (m *Vm) GetAllowHotPlug() bool {
	if m != nil && m.AllowHotPlug != nil {
		return *m.AllowHotPlug
	}
	return Default_Vm_AllowHotPlug
}

func (m *Vm) GetMemoryOvercommit() bool {
	if m != nil && m.MemoryOvercommit != nil {
		return *m.MemoryOvercommit
	}
	return false
}

func (m *Vm) GetPowerOnMemoryBytes() uint64 {
	if m != nil && m.PowerOnMemoryBytes != nil {
		return *m.PowerOnMemoryBytes
	}
	return 0
}

func (m *Vm) GetMinimumMemoryBytes() uint64 {
	if m != nil && m.MinimumMemoryBytes != nil {
		return *m.MinimumMemoryBytes
	}
	return 0
}

type VirtualDisk struct {
	// The associated VM's hypervisor agnostic UUID.
	Vm *string `protobuf:"bytes,1,opt,name=vm" json:"vm,omitempty"`
	// This is the arithmos id in the virtual disk stats report.
	XArithmosId_ *string `protobuf:"bytes,2,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// The associated VM's hypervisor specific UUID.
	AttachVmId *string `protobuf:"bytes,3,opt,name=attach_vm_id,json=attachVmId" json:"attach_vm_id,omitempty"`
	// Virtual disk capacity in bytes.
	CapacityBytes *int64 `protobuf:"varint,4,opt,name=capacity_bytes,json=capacityBytes" json:"capacity_bytes,omitempty"`
	// The virtual disk address.
	DiskAddress *string `protobuf:"bytes,5,opt,name=disk_address,json=diskAddress" json:"disk_address,omitempty"`
	// Whether this is a CD-ROM drive.
	IsCdrom *int64 `protobuf:"varint,6,opt,name=is_cdrom,json=isCdrom" json:"is_cdrom,omitempty"`
	// The container ID.
	ContainerId *int64 `protobuf:"varint,7,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// The container UUID.
	Container *string `protobuf:"bytes,8,opt,name=container" json:"container,omitempty"`
	// Attach image ID.
	AttachImageId *string `protobuf:"bytes,9,opt,name=attach_image_id,json=attachImageId" json:"attach_image_id,omitempty"`
	// Attach volume group ID.
	AttachVolumeGroupId *string `protobuf:"bytes,10,opt,name=attach_volume_group_id,json=attachVolumeGroupId" json:"attach_volume_group_id,omitempty"`
	// Virtual Disk uuid.
	VdiskUuid []byte `protobuf:"bytes,11,opt,name=vdisk_uuid,json=vdiskUuid" json:"vdisk_uuid,omitempty"`
	// The hypervisor type of the VM.
	HypervisorType *string `protobuf:"bytes,12,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// The path to the VDisk in the Nutanix NFS file system. This is typically
	// the path to the virtual disk descriptor file.
	NutanixNfsFilePath *string `protobuf:"bytes,13,opt,name=nutanix_nfs_file_path,json=nutanixNfsFilePath" json:"nutanix_nfs_file_path,omitempty"`
	// The path to iscsi file path. This is not set on ESX. On KVM,
	// set (/dev/disk/by-path/ip-192.168.5.2:3260-iscsi-iqn.2010-06.com.nutanix:
	//      diagnostics-10-3-200-53-disk3-933ba06f-lun-0)
	NutanixIscsiFilePath *string `protobuf:"bytes,14,opt,name=nutanix_iscsi_file_path,json=nutanixIscsiFilePath" json:"nutanix_iscsi_file_path,omitempty"`
	// File name to use for setting virtual disk pinning params.
	NutanixPinNfsFilePath *string `protobuf:"bytes,15,opt,name=nutanix_pin_nfs_file_path,json=nutanixPinNfsFilePath" json:"nutanix_pin_nfs_file_path,omitempty"`
	// Excludes the virtual disk descriptor files..
	AllVirtualDiskFilePaths []string `protobuf:"bytes,16,rep,name=all_virtual_disk_file_paths,json=allVirtualDiskFilePaths" json:"all_virtual_disk_file_paths,omitempty"`
	// The path to the VDisk in the Nutanix NFS file system. Includes all the
	// extents that make up the virtual disk. For eg: In ESX, the disk attached
	// to a VM is defind by a descriptor file named xx.vmdk. The discriptor file
	// has a list of files that actually stores data for the virtual disk. These
	// files are termed as disk_extent_files and are backed by Nutanix vdisks.
	// The nfs file path of the disk extent files are recorded in the
	// 'disk_extents_nutanix_nfs_file_path'.
	DiskExtentsNutanixNfsFilePath []string `protobuf:"bytes,17,rep,name=disk_extents_nutanix_nfs_file_path,json=diskExtentsNutanixNfsFilePath" json:"disk_extents_nutanix_nfs_file_path,omitempty"`
	// The name of the Nutanix vdisk that backs the virtual disk extent is
	// stored in 'disk_extents_nutanix_vdisk_name'. Includes all the names
	// of all the vdisks that back the virtual disk. There exists a 1-1
	// mapping of 'disk_extents_nutanix_vdisk_name' to
	// 'disk_extents_nutanix_nfs_file_path'.
	DiskExtentsNutanixVdiskName []string `protobuf:"bytes,18,rep,name=disk_extents_nutanix_vdisk_name,json=diskExtentsNutanixVdiskName" json:"disk_extents_nutanix_vdisk_name,omitempty"`
	// The cluster UUID.
	Cluster *string `protobuf:"bytes,19,opt,name=cluster" json:"cluster,omitempty"`
	// The cluster name.
	ClusterName *string `protobuf:"bytes,20,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// Total pinned bytes configured for this vm on cloud tier, i.e.
	// "controller.storage_tier.cloud.configured_pinned_bytes"  in Arithmos.
	ControllerStorageTierCloudConfiguredPinnedBytes *int64 `protobuf:"varint,21,opt,name=controller_storage_tier_cloud_configured_pinned_bytes,json=controllerStorageTierCloudConfiguredPinnedBytes" json:"controller_storage_tier_cloud_configured_pinned_bytes,omitempty"`
	// Total pinned bytes configured for this vm on hdd tier, i.e.
	// "controller.storage_tier.das-sata.configured_pinned_bytes" in Arithmos.
	ControllerStorageTierDasSataConfiguredPinnedBytes *int64 `protobuf:"varint,22,opt,name=controller_storage_tier_das_sata_configured_pinned_bytes,json=controllerStorageTierDasSataConfiguredPinnedBytes" json:"controller_storage_tier_das_sata_configured_pinned_bytes,omitempty"`
	// Total pinned bytes configured for this vm on ssd tier, i.e.
	// "controller.storage_tier.ssd.configured_pinned_bytes" in Arithmos.
	ControllerStorageTierSsdConfiguredPinnedBytes *int64 `protobuf:"varint,23,opt,name=controller_storage_tier_ssd_configured_pinned_bytes,json=controllerStorageTierSsdConfiguredPinnedBytes" json:"controller_storage_tier_ssd_configured_pinned_bytes,omitempty"`
	// Number of pinned vdisks attached to the VM, i.e.
	// "controller.total_pinned_vdisks" in Arithmos.
	ControllerTotalPinnedVdisks *int64 `protobuf:"varint,24,opt,name=controller_total_pinned_vdisks,json=controllerTotalPinnedVdisks" json:"controller_total_pinned_vdisks,omitempty"`
	// Device UUID.
	DeviceUuid *string `protobuf:"bytes,25,opt,name=device_uuid,json=deviceUuid" json:"device_uuid,omitempty"`
	// Whether the disk is shared by VMs.
	IsShared *bool `protobuf:"varint,26,opt,name=is_shared,json=isShared" json:"is_shared,omitempty"`
	// Source image UUID.
	SourceImageUuid *string `protobuf:"bytes,27,opt,name=source_image_uuid,json=sourceImageUuid" json:"source_image_uuid,omitempty"`
	// Timestamp at which virtual disk is fetched from the hypervisor.
	HypervisorFetchTimestampUsecs *int64 `protobuf:"varint,28,opt,name=hypervisor_fetch_timestamp_usecs,json=hypervisorFetchTimestampUsecs" json:"hypervisor_fetch_timestamp_usecs,omitempty"`
	// Associated storage container name.
	ContainerName *string `protobuf:"bytes,30,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	// To support instantly recovering workload on AHV, it is possible to create
	// a virtual disk attached to a virtual machine that's backed partially or
	// fully by a data source outside the underlying AOS cluster. The following
	// read-only property gives the URL address of the data source that's backing
	// the virtual machine disk. Note that this property is dynamic -- once AOS
	// ingests the data and seeds the AOS cluster, this property will be unset.
	DataSourceUrl *string `protobuf:"bytes,31,opt,name=data_source_url,json=dataSourceUrl" json:"data_source_url,omitempty"`
	// Source image name.
	SourceImageName *string `protobuf:"bytes,32,opt,name=source_image_name,json=sourceImageName" json:"source_image_name,omitempty"`
	// Description of the Virtual Disk. Used only when the parent of the virtual
	// disk is a VG.
	Annotation *string `protobuf:"bytes,33,opt,name=annotation" json:"annotation,omitempty"`
	// Whether flash mode is enabled on this virtual disk.
	FlashModeEnabled     *bool    `protobuf:"varint,34,opt,name=flash_mode_enabled,json=flashModeEnabled" json:"flash_mode_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDisk) Reset()         { *m = VirtualDisk{} }
func (m *VirtualDisk) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk) ProtoMessage()    {}
func (*VirtualDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{47}
}

func (m *VirtualDisk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk.Unmarshal(m, b)
}
func (m *VirtualDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk.Marshal(b, m, deterministic)
}
func (m *VirtualDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk.Merge(m, src)
}
func (m *VirtualDisk) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk.Size(m)
}
func (m *VirtualDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk proto.InternalMessageInfo

func (m *VirtualDisk) GetVm() string {
	if m != nil && m.Vm != nil {
		return *m.Vm
	}
	return ""
}

func (m *VirtualDisk) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VirtualDisk) GetAttachVmId() string {
	if m != nil && m.AttachVmId != nil {
		return *m.AttachVmId
	}
	return ""
}

func (m *VirtualDisk) GetCapacityBytes() int64 {
	if m != nil && m.CapacityBytes != nil {
		return *m.CapacityBytes
	}
	return 0
}

func (m *VirtualDisk) GetDiskAddress() string {
	if m != nil && m.DiskAddress != nil {
		return *m.DiskAddress
	}
	return ""
}

func (m *VirtualDisk) GetIsCdrom() int64 {
	if m != nil && m.IsCdrom != nil {
		return *m.IsCdrom
	}
	return 0
}

func (m *VirtualDisk) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VirtualDisk) GetContainer() string {
	if m != nil && m.Container != nil {
		return *m.Container
	}
	return ""
}

func (m *VirtualDisk) GetAttachImageId() string {
	if m != nil && m.AttachImageId != nil {
		return *m.AttachImageId
	}
	return ""
}

func (m *VirtualDisk) GetAttachVolumeGroupId() string {
	if m != nil && m.AttachVolumeGroupId != nil {
		return *m.AttachVolumeGroupId
	}
	return ""
}

func (m *VirtualDisk) GetVdiskUuid() []byte {
	if m != nil {
		return m.VdiskUuid
	}
	return nil
}

func (m *VirtualDisk) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VirtualDisk) GetNutanixNfsFilePath() string {
	if m != nil && m.NutanixNfsFilePath != nil {
		return *m.NutanixNfsFilePath
	}
	return ""
}

func (m *VirtualDisk) GetNutanixIscsiFilePath() string {
	if m != nil && m.NutanixIscsiFilePath != nil {
		return *m.NutanixIscsiFilePath
	}
	return ""
}

func (m *VirtualDisk) GetNutanixPinNfsFilePath() string {
	if m != nil && m.NutanixPinNfsFilePath != nil {
		return *m.NutanixPinNfsFilePath
	}
	return ""
}

func (m *VirtualDisk) GetAllVirtualDiskFilePaths() []string {
	if m != nil {
		return m.AllVirtualDiskFilePaths
	}
	return nil
}

func (m *VirtualDisk) GetDiskExtentsNutanixNfsFilePath() []string {
	if m != nil {
		return m.DiskExtentsNutanixNfsFilePath
	}
	return nil
}

func (m *VirtualDisk) GetDiskExtentsNutanixVdiskName() []string {
	if m != nil {
		return m.DiskExtentsNutanixVdiskName
	}
	return nil
}

func (m *VirtualDisk) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *VirtualDisk) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *VirtualDisk) GetControllerStorageTierCloudConfiguredPinnedBytes() int64 {
	if m != nil && m.ControllerStorageTierCloudConfiguredPinnedBytes != nil {
		return *m.ControllerStorageTierCloudConfiguredPinnedBytes
	}
	return 0
}

func (m *VirtualDisk) GetControllerStorageTierDasSataConfiguredPinnedBytes() int64 {
	if m != nil && m.ControllerStorageTierDasSataConfiguredPinnedBytes != nil {
		return *m.ControllerStorageTierDasSataConfiguredPinnedBytes
	}
	return 0
}

func (m *VirtualDisk) GetControllerStorageTierSsdConfiguredPinnedBytes() int64 {
	if m != nil && m.ControllerStorageTierSsdConfiguredPinnedBytes != nil {
		return *m.ControllerStorageTierSsdConfiguredPinnedBytes
	}
	return 0
}

func (m *VirtualDisk) GetControllerTotalPinnedVdisks() int64 {
	if m != nil && m.ControllerTotalPinnedVdisks != nil {
		return *m.ControllerTotalPinnedVdisks
	}
	return 0
}

func (m *VirtualDisk) GetDeviceUuid() string {
	if m != nil && m.DeviceUuid != nil {
		return *m.DeviceUuid
	}
	return ""
}

func (m *VirtualDisk) GetIsShared() bool {
	if m != nil && m.IsShared != nil {
		return *m.IsShared
	}
	return false
}

func (m *VirtualDisk) GetSourceImageUuid() string {
	if m != nil && m.SourceImageUuid != nil {
		return *m.SourceImageUuid
	}
	return ""
}

func (m *VirtualDisk) GetHypervisorFetchTimestampUsecs() int64 {
	if m != nil && m.HypervisorFetchTimestampUsecs != nil {
		return *m.HypervisorFetchTimestampUsecs
	}
	return 0
}

func (m *VirtualDisk) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *VirtualDisk) GetDataSourceUrl() string {
	if m != nil && m.DataSourceUrl != nil {
		return *m.DataSourceUrl
	}
	return ""
}

func (m *VirtualDisk) GetSourceImageName() string {
	if m != nil && m.SourceImageName != nil {
		return *m.SourceImageName
	}
	return ""
}

func (m *VirtualDisk) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VirtualDisk) GetFlashModeEnabled() bool {
	if m != nil && m.FlashModeEnabled != nil {
		return *m.FlashModeEnabled
	}
	return false
}

type VirtualGpu struct {
	// Type of the GPU resource.
	// kVirtual or kPassthroughCompute or kPassthroughGraphics.
	GpuType *string `protobuf:"bytes,1,opt,name=gpu_type,json=gpuType" json:"gpu_type,omitempty"`
	// This is the arithmos ID as found in virtual GPU stats report.
	XArithmosId_ *string `protobuf:"bytes,2,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Device ID of the GPU resource (Eg: 5106).
	DeviceId *string `protobuf:"bytes,3,opt,name=device_id,json=deviceId" json:"device_id,omitempty"`
	// Vendor of GPU resource (Eg: kNvidia).
	VendorName *string `protobuf:"bytes,4,opt,name=vendor_name,json=vendorName" json:"vendor_name,omitempty"`
	// Vendor Device string (Eg: "GM204GL [Tesla M60]").
	DeviceName *string `protobuf:"bytes,5,opt,name=device_name,json=deviceName" json:"device_name,omitempty"`
	// Unique device information.
	// SBDF string must be in format: "ffff:ff:ff.f".
	Sbdf *string `protobuf:"bytes,6,opt,name=sbdf" json:"sbdf,omitempty"`
	// NUMA node GPU belongs to.
	NumaNode *string `protobuf:"bytes,7,opt,name=numa_node,json=numaNode" json:"numa_node,omitempty"`
	// The hypervisor type of the VM.
	HypervisorType *string `protobuf:"bytes,8,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// Hypervisor specific VM ID.
	VmId *string `protobuf:"bytes,9,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// The VM identifier.
	Vm *string `protobuf:"bytes,10,opt,name=vm" json:"vm,omitempty"`
	// Cluster UUID.
	Cluster *string `protobuf:"bytes,11,opt,name=cluster" json:"cluster,omitempty"`
	// Cluster name.
	ClusterName *string `protobuf:"bytes,12,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// Whether the GPU device is in use or not.
	InUse *int64 `protobuf:"varint,13,opt,name=in_use,json=inUse" json:"in_use,omitempty"`
	// Last determined guest driver version.
	GuestDriverVersion *string `protobuf:"bytes,14,opt,name=guest_driver_version,json=guestDriverVersion" json:"guest_driver_version,omitempty"`
	// Number of supported virtual display heads.
	NumVirtualDisplayHeads *int64 `protobuf:"varint,15,opt,name=num_virtual_display_heads,json=numVirtualDisplayHeads" json:"num_virtual_display_heads,omitempty"`
	// Maximum resolution per display head.
	MaxResolution *string `protobuf:"bytes,16,opt,name=max_resolution,json=maxResolution" json:"max_resolution,omitempty"`
	// Fraction of the physical GPU, if this is a vGPU instance.
	Fraction *int64 `protobuf:"varint,17,opt,name=fraction" json:"fraction,omitempty"`
	// GPU framebuffer size.
	FrameBufferSizeBytes *int64 `protobuf:"varint,18,opt,name=frame_buffer_size_bytes,json=frameBufferSizeBytes" json:"frame_buffer_size_bytes,omitempty"`
	// List of license types associated with this GPU.
	LicenseList []string `protobuf:"bytes,19,rep,name=license_list,json=licenseList" json:"license_list,omitempty"`
	// Unused or UsedForPassthrough or UsedForVirtual.
	GpuMode *string `protobuf:"bytes,20,opt,name=gpu_mode,json=gpuMode" json:"gpu_mode,omitempty"`
	// Whether the GPU can be assigned to a VM (1 if True, else 0).
	Assignable *int64 `protobuf:"varint,21,opt,name=assignable" json:"assignable,omitempty"`
	// Number of allocated vGPUs if this is an instance of pGPU.
	NumVgpusAllocated *int64 `protobuf:"varint,22,opt,name=num_vgpus_allocated,json=numVgpusAllocated" json:"num_vgpus_allocated,omitempty"`
	// Maximum potential vGPUs if this is an instance of pGPU.
	MaxAllocatable *int64 `protobuf:"varint,23,opt,name=max_allocatable,json=maxAllocatable" json:"max_allocatable,omitempty"`
	// Index of GPU if this is an instance of vGPU.
	Index *int64 `protobuf:"varint,24,opt,name=index" json:"index,omitempty"`
	// Timestamp at which virtual gpu is fetched from the hypervisor.
	HypervisorFetchTimestampUsecs *int64 `protobuf:"varint,25,opt,name=hypervisor_fetch_timestamp_usecs,json=hypervisorFetchTimestampUsecs" json:"hypervisor_fetch_timestamp_usecs,omitempty"`
	// The Maximum number of vGPU instances of this kind that can be
	// assigned to a VM on this cluster. For vGPU only.
	MaxInstancesPerVm    *int64   `protobuf:"varint,26,opt,name=max_instances_per_vm,json=maxInstancesPerVm" json:"max_instances_per_vm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualGpu) Reset()         { *m = VirtualGpu{} }
func (m *VirtualGpu) String() string { return proto.CompactTextString(m) }
func (*VirtualGpu) ProtoMessage()    {}
func (*VirtualGpu) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{48}
}

func (m *VirtualGpu) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualGpu.Unmarshal(m, b)
}
func (m *VirtualGpu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualGpu.Marshal(b, m, deterministic)
}
func (m *VirtualGpu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualGpu.Merge(m, src)
}
func (m *VirtualGpu) XXX_Size() int {
	return xxx_messageInfo_VirtualGpu.Size(m)
}
func (m *VirtualGpu) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualGpu.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualGpu proto.InternalMessageInfo

func (m *VirtualGpu) GetGpuType() string {
	if m != nil && m.GpuType != nil {
		return *m.GpuType
	}
	return ""
}

func (m *VirtualGpu) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VirtualGpu) GetDeviceId() string {
	if m != nil && m.DeviceId != nil {
		return *m.DeviceId
	}
	return ""
}

func (m *VirtualGpu) GetVendorName() string {
	if m != nil && m.VendorName != nil {
		return *m.VendorName
	}
	return ""
}

func (m *VirtualGpu) GetDeviceName() string {
	if m != nil && m.DeviceName != nil {
		return *m.DeviceName
	}
	return ""
}

func (m *VirtualGpu) GetSbdf() string {
	if m != nil && m.Sbdf != nil {
		return *m.Sbdf
	}
	return ""
}

func (m *VirtualGpu) GetNumaNode() string {
	if m != nil && m.NumaNode != nil {
		return *m.NumaNode
	}
	return ""
}

func (m *VirtualGpu) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VirtualGpu) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *VirtualGpu) GetVm() string {
	if m != nil && m.Vm != nil {
		return *m.Vm
	}
	return ""
}

func (m *VirtualGpu) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *VirtualGpu) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *VirtualGpu) GetInUse() int64 {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return 0
}

func (m *VirtualGpu) GetGuestDriverVersion() string {
	if m != nil && m.GuestDriverVersion != nil {
		return *m.GuestDriverVersion
	}
	return ""
}

func (m *VirtualGpu) GetNumVirtualDisplayHeads() int64 {
	if m != nil && m.NumVirtualDisplayHeads != nil {
		return *m.NumVirtualDisplayHeads
	}
	return 0
}

func (m *VirtualGpu) GetMaxResolution() string {
	if m != nil && m.MaxResolution != nil {
		return *m.MaxResolution
	}
	return ""
}

func (m *VirtualGpu) GetFraction() int64 {
	if m != nil && m.Fraction != nil {
		return *m.Fraction
	}
	return 0
}

func (m *VirtualGpu) GetFrameBufferSizeBytes() int64 {
	if m != nil && m.FrameBufferSizeBytes != nil {
		return *m.FrameBufferSizeBytes
	}
	return 0
}

func (m *VirtualGpu) GetLicenseList() []string {
	if m != nil {
		return m.LicenseList
	}
	return nil
}

func (m *VirtualGpu) GetGpuMode() string {
	if m != nil && m.GpuMode != nil {
		return *m.GpuMode
	}
	return ""
}

func (m *VirtualGpu) GetAssignable() int64 {
	if m != nil && m.Assignable != nil {
		return *m.Assignable
	}
	return 0
}

func (m *VirtualGpu) GetNumVgpusAllocated() int64 {
	if m != nil && m.NumVgpusAllocated != nil {
		return *m.NumVgpusAllocated
	}
	return 0
}

func (m *VirtualGpu) GetMaxAllocatable() int64 {
	if m != nil && m.MaxAllocatable != nil {
		return *m.MaxAllocatable
	}
	return 0
}

func (m *VirtualGpu) GetIndex() int64 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *VirtualGpu) GetHypervisorFetchTimestampUsecs() int64 {
	if m != nil && m.HypervisorFetchTimestampUsecs != nil {
		return *m.HypervisorFetchTimestampUsecs
	}
	return 0
}

func (m *VirtualGpu) GetMaxInstancesPerVm() int64 {
	if m != nil && m.MaxInstancesPerVm != nil {
		return *m.MaxInstancesPerVm
	}
	return 0
}

type VirtualNic struct {
	// Note that Insight requires to have an attribute "vm" to store the VM UUID.
	Vm *string `protobuf:"bytes,1,opt,name=vm" json:"vm,omitempty"`
	// This is the arithmos ID as found in virtual NIC stats report.
	XArithmosId_ *string `protobuf:"bytes,2,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Hypervisor specific VM ID.
	HypervisorSpecificId *string `protobuf:"bytes,3,opt,name=hypervisor_specific_id,json=hypervisorSpecificId" json:"hypervisor_specific_id,omitempty"`
	// The hypervisor type of the VM.
	HypervisorType *string `protobuf:"bytes,4,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// Adaptor type.
	AdaptorType *string `protobuf:"bytes,5,opt,name=adaptor_type,json=adaptorType" json:"adaptor_type,omitempty"`
	// The MAC address of the NIC.
	MacAddress *string `protobuf:"bytes,6,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// Learned IPv4 addresses of the adapter.
	Ipv4Addresses []string `protobuf:"bytes,7,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// Learned IPv6 addresses of the adapter.
	Ipv6Addresses []string `protobuf:"bytes,8,rep,name=ipv6_addresses,json=ipv6Addresses" json:"ipv6_addresses,omitempty"`
	// Host nic ids that this adapter is attached to.
	// This field is used for capturing network performance metrics and set
	// only when publishing VM level stats to Arithmos.
	HostNicIds []string `protobuf:"bytes,9,rep,name=host_nic_ids,json=hostNicIds" json:"host_nic_ids,omitempty"`
	// Host nic ids that this adapter is attached to.
	// This field is used for capturing network performance metrics and set
	// only when publishing VM level stats to Arithmos.
	HostNicUuids []string `protobuf:"bytes,10,rep,name=host_nic_uuids,json=hostNicUuids" json:"host_nic_uuids,omitempty"`
	// Port name. For ESX, this field denotes the label of the virtual NIC.
	PortName *string `protobuf:"bytes,11,opt,name=port_name,json=portName" json:"port_name,omitempty"`
	// VLAN ID.
	VlanId *int64 `protobuf:"varint,12,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// MTU bytes.
	MtuBytes *int64 `protobuf:"varint,13,opt,name=mtu_bytes,json=mtuBytes" json:"mtu_bytes,omitempty"`
	// The cluster UUID.
	Cluster *string `protobuf:"bytes,14,opt,name=cluster" json:"cluster,omitempty"`
	// The cluster name.
	ClusterName *string `protobuf:"bytes,15,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// UUID of the virtual network this NIC belongs to.
	VirtualNetwork *string `protobuf:"bytes,16,opt,name=virtual_network,json=virtualNetwork" json:"virtual_network,omitempty"`
	// Assigned IPv4 addresses of the adapter.
	AssignedIpv4Addresses []string `protobuf:"bytes,17,rep,name=assigned_ipv4_addresses,json=assignedIpv4Addresses" json:"assigned_ipv4_addresses,omitempty"`
	// Assigned IPv6 addresses of the adapter.
	AssignedIpv6Addresses []string `protobuf:"bytes,18,rep,name=assigned_ipv6_addresses,json=assignedIpv6Addresses" json:"assigned_ipv6_addresses,omitempty"`
	// Type of the NIC.
	NicType *string `protobuf:"bytes,19,opt,name=nic_type,json=nicType" json:"nic_type,omitempty"`
	// Type of the Network Function NIC.
	NetworkFunctionNicType *string `protobuf:"bytes,20,opt,name=network_function_nic_type,json=networkFunctionNicType" json:"network_function_nic_type,omitempty"`
	// Network function chain UUID.
	NetworkFunctionChainUuid *string `protobuf:"bytes,21,opt,name=network_function_chain_uuid,json=networkFunctionChainUuid" json:"network_function_chain_uuid,omitempty"`
	// The index of the NIC in the VM configuration.
	NicIndex *int64 `protobuf:"varint,22,opt,name=nic_index,json=nicIndex" json:"nic_index,omitempty"`
	// The model of the NIC.
	Model *string `protobuf:"bytes,23,opt,name=model" json:"model,omitempty"`
	// Timestamp at which virtual NIC is fetched from the hypervisor.
	HypervisorFetchTimestampUsecs *int64 `protobuf:"varint,24,opt,name=hypervisor_fetch_timestamp_usecs,json=hypervisorFetchTimestampUsecs" json:"hypervisor_fetch_timestamp_usecs,omitempty"`
	// Whether or not the nic is connected. True by default
	Connected *bool `protobuf:"varint,25,opt,name=connected,def=1" json:"connected,omitempty"`
	// VLAN mode.
	VlanMode *string `protobuf:"bytes,26,opt,name=vlan_mode,json=vlanMode" json:"vlan_mode,omitempty"`
	// List of VLANs trunked.
	TrunkedVlanList []string `protobuf:"bytes,27,rep,name=trunked_vlan_list,json=trunkedVlanList" json:"trunked_vlan_list,omitempty"`
	// Valid only for ESX VMs.
	// MAC address type (possible values: "kStatic", "kAssigned", "kMSAssigned").
	MacAddressType *string `protobuf:"bytes,28,opt,name=mac_address_type,json=macAddressType" json:"mac_address_type,omitempty"`
	// Port Id of the NIC. Applicable only for ESX.
	PortId               *int64   `protobuf:"varint,29,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNic) Reset()         { *m = VirtualNic{} }
func (m *VirtualNic) String() string { return proto.CompactTextString(m) }
func (*VirtualNic) ProtoMessage()    {}
func (*VirtualNic) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{49}
}

func (m *VirtualNic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNic.Unmarshal(m, b)
}
func (m *VirtualNic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNic.Marshal(b, m, deterministic)
}
func (m *VirtualNic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNic.Merge(m, src)
}
func (m *VirtualNic) XXX_Size() int {
	return xxx_messageInfo_VirtualNic.Size(m)
}
func (m *VirtualNic) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNic.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNic proto.InternalMessageInfo

const Default_VirtualNic_Connected bool = true

func (m *VirtualNic) GetVm() string {
	if m != nil && m.Vm != nil {
		return *m.Vm
	}
	return ""
}

func (m *VirtualNic) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VirtualNic) GetHypervisorSpecificId() string {
	if m != nil && m.HypervisorSpecificId != nil {
		return *m.HypervisorSpecificId
	}
	return ""
}

func (m *VirtualNic) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VirtualNic) GetAdaptorType() string {
	if m != nil && m.AdaptorType != nil {
		return *m.AdaptorType
	}
	return ""
}

func (m *VirtualNic) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *VirtualNic) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *VirtualNic) GetIpv6Addresses() []string {
	if m != nil {
		return m.Ipv6Addresses
	}
	return nil
}

func (m *VirtualNic) GetHostNicIds() []string {
	if m != nil {
		return m.HostNicIds
	}
	return nil
}

func (m *VirtualNic) GetHostNicUuids() []string {
	if m != nil {
		return m.HostNicUuids
	}
	return nil
}

func (m *VirtualNic) GetPortName() string {
	if m != nil && m.PortName != nil {
		return *m.PortName
	}
	return ""
}

func (m *VirtualNic) GetVlanId() int64 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *VirtualNic) GetMtuBytes() int64 {
	if m != nil && m.MtuBytes != nil {
		return *m.MtuBytes
	}
	return 0
}

func (m *VirtualNic) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *VirtualNic) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *VirtualNic) GetVirtualNetwork() string {
	if m != nil && m.VirtualNetwork != nil {
		return *m.VirtualNetwork
	}
	return ""
}

func (m *VirtualNic) GetAssignedIpv4Addresses() []string {
	if m != nil {
		return m.AssignedIpv4Addresses
	}
	return nil
}

func (m *VirtualNic) GetAssignedIpv6Addresses() []string {
	if m != nil {
		return m.AssignedIpv6Addresses
	}
	return nil
}

func (m *VirtualNic) GetNicType() string {
	if m != nil && m.NicType != nil {
		return *m.NicType
	}
	return ""
}

func (m *VirtualNic) GetNetworkFunctionNicType() string {
	if m != nil && m.NetworkFunctionNicType != nil {
		return *m.NetworkFunctionNicType
	}
	return ""
}

func (m *VirtualNic) GetNetworkFunctionChainUuid() string {
	if m != nil && m.NetworkFunctionChainUuid != nil {
		return *m.NetworkFunctionChainUuid
	}
	return ""
}

func (m *VirtualNic) GetNicIndex() int64 {
	if m != nil && m.NicIndex != nil {
		return *m.NicIndex
	}
	return 0
}

func (m *VirtualNic) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *VirtualNic) GetHypervisorFetchTimestampUsecs() int64 {
	if m != nil && m.HypervisorFetchTimestampUsecs != nil {
		return *m.HypervisorFetchTimestampUsecs
	}
	return 0
}

func (m *VirtualNic) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return Default_VirtualNic_Connected
}

func (m *VirtualNic) GetVlanMode() string {
	if m != nil && m.VlanMode != nil {
		return *m.VlanMode
	}
	return ""
}

func (m *VirtualNic) GetTrunkedVlanList() []string {
	if m != nil {
		return m.TrunkedVlanList
	}
	return nil
}

func (m *VirtualNic) GetMacAddressType() string {
	if m != nil && m.MacAddressType != nil {
		return *m.MacAddressType
	}
	return ""
}

func (m *VirtualNic) GetPortId() int64 {
	if m != nil && m.PortId != nil {
		return *m.PortId
	}
	return 0
}

// Virtual network proto in CPDB.
type VirtualNetwork struct {
	// Gateway. E.g: 10.1.64.1
	Ipv4Gateway *string `protobuf:"bytes,1,opt,name=ipv4_gateway,json=ipv4Gateway" json:"ipv4_gateway,omitempty"`
	// Subnet. E.g: 10.1.64.0/255.255.255.0
	Ipv4Subnet *string `protobuf:"bytes,2,opt,name=ipv4_subnet,json=ipv4Subnet" json:"ipv4_subnet,omitempty"`
	// VLAN ID. 64
	VlanId *string `protobuf:"bytes,3,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// Name of the virtual network.
	Name *string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// Hypervisor type. E.g: "github.com/nutanix-core/acs-aos-go/acropolis".
	HypervisorType *string `protobuf:"bytes,5,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// ID of the virtual network.
	Id *string `protobuf:"bytes,6,opt,name=id" json:"id,omitempty"`
	// Managed type (for esx).
	ManagedType *string `protobuf:"bytes,7,opt,name=managed_type,json=managedType" json:"managed_type,omitempty"`
	// Cluster UUID.
	ClusterUuid *string `protobuf:"bytes,8,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Cluster name.
	ClusterName *string `protobuf:"bytes,9,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// Arithmos ID.
	XArithmosId_ *string `protobuf:"bytes,10,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Virtual switch name.
	VirtualSwitchName *string `protobuf:"bytes,11,opt,name=virtual_switch_name,json=virtualSwitchName" json:"virtual_switch_name,omitempty"`
	// Number of Physical NICs.
	PnicNum *int64 `protobuf:"varint,12,opt,name=pnic_num,json=pnicNum" json:"pnic_num,omitempty"`
	// Distributed Virtual Switch uuid.
	SwitchUuid           *string  `protobuf:"bytes,13,opt,name=switch_uuid,json=switchUuid" json:"switch_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNetwork) Reset()         { *m = VirtualNetwork{} }
func (m *VirtualNetwork) String() string { return proto.CompactTextString(m) }
func (*VirtualNetwork) ProtoMessage()    {}
func (*VirtualNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{50}
}

func (m *VirtualNetwork) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetwork.Unmarshal(m, b)
}
func (m *VirtualNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetwork.Marshal(b, m, deterministic)
}
func (m *VirtualNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetwork.Merge(m, src)
}
func (m *VirtualNetwork) XXX_Size() int {
	return xxx_messageInfo_VirtualNetwork.Size(m)
}
func (m *VirtualNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetwork proto.InternalMessageInfo

func (m *VirtualNetwork) GetIpv4Gateway() string {
	if m != nil && m.Ipv4Gateway != nil {
		return *m.Ipv4Gateway
	}
	return ""
}

func (m *VirtualNetwork) GetIpv4Subnet() string {
	if m != nil && m.Ipv4Subnet != nil {
		return *m.Ipv4Subnet
	}
	return ""
}

func (m *VirtualNetwork) GetVlanId() string {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return ""
}

func (m *VirtualNetwork) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VirtualNetwork) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VirtualNetwork) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *VirtualNetwork) GetManagedType() string {
	if m != nil && m.ManagedType != nil {
		return *m.ManagedType
	}
	return ""
}

func (m *VirtualNetwork) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *VirtualNetwork) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *VirtualNetwork) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VirtualNetwork) GetVirtualSwitchName() string {
	if m != nil && m.VirtualSwitchName != nil {
		return *m.VirtualSwitchName
	}
	return ""
}

func (m *VirtualNetwork) GetPnicNum() int64 {
	if m != nil && m.PnicNum != nil {
		return *m.PnicNum
	}
	return 0
}

func (m *VirtualNetwork) GetSwitchUuid() string {
	if m != nil && m.SwitchUuid != nil {
		return *m.SwitchUuid
	}
	return ""
}

type VmSnapshot struct {
	// This is the arithmos ID as found in virtual GPU stats report.
	XArithmosId_ *string `protobuf:"bytes,1,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Name of the snapshot.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// Description of the snapshot.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// Hypervisor specific identifier of the VM snapshot.
	Key *int64 `protobuf:"varint,4,opt,name=key" json:"key,omitempty"`
	// Hypervisor specific VM ID.
	VmId *string `protobuf:"bytes,5,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// VM identifier.
	Vm *string `protobuf:"bytes,6,opt,name=vm" json:"vm,omitempty"`
	// The time at which the snapshot was taken.
	CreateTimeUsecs *int64 `protobuf:"varint,7,opt,name=create_time_usecs,json=createTimeUsecs" json:"create_time_usecs,omitempty"`
	// The hypervisor type of the VM.
	HypervisorType *string `protobuf:"bytes,8,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// Cluster UUID.
	Cluster *string `protobuf:"bytes,9,opt,name=cluster" json:"cluster,omitempty"`
	// Cluster name.
	ClusterName *string `protobuf:"bytes,10,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
	// Timestamp at which VM snapshot is fetched from the hypervisor.
	HypervisorFetchTimestampUsecs *int64   `protobuf:"varint,11,opt,name=hypervisor_fetch_timestamp_usecs,json=hypervisorFetchTimestampUsecs" json:"hypervisor_fetch_timestamp_usecs,omitempty"`
	XXX_NoUnkeyedLiteral          struct{} `json:"-"`
	XXX_unrecognized              []byte   `json:"-"`
	XXX_sizecache                 int32    `json:"-"`
}

func (m *VmSnapshot) Reset()         { *m = VmSnapshot{} }
func (m *VmSnapshot) String() string { return proto.CompactTextString(m) }
func (*VmSnapshot) ProtoMessage()    {}
func (*VmSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{51}
}

func (m *VmSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSnapshot.Unmarshal(m, b)
}
func (m *VmSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSnapshot.Marshal(b, m, deterministic)
}
func (m *VmSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSnapshot.Merge(m, src)
}
func (m *VmSnapshot) XXX_Size() int {
	return xxx_messageInfo_VmSnapshot.Size(m)
}
func (m *VmSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_VmSnapshot proto.InternalMessageInfo

func (m *VmSnapshot) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VmSnapshot) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VmSnapshot) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VmSnapshot) GetKey() int64 {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return 0
}

func (m *VmSnapshot) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *VmSnapshot) GetVm() string {
	if m != nil && m.Vm != nil {
		return *m.Vm
	}
	return ""
}

func (m *VmSnapshot) GetCreateTimeUsecs() int64 {
	if m != nil && m.CreateTimeUsecs != nil {
		return *m.CreateTimeUsecs
	}
	return 0
}

func (m *VmSnapshot) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *VmSnapshot) GetCluster() string {
	if m != nil && m.Cluster != nil {
		return *m.Cluster
	}
	return ""
}

func (m *VmSnapshot) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return ""
}

func (m *VmSnapshot) GetHypervisorFetchTimestampUsecs() int64 {
	if m != nil && m.HypervisorFetchTimestampUsecs != nil {
		return *m.HypervisorFetchTimestampUsecs
	}
	return 0
}

type Node struct {
	// CPU model.
	CpuModel *string `protobuf:"bytes,1,opt,name=cpu_model,json=cpuModel" json:"cpu_model,omitempty"`
	// Memory size in bytes.
	MemorySizeBytes *int64 `protobuf:"varint,2,opt,name=memory_size_bytes,json=memorySizeBytes" json:"memory_size_bytes,omitempty"`
	// CPU frequency in Hz.
	CpuFrequencyHz *int64 `protobuf:"varint,3,opt,name=cpu_frequency_hz,json=cpuFrequencyHz" json:"cpu_frequency_hz,omitempty"`
	// Number of CPU sockets.
	NumCpuSockets *int64 `protobuf:"varint,4,opt,name=num_cpu_sockets,json=numCpuSockets" json:"num_cpu_sockets,omitempty"`
	// Number of CPU cores present.
	NumCpuCores *int64 `protobuf:"varint,5,opt,name=num_cpu_cores,json=numCpuCores" json:"num_cpu_cores,omitempty"`
	// Number of CPU threads present.
	NumCpuThreads *int64 `protobuf:"varint,6,opt,name=num_cpu_threads,json=numCpuThreads" json:"num_cpu_threads,omitempty"`
	// Hypervisor name.
	HypervisorFullName *string `protobuf:"bytes,7,opt,name=hypervisor_full_name,json=hypervisorFullName" json:"hypervisor_full_name,omitempty"`
	// Host boot time in microseconds.
	BootTimeUsecs *int64 `protobuf:"varint,8,opt,name=boot_time_usecs,json=bootTimeUsecs" json:"boot_time_usecs,omitempty"`
	// Hypervisor type.
	HypervisorType *string `protobuf:"bytes,9,opt,name=hypervisor_type,json=hypervisorType" json:"hypervisor_type,omitempty"`
	// Node name.
	NodeName *string `protobuf:"bytes,10,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	// Number of host bus adapaters present.
	NumHbas *int64 `protobuf:"varint,11,opt,name=num_hbas,json=numHbas" json:"num_hbas,omitempty"`
	// Number of NICs present on the node.
	NumNics *int64 `protobuf:"varint,12,opt,name=num_nics,json=numNics" json:"num_nics,omitempty"`
	// Number of NUMA nodes present.
	NumNumaNodes *int64 `protobuf:"varint,13,opt,name=num_numa_nodes,json=numNumaNodes" json:"num_numa_nodes,omitempty"`
	// Maximum virtual hardware verison supported on the node.
	MaxSupportedVirtualHardwareVersion *int64 `protobuf:"varint,14,opt,name=max_supported_virtual_hardware_version,json=maxSupportedVirtualHardwareVersion" json:"max_supported_virtual_hardware_version,omitempty"`
	// List of IPv4 addresses.
	Ipv4Addresses []string `protobuf:"bytes,15,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// List of kernel NIC IDs present on the node.
	KernelNicIds []string `protobuf:"bytes,16,rep,name=kernel_nic_ids,json=kernelNicIds" json:"kernel_nic_ids,omitempty"`
	// List of host NIC IDs present on the node.
	HostNicIds []string `protobuf:"bytes,17,rep,name=host_nic_ids,json=hostNicIds" json:"host_nic_ids,omitempty"`
	// This is the arithmos id in the Node stats report.
	XArithmosId_ *string `protobuf:"bytes,18,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Number of VMs on the node, required in New Unified Publisher for HyperV.
	NumVms *int64 `protobuf:"varint,19,opt,name=num_vms,json=numVms" json:"num_vms,omitempty"`
	// Reboot Pending information, required in New Unified Publisher for HyperV.
	RebootPending *int64 `protobuf:"varint,20,opt,name=reboot_pending,json=rebootPending" json:"reboot_pending,omitempty"`
	// Host's Version, required in New Unified Publisher for HyperV.
	HostVersion *int64 `protobuf:"varint,21,opt,name=host_version,json=hostVersion" json:"host_version,omitempty"`
	// Status of node in Failover Cluster, required in New Unified Publisher for
	// HyperV.
	FailoverClusterNodeStatus *string `protobuf:"bytes,22,opt,name=failover_cluster_node_status,json=failoverClusterNodeStatus" json:"failover_cluster_node_status,omitempty"`
	// FQDN information, required in New Unified Publisher for HyperV.
	FailoverClusterFqdn *string `protobuf:"bytes,23,opt,name=failover_cluster_fqdn,json=failoverClusterFqdn" json:"failover_cluster_fqdn,omitempty"`
	// Host's VM's default location, required in New Unified Publisher for HyperV.
	DefaultVmLocation *string `protobuf:"bytes,24,opt,name=default_vm_location,json=defaultVmLocation" json:"default_vm_location,omitempty"`
	// Host's VM's VHDs default location, required in New Unified Publisher for
	// HyperV.
	DefaultVhdLocation *string `protobuf:"bytes,25,opt,name=default_vhd_location,json=defaultVhdLocation" json:"default_vhd_location,omitempty"`
	// Host's VM's default container ID, required in New Unified Publisher for
	// HyperV.
	DefaultVmContainerId *string `protobuf:"bytes,26,opt,name=default_vm_container_id,json=defaultVmContainerId" json:"default_vm_container_id,omitempty"`
	// Host's VM's default container UUID, required in New Unified Publisher for
	// HyperV.
	DefaultVmContainerUuid *string `protobuf:"bytes,27,opt,name=default_vm_container_uuid,json=defaultVmContainerUuid" json:"default_vm_container_uuid,omitempty"`
	// Host's VM's VHD default container ID, required in New Unified Publisher for
	// HyperV.
	DefaultVhdContainerId *string `protobuf:"bytes,28,opt,name=default_vhd_container_id,json=defaultVhdContainerId" json:"default_vhd_container_id,omitempty"`
	// Host's VM's VHD default container UUID, required in New Unified Publisher
	//for HyperV.
	DefaultVhdContainerUuid *string  `protobuf:"bytes,29,opt,name=default_vhd_container_uuid,json=defaultVhdContainerUuid" json:"default_vhd_container_uuid,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{52}
}

func (m *Node) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Node.Unmarshal(m, b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Node.Marshal(b, m, deterministic)
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return xxx_messageInfo_Node.Size(m)
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetCpuModel() string {
	if m != nil && m.CpuModel != nil {
		return *m.CpuModel
	}
	return ""
}

func (m *Node) GetMemorySizeBytes() int64 {
	if m != nil && m.MemorySizeBytes != nil {
		return *m.MemorySizeBytes
	}
	return 0
}

func (m *Node) GetCpuFrequencyHz() int64 {
	if m != nil && m.CpuFrequencyHz != nil {
		return *m.CpuFrequencyHz
	}
	return 0
}

func (m *Node) GetNumCpuSockets() int64 {
	if m != nil && m.NumCpuSockets != nil {
		return *m.NumCpuSockets
	}
	return 0
}

func (m *Node) GetNumCpuCores() int64 {
	if m != nil && m.NumCpuCores != nil {
		return *m.NumCpuCores
	}
	return 0
}

func (m *Node) GetNumCpuThreads() int64 {
	if m != nil && m.NumCpuThreads != nil {
		return *m.NumCpuThreads
	}
	return 0
}

func (m *Node) GetHypervisorFullName() string {
	if m != nil && m.HypervisorFullName != nil {
		return *m.HypervisorFullName
	}
	return ""
}

func (m *Node) GetBootTimeUsecs() int64 {
	if m != nil && m.BootTimeUsecs != nil {
		return *m.BootTimeUsecs
	}
	return 0
}

func (m *Node) GetHypervisorType() string {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return ""
}

func (m *Node) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

func (m *Node) GetNumHbas() int64 {
	if m != nil && m.NumHbas != nil {
		return *m.NumHbas
	}
	return 0
}

func (m *Node) GetNumNics() int64 {
	if m != nil && m.NumNics != nil {
		return *m.NumNics
	}
	return 0
}

func (m *Node) GetNumNumaNodes() int64 {
	if m != nil && m.NumNumaNodes != nil {
		return *m.NumNumaNodes
	}
	return 0
}

func (m *Node) GetMaxSupportedVirtualHardwareVersion() int64 {
	if m != nil && m.MaxSupportedVirtualHardwareVersion != nil {
		return *m.MaxSupportedVirtualHardwareVersion
	}
	return 0
}

func (m *Node) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *Node) GetKernelNicIds() []string {
	if m != nil {
		return m.KernelNicIds
	}
	return nil
}

func (m *Node) GetHostNicIds() []string {
	if m != nil {
		return m.HostNicIds
	}
	return nil
}

func (m *Node) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *Node) GetNumVms() int64 {
	if m != nil && m.NumVms != nil {
		return *m.NumVms
	}
	return 0
}

func (m *Node) GetRebootPending() int64 {
	if m != nil && m.RebootPending != nil {
		return *m.RebootPending
	}
	return 0
}

func (m *Node) GetHostVersion() int64 {
	if m != nil && m.HostVersion != nil {
		return *m.HostVersion
	}
	return 0
}

func (m *Node) GetFailoverClusterNodeStatus() string {
	if m != nil && m.FailoverClusterNodeStatus != nil {
		return *m.FailoverClusterNodeStatus
	}
	return ""
}

func (m *Node) GetFailoverClusterFqdn() string {
	if m != nil && m.FailoverClusterFqdn != nil {
		return *m.FailoverClusterFqdn
	}
	return ""
}

func (m *Node) GetDefaultVmLocation() string {
	if m != nil && m.DefaultVmLocation != nil {
		return *m.DefaultVmLocation
	}
	return ""
}

func (m *Node) GetDefaultVhdLocation() string {
	if m != nil && m.DefaultVhdLocation != nil {
		return *m.DefaultVhdLocation
	}
	return ""
}

func (m *Node) GetDefaultVmContainerId() string {
	if m != nil && m.DefaultVmContainerId != nil {
		return *m.DefaultVmContainerId
	}
	return ""
}

func (m *Node) GetDefaultVmContainerUuid() string {
	if m != nil && m.DefaultVmContainerUuid != nil {
		return *m.DefaultVmContainerUuid
	}
	return ""
}

func (m *Node) GetDefaultVhdContainerId() string {
	if m != nil && m.DefaultVhdContainerId != nil {
		return *m.DefaultVhdContainerId
	}
	return ""
}

func (m *Node) GetDefaultVhdContainerUuid() string {
	if m != nil && m.DefaultVhdContainerUuid != nil {
		return *m.DefaultVhdContainerUuid
	}
	return ""
}

type VmkernelNic struct {
	// Host ID stored in zeus.
	HostId *string `protobuf:"bytes,1,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// Port ID.
	PortId *string `protobuf:"bytes,2,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	// Node UUID.
	Node *string `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	// Host NIC ids that this adapter is attached to.
	HostNicIds []string `protobuf:"bytes,4,rep,name=host_nic_ids,json=hostNicIds" json:"host_nic_ids,omitempty"`
	// Host NIC UUIDs that this adapter is attached to.
	HostNicUuids []string `protobuf:"bytes,5,rep,name=host_nic_uuids,json=hostNicUuids" json:"host_nic_uuids,omitempty"`
	// The MAC address of the NIC.
	MacAddress *string `protobuf:"bytes,6,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// MTU bytes.
	MtuBytes *int64 `protobuf:"varint,7,opt,name=mtu_bytes,json=mtuBytes" json:"mtu_bytes,omitempty"`
	// IPV4 Address list.
	Ipv4Addresses []string `protobuf:"bytes,8,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// IPV6 Address list.
	Ipv6Addresses []string `protobuf:"bytes,9,rep,name=ipv6_addresses,json=ipv6Addresses" json:"ipv6_addresses,omitempty"`
	// Arithmos ID.
	XArithmosId_ *string `protobuf:"bytes,10,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Description.
	Description *string `protobuf:"bytes,11,opt,name=description" json:"description,omitempty"`
	// Status.
	Status *string `protobuf:"bytes,12,opt,name=status" json:"status,omitempty"`
	// DHCP enabled information.
	DhcpEnabled *int64 `protobuf:"varint,13,opt,name=dhcp_enabled,json=dhcpEnabled" json:"dhcp_enabled,omitempty"`
	// Speed of the link.
	LinkSpeedKbps        *int64   `protobuf:"varint,14,opt,name=link_speed_kbps,json=linkSpeedKbps" json:"link_speed_kbps,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmkernelNic) Reset()         { *m = VmkernelNic{} }
func (m *VmkernelNic) String() string { return proto.CompactTextString(m) }
func (*VmkernelNic) ProtoMessage()    {}
func (*VmkernelNic) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{53}
}

func (m *VmkernelNic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmkernelNic.Unmarshal(m, b)
}
func (m *VmkernelNic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmkernelNic.Marshal(b, m, deterministic)
}
func (m *VmkernelNic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmkernelNic.Merge(m, src)
}
func (m *VmkernelNic) XXX_Size() int {
	return xxx_messageInfo_VmkernelNic.Size(m)
}
func (m *VmkernelNic) XXX_DiscardUnknown() {
	xxx_messageInfo_VmkernelNic.DiscardUnknown(m)
}

var xxx_messageInfo_VmkernelNic proto.InternalMessageInfo

func (m *VmkernelNic) GetHostId() string {
	if m != nil && m.HostId != nil {
		return *m.HostId
	}
	return ""
}

func (m *VmkernelNic) GetPortId() string {
	if m != nil && m.PortId != nil {
		return *m.PortId
	}
	return ""
}

func (m *VmkernelNic) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *VmkernelNic) GetHostNicIds() []string {
	if m != nil {
		return m.HostNicIds
	}
	return nil
}

func (m *VmkernelNic) GetHostNicUuids() []string {
	if m != nil {
		return m.HostNicUuids
	}
	return nil
}

func (m *VmkernelNic) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *VmkernelNic) GetMtuBytes() int64 {
	if m != nil && m.MtuBytes != nil {
		return *m.MtuBytes
	}
	return 0
}

func (m *VmkernelNic) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *VmkernelNic) GetIpv6Addresses() []string {
	if m != nil {
		return m.Ipv6Addresses
	}
	return nil
}

func (m *VmkernelNic) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *VmkernelNic) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *VmkernelNic) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *VmkernelNic) GetDhcpEnabled() int64 {
	if m != nil && m.DhcpEnabled != nil {
		return *m.DhcpEnabled
	}
	return 0
}

func (m *VmkernelNic) GetLinkSpeedKbps() int64 {
	if m != nil && m.LinkSpeedKbps != nil {
		return *m.LinkSpeedKbps
	}
	return 0
}

type HostNic struct {
	// Port name (eth0, eth1..).
	PortName *string `protobuf:"bytes,1,opt,name=port_name,json=portName" json:"port_name,omitempty"`
	// Host ID stored in zeus.
	HostId *string `protobuf:"bytes,2,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// Node UUID.
	Node *string `protobuf:"bytes,3,opt,name=node" json:"node,omitempty"`
	// MAC address.
	MacAddress *string `protobuf:"bytes,4,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// IPV4 Address list.
	Ipv4Addresses []string `protobuf:"bytes,5,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// IPV6 Address list.
	Ipv6Addresses []string `protobuf:"bytes,6,rep,name=ipv6_addresses,json=ipv6Addresses" json:"ipv6_addresses,omitempty"`
	// Speed of the link.
	LinkSpeedKbps *int64 `protobuf:"varint,7,opt,name=link_speed_kbps,json=linkSpeedKbps" json:"link_speed_kbps,omitempty"`
	// Discovery protocol used for switch.
	DiscoveryProtocol *string `protobuf:"bytes,8,opt,name=discovery_protocol,json=discoveryProtocol" json:"discovery_protocol,omitempty"`
	// Switch device ID. (E.g.: R2-AGS)
	SwitchDevId *string `protobuf:"bytes,9,opt,name=switch_dev_id,json=switchDevId" json:"switch_dev_id,omitempty"`
	// Switch port ID.
	SwitchPortId *string `protobuf:"bytes,10,opt,name=switch_port_id,json=switchPortId" json:"switch_port_id,omitempty"`
	// Switch platform name.
	SwitchHardwarePlatform *string `protobuf:"bytes,11,opt,name=switch_hardware_platform,json=switchHardwarePlatform" json:"switch_hardware_platform,omitempty"`
	// Management IP Address.
	SwitchMgmtIpAddress *string `protobuf:"bytes,12,opt,name=switch_mgmt_ip_address,json=switchMgmtIpAddress" json:"switch_mgmt_ip_address,omitempty"`
	// Switch VLAN ID.
	SwitchVlanId *int64 `protobuf:"varint,13,opt,name=switch_vlan_id,json=switchVlanId" json:"switch_vlan_id,omitempty"`
	// Arithmos ID.
	XArithmosId_ *string `protobuf:"bytes,14,opt,name=_arithmos_id_,json=ArithmosId" json:"_arithmos_id_,omitempty"`
	// Description.
	Description *string `protobuf:"bytes,15,opt,name=description" json:"description,omitempty"`
	// Status.
	Status *string `protobuf:"bytes,16,opt,name=status" json:"status,omitempty"`
	// DHCP enabled information.
	DhcpEnabled          *int64   `protobuf:"varint,17,opt,name=dhcp_enabled,json=dhcpEnabled" json:"dhcp_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostNic) Reset()         { *m = HostNic{} }
func (m *HostNic) String() string { return proto.CompactTextString(m) }
func (*HostNic) ProtoMessage()    {}
func (*HostNic) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{54}
}

func (m *HostNic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostNic.Unmarshal(m, b)
}
func (m *HostNic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostNic.Marshal(b, m, deterministic)
}
func (m *HostNic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostNic.Merge(m, src)
}
func (m *HostNic) XXX_Size() int {
	return xxx_messageInfo_HostNic.Size(m)
}
func (m *HostNic) XXX_DiscardUnknown() {
	xxx_messageInfo_HostNic.DiscardUnknown(m)
}

var xxx_messageInfo_HostNic proto.InternalMessageInfo

func (m *HostNic) GetPortName() string {
	if m != nil && m.PortName != nil {
		return *m.PortName
	}
	return ""
}

func (m *HostNic) GetHostId() string {
	if m != nil && m.HostId != nil {
		return *m.HostId
	}
	return ""
}

func (m *HostNic) GetNode() string {
	if m != nil && m.Node != nil {
		return *m.Node
	}
	return ""
}

func (m *HostNic) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *HostNic) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *HostNic) GetIpv6Addresses() []string {
	if m != nil {
		return m.Ipv6Addresses
	}
	return nil
}

func (m *HostNic) GetLinkSpeedKbps() int64 {
	if m != nil && m.LinkSpeedKbps != nil {
		return *m.LinkSpeedKbps
	}
	return 0
}

func (m *HostNic) GetDiscoveryProtocol() string {
	if m != nil && m.DiscoveryProtocol != nil {
		return *m.DiscoveryProtocol
	}
	return ""
}

func (m *HostNic) GetSwitchDevId() string {
	if m != nil && m.SwitchDevId != nil {
		return *m.SwitchDevId
	}
	return ""
}

func (m *HostNic) GetSwitchPortId() string {
	if m != nil && m.SwitchPortId != nil {
		return *m.SwitchPortId
	}
	return ""
}

func (m *HostNic) GetSwitchHardwarePlatform() string {
	if m != nil && m.SwitchHardwarePlatform != nil {
		return *m.SwitchHardwarePlatform
	}
	return ""
}

func (m *HostNic) GetSwitchMgmtIpAddress() string {
	if m != nil && m.SwitchMgmtIpAddress != nil {
		return *m.SwitchMgmtIpAddress
	}
	return ""
}

func (m *HostNic) GetSwitchVlanId() int64 {
	if m != nil && m.SwitchVlanId != nil {
		return *m.SwitchVlanId
	}
	return 0
}

func (m *HostNic) GetXArithmosId_() string {
	if m != nil && m.XArithmosId_ != nil {
		return *m.XArithmosId_
	}
	return ""
}

func (m *HostNic) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *HostNic) GetStatus() string {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return ""
}

func (m *HostNic) GetDhcpEnabled() int64 {
	if m != nil && m.DhcpEnabled != nil {
		return *m.DhcpEnabled
	}
	return 0
}

//UUID Mapping proto in CPDB.
type UuidMapping struct {
	// Platform agnostic uuid.
	PlatformAgnosticUuid *string `protobuf:"bytes,1,opt,name=platform_agnostic_uuid,json=platformAgnosticUuid" json:"platform_agnostic_uuid,omitempty"`
	// Type of entity. e.g. vm, virtual_disk, virtual_network
	MappingType          *string  `protobuf:"bytes,2,opt,name=mapping_type,json=mappingType" json:"mapping_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UuidMapping) Reset()         { *m = UuidMapping{} }
func (m *UuidMapping) String() string { return proto.CompactTextString(m) }
func (*UuidMapping) ProtoMessage()    {}
func (*UuidMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{55}
}

func (m *UuidMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UuidMapping.Unmarshal(m, b)
}
func (m *UuidMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UuidMapping.Marshal(b, m, deterministic)
}
func (m *UuidMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UuidMapping.Merge(m, src)
}
func (m *UuidMapping) XXX_Size() int {
	return xxx_messageInfo_UuidMapping.Size(m)
}
func (m *UuidMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_UuidMapping.DiscardUnknown(m)
}

var xxx_messageInfo_UuidMapping proto.InternalMessageInfo

func (m *UuidMapping) GetPlatformAgnosticUuid() string {
	if m != nil && m.PlatformAgnosticUuid != nil {
		return *m.PlatformAgnosticUuid
	}
	return ""
}

func (m *UuidMapping) GetMappingType() string {
	if m != nil && m.MappingType != nil {
		return *m.MappingType
	}
	return ""
}

// Message which contains the information about affinity rules.
// This mapping is stored in EntityDB.
type AffinityInfo struct {
	// Hypervisor agnostic UUID.
	// Example: "d09430f6-e957-4aa5-8e50-c26d9a2163c5"
	AffinityUuid *string `protobuf:"bytes,1,opt,name=affinity_uuid,json=affinityUuid" json:"affinity_uuid,omitempty"`
	// Hypervisor specific key/id for affinity rule.
	// This is generated by VCenter in case of ESX cluster.
	Key                  *string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AffinityInfo) Reset()         { *m = AffinityInfo{} }
func (m *AffinityInfo) String() string { return proto.CompactTextString(m) }
func (*AffinityInfo) ProtoMessage()    {}
func (*AffinityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{56}
}

func (m *AffinityInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AffinityInfo.Unmarshal(m, b)
}
func (m *AffinityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AffinityInfo.Marshal(b, m, deterministic)
}
func (m *AffinityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AffinityInfo.Merge(m, src)
}
func (m *AffinityInfo) XXX_Size() int {
	return xxx_messageInfo_AffinityInfo.Size(m)
}
func (m *AffinityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AffinityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AffinityInfo proto.InternalMessageInfo

func (m *AffinityInfo) GetAffinityUuid() string {
	if m != nil && m.AffinityUuid != nil {
		return *m.AffinityUuid
	}
	return ""
}

func (m *AffinityInfo) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

type VMMetric struct {
	// Average CPU usage expressed in parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	HypervisorCpuUsagePpm *int64 `protobuf:"varint,1,opt,name=hypervisor_cpu_usage_ppm,json=hypervisorCpuUsagePpm" json:"hypervisor_cpu_usage_ppm,omitempty"`
	// Memory usage percentage expressed parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	// Does not apply to Hyper-V.
	HypervisorMemoryUsagePpm *int64 `protobuf:"varint,2,opt,name=hypervisor_memory_usage_ppm,json=hypervisorMemoryUsagePpm" json:"hypervisor_memory_usage_ppm,omitempty"`
	// Number of bytes received by the VM from the network during the
	// interval.
	HypervisorNumReceivedBytes *int64 `protobuf:"varint,3,opt,name=hypervisor_num_received_bytes,json=hypervisorNumReceivedBytes" json:"hypervisor_num_received_bytes,omitempty"`
	// Number of bytes transmitted by the VM during the interval.
	HypervisorNumTransmittedBytes *int64 `protobuf:"varint,4,opt,name=hypervisor_num_transmitted_bytes,json=hypervisorNumTransmittedBytes" json:"hypervisor_num_transmitted_bytes,omitempty"`
	// The time span over which the VM stats reported by the hypervisor are
	// recorded.
	HypervisorVmTimespanUsecs *int64 `protobuf:"varint,5,opt,name=hypervisor_vm_timespan_usecs,json=hypervisorVmTimespanUsecs" json:"hypervisor_vm_timespan_usecs,omitempty"`
	// Memory Assigned is relevant only for VMs with dynamic memory. Applicable
	// only for Hyper-V.
	HypervisorMemoryAssignedBytes *int64 `protobuf:"varint,6,opt,name=hypervisor_memory_assigned_bytes,json=hypervisorMemoryAssignedBytes" json:"hypervisor_memory_assigned_bytes,omitempty"`
	// CPU ready time expressed parts per million.
	HypervisorCpuReadyTimePpm *int64 `protobuf:"varint,7,opt,name=hypervisor_cpu_ready_time_ppm,json=hypervisorCpuReadyTimePpm" json:"hypervisor_cpu_ready_time_ppm,omitempty"`
	// Memory balloon reclaim target in bytes.
	HypervisorMemoryBalloonReclaimTargetBytes *int64 `protobuf:"varint,8,opt,name=hypervisor_memory_balloon_reclaim_target_bytes,json=hypervisorMemoryBalloonReclaimTargetBytes" json:"hypervisor_memory_balloon_reclaim_target_bytes,omitempty"`
	// Avg amount of memory allocated by the VM memory control driver.
	HypervisorMemoryBalloonReclaimedBytes *int64 `protobuf:"varint,9,opt,name=hypervisor_memory_balloon_reclaimed_bytes,json=hypervisorMemoryBalloonReclaimedBytes" json:"hypervisor_memory_balloon_reclaimed_bytes,omitempty"`
	// The average rate memory is swapped from disk into active memory, in KBps.
	HypervisorSwapInRateKBps *int64 `protobuf:"varint,10,opt,name=hypervisor_swap_in_rate_kBps,json=hypervisorSwapInRateKBps" json:"hypervisor_swap_in_rate_kBps,omitempty"`
	// The average rate of memory swapped-out to disk, in KBps.
	HypervisorSwapOutRateKBps *int64 `protobuf:"varint,11,opt,name=hypervisor_swap_out_rate_kBps,json=hypervisorSwapOutRateKBps" json:"hypervisor_swap_out_rate_kBps,omitempty"`
	// The average rate of memory swapped-out to disk, in KBps.
	HypervisorNumReceivePacketsDropped *int64 `protobuf:"varint,12,opt,name=hypervisor_num_receive_packets_dropped,json=hypervisorNumReceivePacketsDropped" json:"hypervisor_num_receive_packets_dropped,omitempty"`
	// The number of transmit packets dropped.
	HypervisorNumTransmitPacketsDropped *int64 `protobuf:"varint,13,opt,name=hypervisor_num_transmit_packets_dropped,json=hypervisorNumTransmitPacketsDropped" json:"hypervisor_num_transmit_packets_dropped,omitempty"`
	// Memory usage percentage expressed parts per million.
	MemoryUsagePpm *int64 `protobuf:"varint,14,opt,name=memory_usage_ppm,json=memoryUsagePpm" json:"memory_usage_ppm,omitempty"`
	// CPU ready time per vCPU expressed parts per million.
	CpuReadyTimePpm *int64 `protobuf:"varint,15,opt,name=cpu_ready_time_ppm,json=cpuReadyTimePpm" json:"cpu_ready_time_ppm,omitempty"`
	// Total CPU usage time since VM boot.
	HypervisorTotalCpuUsageTimeSinceBootUsecs *int64   `protobuf:"varint,16,opt,name=hypervisor_total_cpu_usage_time_since_boot_usecs,json=hypervisorTotalCpuUsageTimeSinceBootUsecs" json:"hypervisor_total_cpu_usage_time_since_boot_usecs,omitempty"`
	XXX_NoUnkeyedLiteral                      struct{} `json:"-"`
	XXX_unrecognized                          []byte   `json:"-"`
	XXX_sizecache                             int32    `json:"-"`
}

func (m *VMMetric) Reset()         { *m = VMMetric{} }
func (m *VMMetric) String() string { return proto.CompactTextString(m) }
func (*VMMetric) ProtoMessage()    {}
func (*VMMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{57}
}

func (m *VMMetric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VMMetric.Unmarshal(m, b)
}
func (m *VMMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VMMetric.Marshal(b, m, deterministic)
}
func (m *VMMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMMetric.Merge(m, src)
}
func (m *VMMetric) XXX_Size() int {
	return xxx_messageInfo_VMMetric.Size(m)
}
func (m *VMMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_VMMetric.DiscardUnknown(m)
}

var xxx_messageInfo_VMMetric proto.InternalMessageInfo

func (m *VMMetric) GetHypervisorCpuUsagePpm() int64 {
	if m != nil && m.HypervisorCpuUsagePpm != nil {
		return *m.HypervisorCpuUsagePpm
	}
	return 0
}

func (m *VMMetric) GetHypervisorMemoryUsagePpm() int64 {
	if m != nil && m.HypervisorMemoryUsagePpm != nil {
		return *m.HypervisorMemoryUsagePpm
	}
	return 0
}

func (m *VMMetric) GetHypervisorNumReceivedBytes() int64 {
	if m != nil && m.HypervisorNumReceivedBytes != nil {
		return *m.HypervisorNumReceivedBytes
	}
	return 0
}

func (m *VMMetric) GetHypervisorNumTransmittedBytes() int64 {
	if m != nil && m.HypervisorNumTransmittedBytes != nil {
		return *m.HypervisorNumTransmittedBytes
	}
	return 0
}

func (m *VMMetric) GetHypervisorVmTimespanUsecs() int64 {
	if m != nil && m.HypervisorVmTimespanUsecs != nil {
		return *m.HypervisorVmTimespanUsecs
	}
	return 0
}

func (m *VMMetric) GetHypervisorMemoryAssignedBytes() int64 {
	if m != nil && m.HypervisorMemoryAssignedBytes != nil {
		return *m.HypervisorMemoryAssignedBytes
	}
	return 0
}

func (m *VMMetric) GetHypervisorCpuReadyTimePpm() int64 {
	if m != nil && m.HypervisorCpuReadyTimePpm != nil {
		return *m.HypervisorCpuReadyTimePpm
	}
	return 0
}

func (m *VMMetric) GetHypervisorMemoryBalloonReclaimTargetBytes() int64 {
	if m != nil && m.HypervisorMemoryBalloonReclaimTargetBytes != nil {
		return *m.HypervisorMemoryBalloonReclaimTargetBytes
	}
	return 0
}

func (m *VMMetric) GetHypervisorMemoryBalloonReclaimedBytes() int64 {
	if m != nil && m.HypervisorMemoryBalloonReclaimedBytes != nil {
		return *m.HypervisorMemoryBalloonReclaimedBytes
	}
	return 0
}

func (m *VMMetric) GetHypervisorSwapInRateKBps() int64 {
	if m != nil && m.HypervisorSwapInRateKBps != nil {
		return *m.HypervisorSwapInRateKBps
	}
	return 0
}

func (m *VMMetric) GetHypervisorSwapOutRateKBps() int64 {
	if m != nil && m.HypervisorSwapOutRateKBps != nil {
		return *m.HypervisorSwapOutRateKBps
	}
	return 0
}

func (m *VMMetric) GetHypervisorNumReceivePacketsDropped() int64 {
	if m != nil && m.HypervisorNumReceivePacketsDropped != nil {
		return *m.HypervisorNumReceivePacketsDropped
	}
	return 0
}

func (m *VMMetric) GetHypervisorNumTransmitPacketsDropped() int64 {
	if m != nil && m.HypervisorNumTransmitPacketsDropped != nil {
		return *m.HypervisorNumTransmitPacketsDropped
	}
	return 0
}

func (m *VMMetric) GetMemoryUsagePpm() int64 {
	if m != nil && m.MemoryUsagePpm != nil {
		return *m.MemoryUsagePpm
	}
	return 0
}

func (m *VMMetric) GetCpuReadyTimePpm() int64 {
	if m != nil && m.CpuReadyTimePpm != nil {
		return *m.CpuReadyTimePpm
	}
	return 0
}

func (m *VMMetric) GetHypervisorTotalCpuUsageTimeSinceBootUsecs() int64 {
	if m != nil && m.HypervisorTotalCpuUsageTimeSinceBootUsecs != nil {
		return *m.HypervisorTotalCpuUsageTimeSinceBootUsecs
	}
	return 0
}

type VDiskMetric struct {
	// The time span over which the stats reported by the hypervisor are recorded.
	HypervisorTimespanUsecs *int64 `protobuf:"varint,1,opt,name=hypervisor_timespan_usecs,json=hypervisorTimespanUsecs" json:"hypervisor_timespan_usecs,omitempty"`
	// Number of reads as reported by the hypervisor.
	HypervisorNumReadIo *int64 `protobuf:"varint,2,opt,name=hypervisor_num_read_io,json=hypervisorNumReadIo" json:"hypervisor_num_read_io,omitempty"`
	// Total number of reads and writes as reported by the hypervisor.
	HypervisorNumIo *int64 `protobuf:"varint,3,opt,name=hypervisor_num_io,json=hypervisorNumIo" json:"hypervisor_num_io,omitempty"`
	// Total read IO size on a virtual disk as reported by the hypervisor.
	HypervisorTotalReadIoSizeKbytes *int64 `protobuf:"varint,4,opt,name=hypervisor_total_read_io_size_kbytes,json=hypervisorTotalReadIoSizeKbytes" json:"hypervisor_total_read_io_size_kbytes,omitempty"`
	// Total IO size (reads and writes) as reported by the hypervisor.
	HypervisorTotalIoSizeKbytes *int64 `protobuf:"varint,5,opt,name=hypervisor_total_io_size_kbytes,json=hypervisorTotalIoSizeKbytes" json:"hypervisor_total_io_size_kbytes,omitempty"`
	// Total read IO time as reported by the hypervisor.
	HypervisorTotalReadIoTimeUsecs *int64 `protobuf:"varint,6,opt,name=hypervisor_total_read_io_time_usecs,json=hypervisorTotalReadIoTimeUsecs" json:"hypervisor_total_read_io_time_usecs,omitempty"`
	// Total IO time (for the reads and writes) as reported by the hypervisor.
	HypervisorTotalIoTimeUsecs *int64   `protobuf:"varint,7,opt,name=hypervisor_total_io_time_usecs,json=hypervisorTotalIoTimeUsecs" json:"hypervisor_total_io_time_usecs,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *VDiskMetric) Reset()         { *m = VDiskMetric{} }
func (m *VDiskMetric) String() string { return proto.CompactTextString(m) }
func (*VDiskMetric) ProtoMessage()    {}
func (*VDiskMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{58}
}

func (m *VDiskMetric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskMetric.Unmarshal(m, b)
}
func (m *VDiskMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskMetric.Marshal(b, m, deterministic)
}
func (m *VDiskMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskMetric.Merge(m, src)
}
func (m *VDiskMetric) XXX_Size() int {
	return xxx_messageInfo_VDiskMetric.Size(m)
}
func (m *VDiskMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskMetric.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskMetric proto.InternalMessageInfo

func (m *VDiskMetric) GetHypervisorTimespanUsecs() int64 {
	if m != nil && m.HypervisorTimespanUsecs != nil {
		return *m.HypervisorTimespanUsecs
	}
	return 0
}

func (m *VDiskMetric) GetHypervisorNumReadIo() int64 {
	if m != nil && m.HypervisorNumReadIo != nil {
		return *m.HypervisorNumReadIo
	}
	return 0
}

func (m *VDiskMetric) GetHypervisorNumIo() int64 {
	if m != nil && m.HypervisorNumIo != nil {
		return *m.HypervisorNumIo
	}
	return 0
}

func (m *VDiskMetric) GetHypervisorTotalReadIoSizeKbytes() int64 {
	if m != nil && m.HypervisorTotalReadIoSizeKbytes != nil {
		return *m.HypervisorTotalReadIoSizeKbytes
	}
	return 0
}

func (m *VDiskMetric) GetHypervisorTotalIoSizeKbytes() int64 {
	if m != nil && m.HypervisorTotalIoSizeKbytes != nil {
		return *m.HypervisorTotalIoSizeKbytes
	}
	return 0
}

func (m *VDiskMetric) GetHypervisorTotalReadIoTimeUsecs() int64 {
	if m != nil && m.HypervisorTotalReadIoTimeUsecs != nil {
		return *m.HypervisorTotalReadIoTimeUsecs
	}
	return 0
}

func (m *VDiskMetric) GetHypervisorTotalIoTimeUsecs() int64 {
	if m != nil && m.HypervisorTotalIoTimeUsecs != nil {
		return *m.HypervisorTotalIoTimeUsecs
	}
	return 0
}

type VNICMetric struct {
	// The average amount of data received per second in Kbps.
	NetworkReceivedRateKBps *int64 `protobuf:"varint,1,opt,name=network_received_rate_kBps,json=networkReceivedRateKBps" json:"network_received_rate_kBps,omitempty"`
	//The average amount of data received per second in bytes.
	NetworkReceivedBytes *int64 `protobuf:"varint,2,opt,name=network_received_bytes,json=networkReceivedBytes" json:"network_received_bytes,omitempty"`
	// The average rate at which data is transmitted per second in Kbps.
	NetworkTransmittedRateKBps *int64 `protobuf:"varint,3,opt,name=network_transmitted_rate_kBps,json=networkTransmittedRateKBps" json:"network_transmitted_rate_kBps,omitempty"`
	// The average amount of data transmitted per second in bytes.
	NetworkTransmittedBytes *int64 `protobuf:"varint,4,opt,name=network_transmitted_bytes,json=networkTransmittedBytes" json:"network_transmitted_bytes,omitempty"`
	// The number of receive packets dropped.
	NetworkDroppedReceivedPkts *int64 `protobuf:"varint,5,opt,name=network_dropped_received_pkts,json=networkDroppedReceivedPkts" json:"network_dropped_received_pkts,omitempty"`
	// The number of transmit packets dropped.
	NetworkDroppedTransmittedPkts *int64 `protobuf:"varint,6,opt,name=network_dropped_transmitted_pkts,json=networkDroppedTransmittedPkts" json:"network_dropped_transmitted_pkts,omitempty"`
	// Number of packets received during the interval.
	NetworkReceivedPkts *int64 `protobuf:"varint,7,opt,name=network_received_pkts,json=networkReceivedPkts" json:"network_received_pkts,omitempty"`
	// Number of packets transmitted during the interval.
	NetworkTransmittedPkts *int64 `protobuf:"varint,8,opt,name=network_transmitted_pkts,json=networkTransmittedPkts" json:"network_transmitted_pkts,omitempty"`
	// The number of broadcast packets received during the sampling interval.
	NetworkBroadcastReceivedPkts *int64 `protobuf:"varint,9,opt,name=network_broadcast_received_pkts,json=networkBroadcastReceivedPkts" json:"network_broadcast_received_pkts,omitempty"`
	// The number of broadcast packets transmitted during the sampling interval.
	NetworkBroadcastTransmittedPkts *int64 `protobuf:"varint,10,opt,name=network_broadcast_transmitted_pkts,json=networkBroadcastTransmittedPkts" json:"network_broadcast_transmitted_pkts,omitempty"`
	// The number of packets with errors received during the sampling interval.
	NetworkErrorReceivedPkts *int64 `protobuf:"varint,11,opt,name=network_error_received_pkts,json=networkErrorReceivedPkts" json:"network_error_received_pkts,omitempty"`
	// The number of packets with errors transmitted during the sampling interval.
	NetworkErrorTransmittedPkts *int64 `protobuf:"varint,12,opt,name=network_error_transmitted_pkts,json=networkErrorTransmittedPkts" json:"network_error_transmitted_pkts,omitempty"`
	// The number of multicast packets received during the sampling interval.
	NetworkMulticastReceivedPkts *int64 `protobuf:"varint,13,opt,name=network_multicast_received_pkts,json=networkMulticastReceivedPkts" json:"network_multicast_received_pkts,omitempty"`
	// The number of multicast packets transmitted during the sampling interval.
	NetworkMulticastTransmittedPkts *int64 `protobuf:"varint,14,opt,name=network_multicast_transmitted_pkts,json=networkMulticastTransmittedPkts" json:"network_multicast_transmitted_pkts,omitempty"`
	// Network utilization (combined transmit- & receive-rates) during the
	// interval.
	NetworkUsageRateKBps *int64   `protobuf:"varint,15,opt,name=network_usage_rate_kBps,json=networkUsageRateKBps" json:"network_usage_rate_kBps,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNICMetric) Reset()         { *m = VNICMetric{} }
func (m *VNICMetric) String() string { return proto.CompactTextString(m) }
func (*VNICMetric) ProtoMessage()    {}
func (*VNICMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{59}
}

func (m *VNICMetric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNICMetric.Unmarshal(m, b)
}
func (m *VNICMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNICMetric.Marshal(b, m, deterministic)
}
func (m *VNICMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNICMetric.Merge(m, src)
}
func (m *VNICMetric) XXX_Size() int {
	return xxx_messageInfo_VNICMetric.Size(m)
}
func (m *VNICMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_VNICMetric.DiscardUnknown(m)
}

var xxx_messageInfo_VNICMetric proto.InternalMessageInfo

func (m *VNICMetric) GetNetworkReceivedRateKBps() int64 {
	if m != nil && m.NetworkReceivedRateKBps != nil {
		return *m.NetworkReceivedRateKBps
	}
	return 0
}

func (m *VNICMetric) GetNetworkReceivedBytes() int64 {
	if m != nil && m.NetworkReceivedBytes != nil {
		return *m.NetworkReceivedBytes
	}
	return 0
}

func (m *VNICMetric) GetNetworkTransmittedRateKBps() int64 {
	if m != nil && m.NetworkTransmittedRateKBps != nil {
		return *m.NetworkTransmittedRateKBps
	}
	return 0
}

func (m *VNICMetric) GetNetworkTransmittedBytes() int64 {
	if m != nil && m.NetworkTransmittedBytes != nil {
		return *m.NetworkTransmittedBytes
	}
	return 0
}

func (m *VNICMetric) GetNetworkDroppedReceivedPkts() int64 {
	if m != nil && m.NetworkDroppedReceivedPkts != nil {
		return *m.NetworkDroppedReceivedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkDroppedTransmittedPkts() int64 {
	if m != nil && m.NetworkDroppedTransmittedPkts != nil {
		return *m.NetworkDroppedTransmittedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkReceivedPkts() int64 {
	if m != nil && m.NetworkReceivedPkts != nil {
		return *m.NetworkReceivedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkTransmittedPkts() int64 {
	if m != nil && m.NetworkTransmittedPkts != nil {
		return *m.NetworkTransmittedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkBroadcastReceivedPkts() int64 {
	if m != nil && m.NetworkBroadcastReceivedPkts != nil {
		return *m.NetworkBroadcastReceivedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkBroadcastTransmittedPkts() int64 {
	if m != nil && m.NetworkBroadcastTransmittedPkts != nil {
		return *m.NetworkBroadcastTransmittedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkErrorReceivedPkts() int64 {
	if m != nil && m.NetworkErrorReceivedPkts != nil {
		return *m.NetworkErrorReceivedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkErrorTransmittedPkts() int64 {
	if m != nil && m.NetworkErrorTransmittedPkts != nil {
		return *m.NetworkErrorTransmittedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkMulticastReceivedPkts() int64 {
	if m != nil && m.NetworkMulticastReceivedPkts != nil {
		return *m.NetworkMulticastReceivedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkMulticastTransmittedPkts() int64 {
	if m != nil && m.NetworkMulticastTransmittedPkts != nil {
		return *m.NetworkMulticastTransmittedPkts
	}
	return 0
}

func (m *VNICMetric) GetNetworkUsageRateKBps() int64 {
	if m != nil && m.NetworkUsageRateKBps != nil {
		return *m.NetworkUsageRateKBps
	}
	return 0
}

type NodeMetric struct {
	// The time span over which the stats reported by the hypervisor are recorded.
	HypervisorTimespanUsecs *int64 `protobuf:"varint,1,opt,name=hypervisor_timespan_usecs,json=hypervisorTimespanUsecs" json:"hypervisor_timespan_usecs,omitempty"`
	// Avg amount of memory allocated by the VM memory control driver.
	HypervisorMemoryBalloonReclaimedBytes *int64 `protobuf:"varint,2,opt,name=hypervisor_memory_balloon_reclaimed_bytes,json=hypervisorMemoryBalloonReclaimedBytes" json:"hypervisor_memory_balloon_reclaimed_bytes,omitempty"`
	// Number of bytes transmitted by the VM during the interval.
	HypervisorSwapUsedBytes *int64 `protobuf:"varint,3,opt,name=hypervisor_swap_used_bytes,json=hypervisorSwapUsedBytes" json:"hypervisor_swap_used_bytes,omitempty"`
	// The average rate memory is swapped from disk into active memory, in KBps.
	HypervisorSwapInRateKBps *int64 `protobuf:"varint,4,opt,name=hypervisor_swap_in_rate_kBps,json=hypervisorSwapInRateKBps" json:"hypervisor_swap_in_rate_kBps,omitempty"`
	// The average rate of memory swapped-out to disk, in KBps.
	HypervisorSwapOutRateKBps *int64 `protobuf:"varint,5,opt,name=hypervisor_swap_out_rate_kBps,json=hypervisorSwapOutRateKBps" json:"hypervisor_swap_out_rate_kBps,omitempty"`
	// The average rate of memory swapped-out to disk, in KBps.
	HypervisorNumReceivePacketsDropped *int64 `protobuf:"varint,6,opt,name=hypervisor_num_receive_packets_dropped,json=hypervisorNumReceivePacketsDropped" json:"hypervisor_num_receive_packets_dropped,omitempty"`
	// The number of transmit packets dropped.
	HypervisorNumTransmitPacketsDropped *int64 `protobuf:"varint,7,opt,name=hypervisor_num_transmit_packets_dropped,json=hypervisorNumTransmitPacketsDropped" json:"hypervisor_num_transmit_packets_dropped,omitempty"`
	// Average CPU usage expressed in parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	HypervisorCpuUsagePpm *int64 `protobuf:"varint,8,opt,name=hypervisor_cpu_usage_ppm,json=hypervisorCpuUsagePpm" json:"hypervisor_cpu_usage_ppm,omitempty"`
	// Memory usage percentage expressed parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	HypervisorMemoryUsagePpm *int64 `protobuf:"varint,9,opt,name=hypervisor_memory_usage_ppm,json=hypervisorMemoryUsagePpm" json:"hypervisor_memory_usage_ppm,omitempty"`
	// Number of bytes received by the VM from the network during the
	// interval.
	HypervisorNumReceivedBytes *int64 `protobuf:"varint,10,opt,name=hypervisor_num_received_bytes,json=hypervisorNumReceivedBytes" json:"hypervisor_num_received_bytes,omitempty"`
	// Number of bytes transmitted by the VM during the interval.
	HypervisorNumTransmittedBytes *int64 `protobuf:"varint,11,opt,name=hypervisor_num_transmitted_bytes,json=hypervisorNumTransmittedBytes" json:"hypervisor_num_transmitted_bytes,omitempty"`
	// Amount of memory usage in bytes by hypervisor.
	HypervisorMemoryUsageBytes *int64 `protobuf:"varint,12,opt,name=hypervisor_memory_usage_bytes,json=hypervisorMemoryUsageBytes" json:"hypervisor_memory_usage_bytes,omitempty"`
	// Memory usage percentage expressed parts per million. To get percentage,
	// the value should be divided by 1 million and multipled by 100.
	// This has the same value as "hypervisor_memory_usage_ppm" excpet for AHV
	// hypervisor.
	AggregateHypervisorMemoryUsagePpm *int64   `protobuf:"varint,13,opt,name=aggregate_hypervisor_memory_usage_ppm,json=aggregateHypervisorMemoryUsagePpm" json:"aggregate_hypervisor_memory_usage_ppm,omitempty"`
	XXX_NoUnkeyedLiteral              struct{} `json:"-"`
	XXX_unrecognized                  []byte   `json:"-"`
	XXX_sizecache                     int32    `json:"-"`
}

func (m *NodeMetric) Reset()         { *m = NodeMetric{} }
func (m *NodeMetric) String() string { return proto.CompactTextString(m) }
func (*NodeMetric) ProtoMessage()    {}
func (*NodeMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{60}
}

func (m *NodeMetric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeMetric.Unmarshal(m, b)
}
func (m *NodeMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeMetric.Marshal(b, m, deterministic)
}
func (m *NodeMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMetric.Merge(m, src)
}
func (m *NodeMetric) XXX_Size() int {
	return xxx_messageInfo_NodeMetric.Size(m)
}
func (m *NodeMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMetric.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMetric proto.InternalMessageInfo

func (m *NodeMetric) GetHypervisorTimespanUsecs() int64 {
	if m != nil && m.HypervisorTimespanUsecs != nil {
		return *m.HypervisorTimespanUsecs
	}
	return 0
}

func (m *NodeMetric) GetHypervisorMemoryBalloonReclaimedBytes() int64 {
	if m != nil && m.HypervisorMemoryBalloonReclaimedBytes != nil {
		return *m.HypervisorMemoryBalloonReclaimedBytes
	}
	return 0
}

func (m *NodeMetric) GetHypervisorSwapUsedBytes() int64 {
	if m != nil && m.HypervisorSwapUsedBytes != nil {
		return *m.HypervisorSwapUsedBytes
	}
	return 0
}

func (m *NodeMetric) GetHypervisorSwapInRateKBps() int64 {
	if m != nil && m.HypervisorSwapInRateKBps != nil {
		return *m.HypervisorSwapInRateKBps
	}
	return 0
}

func (m *NodeMetric) GetHypervisorSwapOutRateKBps() int64 {
	if m != nil && m.HypervisorSwapOutRateKBps != nil {
		return *m.HypervisorSwapOutRateKBps
	}
	return 0
}

func (m *NodeMetric) GetHypervisorNumReceivePacketsDropped() int64 {
	if m != nil && m.HypervisorNumReceivePacketsDropped != nil {
		return *m.HypervisorNumReceivePacketsDropped
	}
	return 0
}

func (m *NodeMetric) GetHypervisorNumTransmitPacketsDropped() int64 {
	if m != nil && m.HypervisorNumTransmitPacketsDropped != nil {
		return *m.HypervisorNumTransmitPacketsDropped
	}
	return 0
}

func (m *NodeMetric) GetHypervisorCpuUsagePpm() int64 {
	if m != nil && m.HypervisorCpuUsagePpm != nil {
		return *m.HypervisorCpuUsagePpm
	}
	return 0
}

func (m *NodeMetric) GetHypervisorMemoryUsagePpm() int64 {
	if m != nil && m.HypervisorMemoryUsagePpm != nil {
		return *m.HypervisorMemoryUsagePpm
	}
	return 0
}

func (m *NodeMetric) GetHypervisorNumReceivedBytes() int64 {
	if m != nil && m.HypervisorNumReceivedBytes != nil {
		return *m.HypervisorNumReceivedBytes
	}
	return 0
}

func (m *NodeMetric) GetHypervisorNumTransmittedBytes() int64 {
	if m != nil && m.HypervisorNumTransmittedBytes != nil {
		return *m.HypervisorNumTransmittedBytes
	}
	return 0
}

func (m *NodeMetric) GetHypervisorMemoryUsageBytes() int64 {
	if m != nil && m.HypervisorMemoryUsageBytes != nil {
		return *m.HypervisorMemoryUsageBytes
	}
	return 0
}

func (m *NodeMetric) GetAggregateHypervisorMemoryUsagePpm() int64 {
	if m != nil && m.AggregateHypervisorMemoryUsagePpm != nil {
		return *m.AggregateHypervisorMemoryUsagePpm
	}
	return 0
}

type ManagementServerInfo struct {
	// The hypervisor management server address.
	// Any routable address is supported.
	Address *string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The hypervisor management server port.
	Port *int64 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	// The extension key.
	ExtensionKey *string `protobuf:"bytes,3,opt,name=extension_key,json=extensionKey" json:"extension_key,omitempty"`
	// The Management Server Type. e.g., "vcenter", "github.com/nutanix-core/acs-aos-go/acropolis" etc.
	ManagementServerType *string `protobuf:"bytes,4,opt,name=management_server_type,json=managementServerType" json:"management_server_type,omitempty"`
	// The cluster UUID.
	ClusterUuid *string `protobuf:"bytes,5,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// Whether DRS is enabled.
	DrsEnabled *bool `protobuf:"varint,6,opt,name=drs_enabled,json=drsEnabled" json:"drs_enabled,omitempty"`
	// Whether any host is managed by this entity.
	InUse                *bool    `protobuf:"varint,7,opt,name=in_use,json=inUse" json:"in_use,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ManagementServerInfo) Reset()         { *m = ManagementServerInfo{} }
func (m *ManagementServerInfo) String() string { return proto.CompactTextString(m) }
func (*ManagementServerInfo) ProtoMessage()    {}
func (*ManagementServerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{61}
}

func (m *ManagementServerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ManagementServerInfo.Unmarshal(m, b)
}
func (m *ManagementServerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ManagementServerInfo.Marshal(b, m, deterministic)
}
func (m *ManagementServerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManagementServerInfo.Merge(m, src)
}
func (m *ManagementServerInfo) XXX_Size() int {
	return xxx_messageInfo_ManagementServerInfo.Size(m)
}
func (m *ManagementServerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ManagementServerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ManagementServerInfo proto.InternalMessageInfo

func (m *ManagementServerInfo) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *ManagementServerInfo) GetPort() int64 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *ManagementServerInfo) GetExtensionKey() string {
	if m != nil && m.ExtensionKey != nil {
		return *m.ExtensionKey
	}
	return ""
}

func (m *ManagementServerInfo) GetManagementServerType() string {
	if m != nil && m.ManagementServerType != nil {
		return *m.ManagementServerType
	}
	return ""
}

func (m *ManagementServerInfo) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *ManagementServerInfo) GetDrsEnabled() bool {
	if m != nil && m.DrsEnabled != nil {
		return *m.DrsEnabled
	}
	return false
}

func (m *ManagementServerInfo) GetInUse() bool {
	if m != nil && m.InUse != nil {
		return *m.InUse
	}
	return false
}

//-----------------------------------------------------------------------------
type DatastoreConfig struct {
	// Nutanix container as identified by the Hypervisor.
	DatastoreId *string `protobuf:"bytes,1,opt,name=datastore_id,json=datastoreId" json:"datastore_id,omitempty"`
	// The name of the datastore.
	DatastoreName *string `protobuf:"bytes,2,opt,name=datastore_name,json=datastoreName" json:"datastore_name,omitempty"`
	// The uuid of the container that's used to mount the NFS share.
	ContainerUuid []byte `protobuf:"bytes,3,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// List of nodes in which the datastore is mounted.
	NodeStatusList       []*DatastoreConfig_NodeStatus `protobuf:"bytes,4,rep,name=node_status_list,json=nodeStatusList" json:"node_status_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *DatastoreConfig) Reset()         { *m = DatastoreConfig{} }
func (m *DatastoreConfig) String() string { return proto.CompactTextString(m) }
func (*DatastoreConfig) ProtoMessage()    {}
func (*DatastoreConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{62}
}

func (m *DatastoreConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatastoreConfig.Unmarshal(m, b)
}
func (m *DatastoreConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatastoreConfig.Marshal(b, m, deterministic)
}
func (m *DatastoreConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatastoreConfig.Merge(m, src)
}
func (m *DatastoreConfig) XXX_Size() int {
	return xxx_messageInfo_DatastoreConfig.Size(m)
}
func (m *DatastoreConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DatastoreConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DatastoreConfig proto.InternalMessageInfo

func (m *DatastoreConfig) GetDatastoreId() string {
	if m != nil && m.DatastoreId != nil {
		return *m.DatastoreId
	}
	return ""
}

func (m *DatastoreConfig) GetDatastoreName() string {
	if m != nil && m.DatastoreName != nil {
		return *m.DatastoreName
	}
	return ""
}

func (m *DatastoreConfig) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *DatastoreConfig) GetNodeStatusList() []*DatastoreConfig_NodeStatus {
	if m != nil {
		return m.NodeStatusList
	}
	return nil
}

type DatastoreConfig_NodeStatus struct {
	// Nutanix Uuid of the node
	NodeUuid []byte `protobuf:"bytes,1,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// Indicates if the datastore is accessible.
	IsAccessible *bool `protobuf:"varint,2,opt,name=is_accessible,json=isAccessible" json:"is_accessible,omitempty"`
	// Indicates if the datastore is mounted.
	IsMounted *bool `protobuf:"varint,3,opt,name=is_mounted,json=isMounted" json:"is_mounted,omitempty"`
	// Node IP
	NodeIp               *string  `protobuf:"bytes,4,opt,name=node_ip,json=nodeIp" json:"node_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatastoreConfig_NodeStatus) Reset()         { *m = DatastoreConfig_NodeStatus{} }
func (m *DatastoreConfig_NodeStatus) String() string { return proto.CompactTextString(m) }
func (*DatastoreConfig_NodeStatus) ProtoMessage()    {}
func (*DatastoreConfig_NodeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{62, 0}
}

func (m *DatastoreConfig_NodeStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatastoreConfig_NodeStatus.Unmarshal(m, b)
}
func (m *DatastoreConfig_NodeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatastoreConfig_NodeStatus.Marshal(b, m, deterministic)
}
func (m *DatastoreConfig_NodeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatastoreConfig_NodeStatus.Merge(m, src)
}
func (m *DatastoreConfig_NodeStatus) XXX_Size() int {
	return xxx_messageInfo_DatastoreConfig_NodeStatus.Size(m)
}
func (m *DatastoreConfig_NodeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DatastoreConfig_NodeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DatastoreConfig_NodeStatus proto.InternalMessageInfo

func (m *DatastoreConfig_NodeStatus) GetNodeUuid() []byte {
	if m != nil {
		return m.NodeUuid
	}
	return nil
}

func (m *DatastoreConfig_NodeStatus) GetIsAccessible() bool {
	if m != nil && m.IsAccessible != nil {
		return *m.IsAccessible
	}
	return false
}

func (m *DatastoreConfig_NodeStatus) GetIsMounted() bool {
	if m != nil && m.IsMounted != nil {
		return *m.IsMounted
	}
	return false
}

func (m *DatastoreConfig_NodeStatus) GetNodeIp() string {
	if m != nil && m.NodeIp != nil {
		return *m.NodeIp
	}
	return ""
}

type MappingType struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MappingType) Reset()         { *m = MappingType{} }
func (m *MappingType) String() string { return proto.CompactTextString(m) }
func (*MappingType) ProtoMessage()    {}
func (*MappingType) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{63}
}

func (m *MappingType) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MappingType.Unmarshal(m, b)
}
func (m *MappingType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MappingType.Marshal(b, m, deterministic)
}
func (m *MappingType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MappingType.Merge(m, src)
}
func (m *MappingType) XXX_Size() int {
	return xxx_messageInfo_MappingType.Size(m)
}
func (m *MappingType) XXX_DiscardUnknown() {
	xxx_messageInfo_MappingType.DiscardUnknown(m)
}

var xxx_messageInfo_MappingType proto.InternalMessageInfo

type VmUuidMap struct {
	// The arithmos ID for VM entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic VM UUIDs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmUuidMap) Reset()         { *m = VmUuidMap{} }
func (m *VmUuidMap) String() string { return proto.CompactTextString(m) }
func (*VmUuidMap) ProtoMessage()    {}
func (*VmUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{64}
}

func (m *VmUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmUuidMap.Unmarshal(m, b)
}
func (m *VmUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmUuidMap.Marshal(b, m, deterministic)
}
func (m *VmUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmUuidMap.Merge(m, src)
}
func (m *VmUuidMap) XXX_Size() int {
	return xxx_messageInfo_VmUuidMap.Size(m)
}
func (m *VmUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VmUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VmUuidMap proto.InternalMessageInfo

func (m *VmUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VmUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualDiskUuidMap struct {
	// The arithmos ID for virtual disk entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for virtual disks.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDiskUuidMap) Reset()         { *m = VirtualDiskUuidMap{} }
func (m *VirtualDiskUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualDiskUuidMap) ProtoMessage()    {}
func (*VirtualDiskUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{65}
}

func (m *VirtualDiskUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDiskUuidMap.Unmarshal(m, b)
}
func (m *VirtualDiskUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDiskUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualDiskUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDiskUuidMap.Merge(m, src)
}
func (m *VirtualDiskUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualDiskUuidMap.Size(m)
}
func (m *VirtualDiskUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDiskUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDiskUuidMap proto.InternalMessageInfo

func (m *VirtualDiskUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualDiskUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualDiskUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualNicUuidMap struct {
	// The arithmos ID for virtual NIC entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for virtual NICs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNicUuidMap) Reset()         { *m = VirtualNicUuidMap{} }
func (m *VirtualNicUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualNicUuidMap) ProtoMessage()    {}
func (*VirtualNicUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{66}
}

func (m *VirtualNicUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNicUuidMap.Unmarshal(m, b)
}
func (m *VirtualNicUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNicUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualNicUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNicUuidMap.Merge(m, src)
}
func (m *VirtualNicUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualNicUuidMap.Size(m)
}
func (m *VirtualNicUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNicUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNicUuidMap proto.InternalMessageInfo

func (m *VirtualNicUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualNicUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualNicUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualGpuUuidMap struct {
	// The arithmos ID for virtual GPU entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for virtual GPUs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualGpuUuidMap) Reset()         { *m = VirtualGpuUuidMap{} }
func (m *VirtualGpuUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualGpuUuidMap) ProtoMessage()    {}
func (*VirtualGpuUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{67}
}

func (m *VirtualGpuUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualGpuUuidMap.Unmarshal(m, b)
}
func (m *VirtualGpuUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualGpuUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualGpuUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualGpuUuidMap.Merge(m, src)
}
func (m *VirtualGpuUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualGpuUuidMap.Size(m)
}
func (m *VirtualGpuUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualGpuUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualGpuUuidMap proto.InternalMessageInfo

func (m *VirtualGpuUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualGpuUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualGpuUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VmSnapshotUuidMap struct {
	// The arithmos ID for VM snapshot entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for VM snapshot.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmSnapshotUuidMap) Reset()         { *m = VmSnapshotUuidMap{} }
func (m *VmSnapshotUuidMap) String() string { return proto.CompactTextString(m) }
func (*VmSnapshotUuidMap) ProtoMessage()    {}
func (*VmSnapshotUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{68}
}

func (m *VmSnapshotUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmSnapshotUuidMap.Unmarshal(m, b)
}
func (m *VmSnapshotUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmSnapshotUuidMap.Marshal(b, m, deterministic)
}
func (m *VmSnapshotUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmSnapshotUuidMap.Merge(m, src)
}
func (m *VmSnapshotUuidMap) XXX_Size() int {
	return xxx_messageInfo_VmSnapshotUuidMap.Size(m)
}
func (m *VmSnapshotUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VmSnapshotUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VmSnapshotUuidMap proto.InternalMessageInfo

func (m *VmSnapshotUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VmSnapshotUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VmSnapshotUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type NodeGpuUuidMap struct {
	// The arithmos ID for node GPU entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for node GPUs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeGpuUuidMap) Reset()         { *m = NodeGpuUuidMap{} }
func (m *NodeGpuUuidMap) String() string { return proto.CompactTextString(m) }
func (*NodeGpuUuidMap) ProtoMessage()    {}
func (*NodeGpuUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{69}
}

func (m *NodeGpuUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeGpuUuidMap.Unmarshal(m, b)
}
func (m *NodeGpuUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeGpuUuidMap.Marshal(b, m, deterministic)
}
func (m *NodeGpuUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeGpuUuidMap.Merge(m, src)
}
func (m *NodeGpuUuidMap) XXX_Size() int {
	return xxx_messageInfo_NodeGpuUuidMap.Size(m)
}
func (m *NodeGpuUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeGpuUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodeGpuUuidMap proto.InternalMessageInfo

func (m *NodeGpuUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *NodeGpuUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NodeGpuUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type NodePhysicalNicUuidMap struct {
	// The arithmos ID for node physical NIC entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for node physical NICs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodePhysicalNicUuidMap) Reset()         { *m = NodePhysicalNicUuidMap{} }
func (m *NodePhysicalNicUuidMap) String() string { return proto.CompactTextString(m) }
func (*NodePhysicalNicUuidMap) ProtoMessage()    {}
func (*NodePhysicalNicUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{70}
}

func (m *NodePhysicalNicUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodePhysicalNicUuidMap.Unmarshal(m, b)
}
func (m *NodePhysicalNicUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodePhysicalNicUuidMap.Marshal(b, m, deterministic)
}
func (m *NodePhysicalNicUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodePhysicalNicUuidMap.Merge(m, src)
}
func (m *NodePhysicalNicUuidMap) XXX_Size() int {
	return xxx_messageInfo_NodePhysicalNicUuidMap.Size(m)
}
func (m *NodePhysicalNicUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodePhysicalNicUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodePhysicalNicUuidMap proto.InternalMessageInfo

func (m *NodePhysicalNicUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *NodePhysicalNicUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NodePhysicalNicUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type NodeVirtualNicUuidMap struct {
	// The arithmos ID for node virtual NIC entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for node virtual NICs.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeVirtualNicUuidMap) Reset()         { *m = NodeVirtualNicUuidMap{} }
func (m *NodeVirtualNicUuidMap) String() string { return proto.CompactTextString(m) }
func (*NodeVirtualNicUuidMap) ProtoMessage()    {}
func (*NodeVirtualNicUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{71}
}

func (m *NodeVirtualNicUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeVirtualNicUuidMap.Unmarshal(m, b)
}
func (m *NodeVirtualNicUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeVirtualNicUuidMap.Marshal(b, m, deterministic)
}
func (m *NodeVirtualNicUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeVirtualNicUuidMap.Merge(m, src)
}
func (m *NodeVirtualNicUuidMap) XXX_Size() int {
	return xxx_messageInfo_NodeVirtualNicUuidMap.Size(m)
}
func (m *NodeVirtualNicUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeVirtualNicUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_NodeVirtualNicUuidMap proto.InternalMessageInfo

func (m *NodeVirtualNicUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *NodeVirtualNicUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *NodeVirtualNicUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualNetworkUuidMap struct {
	// The arithmos ID for node virtual network entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// The hypervisor agnostic UUID for a virtual network.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNetworkUuidMap) Reset()         { *m = VirtualNetworkUuidMap{} }
func (m *VirtualNetworkUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualNetworkUuidMap) ProtoMessage()    {}
func (*VirtualNetworkUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{72}
}

func (m *VirtualNetworkUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetworkUuidMap.Unmarshal(m, b)
}
func (m *VirtualNetworkUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetworkUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualNetworkUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkUuidMap.Merge(m, src)
}
func (m *VirtualNetworkUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualNetworkUuidMap.Size(m)
}
func (m *VirtualNetworkUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkUuidMap proto.InternalMessageInfo

func (m *VirtualNetworkUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualNetworkUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualNetworkUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type VirtualDeviceUuidMap struct {
	// The arithmos ID for node virtual device entities.
	ArithmosId *string `protobuf:"bytes,1,opt,name=arithmos_id,json=arithmosId" json:"arithmos_id,omitempty"`
	// Device UUID.
	Uuid []byte `protobuf:"bytes,2,opt,name=uuid" json:"uuid,omitempty"`
	// Whether this entry has been deleted.
	Deleted              *bool    `protobuf:"varint,3,opt,name=deleted" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDeviceUuidMap) Reset()         { *m = VirtualDeviceUuidMap{} }
func (m *VirtualDeviceUuidMap) String() string { return proto.CompactTextString(m) }
func (*VirtualDeviceUuidMap) ProtoMessage()    {}
func (*VirtualDeviceUuidMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{73}
}

func (m *VirtualDeviceUuidMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDeviceUuidMap.Unmarshal(m, b)
}
func (m *VirtualDeviceUuidMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDeviceUuidMap.Marshal(b, m, deterministic)
}
func (m *VirtualDeviceUuidMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDeviceUuidMap.Merge(m, src)
}
func (m *VirtualDeviceUuidMap) XXX_Size() int {
	return xxx_messageInfo_VirtualDeviceUuidMap.Size(m)
}
func (m *VirtualDeviceUuidMap) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDeviceUuidMap.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDeviceUuidMap proto.InternalMessageInfo

func (m *VirtualDeviceUuidMap) GetArithmosId() string {
	if m != nil && m.ArithmosId != nil {
		return *m.ArithmosId
	}
	return ""
}

func (m *VirtualDeviceUuidMap) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VirtualDeviceUuidMap) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

type CerebroVmInfo struct {
	// The protection domain where this VM belongs to.
	ProtectionDomain *string `protobuf:"bytes,1,opt,name=protection_domain,json=protectionDomain" json:"protection_domain,omitempty"`
	// The protection domain name where this VM belongs to.
	ProtectionDomainName *string `protobuf:"bytes,2,opt,name=protection_domain_name,json=protectionDomainName" json:"protection_domain_name,omitempty"`
	// The consistency group where this VM belongs to.
	ConsistencyGroup *string `protobuf:"bytes,3,opt,name=consistency_group,json=consistencyGroup" json:"consistency_group,omitempty"`
	// The consistency group name where this VM belongs to.
	ConsistencyGroupName *string `protobuf:"bytes,4,opt,name=consistency_group_name,json=consistencyGroupName" json:"consistency_group_name,omitempty"`
	// UUID of the protection rule which is protecting this VM.
	ProtectionRuleUuid *string `protobuf:"bytes,5,opt,name=protection_rule_uuid,json=protectionRuleUuid" json:"protection_rule_uuid,omitempty"`
	// Type of protection applied on this VM.
	ProtectionType *string `protobuf:"bytes,6,opt,name=protection_type,json=protectionType" json:"protection_type,omitempty"`
	// The version of the protection rule which is protecting the VM.
	// The PR version gets incremented every time the PR is updated.
	ProtectionRuleVersion *int64   `protobuf:"varint,7,opt,name=protection_rule_version,json=protectionRuleVersion" json:"protection_rule_version,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *CerebroVmInfo) Reset()         { *m = CerebroVmInfo{} }
func (m *CerebroVmInfo) String() string { return proto.CompactTextString(m) }
func (*CerebroVmInfo) ProtoMessage()    {}
func (*CerebroVmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{74}
}

func (m *CerebroVmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CerebroVmInfo.Unmarshal(m, b)
}
func (m *CerebroVmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CerebroVmInfo.Marshal(b, m, deterministic)
}
func (m *CerebroVmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CerebroVmInfo.Merge(m, src)
}
func (m *CerebroVmInfo) XXX_Size() int {
	return xxx_messageInfo_CerebroVmInfo.Size(m)
}
func (m *CerebroVmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CerebroVmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CerebroVmInfo proto.InternalMessageInfo

func (m *CerebroVmInfo) GetProtectionDomain() string {
	if m != nil && m.ProtectionDomain != nil {
		return *m.ProtectionDomain
	}
	return ""
}

func (m *CerebroVmInfo) GetProtectionDomainName() string {
	if m != nil && m.ProtectionDomainName != nil {
		return *m.ProtectionDomainName
	}
	return ""
}

func (m *CerebroVmInfo) GetConsistencyGroup() string {
	if m != nil && m.ConsistencyGroup != nil {
		return *m.ConsistencyGroup
	}
	return ""
}

func (m *CerebroVmInfo) GetConsistencyGroupName() string {
	if m != nil && m.ConsistencyGroupName != nil {
		return *m.ConsistencyGroupName
	}
	return ""
}

func (m *CerebroVmInfo) GetProtectionRuleUuid() string {
	if m != nil && m.ProtectionRuleUuid != nil {
		return *m.ProtectionRuleUuid
	}
	return ""
}

func (m *CerebroVmInfo) GetProtectionType() string {
	if m != nil && m.ProtectionType != nil {
		return *m.ProtectionType
	}
	return ""
}

func (m *CerebroVmInfo) GetProtectionRuleVersion() int64 {
	if m != nil && m.ProtectionRuleVersion != nil {
		return *m.ProtectionRuleVersion
	}
	return 0
}

type NgtVmInfo struct {
	// NGT enabled, i.e. "ngt.enabled" in Arithmos.
	NgtEnabled *int64 `protobuf:"varint,1,opt,name=ngt_enabled,json=ngtEnabled" json:"ngt_enabled,omitempty"`
	// NGT ISO mounted, i.e. "ngt.iso_mounted" in Arithmos.
	NgtIsoMounted *int64 `protobuf:"varint,2,opt,name=ngt_iso_mounted,json=ngtIsoMounted" json:"ngt_iso_mounted,omitempty"`
	// NGT communication active, i.e. "ngt.communication_active" in Arithmos.
	// This field indicates whether the cvm is reachable from the uvm.
	NgtCommunicationActive *int64 `protobuf:"varint,3,opt,name=ngt_communication_active,json=ngtCommunicationActive" json:"ngt_communication_active,omitempty"`
	// NGT installed version, i.e. "ngt.installed_version" in Arithmos.
	// Version of ngt installed on the uvm.
	NgtInstalledVersion *string `protobuf:"bytes,4,opt,name=ngt_installed_version,json=ngtInstalledVersion" json:"ngt_installed_version,omitempty"`
	// NGT cluster version, i.e. "ngt.cluster_version" in Arithmos.
	// Version og ngt available on the cluster, this will be useful in upgrade.
	NgtClusterVersion *string `protobuf:"bytes,5,opt,name=ngt_cluster_version,json=ngtClusterVersion" json:"ngt_cluster_version,omitempty"`
	// NGT vss enabled, i.e. "ngt.vm_vss_enabled" in Arithmos.
	NgtVmVssEnabled *int64 `protobuf:"varint,6,opt,name=ngt_vm_vss_enabled,json=ngtVmVssEnabled" json:"ngt_vm_vss_enabled,omitempty"`
	// NGT enabled applications, i.e. "ngt.enabled_applications" in Arithmos.
	// Various applications supported by NGT, like file level restore will
	// be captured here.
	NgtEnabledApplications []string `protobuf:"bytes,7,rep,name=ngt_enabled_applications,json=ngtEnabledApplications" json:"ngt_enabled_applications,omitempty"`
	// NGT File level restore enabled, i.e. "ngt.flr_enabled" in Arithmos.
	NgtFlrEnabled *int64 `protobuf:"varint,8,opt,name=ngt_flr_enabled,json=ngtFlrEnabled" json:"ngt_flr_enabled,omitempty"`
	// NGT Guest OS information, i.e. "ngt.guest_os" in Arithmos.
	NgtGuestOs *string `protobuf:"bytes,9,opt,name=ngt_guest_os,json=ngtGuestOs" json:"ngt_guest_os,omitempty"`
	// NGT iSCSI qualified name of the VM , i.e. "ngt.iscsi_iqn" in Arithmos.
	NgtIscsiIqn *string `protobuf:"bytes,10,opt,name=ngt_iscsi_iqn,json=ngtIscsiIqn" json:"ngt_iscsi_iqn,omitempty"`
	// NGT is deleted, i.e. "ngt.is_deleted" in Arithmos.
	NgtIsDeleted *int64 `protobuf:"varint,11,opt,name=ngt_is_deleted,json=ngtIsDeleted" json:"ngt_is_deleted,omitempty"`
	// NGT ESX mobility drivers are installed. "ngt.esx_drivers_installed" in
	// Arithmos.
	NgtEsxDriversInstalled *int64 `protobuf:"varint,12,opt,name=ngt_esx_drivers_installed,json=ngtEsxDriversInstalled" json:"ngt_esx_drivers_installed,omitempty"`
	// NGT KVM mobility drivers are installed. "ngt.kvm_drivers_installed" in
	// Arithmos.
	NgtKvmDriversInstalled *int64 `protobuf:"varint,13,opt,name=ngt_kvm_drivers_installed,json=ngtKvmDriversInstalled" json:"ngt_kvm_drivers_installed,omitempty"`
	// NGT multipathing enabled for devices.
	// "ngt.multipathing_enabled_for_devices" in Arithmos.
	NgtMultipathingEnabledForDevices *int64 `protobuf:"varint,14,opt,name=ngt_multipathing_enabled_for_devices,json=ngtMultipathingEnabledForDevices" json:"ngt_multipathing_enabled_for_devices,omitempty"`
	// Information about the NGT network interfaces i.e. "ngt.network_interfaces"
	// in Arithmos.
	NgtNetworkInterfaces []string `protobuf:"bytes,15,rep,name=ngt_network_interfaces,json=ngtNetworkInterfaces" json:"ngt_network_interfaces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NgtVmInfo) Reset()         { *m = NgtVmInfo{} }
func (m *NgtVmInfo) String() string { return proto.CompactTextString(m) }
func (*NgtVmInfo) ProtoMessage()    {}
func (*NgtVmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{75}
}

func (m *NgtVmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NgtVmInfo.Unmarshal(m, b)
}
func (m *NgtVmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NgtVmInfo.Marshal(b, m, deterministic)
}
func (m *NgtVmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NgtVmInfo.Merge(m, src)
}
func (m *NgtVmInfo) XXX_Size() int {
	return xxx_messageInfo_NgtVmInfo.Size(m)
}
func (m *NgtVmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NgtVmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NgtVmInfo proto.InternalMessageInfo

func (m *NgtVmInfo) GetNgtEnabled() int64 {
	if m != nil && m.NgtEnabled != nil {
		return *m.NgtEnabled
	}
	return 0
}

func (m *NgtVmInfo) GetNgtIsoMounted() int64 {
	if m != nil && m.NgtIsoMounted != nil {
		return *m.NgtIsoMounted
	}
	return 0
}

func (m *NgtVmInfo) GetNgtCommunicationActive() int64 {
	if m != nil && m.NgtCommunicationActive != nil {
		return *m.NgtCommunicationActive
	}
	return 0
}

func (m *NgtVmInfo) GetNgtInstalledVersion() string {
	if m != nil && m.NgtInstalledVersion != nil {
		return *m.NgtInstalledVersion
	}
	return ""
}

func (m *NgtVmInfo) GetNgtClusterVersion() string {
	if m != nil && m.NgtClusterVersion != nil {
		return *m.NgtClusterVersion
	}
	return ""
}

func (m *NgtVmInfo) GetNgtVmVssEnabled() int64 {
	if m != nil && m.NgtVmVssEnabled != nil {
		return *m.NgtVmVssEnabled
	}
	return 0
}

func (m *NgtVmInfo) GetNgtEnabledApplications() []string {
	if m != nil {
		return m.NgtEnabledApplications
	}
	return nil
}

func (m *NgtVmInfo) GetNgtFlrEnabled() int64 {
	if m != nil && m.NgtFlrEnabled != nil {
		return *m.NgtFlrEnabled
	}
	return 0
}

func (m *NgtVmInfo) GetNgtGuestOs() string {
	if m != nil && m.NgtGuestOs != nil {
		return *m.NgtGuestOs
	}
	return ""
}

func (m *NgtVmInfo) GetNgtIscsiIqn() string {
	if m != nil && m.NgtIscsiIqn != nil {
		return *m.NgtIscsiIqn
	}
	return ""
}

func (m *NgtVmInfo) GetNgtIsDeleted() int64 {
	if m != nil && m.NgtIsDeleted != nil {
		return *m.NgtIsDeleted
	}
	return 0
}

func (m *NgtVmInfo) GetNgtEsxDriversInstalled() int64 {
	if m != nil && m.NgtEsxDriversInstalled != nil {
		return *m.NgtEsxDriversInstalled
	}
	return 0
}

func (m *NgtVmInfo) GetNgtKvmDriversInstalled() int64 {
	if m != nil && m.NgtKvmDriversInstalled != nil {
		return *m.NgtKvmDriversInstalled
	}
	return 0
}

func (m *NgtVmInfo) GetNgtMultipathingEnabledForDevices() int64 {
	if m != nil && m.NgtMultipathingEnabledForDevices != nil {
		return *m.NgtMultipathingEnabledForDevices
	}
	return 0
}

func (m *NgtVmInfo) GetNgtNetworkInterfaces() []string {
	if m != nil {
		return m.NgtNetworkInterfaces
	}
	return nil
}

type QosVmInfo struct {
	// The QOS group policy acting on a VM.
	QosPolicy *string `protobuf:"bytes,1,opt,name=qos_policy,json=qosPolicy" json:"qos_policy,omitempty"`
	// Provisioned IOPS set on a VM.
	ProvisionedIops *int64 `protobuf:"varint,2,opt,name=provisioned_iops,json=provisionedIops" json:"provisioned_iops,omitempty"`
	// Throttled IOPS set on a VM.
	ThrottledIops        *int64   `protobuf:"varint,3,opt,name=throttled_iops,json=throttledIops" json:"throttled_iops,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QosVmInfo) Reset()         { *m = QosVmInfo{} }
func (m *QosVmInfo) String() string { return proto.CompactTextString(m) }
func (*QosVmInfo) ProtoMessage()    {}
func (*QosVmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d39afc1bf0dda0b8, []int{76}
}

func (m *QosVmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QosVmInfo.Unmarshal(m, b)
}
func (m *QosVmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QosVmInfo.Marshal(b, m, deterministic)
}
func (m *QosVmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QosVmInfo.Merge(m, src)
}
func (m *QosVmInfo) XXX_Size() int {
	return xxx_messageInfo_QosVmInfo.Size(m)
}
func (m *QosVmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_QosVmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_QosVmInfo proto.InternalMessageInfo

func (m *QosVmInfo) GetQosPolicy() string {
	if m != nil && m.QosPolicy != nil {
		return *m.QosPolicy
	}
	return ""
}

func (m *QosVmInfo) GetProvisionedIops() int64 {
	if m != nil && m.ProvisionedIops != nil {
		return *m.ProvisionedIops
	}
	return 0
}

func (m *QosVmInfo) GetThrottledIops() int64 {
	if m != nil && m.ThrottledIops != nil {
		return *m.ThrottledIops
	}
	return 0
}

func init() {
	proto.RegisterEnum("nutanix.uhura.VmChildEntityType", VmChildEntityType_name, VmChildEntityType_value)
	proto.RegisterEnum("nutanix.uhura.VmNicVlanType", VmNicVlanType_name, VmNicVlanType_value)
	proto.RegisterEnum("nutanix.uhura.VmNicType", VmNicType_name, VmNicType_value)
	proto.RegisterEnum("nutanix.uhura.NetworkFunctionNicType", NetworkFunctionNicType_name, NetworkFunctionNicType_value)
	proto.RegisterEnum("nutanix.uhura.DrsBehavior", DrsBehavior_name, DrsBehavior_value)
	proto.RegisterEnum("nutanix.uhura.GPUType", GPUType_name, GPUType_value)
	proto.RegisterEnum("nutanix.uhura.GPUVendor", GPUVendor_name, GPUVendor_value)
	proto.RegisterEnum("nutanix.uhura.GPUMode", GPUMode_name, GPUMode_value)
	proto.RegisterEnum("nutanix.uhura.PowerStateMechanism", PowerStateMechanism_name, PowerStateMechanism_value)
	proto.RegisterEnum("nutanix.uhura.VmStateTransition_Transition", VmStateTransition_Transition_name, VmStateTransition_Transition_value)
	proto.RegisterEnum("nutanix.uhura.AutomaticStartAction_Action", AutomaticStartAction_Action_name, AutomaticStartAction_Action_value)
	proto.RegisterEnum("nutanix.uhura.AutomaticStopAction_Action", AutomaticStopAction_Action_name, AutomaticStopAction_Action_value)
	proto.RegisterEnum("nutanix.uhura.VmDiskAddress_AdapterType", VmDiskAddress_AdapterType_name, VmDiskAddress_AdapterType_value)
	proto.RegisterEnum("nutanix.uhura.VmNfsFileConfig_Type", VmNfsFileConfig_Type_name, VmNfsFileConfig_Type_value)
	proto.RegisterEnum("nutanix.uhura.VmNicConfig_AdapterType", VmNicConfig_AdapterType_name, VmNicConfig_AdapterType_value)
	proto.RegisterEnum("nutanix.uhura.VmNicConfig_MacAddressType", VmNicConfig_MacAddressType_name, VmNicConfig_MacAddressType_value)
	proto.RegisterEnum("nutanix.uhura.VmNicConfig_IpAddress_NetworkIpType", VmNicConfig_IpAddress_NetworkIpType_name, VmNicConfig_IpAddress_NetworkIpType_value)
	proto.RegisterEnum("nutanix.uhura.VmBootDeviceType_Type", VmBootDeviceType_Type_name, VmBootDeviceType_Type_value)
	proto.RegisterEnum("nutanix.uhura.NetworkConfig_Type", NetworkConfig_Type_name, NetworkConfig_Type_value)
	proto.RegisterEnum("nutanix.uhura.NetworkConfig_ManagedType", NetworkConfig_ManagedType_name, NetworkConfig_ManagedType_value)
	proto.RegisterEnum("nutanix.uhura.NetworkConfig_NetworkType", NetworkConfig_NetworkType_name, NetworkConfig_NetworkType_value)
	proto.RegisterEnum("nutanix.uhura.CloudInitConfig_DatasourceType", CloudInitConfig_DatasourceType_name, CloudInitConfig_DatasourceType_value)
	proto.RegisterEnum("nutanix.uhura.VmSerialPortConfig_Type", VmSerialPortConfig_Type_name, VmSerialPortConfig_Type_value)
	proto.RegisterEnum("nutanix.uhura.VmConfig_VmType", VmConfig_VmType_name, VmConfig_VmType_value)
	proto.RegisterEnum("nutanix.uhura.Affinity_Policy", Affinity_Policy_name, Affinity_Policy_value)
	proto.RegisterEnum("nutanix.uhura.Affinity_Constraint", Affinity_Constraint_name, Affinity_Constraint_value)
	proto.RegisterEnum("nutanix.uhura.ManagedEntityStatus_Status", ManagedEntityStatus_Status_name, ManagedEntityStatus_Status_value)
	proto.RegisterEnum("nutanix.uhura.VmState_State", VmState_State_name, VmState_State_value)
	proto.RegisterEnum("nutanix.uhura.GuestToolsOperation_Operation", GuestToolsOperation_Operation_name, GuestToolsOperation_Operation_value)
	proto.RegisterEnum("nutanix.uhura.VmToolsRunningStatus_Status", VmToolsRunningStatus_Status_name, VmToolsRunningStatus_Status_value)
	proto.RegisterEnum("nutanix.uhura.VmToolsVersionStatus_Status", VmToolsVersionStatus_Status_name, VmToolsVersionStatus_Status_value)
	proto.RegisterEnum("nutanix.uhura.MappingType_Type", MappingType_Type_name, MappingType_Type_value)
	proto.RegisterType((*MetaRequest)(nil), "nutanix.uhura.MetaRequest")
	proto.RegisterType((*MetaResponse)(nil), "nutanix.uhura.MetaResponse")
	proto.RegisterType((*PayloadValue)(nil), "nutanix.uhura.PayloadValue")
	proto.RegisterType((*PayloadOrEmbeddedValue)(nil), "nutanix.uhura.PayloadOrEmbeddedValue")
	proto.RegisterType((*VmStateTransition)(nil), "nutanix.uhura.VmStateTransition")
	proto.RegisterType((*GenericKeyValuePair)(nil), "nutanix.uhura.GenericKeyValuePair")
	proto.RegisterType((*AutomaticStartAction)(nil), "nutanix.uhura.AutomaticStartAction")
	proto.RegisterType((*AutomaticStopAction)(nil), "nutanix.uhura.AutomaticStopAction")
	proto.RegisterType((*UhuraConfig)(nil), "nutanix.uhura.UhuraConfig")
	proto.RegisterType((*VmCreateConfig)(nil), "nutanix.uhura.VmCreateConfig")
	proto.RegisterType((*VmDiskCreateConfig)(nil), "nutanix.uhura.VmDiskCreateConfig")
	proto.RegisterType((*VmDiskSpecExisting)(nil), "nutanix.uhura.VmDiskSpecExisting")
	proto.RegisterType((*VmDiskCloneConfig)(nil), "nutanix.uhura.VmDiskCloneConfig")
	proto.RegisterType((*VmDiskSpecCloneExternal)(nil), "nutanix.uhura.VmDiskSpecCloneExternal")
	proto.RegisterType((*VmDiskSpecPassthruExternal)(nil), "nutanix.uhura.VmDiskSpecPassthruExternal")
	proto.RegisterType((*VmDiskAddress)(nil), "nutanix.uhura.VmDiskAddress")
	proto.RegisterType((*VmDiskInfo)(nil), "nutanix.uhura.VmDiskInfo")
	proto.RegisterType((*VmDiskConfig)(nil), "nutanix.uhura.VmDiskConfig")
	proto.RegisterType((*VmNfsFileConfig)(nil), "nutanix.uhura.VmNfsFileConfig")
	proto.RegisterType((*VmNicConfig)(nil), "nutanix.uhura.VmNicConfig")
	proto.RegisterType((*VmNicConfig_IpAddress)(nil), "nutanix.uhura.VmNicConfig.IpAddress")
	proto.RegisterType((*VmNicUpdateConfig)(nil), "nutanix.uhura.VmNicUpdateConfig")
	proto.RegisterType((*VmBootDeviceType)(nil), "nutanix.uhura.VmBootDeviceType")
	proto.RegisterType((*VmBootConfig)(nil), "nutanix.uhura.VmBootConfig")
	proto.RegisterType((*VmBootConfig_VmBootDevice)(nil), "nutanix.uhura.VmBootConfig.VmBootDevice")
	proto.RegisterType((*VmBootConfig_VmFirmwareConfig)(nil), "nutanix.uhura.VmBootConfig.VmFirmwareConfig")
	proto.RegisterType((*VmCloneConfig)(nil), "nutanix.uhura.VmCloneConfig")
	proto.RegisterType((*VmDiskCloneConfigDetails)(nil), "nutanix.uhura.VmDiskCloneConfigDetails")
	proto.RegisterType((*NetworkConfig)(nil), "nutanix.uhura.NetworkConfig")
	proto.RegisterType((*IPConfig)(nil), "nutanix.uhura.IPConfig")
	proto.RegisterType((*IPConfig_Route)(nil), "nutanix.uhura.IPConfig.Route")
	proto.RegisterType((*IPConfig_DHCPOption)(nil), "nutanix.uhura.IPConfig.DHCPOption")
	proto.RegisterType((*IPConfig_IpAddressPool)(nil), "nutanix.uhura.IPConfig.IpAddressPool")
	proto.RegisterType((*CloudInitConfig)(nil), "nutanix.uhura.CloudInitConfig")
	proto.RegisterType((*SysprepConfig)(nil), "nutanix.uhura.SysprepConfig")
	proto.RegisterType((*VmCustomizationConfig)(nil), "nutanix.uhura.VmCustomizationConfig")
	proto.RegisterType((*VmCustomizationConfig_FileToInject)(nil), "nutanix.uhura.VmCustomizationConfig.FileToInject")
	proto.RegisterType((*VmSerialPortConfig)(nil), "nutanix.uhura.VmSerialPortConfig")
	proto.RegisterType((*VmGPUConfig)(nil), "nutanix.uhura.VmGPUConfig")
	proto.RegisterType((*NodeGPU)(nil), "nutanix.uhura.NodeGPU")
	proto.RegisterType((*VmConfig)(nil), "nutanix.uhura.VmConfig")
	proto.RegisterType((*Affinity)(nil), "nutanix.uhura.Affinity")
	proto.RegisterType((*VmToVmAffinityConfig)(nil), "nutanix.uhura.VmToVmAffinityConfig")
	proto.RegisterType((*ManagedEntityStatus)(nil), "nutanix.uhura.ManagedEntityStatus")
	proto.RegisterType((*VmToVmAffinityInfo)(nil), "nutanix.uhura.VmToVmAffinityInfo")
	proto.RegisterType((*VmHypervisorInfo)(nil), "nutanix.uhura.VmHypervisorInfo")
	proto.RegisterType((*VmState)(nil), "nutanix.uhura.VmState")
	proto.RegisterType((*GuestToolsOperation)(nil), "nutanix.uhura.GuestToolsOperation")
	proto.RegisterType((*VmToolsRunningStatus)(nil), "nutanix.uhura.VmToolsRunningStatus")
	proto.RegisterType((*VmToolsVersionStatus)(nil), "nutanix.uhura.VmToolsVersionStatus")
	proto.RegisterType((*VmSnapshotInfo)(nil), "nutanix.uhura.VmSnapshotInfo")
	proto.RegisterType((*VmInfo)(nil), "nutanix.uhura.VmInfo")
	proto.RegisterType((*VmInfo_HypervisorVmInfo)(nil), "nutanix.uhura.VmInfo.HypervisorVmInfo")
	proto.RegisterType((*ServerInfo)(nil), "nutanix.uhura.ServerInfo")
	proto.RegisterType((*Vm)(nil), "nutanix.uhura.Vm")
	proto.RegisterType((*VirtualDisk)(nil), "nutanix.uhura.VirtualDisk")
	proto.RegisterType((*VirtualGpu)(nil), "nutanix.uhura.VirtualGpu")
	proto.RegisterType((*VirtualNic)(nil), "nutanix.uhura.VirtualNic")
	proto.RegisterType((*VirtualNetwork)(nil), "nutanix.uhura.VirtualNetwork")
	proto.RegisterType((*VmSnapshot)(nil), "nutanix.uhura.VmSnapshot")
	proto.RegisterType((*Node)(nil), "nutanix.uhura.Node")
	proto.RegisterType((*VmkernelNic)(nil), "nutanix.uhura.VmkernelNic")
	proto.RegisterType((*HostNic)(nil), "nutanix.uhura.HostNic")
	proto.RegisterType((*UuidMapping)(nil), "nutanix.uhura.UuidMapping")
	proto.RegisterType((*AffinityInfo)(nil), "nutanix.uhura.AffinityInfo")
	proto.RegisterType((*VMMetric)(nil), "nutanix.uhura.VMMetric")
	proto.RegisterType((*VDiskMetric)(nil), "nutanix.uhura.VDiskMetric")
	proto.RegisterType((*VNICMetric)(nil), "nutanix.uhura.VNICMetric")
	proto.RegisterType((*NodeMetric)(nil), "nutanix.uhura.NodeMetric")
	proto.RegisterType((*ManagementServerInfo)(nil), "nutanix.uhura.ManagementServerInfo")
	proto.RegisterType((*DatastoreConfig)(nil), "nutanix.uhura.DatastoreConfig")
	proto.RegisterType((*DatastoreConfig_NodeStatus)(nil), "nutanix.uhura.DatastoreConfig.NodeStatus")
	proto.RegisterType((*MappingType)(nil), "nutanix.uhura.MappingType")
	proto.RegisterType((*VmUuidMap)(nil), "nutanix.uhura.VmUuidMap")
	proto.RegisterType((*VirtualDiskUuidMap)(nil), "nutanix.uhura.VirtualDiskUuidMap")
	proto.RegisterType((*VirtualNicUuidMap)(nil), "nutanix.uhura.VirtualNicUuidMap")
	proto.RegisterType((*VirtualGpuUuidMap)(nil), "nutanix.uhura.VirtualGpuUuidMap")
	proto.RegisterType((*VmSnapshotUuidMap)(nil), "nutanix.uhura.VmSnapshotUuidMap")
	proto.RegisterType((*NodeGpuUuidMap)(nil), "nutanix.uhura.NodeGpuUuidMap")
	proto.RegisterType((*NodePhysicalNicUuidMap)(nil), "nutanix.uhura.NodePhysicalNicUuidMap")
	proto.RegisterType((*NodeVirtualNicUuidMap)(nil), "nutanix.uhura.NodeVirtualNicUuidMap")
	proto.RegisterType((*VirtualNetworkUuidMap)(nil), "nutanix.uhura.VirtualNetworkUuidMap")
	proto.RegisterType((*VirtualDeviceUuidMap)(nil), "nutanix.uhura.VirtualDeviceUuidMap")
	proto.RegisterType((*CerebroVmInfo)(nil), "nutanix.uhura.CerebroVmInfo")
	proto.RegisterType((*NgtVmInfo)(nil), "nutanix.uhura.NgtVmInfo")
	proto.RegisterType((*QosVmInfo)(nil), "nutanix.uhura.QosVmInfo")
}

func init() { proto.RegisterFile("uhura/uhura_types.proto", fileDescriptor_d39afc1bf0dda0b8) }

var fileDescriptor_d39afc1bf0dda0b8 = []byte{
	// 12739 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0xbd, 0x49, 0x70, 0x24, 0x47,
	0x96, 0x18, 0x3a, 0x99, 0x09, 0x20, 0x33, 0x5f, 0x2e, 0x08, 0x04, 0x50, 0x40, 0x16, 0x8a, 0xb5,
	0x25, 0x8b, 0xc5, 0x62, 0x91, 0x5d, 0x2c, 0x56, 0x91, 0x6c, 0xb2, 0xba, 0xd9, 0x3d, 0x28, 0xa0,
	0x16, 0x34, 0x09, 0x14, 0x3a, 0x80, 0xca, 0xe9, 0xdf, 0xb3, 0x44, 0x07, 0x22, 0x1c, 0x89, 0x68,
	0x64, 0x2c, 0x8c, 0x25, 0xab, 0xc0, 0x3f, 0xff, 0x4b, 0x33, 0xa3, 0x1e, 0xcd, 0x48, 0x1a, 0x49,
	0xa3, 0x83, 0x8e, 0x3a, 0xc8, 0x74, 0xd1, 0x1c, 0x75, 0xd2, 0x4d, 0x07, 0x9d, 0x74, 0x91, 0xc6,
	0x64, 0x92, 0x99, 0xcc, 0xe6, 0x32, 0x23, 0x93, 0x4c, 0x8b, 0x99, 0x4c, 0x26, 0x93, 0xc9, 0x24,
	0x9b, 0x8b, 0x64, 0xfe, 0x9e, 0x7b, 0x84, 0x47, 0x66, 0x24, 0x88, 0xe2, 0x32, 0xba, 0x00, 0x19,
	0xee, 0xcf, 0x9f, 0x2f, 0xe1, 0xfe, 0xfc, 0xed, 0x01, 0x6b, 0xe9, 0x71, 0x1a, 0x59, 0xef, 0xe2,
	0x5f, 0x33, 0x39, 0x0d, 0x59, 0x7c, 0x27, 0x8c, 0x82, 0x24, 0xd0, 0x3b, 0x7e, 0x9a, 0x58, 0xbe,
	0xfb, 0xf2, 0x0e, 0x56, 0xad, 0xaf, 0x1d, 0x9f, 0x86, 0x2c, 0x72, 0xfd, 0xe4, 0x5d, 0xf9, 0x83,
	0xe0, 0xd6, 0x7b, 0x5f, 0xb0, 0x34, 0x7e, 0xd7, 0x0e, 0xfc, 0x23, 0x77, 0x98, 0x46, 0x56, 0xe2,
	0x06, 0xbe, 0xa8, 0x29, 0xa0, 0x66, 0x51, 0x14, 0x44, 0x54, 0xd1, 0xff, 0x45, 0x05, 0x5a, 0x3b,
	0x2c, 0xb1, 0x0c, 0xf6, 0x79, 0xca, 0xe2, 0x44, 0xbf, 0x0a, 0x2d, 0x8f, 0x25, 0xc7, 0x81, 0x63,
	0xfa, 0x96, 0xc7, 0x7a, 0x95, 0x6b, 0x95, 0x5b, 0x4d, 0x03, 0xa8, 0x68, 0xd7, 0xf2, 0x98, 0xfe,
	0x5d, 0xa8, 0x59, 0xd1, 0xb0, 0x57, 0xbd, 0x56, 0xb9, 0xd5, 0xba, 0xf7, 0xc6, 0x9d, 0xc2, 0xc8,
	0xee, 0xec, 0x59, 0xa7, 0xa3, 0xc0, 0x72, 0x9e, 0x45, 0x8f, 0xbc, 0x43, 0xe6, 0x38, 0xcc, 0x19,
	0x58, 0xa3, 0x94, 0x19, 0xbc, 0x85, 0xfe, 0x1a, 0x34, 0x8f, 0x82, 0xe8, 0x85, 0x15, 0x39, 0xcc,
	0xe9, 0xd5, 0xae, 0x55, 0x6e, 0x35, 0x8c, 0xbc, 0xa0, 0xff, 0x0f, 0x2b, 0xd0, 0xa6, 0x71, 0xc4,
	0x61, 0xe0, 0xc7, 0x4c, 0xff, 0x04, 0x00, 0xc7, 0x69, 0xda, 0x81, 0x43, 0xe3, 0xe8, 0xde, 0xbb,
	0x32, 0xd1, 0xdd, 0x73, 0xfe, 0xf7, 0x11, 0xce, 0xe6, 0xe0, 0x34, 0x64, 0x46, 0x13, 0x5b, 0x6c,
	0x06, 0x0e, 0xd3, 0xaf, 0x43, 0x9b, 0x9a, 0x3b, 0x2c, 0xb1, 0xdc, 0x11, 0x8e, 0xb7, 0x69, 0xb4,
	0xb0, 0x6c, 0x0b, 0x8b, 0xf8, 0x4c, 0x22, 0x96, 0xe0, 0x50, 0xce, 0x3f, 0x93, 0x88, 0x25, 0xfd,
	0x07, 0xd0, 0x16, 0xd5, 0x58, 0xa8, 0xaf, 0xc2, 0x42, 0x70, 0x74, 0x14, 0xb3, 0x04, 0x87, 0x39,
	0x67, 0x88, 0x27, 0x5d, 0x87, 0xb9, 0xd8, 0xfd, 0x82, 0x61, 0xdf, 0x73, 0x06, 0xfe, 0xee, 0x9f,
	0xc0, 0x6a, 0x39, 0x6a, 0xfd, 0x03, 0xa8, 0x87, 0x54, 0x83, 0x68, 0x5a, 0xf7, 0x2e, 0x95, 0x0f,
	0x89, 0x06, 0x22, 0x61, 0xf5, 0x75, 0x68, 0x30, 0x81, 0x07, 0x3b, 0x6a, 0x1b, 0xd9, 0x73, 0xff,
	0xcf, 0x2b, 0xb0, 0x34, 0xf0, 0xf6, 0x13, 0x2b, 0x61, 0x07, 0x91, 0xe5, 0xc7, 0x2e, 0xdf, 0x11,
	0xfd, 0x7f, 0x57, 0x01, 0xc8, 0x1f, 0xf5, 0x36, 0x34, 0x4e, 0xf6, 0x82, 0x17, 0x2c, 0x7a, 0xe6,
	0x6b, 0x15, 0xbd, 0x03, 0x4d, 0xf1, 0x74, 0x74, 0xa4, 0x55, 0xf5, 0x45, 0x68, 0xd1, 0xe3, 0xe6,
	0xa9, 0x3d, 0x62, 0x5a, 0x4d, 0x07, 0x58, 0x38, 0x31, 0x58, 0xcc, 0x12, 0x6d, 0x0e, 0x7f, 0xef,
	0x59, 0x69, 0xcc, 0xb4, 0x79, 0xc4, 0xb2, 0x9f, 0xc6, 0x21, 0xf3, 0x1d, 0x6d, 0x41, 0x6f, 0x41,
	0x9d, 0x43, 0xa5, 0x1e, 0xd3, 0xea, 0xfa, 0x12, 0x74, 0x4e, 0x36, 0xec, 0xd0, 0xdd, 0x3f, 0x4e,
	0x13, 0x27, 0x78, 0xe1, 0x6b, 0x0d, 0x44, 0xcb, 0x8b, 0x0c, 0x76, 0x18, 0x04, 0x89, 0xd6, 0xc4,
	0x6e, 0xb3, 0x7a, 0xd0, 0x9b, 0x30, 0x7f, 0xb2, 0x6f, 0x8d, 0x99, 0xd6, 0xc2, 0xd6, 0x5b, 0x6e,
	0x6c, 0x5b, 0x91, 0xc3, 0x4b, 0x1c, 0xad, 0xad, 0xeb, 0xd0, 0x3d, 0x79, 0xc2, 0x77, 0x6b, 0xd6,
	0xa2, 0xa3, 0x6b, 0xd0, 0xa6, 0x32, 0x81, 0xb2, 0xdb, 0xff, 0x04, 0x96, 0x9f, 0x30, 0x9f, 0x45,
	0xae, 0xfd, 0x29, 0x3b, 0xc5, 0x45, 0xdb, 0xb3, 0xdc, 0x48, 0xd7, 0xa0, 0x76, 0xc2, 0x4e, 0xc5,
	0xc6, 0xe6, 0x3f, 0xf5, 0x15, 0x98, 0x1f, 0xf3, 0x6a, 0xb1, 0x47, 0xe8, 0xa1, 0xff, 0x0c, 0x56,
	0x36, 0xd2, 0x24, 0xf0, 0xac, 0xc4, 0xb5, 0xf7, 0x13, 0x2b, 0x4a, 0x36, 0x6c, 0x5c, 0xbd, 0xef,
	0xc2, 0x02, 0xfd, 0xc2, 0x29, 0xef, 0x06, 0xc9, 0xb1, 0xeb, 0x0f, 0xb5, 0x8a, 0xbe, 0x0c, 0x8b,
	0x27, 0x08, 0xb7, 0x7d, 0x64, 0xa4, 0xbe, 0xcf, 0x0b, 0xab, 0xb8, 0x42, 0x58, 0xa8, 0xd5, 0xfa,
	0x4f, 0x60, 0x59, 0x41, 0x18, 0x84, 0x02, 0xdf, 0xdd, 0x02, 0xbe, 0x83, 0x34, 0xf2, 0xf9, 0xca,
	0x57, 0xf2, 0x25, 0xa8, 0x66, 0x8b, 0xb3, 0xc5, 0xa7, 0x5a, 0xeb, 0xff, 0x49, 0x15, 0x5a, 0xb8,
	0xf3, 0x37, 0xf1, 0xa0, 0xf3, 0x6d, 0x96, 0xa6, 0x2e, 0xed, 0x9a, 0xb6, 0x81, 0xbf, 0xf5, 0x0d,
	0xb8, 0x42, 0x67, 0xdd, 0x75, 0x8e, 0xcc, 0xb1, 0x67, 0xc6, 0x7c, 0x0f, 0x98, 0x69, 0xe8, 0xf0,
	0x7f, 0x4e, 0xe0, 0xd3, 0x64, 0x1b, 0xc6, 0x45, 0x84, 0xda, 0x76, 0x8e, 0xc4, 0x36, 0x79, 0x8e,
	0x10, 0x5b, 0x81, 0xcf, 0xf4, 0x47, 0x70, 0x2d, 0x47, 0x71, 0x34, 0xb2, 0xe2, 0x63, 0xd3, 0x0b,
	0x9c, 0x22, 0x12, 0x3a, 0xc6, 0x97, 0x24, 0x92, 0xc7, 0x1c, 0x6a, 0x27, 0x70, 0x54, 0x34, 0x5b,
	0x70, 0x95, 0xd0, 0x28, 0x28, 0x22, 0x66, 0x07, 0xbe, 0xed, 0x8e, 0x04, 0x96, 0x39, 0x05, 0x4b,
	0x86, 0xc2, 0x90, 0x30, 0x88, 0xe5, 0x18, 0xee, 0x4d, 0x61, 0x71, 0xdc, 0xd8, 0x3a, 0x1c, 0x31,
	0x87, 0xff, 0x38, 0x89, 0x4d, 0x27, 0x0d, 0x47, 0xae, 0x6d, 0x25, 0x2c, 0x36, 0x23, 0xe6, 0x05,
	0x63, 0xe6, 0xf4, 0xe6, 0x11, 0xf1, 0x3b, 0x45, 0xc4, 0x5b, 0xa2, 0xd9, 0x16, 0x6f, 0xb5, 0x95,
	0x35, 0x32, 0xa8, 0x4d, 0xff, 0x77, 0x1a, 0xd0, 0x1d, 0x78, 0x9b, 0x11, 0xb3, 0x12, 0x96, 0x2f,
	0xb0, 0x42, 0x0c, 0xf1, 0xb7, 0x7e, 0x05, 0xc0, 0xf2, 0xfd, 0x20, 0x41, 0x22, 0x2b, 0x76, 0x8e,
	0x52, 0xa2, 0x5f, 0x82, 0xa6, 0x9f, 0x7a, 0xe6, 0xd8, 0x0e, 0xd3, 0x18, 0x97, 0x69, 0xce, 0x68,
	0xf8, 0xa9, 0x37, 0xe0, 0xcf, 0xfa, 0xdb, 0xa0, 0xf3, 0x4a, 0x3b, 0x88, 0x58, 0x6c, 0x86, 0x2c,
	0x42, 0x30, 0x5c, 0x86, 0x9a, 0xb1, 0xe8, 0xa7, 0xde, 0x26, 0xaf, 0xd8, 0x63, 0x11, 0x87, 0xd6,
	0x6f, 0x40, 0xd7, 0x63, 0x5e, 0x10, 0x9d, 0x9a, 0x9c, 0x80, 0x98, 0xde, 0x21, 0x4e, 0x6b, 0xce,
	0x68, 0x53, 0xe9, 0xbe, 0xfb, 0x05, 0xdb, 0x39, 0xd4, 0x3f, 0x82, 0x26, 0x5f, 0x06, 0x73, 0xe4,
	0xc6, 0x49, 0x6f, 0xe1, 0x5a, 0xad, 0x84, 0x7e, 0x0c, 0x3c, 0x3e, 0x65, 0x9a, 0x93, 0xd1, 0xe0,
	0xd0, 0x9f, 0xb9, 0x71, 0xa2, 0x7f, 0x00, 0x0d, 0xdf, 0xb5, 0xa9, 0x61, 0x1d, 0x1b, 0xae, 0x4f,
	0x35, 0xdc, 0x75, 0x6d, 0xd1, 0xae, 0xee, 0xbb, 0x36, 0x36, 0xfb, 0x3e, 0xb4, 0xf8, 0x41, 0x33,
	0xe9, 0xb6, 0xe9, 0x35, 0x4a, 0x49, 0xd6, 0xc0, 0x7b, 0x18, 0x04, 0x89, 0x68, 0x0a, 0x87, 0xd9,
	0x6f, 0xfd, 0x0e, 0x68, 0xc7, 0x2f, 0xec, 0x51, 0x60, 0x9f, 0x98, 0x89, 0xeb, 0xb1, 0x2f, 0xf8,
	0x36, 0x68, 0xf2, 0x45, 0x7c, 0x50, 0x7b, 0x7e, 0xb0, 0x69, 0x2c, 0x8a, 0xca, 0x03, 0x51, 0xc7,
	0xaf, 0xa5, 0x63, 0xcb, 0x0c, 0x23, 0x37, 0x88, 0xdc, 0xe4, 0xb4, 0x07, 0xb8, 0x54, 0x70, 0x6c,
	0xed, 0x89, 0x12, 0xfd, 0x3e, 0xac, 0xda, 0x87, 0x91, 0xe9, 0xf3, 0x11, 0x59, 0x21, 0x7f, 0xc1,
	0x66, 0xc4, 0xac, 0x38, 0xf0, 0x7b, 0x2d, 0x7c, 0x37, 0xcb, 0xf6, 0x61, 0xb4, 0x1b, 0x24, 0x9b,
	0x54, 0x67, 0x60, 0x95, 0xfe, 0x29, 0x68, 0x31, 0x8b, 0x5c, 0x6b, 0x64, 0x86, 0x41, 0x94, 0xd0,
	0x12, 0xb4, 0x71, 0x09, 0xae, 0x4f, 0x4d, 0x64, 0x1f, 0x01, 0xf7, 0x82, 0x48, 0x4e, 0xa7, 0x1b,
	0x67, 0x25, 0xb8, 0x20, 0xf7, 0xa1, 0x61, 0x1d, 0x1d, 0xb9, 0x3e, 0x1f, 0x5f, 0x07, 0x57, 0x63,
	0x6d, 0x02, 0xc9, 0x86, 0xa8, 0x36, 0x32, 0x40, 0xfd, 0x1a, 0x34, 0xac, 0x21, 0xf3, 0x13, 0x73,
	0xec, 0xf5, 0xba, 0x7c, 0xb7, 0x3e, 0x98, 0x3f, 0xb2, 0x46, 0x31, 0x33, 0xea, 0x58, 0x3c, 0xf0,
	0xf4, 0x87, 0xb0, 0x38, 0x0c, 0x53, 0xb1, 0xcc, 0x34, 0xc4, 0xc5, 0x19, 0x6f, 0xe9, 0xc9, 0xde,
	0x73, 0x31, 0xb6, 0xce, 0x30, 0x4c, 0xe9, 0x27, 0x0e, 0xed, 0x5d, 0x58, 0xe1, 0xfb, 0x2d, 0x39,
	0x8e, 0x98, 0xe5, 0xd0, 0x8e, 0xe3, 0x7b, 0xaf, 0xa7, 0xe1, 0x32, 0x2e, 0xf9, 0xa9, 0x77, 0x40,
	0x55, 0x7b, 0x2c, 0xe2, 0x7b, 0x4f, 0xef, 0x43, 0x87, 0x6f, 0x49, 0xf3, 0xd8, 0x8a, 0x1c, 0x33,
	0x74, 0xfd, 0xde, 0x12, 0x9e, 0xa4, 0x16, 0x2f, 0x7c, 0x6a, 0x45, 0xce, 0x9e, 0xeb, 0xeb, 0x37,
	0x61, 0x11, 0x77, 0xb8, 0x9f, 0x7a, 0x96, 0xe9, 0x07, 0x0e, 0x8b, 0x7b, 0x3a, 0x6e, 0xcc, 0x0e,
	0xdf, 0xe7, 0xbc, 0x74, 0x97, 0x17, 0xea, 0x77, 0x60, 0x91, 0xa3, 0x0a, 0xad, 0x38, 0x4e, 0x8e,
	0xa3, 0x20, 0x1d, 0x1e, 0xf7, 0x96, 0xd5, 0x99, 0x76, 0xed, 0x30, 0xdd, 0xcb, 0x2b, 0xf5, 0xbb,
	0xa0, 0x89, 0x93, 0x6d, 0x1e, 0x46, 0x96, 0xef, 0xb8, 0xfe, 0xb0, 0xb7, 0xa2, 0x36, 0x58, 0x14,
	0xd5, 0x0f, 0x45, 0xad, 0xfe, 0x06, 0xb4, 0x3d, 0xcb, 0x3e, 0x76, 0x7d, 0x86, 0x5c, 0x53, 0xef,
	0x02, 0x6e, 0xa4, 0x6a, 0x68, 0x1b, 0x2d, 0x51, 0xce, 0xb9, 0x03, 0xfd, 0x36, 0x74, 0xad, 0xd1,
	0x28, 0x78, 0x61, 0x1e, 0x07, 0x89, 0x19, 0x8e, 0xd2, 0x61, 0x6f, 0x15, 0xd1, 0xce, 0x25, 0x51,
	0xca, 0x8c, 0x36, 0xd6, 0x3d, 0x0d, 0x92, 0xbd, 0x51, 0x3a, 0xec, 0xff, 0xd3, 0x0a, 0xe8, 0xe2,
	0xbc, 0xa8, 0x94, 0xe0, 0x1a, 0xb4, 0xf1, 0x94, 0xc9, 0x93, 0x48, 0xf7, 0x3d, 0xf0, 0x32, 0x71,
	0x0e, 0xdf, 0x80, 0xae, 0x1d, 0xf8, 0x89, 0xe5, 0xfa, 0x2c, 0x32, 0x91, 0x2c, 0xd3, 0xa5, 0xdc,
	0xc9, 0x4a, 0x9f, 0x73, 0xfa, 0x7c, 0x49, 0x1c, 0xd7, 0xd0, 0x4a, 0x8e, 0x91, 0x3c, 0x34, 0xe9,
	0x44, 0xee, 0x59, 0xc9, 0x31, 0xdf, 0xec, 0x63, 0x0f, 0xab, 0x11, 0xc1, 0x1c, 0x22, 0x00, 0x2a,
	0xc2, 0xd6, 0x37, 0x61, 0x31, 0x1f, 0xc6, 0xe1, 0x69, 0xc2, 0x62, 0x41, 0x13, 0x3a, 0x72, 0x24,
	0x0f, 0x79, 0x61, 0xff, 0x8f, 0xaa, 0x72, 0x16, 0xfb, 0x21, 0xb3, 0x1f, 0xbd, 0x74, 0xe3, 0x84,
	0xaf, 0x57, 0xa1, 0xf3, 0xca, 0xd9, 0x9d, 0x57, 0xa7, 0x3a, 0xbf, 0x0e, 0xed, 0x7c, 0x86, 0xae,
	0x23, 0x88, 0x5b, 0x2b, 0x2b, 0xdb, 0x76, 0x4a, 0x16, 0x61, 0xae, 0x6c, 0x11, 0x3e, 0x84, 0x5e,
	0x1a, 0x33, 0x73, 0x3c, 0x34, 0xdd, 0xd8, 0x8e, 0x5d, 0x33, 0xb1, 0xa2, 0x21, 0x4b, 0x88, 0xf1,
	0x24, 0xd2, 0xbd, 0x92, 0xc6, 0x6c, 0x30, 0xdc, 0xe6, 0xb5, 0x07, 0x58, 0x89, 0x2c, 0xe8, 0x3b,
	0xa0, 0xc7, 0x41, 0x1a, 0xd9, 0xcc, 0x54, 0x47, 0xba, 0x80, 0x5d, 0x68, 0x54, 0x33, 0x28, 0x2c,
	0x96, 0x80, 0xf6, 0x8f, 0x62, 0x9a, 0x73, 0x1d, 0xe7, 0xdc, 0xa1, 0xe2, 0xdd, 0xa3, 0x98, 0x4f,
	0xbc, 0xff, 0xcf, 0xaa, 0x9c, 0x59, 0xc2, 0x57, 0x3e, 0x0a, 0x7c, 0xf9, 0xc6, 0x3f, 0x16, 0x6b,
	0x65, 0x39, 0x4e, 0x24, 0xf8, 0xb2, 0xd7, 0x4a, 0xe9, 0xea, 0x86, 0xe3, 0x44, 0x2c, 0x8e, 0x69,
	0x25, 0xf9, 0xc3, 0x79, 0xb7, 0xc2, 0x1d, 0x58, 0x8e, 0x7d, 0x2b, 0x8c, 0xf9, 0xae, 0x1c, 0x46,
	0x41, 0x1a, 0x12, 0x6c, 0x0d, 0x61, 0x97, 0x64, 0xd5, 0x13, 0x5e, 0x83, 0xf0, 0xfc, 0x3e, 0x70,
	0x7d, 0xf5, 0xdd, 0xd3, 0xc5, 0xd1, 0xf6, 0x5c, 0x3f, 0x7b, 0xf5, 0x78, 0x3a, 0xd9, 0x8b, 0xc2,
	0x02, 0xcd, 0x53, 0xef, 0x3e, 0x7b, 0xa1, 0xac, 0xce, 0xb7, 0xb3, 0x96, 0xbf, 0x55, 0x81, 0xb5,
	0x7c, 0xe3, 0xe1, 0x7a, 0x3e, 0x7a, 0x99, 0xb0, 0xc8, 0xb7, 0x46, 0x25, 0xe3, 0xaf, 0x88, 0xfb,
	0x4c, 0x1d, 0xff, 0x39, 0x17, 0xef, 0x22, 0x34, 0x68, 0xd4, 0xd1, 0x48, 0x1c, 0xa3, 0x3a, 0x0e,
	0x36, 0x1a, 0xf5, 0x7f, 0x03, 0xd6, 0xf3, 0x21, 0x08, 0x02, 0x93, 0x66, 0xa3, 0x98, 0xc6, 0x5f,
	0xf9, 0x32, 0xfc, 0xd5, 0x22, 0xfe, 0x7f, 0x55, 0x83, 0x4e, 0xe1, 0xd5, 0xeb, 0x9f, 0x42, 0xdb,
	0x72, 0xac, 0x30, 0x61, 0x11, 0xd1, 0x21, 0x12, 0x5a, 0x6e, 0x9d, 0xb5, 0x5d, 0xee, 0x6c, 0x50,
	0x03, 0x14, 0x5f, 0x5a, 0x56, 0xfe, 0xc0, 0x8f, 0x99, 0xc3, 0xc6, 0xae, 0xcd, 0x4c, 0xd7, 0x77,
	0xd8, 0x4b, 0xec, 0x7d, 0xde, 0x68, 0x51, 0xd9, 0x36, 0x2f, 0x9a, 0x3c, 0xaa, 0xb5, 0xa9, 0xa3,
	0x7a, 0x11, 0x1a, 0xd9, 0x7b, 0x9a, 0xa3, 0xd1, 0xfb, 0xf4, 0x86, 0xf4, 0xcb, 0xd0, 0x70, 0x63,
	0xd3, 0x76, 0xa2, 0xc0, 0xa3, 0xb3, 0xf6, 0xb0, 0xda, 0xab, 0x18, 0x75, 0x37, 0xde, 0xe4, 0x45,
	0xfa, 0x65, 0x00, 0x62, 0x27, 0xac, 0x43, 0x36, 0xc2, 0xed, 0xd0, 0x34, 0xf0, 0x20, 0x7c, 0xc6,
	0x0b, 0xf4, 0xab, 0xd0, 0x88, 0xac, 0x17, 0xc8, 0x78, 0xe1, 0x06, 0x90, 0x44, 0xb4, 0x1e, 0x59,
	0x2f, 0xf8, 0xec, 0xf4, 0xdb, 0xb0, 0x34, 0x0e, 0x46, 0xa9, 0xc7, 0xd4, 0x2d, 0xdd, 0xc0, 0x01,
	0x2e, 0x52, 0x45, 0xbe, 0xa1, 0x0b, 0xe4, 0xa8, 0x39, 0x4d, 0x8e, 0xc4, 0x32, 0x20, 0x0a, 0xa0,
	0x39, 0x52, 0x11, 0x6f, 0xdd, 0xdf, 0x85, 0x96, 0xb2, 0x86, 0xc4, 0x36, 0x6f, 0xee, 0x6f, 0x6b,
	0xbf, 0xa4, 0x37, 0x60, 0xee, 0x64, 0x7b, 0xeb, 0x91, 0x56, 0xc1, 0x5f, 0x7b, 0x9b, 0xdb, 0x5a,
	0x95, 0xaa, 0x37, 0x0e, 0x36, 0x84, 0x24, 0xb3, 0xbf, 0xb7, 0xb1, 0x67, 0x68, 0x73, 0x58, 0xbc,
	0x3b, 0xd8, 0x79, 0xa4, 0xcd, 0xf7, 0xff, 0xe5, 0x1c, 0x00, 0xbd, 0xa2, 0x6d, 0xff, 0x28, 0xf8,
	0x3a, 0xe7, 0xff, 0x22, 0x2e, 0x31, 0xf3, 0xc2, 0xe4, 0x54, 0x70, 0xdb, 0x75, 0x37, 0x7e, 0xc4,
	0x1f, 0xf9, 0x99, 0x77, 0x63, 0x93, 0x8b, 0x0e, 0x66, 0x18, 0x05, 0x63, 0x37, 0x76, 0x03, 0x3f,
	0x93, 0x8a, 0x97, 0xdc, 0xf8, 0xe0, 0xd8, 0xf5, 0xf7, 0xf2, 0x0a, 0xfd, 0x47, 0x93, 0xa7, 0x14,
	0x87, 0x33, 0x77, 0x8e, 0xe1, 0x14, 0xce, 0x30, 0x0e, 0x6b, 0x15, 0x16, 0xe2, 0x63, 0x2b, 0xca,
	0xd8, 0x63, 0xf1, 0x34, 0x45, 0xd7, 0x17, 0x90, 0xaa, 0x14, 0xe8, 0xfa, 0x47, 0xd0, 0x43, 0x42,
	0xad, 0xdc, 0xe5, 0x26, 0xf3, 0x91, 0x9b, 0xa6, 0x6d, 0x60, 0xac, 0xf2, 0x7a, 0xe5, 0x36, 0x7f,
	0x44, 0xb5, 0xfa, 0x7d, 0xd0, 0x15, 0xce, 0x5d, 0xb6, 0x69, 0xa8, 0xd7, 0xba, 0x76, 0x24, 0x39,
	0x74, 0xd9, 0xe8, 0x32, 0x80, 0x42, 0x25, 0x9a, 0x38, 0x9e, 0x66, 0x9c, 0x91, 0x88, 0x8b, 0xca,
	0x16, 0x06, 0xb9, 0xbe, 0xb4, 0x7d, 0x37, 0xe1, 0x2a, 0x2e, 0x13, 0x7b, 0x99, 0x70, 0xe6, 0xea,
	0x88, 0x8b, 0x1a, 0x7c, 0x7b, 0xe1, 0xdd, 0x42, 0x4c, 0x54, 0xeb, 0x5a, 0xed, 0x56, 0xd3, 0x58,
	0xe7, 0x60, 0x8f, 0x10, 0xea, 0xb1, 0x3b, 0x62, 0x7c, 0xcb, 0xf1, 0x2b, 0x06, 0xb9, 0xa6, 0xeb,
	0xd0, 0xe6, 0xf8, 0x03, 0xdf, 0x67, 0x76, 0xc2, 0x9c, 0x5e, 0x9b, 0x78, 0x20, 0x37, 0xde, 0x94,
	0x45, 0x78, 0x11, 0x5b, 0x89, 0x65, 0x8a, 0x97, 0xc3, 0xa9, 0x44, 0x87, 0xe8, 0x21, 0x2f, 0xde,
	0xc7, 0x52, 0x4e, 0x2b, 0xfe, 0x78, 0x1e, 0xda, 0x2a, 0xfb, 0xfd, 0x17, 0x4e, 0x2a, 0xd4, 0xb5,
	0xaa, 0x15, 0xd7, 0x4a, 0xdd, 0xa6, 0x73, 0xe7, 0xda, 0xa6, 0xf3, 0xb3, 0xb6, 0xe9, 0x87, 0x30,
	0x6f, 0x73, 0x5a, 0x8f, 0x7b, 0xa7, 0x75, 0xef, 0x5a, 0xb9, 0x00, 0x92, 0xdf, 0xae, 0x06, 0x81,
	0xeb, 0x1f, 0xc3, 0x82, 0x8d, 0x6c, 0x16, 0xee, 0xa2, 0x32, 0xee, 0x7b, 0x92, 0x13, 0x33, 0x44,
	0x03, 0xfd, 0x13, 0x68, 0x30, 0xc1, 0xd7, 0xe0, 0x26, 0x98, 0xd5, 0x58, 0x65, 0x80, 0x8c, 0xac,
	0x49, 0x81, 0x42, 0x36, 0x8a, 0x14, 0xf2, 0xac, 0xcd, 0xde, 0x3c, 0x73, 0xb3, 0x17, 0x08, 0x5a,
	0xeb, 0x6c, 0x82, 0xd6, 0x9e, 0x24, 0x68, 0xfa, 0x0e, 0x74, 0x71, 0x55, 0x70, 0xf3, 0xf2, 0xbb,
	0x4a, 0x48, 0x13, 0x37, 0x67, 0xce, 0xab, 0x70, 0xbf, 0x1a, 0x1d, 0xbb, 0x70, 0xdd, 0x0e, 0x60,
	0x49, 0xcc, 0x20, 0xcd, 0x31, 0x76, 0x11, 0xe3, 0x5b, 0x33, 0x31, 0x4e, 0x5e, 0x97, 0x86, 0x16,
	0x4e, 0x94, 0xf4, 0xff, 0x49, 0x05, 0x16, 0x07, 0xde, 0xee, 0x51, 0xcc, 0xcf, 0x8d, 0xd8, 0xd5,
	0x7d, 0xe8, 0xf0, 0xd5, 0xcc, 0x8e, 0x9b, 0x60, 0x2e, 0x5b, 0x3e, 0x41, 0xe1, 0xfc, 0xbf, 0x0b,
	0x73, 0xb8, 0xe3, 0xab, 0xb8, 0xe3, 0x5f, 0x9f, 0x16, 0x35, 0x55, 0x8c, 0xa4, 0xd6, 0xc3, 0x06,
	0xfd, 0x67, 0x30, 0x87, 0xbb, 0xbd, 0x05, 0x75, 0x71, 0x8a, 0x04, 0x65, 0xff, 0x2c, 0x18, 0x0a,
	0xca, 0xce, 0x87, 0xaf, 0xd5, 0x48, 0x91, 0xe2, 0x85, 0xf8, 0x34, 0x47, 0xda, 0x13, 0xc1, 0x45,
	0x69, 0xf3, 0x74, 0x2b, 0xec, 0x3f, 0xd3, 0x16, 0xfa, 0xbf, 0x68, 0x43, 0x4b, 0x11, 0x6d, 0xf9,
	0x5e, 0xf0, 0x2c, 0x3b, 0xa7, 0xf4, 0x6d, 0xa3, 0xee, 0x59, 0x36, 0xd2, 0xcc, 0x2d, 0x68, 0x8e,
	0xee, 0x49, 0x51, 0x97, 0x54, 0x9f, 0xf9, 0xc8, 0x33, 0x25, 0xec, 0xc0, 0xfb, 0xec, 0xde, 0x2e,
	0x4b, 0x5e, 0x04, 0x91, 0x18, 0x20, 0xde, 0xa9, 0x8d, 0xd1, 0x3d, 0xd1, 0xc1, 0x0a, 0xcc, 0x73,
	0xf2, 0x27, 0x39, 0x15, 0x7a, 0xd0, 0xdf, 0x87, 0x95, 0x88, 0x94, 0xaf, 0xcc, 0x31, 0xdd, 0x10,
	0xfb, 0x67, 0x31, 0x71, 0x75, 0x6d, 0xc4, 0xa0, 0x67, 0xf5, 0xdb, 0xa1, 0xe4, 0x35, 0x1e, 0x42,
	0x73, 0x3c, 0xb2, 0x7c, 0xa4, 0xa7, 0x78, 0x20, 0xbb, 0x25, 0x17, 0xc1, 0xae, 0x6b, 0x0f, 0x46,
	0x96, 0xcf, 0x97, 0xed, 0x41, 0xfd, 0x64, 0xc3, 0xb6, 0xf1, 0x82, 0xe2, 0xed, 0x38, 0x99, 0xd5,
	0xdf, 0x02, 0x2d, 0x89, 0x52, 0xff, 0x84, 0x39, 0xa6, 0x4f, 0xc3, 0x8e, 0x51, 0x75, 0x30, 0x6f,
	0x2c, 0x8a, 0x72, 0x31, 0x9b, 0x58, 0x7f, 0x1d, 0x40, 0x0c, 0xc2, 0x74, 0xc3, 0xc2, 0x95, 0xdf,
	0x14, 0xe5, 0xdb, 0xa1, 0xbe, 0x06, 0x75, 0x94, 0xa3, 0xc5, 0x55, 0xdf, 0x34, 0x16, 0xf8, 0xe3,
	0xb6, 0xc3, 0x27, 0x4e, 0x8c, 0x04, 0xdd, 0xee, 0xf4, 0xa0, 0xef, 0x4f, 0xd0, 0x40, 0xc0, 0x59,
	0xdc, 0x9c, 0xad, 0x7c, 0x50, 0x29, 0xe0, 0x83, 0xc6, 0xc9, 0xc0, 0x7b, 0xe9, 0xb3, 0xe4, 0xfe,
	0x14, 0x2d, 0x14, 0x73, 0xa1, 0xf3, 0xd5, 0xc2, 0x17, 0xd9, 0x12, 0x65, 0x42, 0x80, 0x01, 0x65,
	0x99, 0xdb, 0xd9, 0x32, 0x37, 0xdd, 0x6c, 0x75, 0x3f, 0x12, 0x9b, 0xb4, 0x83, 0x43, 0xea, 0x95,
	0x0d, 0x09, 0x07, 0x01, 0x27, 0xbb, 0x41, 0xe4, 0x59, 0xa3, 0x5d, 0xd7, 0xa6, 0x5d, 0xaa, 0xff,
	0x0c, 0x2e, 0xca, 0xfe, 0x8f, 0x52, 0x1f, 0x15, 0x7b, 0xa6, 0xef, 0xda, 0x34, 0xc3, 0x2e, 0xa2,
	0x9b, 0x54, 0x35, 0x8b, 0x45, 0x7e, 0x2c, 0xc0, 0x05, 0x6e, 0x63, 0xd5, 0x2f, 0x2d, 0xd7, 0x3f,
	0x81, 0x4b, 0x53, 0x3d, 0xd8, 0xc7, 0x96, 0xeb, 0xd3, 0x84, 0x17, 0x71, 0xc2, 0xbd, 0x89, 0xc6,
	0x9b, 0x1c, 0x00, 0x67, 0xbf, 0x0f, 0x9a, 0xdc, 0xe5, 0x2c, 0x8e, 0x69, 0x5c, 0x3a, 0x8e, 0xeb,
	0xad, 0x33, 0x56, 0x7e, 0x87, 0x0e, 0x02, 0x8b, 0x63, 0x1c, 0x5b, 0xd7, 0x2b, 0x3c, 0xeb, 0xaf,
	0x41, 0x33, 0xbf, 0x27, 0x97, 0x49, 0xb7, 0x9f, 0x15, 0xe8, 0x9f, 0xc1, 0x62, 0xbe, 0xe0, 0x74,
	0xfb, 0xae, 0xa2, 0x0a, 0xe3, 0xc6, 0x19, 0x3d, 0x66, 0x5b, 0xdd, 0xe8, 0x64, 0xef, 0x05, 0xaf,
	0xe5, 0x3d, 0xd0, 0x25, 0x1d, 0x33, 0xad, 0x24, 0x89, 0x08, 0xe1, 0x1a, 0x22, 0xec, 0x4f, 0x20,
	0x2c, 0x51, 0x00, 0x1b, 0x9a, 0x6c, 0xbd, 0x91, 0x24, 0x11, 0x62, 0x94, 0x0a, 0xd4, 0x9e, 0xa2,
	0x40, 0x5d, 0x83, 0x3a, 0x9e, 0x2f, 0xd7, 0xe9, 0x5d, 0xbc, 0x56, 0xb9, 0xd5, 0x31, 0x16, 0xf8,
	0xe3, 0x36, 0xe7, 0xa9, 0x17, 0x3e, 0x4f, 0x59, 0xca, 0xe2, 0xde, 0x3a, 0x2f, 0x7f, 0x50, 0x79,
	0xcf, 0x10, 0x05, 0xea, 0xde, 0x43, 0x19, 0xf6, 0x92, 0xa0, 0x7e, 0x54, 0xc6, 0xf9, 0x8a, 0xf5,
	0x3f, 0xab, 0x40, 0x33, 0x3f, 0xc4, 0x3f, 0x03, 0x9d, 0x2f, 0x4c, 0x1c, 0xbb, 0x43, 0xdf, 0xe3,
	0x8c, 0x8a, 0xc2, 0x0b, 0xdc, 0x3b, 0xcf, 0xda, 0xc8, 0xbd, 0xb3, 0x1d, 0xe2, 0x6b, 0xd1, 0xdc,
	0x70, 0x23, 0x43, 0x26, 0x8f, 0x83, 0x1b, 0x8e, 0xdf, 0xcf, 0x76, 0x3b, 0x09, 0x51, 0x2d, 0x5e,
	0x26, 0x07, 0x41, 0x20, 0x1f, 0x66, 0x20, 0xb5, 0x0c, 0xe4, 0x43, 0x01, 0xd2, 0x7f, 0x07, 0x3a,
	0x85, 0x8e, 0x90, 0xc2, 0x7e, 0xc6, 0xac, 0xc8, 0x67, 0x8e, 0xb0, 0x19, 0x50, 0xbf, 0xcc, 0xd1,
	0xaa, 0xfd, 0xa0, 0xc8, 0x91, 0x73, 0x3e, 0xfb, 0xd1, 0x7b, 0x77, 0xef, 0xde, 0xd5, 0x2a, 0x64,
	0x6b, 0xd8, 0xdc, 0x65, 0xc9, 0xfd, 0x7b, 0x5a, 0x15, 0x29, 0x39, 0x1d, 0x62, 0x41, 0xb4, 0xe9,
	0xe1, 0x9e, 0x36, 0xa7, 0x3c, 0xdd, 0xd7, 0xe6, 0x11, 0x10, 0x51, 0x30, 0x6d, 0x01, 0x35, 0xfd,
	0xcf, 0xfd, 0xfd, 0x34, 0xe4, 0xc4, 0x85, 0x39, 0x9a, 0xd3, 0xff, 0x04, 0xba, 0xc5, 0xfd, 0x89,
	0x0d, 0xf6, 0x13, 0x2b, 0x71, 0xed, 0xa9, 0xe1, 0xa1, 0xed, 0x61, 0x67, 0x3f, 0x2b, 0xa8, 0xf5,
	0xff, 0xcd, 0x1c, 0x17, 0xfc, 0x77, 0x5d, 0x9b, 0xb4, 0xd6, 0x5f, 0x7e, 0x1b, 0x4c, 0xd2, 0x98,
	0xea, 0x34, 0x8d, 0xb9, 0x5c, 0xa0, 0x97, 0xc2, 0xda, 0x95, 0x53, 0xca, 0xcb, 0x05, 0x12, 0x44,
	0xca, 0x11, 0x85, 0xfc, 0xdc, 0x02, 0xcd, 0x3e, 0xb6, 0xfc, 0x21, 0x33, 0x69, 0x0f, 0xfa, 0x47,
	0x81, 0x60, 0xba, 0xba, 0x54, 0xce, 0xa9, 0x3a, 0x8a, 0x27, 0x85, 0x6b, 0x60, 0xe1, 0x9b, 0xbb,
	0x06, 0xea, 0xe5, 0xd7, 0xc0, 0x97, 0xd0, 0x9e, 0xc6, 0x97, 0xd0, 0x9e, 0x1f, 0x41, 0x5f, 0x58,
	0x0f, 0xce, 0xc2, 0x42, 0xcc, 0xd5, 0x15, 0x82, 0xdc, 0x9d, 0x85, 0xab, 0x9c, 0x0c, 0xc0, 0x37,
	0x40, 0x06, 0x5a, 0x0a, 0x19, 0xe8, 0xab, 0x84, 0xad, 0xad, 0x5e, 0x7b, 0x39, 0x79, 0xcb, 0x29,
	0x42, 0x67, 0x82, 0x22, 0xf4, 0x7f, 0x08, 0x1a, 0xa9, 0xc0, 0xb7, 0x90, 0xbf, 0xe3, 0x6f, 0xa0,
	0xff, 0xb6, 0xe0, 0x63, 0xf8, 0xb9, 0x40, 0x0e, 0x5c, 0x18, 0x7b, 0x90, 0x5d, 0xa9, 0x92, 0x55,
	0x89, 0x26, 0xad, 0xd5, 0xfa, 0xff, 0x7d, 0x8e, 0x0b, 0x0e, 0xb9, 0x12, 0x5d, 0xdf, 0x16, 0x6a,
	0x77, 0x62, 0x18, 0x85, 0x44, 0x7a, 0xeb, 0x0c, 0xb5, 0xfb, 0x1d, 0x75, 0x00, 0xa4, 0x83, 0xa7,
	0xdf, 0xfa, 0x1e, 0x2c, 0x29, 0xa8, 0xcc, 0x20, 0x72, 0x58, 0xd4, 0xab, 0x5e, 0xab, 0xdd, 0xea,
	0x96, 0x10, 0xe6, 0xe2, 0x24, 0x88, 0x2f, 0x5b, 0xcc, 0x91, 0x3d, 0xe3, 0x8d, 0xf9, 0x6a, 0xa5,
	0xec, 0xc8, 0x35, 0x79, 0x39, 0x6d, 0x7a, 0x29, 0xdc, 0x35, 0x78, 0x39, 0xc7, 0xa1, 0x3f, 0x87,
	0xc5, 0x23, 0x37, 0xf2, 0x5e, 0x58, 0x11, 0x93, 0x0c, 0x15, 0xc9, 0xb1, 0xef, 0x9c, 0x3d, 0x89,
	0xc7, 0xa2, 0x91, 0xd4, 0xbe, 0x1f, 0x15, 0x9e, 0x39, 0x5b, 0x1d, 0x33, 0x3b, 0x8d, 0x18, 0x75,
	0x4e, 0xa7, 0x05, 0xa8, 0x08, 0xfb, 0xfd, 0x01, 0xac, 0x1d, 0x5b, 0x91, 0x83, 0xfd, 0x8e, 0xdd,
	0x28, 0x49, 0xad, 0x91, 0xfb, 0x05, 0x59, 0x6f, 0x16, 0xd4, 0x91, 0xae, 0x4a, 0xa8, 0x41, 0x01,
	0x68, 0xdd, 0x91, 0x2f, 0x42, 0xac, 0xde, 0xd7, 0x53, 0x0c, 0x64, 0xa4, 0xa5, 0x5a, 0x20, 0x2d,
	0xeb, 0xbf, 0x53, 0xe1, 0x3b, 0xa6, 0x38, 0x57, 0xfd, 0x09, 0x2c, 0xf9, 0xe3, 0xc8, 0xf2, 0x50,
	0xdf, 0x22, 0x17, 0xad, 0x32, 0xc3, 0xe0, 0xa2, 0xd8, 0x78, 0x16, 0xb1, 0x95, 0x22, 0x75, 0xde,
	0x84, 0x45, 0x05, 0x91, 0xaa, 0x55, 0xcb, 0x20, 0x51, 0xa7, 0xf2, 0x77, 0x17, 0xa0, 0x33, 0xf0,
	0x54, 0x35, 0x68, 0x99, 0x09, 0x4c, 0x9e, 0x97, 0x86, 0x72, 0x5e, 0x5c, 0x58, 0x44, 0x76, 0x78,
	0xec, 0xc6, 0x41, 0x81, 0xad, 0xfb, 0xe5, 0x6c, 0xa0, 0x5f, 0xb0, 0x34, 0xbe, 0xb3, 0xa9, 0xfa,
	0x28, 0xec, 0x45, 0x41, 0x12, 0xdc, 0xd9, 0xb1, 0x7c, 0x6b, 0xc8, 0xf8, 0xcd, 0xb5, 0xcf, 0xa2,
	0x31, 0x8b, 0xee, 0x3c, 0xcd, 0x10, 0x11, 0xcf, 0x71, 0x5c, 0x78, 0xe6, 0x52, 0xd6, 0x71, 0x10,
	0x27, 0x39, 0xcd, 0x68, 0x1b, 0x0d, 0x5e, 0x20, 0x75, 0x4a, 0xb9, 0xf9, 0xad, 0x8a, 0x17, 0x78,
	0x6e, 0x7e, 0x9b, 0xb6, 0xa8, 0xd5, 0x4a, 0x2c, 0x6a, 0x1f, 0xc2, 0x5a, 0x30, 0x66, 0x51, 0xe4,
	0x3a, 0x39, 0xb9, 0x52, 0x36, 0x6c, 0xc3, 0xb8, 0x20, 0xab, 0x0b, 0x3c, 0x7f, 0xc1, 0x9e, 0x36,
	0xff, 0x95, 0xed, 0x69, 0x0b, 0xaf, 0x66, 0x4f, 0x2b, 0xb7, 0x28, 0xd6, 0xcb, 0x2d, 0x8a, 0xef,
	0x48, 0x09, 0x33, 0xb3, 0x57, 0xb5, 0xd4, 0x13, 0x40, 0x02, 0xa4, 0x34, 0x56, 0xf1, 0xd7, 0x8c,
	0xb2, 0x5c, 0x9b, 0x5e, 0x3d, 0xff, 0x3d, 0xd3, 0xa0, 0xd4, 0x39, 0xb7, 0x41, 0xa9, 0x3b, 0x6d,
	0x50, 0x7a, 0x73, 0xda, 0x50, 0xb4, 0x28, 0x2e, 0xbd, 0xa2, 0x85, 0xe8, 0xad, 0x12, 0x0b, 0x91,
	0x86, 0x90, 0x53, 0xa6, 0xa1, 0xeb, 0x13, 0xa6, 0xa1, 0x25, 0x62, 0xc9, 0xce, 0x36, 0x0b, 0xe9,
	0x33, 0xcd, 0x42, 0x3f, 0x81, 0xde, 0x94, 0x12, 0x83, 0xbc, 0x49, 0x62, 0xfd, 0x32, 0x2c, 0xa0,
	0x5a, 0x81, 0xf4, 0xd9, 0xd9, 0x6a, 0x8a, 0xc2, 0x09, 0x65, 0x16, 0xb9, 0x84, 0xe4, 0xca, 0xac,
	0xfe, 0x6f, 0x2f, 0x64, 0x3c, 0xd6, 0x19, 0x66, 0xfd, 0x1e, 0xd4, 0x1d, 0x36, 0x62, 0x89, 0xf0,
	0xf5, 0x68, 0x18, 0xf2, 0x51, 0x7f, 0x1b, 0x96, 0x46, 0xc1, 0xd0, 0xb5, 0xad, 0x11, 0x1a, 0x54,
	0xe3, 0xc4, 0xf2, 0x88, 0xef, 0xa8, 0x19, 0x9a, 0xa8, 0x38, 0x90, 0xe5, 0xfa, 0x0f, 0x85, 0x78,
	0x33, 0x87, 0x47, 0xf3, 0x7a, 0xb9, 0x3c, 0xa2, 0x48, 0xe0, 0x0f, 0x1a, 0x27, 0x0f, 0x23, 0xd7,
	0x19, 0x32, 0x47, 0x48, 0x39, 0x5c, 0x84, 0x72, 0x98, 0x9f, 0xb8, 0x47, 0x2e, 0x8b, 0x90, 0xd8,
	0xce, 0x3f, 0xa8, 0xdc, 0x35, 0x94, 0x42, 0xfd, 0x7d, 0x68, 0xba, 0x61, 0x71, 0x37, 0x4f, 0xda,
	0x43, 0xb7, 0xf7, 0xa4, 0x31, 0xda, 0x0d, 0xb3, 0x7d, 0xbc, 0x24, 0x7c, 0x82, 0x4c, 0x2f, 0x1d,
	0x25, 0xae, 0x6d, 0xa1, 0x55, 0x9a, 0x4f, 0x55, 0x13, 0x15, 0x3b, 0xb2, 0x9c, 0xbf, 0xdc, 0x71,
	0xfc, 0xc2, 0x4d, 0x6c, 0xd2, 0xeb, 0x09, 0xa1, 0xb3, 0x25, 0xca, 0xd0, 0x54, 0xa4, 0x41, 0xcd,
	0x4b, 0x52, 0x24, 0x0f, 0xf3, 0x06, 0xff, 0x99, 0x51, 0x32, 0x98, 0x69, 0xcc, 0x6f, 0x4d, 0x19,
	0xf3, 0x3f, 0xe5, 0xbb, 0x88, 0x53, 0x27, 0x87, 0x76, 0x51, 0xbb, 0x54, 0x5b, 0x57, 0x5c, 0x37,
	0x22, 0x67, 0x0e, 0x69, 0xeb, 0xbc, 0xfc, 0x81, 0x23, 0x93, 0xe4, 0x44, 0x91, 0x31, 0xcf, 0x46,
	0x26, 0x9e, 0x08, 0x99, 0x9f, 0x3f, 0xe8, 0x77, 0x60, 0x59, 0x5c, 0x66, 0xa6, 0x58, 0x09, 0xdc,
	0x33, 0x5d, 0x9c, 0xc2, 0x92, 0xa8, 0xda, 0xc7, 0x1a, 0xa4, 0xec, 0x0f, 0x04, 0xf3, 0xc1, 0xb9,
	0x0c, 0xf1, 0x4a, 0x05, 0x5b, 0xfe, 0x6c, 0xcc, 0xa2, 0x91, 0x75, 0xaa, 0x55, 0xf5, 0x55, 0xd0,
	0x4f, 0xa4, 0x9a, 0x67, 0x74, 0x2a, 0xe6, 0xa1, 0xd5, 0xfa, 0xf7, 0xa1, 0xa5, 0x4c, 0x0a, 0xf9,
	0x97, 0xcf, 0x02, 0xdb, 0x1a, 0x69, 0x15, 0xe4, 0xb7, 0x9f, 0x8c, 0x82, 0x43, 0x6b, 0x24, 0xd8,
	0xfa, 0x67, 0xa1, 0xf5, 0x79, 0xca, 0xb4, 0x5a, 0xff, 0x6d, 0x68, 0x29, 0x83, 0x47, 0x5e, 0x5c,
	0xe2, 0xd6, 0x7e, 0x09, 0x1f, 0xb7, 0x7d, 0xf1, 0x58, 0xe9, 0xff, 0xcf, 0x39, 0x68, 0xc8, 0x4d,
	0xc1, 0xc9, 0x81, 0x5c, 0x27, 0xc9, 0x28, 0xd3, 0x51, 0xe8, 0x8a, 0x62, 0xc9, 0x2d, 0xbf, 0x0e,
	0x9d, 0x30, 0x62, 0x47, 0xee, 0x4b, 0x73, 0xc4, 0xfc, 0x61, 0x72, 0x2c, 0xf4, 0x9f, 0x6d, 0x2a,
	0xfc, 0x0c, 0xcb, 0xf4, 0xef, 0x03, 0x44, 0x41, 0x9a, 0x08, 0xe5, 0x6f, 0x0d, 0xe9, 0xf2, 0xe5,
	0x19, 0xfb, 0xf1, 0x8e, 0xc1, 0x21, 0x8d, 0x26, 0x36, 0x40, 0xe2, 0xfc, 0x19, 0x68, 0xce, 0xb1,
	0x1d, 0x9a, 0x41, 0x88, 0xcc, 0xaa, 0xe2, 0x64, 0xd1, 0x9f, 0x85, 0x63, 0xeb, 0xe9, 0xe6, 0xde,
	0x33, 0x04, 0x37, 0xba, 0xbc, 0x2d, 0xfd, 0x46, 0x6c, 0x4f, 0xb8, 0xc4, 0x65, 0x86, 0x41, 0x30,
	0x52, 0xbd, 0x2e, 0xde, 0x98, 0x85, 0x29, 0x93, 0xf6, 0xf6, 0x82, 0x60, 0x64, 0x80, 0x1b, 0xf2,
	0xff, 0x88, 0xe8, 0x0e, 0x2c, 0xe3, 0xb0, 0x62, 0xbc, 0x30, 0xb3, 0x65, 0xa2, 0x0b, 0x79, 0x89,
	0x57, 0xd1, 0x55, 0x2a, 0xda, 0xaf, 0x07, 0x30, 0x8f, 0x53, 0xfb, 0x86, 0xd7, 0xb6, 0x07, 0xf5,
	0xa1, 0x95, 0xb0, 0x17, 0xd6, 0xa9, 0x10, 0x1e, 0xe5, 0xe3, 0xfa, 0x1e, 0x40, 0xbe, 0x0e, 0x9c,
	0x47, 0x13, 0x0b, 0x98, 0xf9, 0xf4, 0xcd, 0x1b, 0x40, 0x45, 0xd2, 0x69, 0x4f, 0x00, 0xe4, 0x0e,
	0x59, 0x6d, 0x43, 0x34, 0x42, 0xd6, 0x7d, 0xfd, 0x39, 0x74, 0x0a, 0xeb, 0xc1, 0x47, 0x18, 0x27,
	0x56, 0x94, 0x4c, 0x4c, 0xa4, 0x8d, 0x85, 0x72, 0x1a, 0x57, 0xa1, 0xc5, 0x7c, 0x67, 0x42, 0x0a,
	0x06, 0xe6, 0x3b, 0x52, 0xc2, 0xfd, 0xe7, 0x15, 0x58, 0xdc, 0x1c, 0x05, 0xa9, 0xb3, 0xed, 0xbb,
	0xf2, 0x4e, 0xfd, 0x75, 0x00, 0xc7, 0x4a, 0x2c, 0xd2, 0xed, 0x0b, 0xa9, 0xfc, 0x3b, 0x13, 0x2f,
	0x69, 0xa2, 0xcd, 0x9d, 0xad, 0xac, 0x01, 0xd2, 0xcd, 0xae, 0x38, 0xc0, 0x5b, 0x91, 0x3b, 0x66,
	0x83, 0x7b, 0x86, 0x82, 0x50, 0x5f, 0x87, 0x86, 0xc7, 0x12, 0x8b, 0x97, 0x08, 0xd3, 0x62, 0xf6,
	0xcc, 0xeb, 0xd2, 0x98, 0x45, 0x58, 0x27, 0xbc, 0x03, 0xe4, 0x73, 0xff, 0x06, 0x74, 0x8b, 0xbd,
	0xa0, 0x3f, 0x5c, 0xa1, 0x1f, 0xed, 0x97, 0xfa, 0x3f, 0x83, 0xce, 0xfe, 0x69, 0x1c, 0x46, 0x4c,
	0x52, 0xd6, 0xd7, 0xa1, 0x93, 0xfa, 0x56, 0x92, 0xf0, 0x75, 0x40, 0xbc, 0xc4, 0xca, 0xb5, 0x65,
	0x21, 0xc7, 0xa9, 0xdf, 0x86, 0xce, 0x51, 0xc4, 0xe2, 0x63, 0xd3, 0xf5, 0xe3, 0xc4, 0x1a, 0x91,
	0xcd, 0x33, 0xbb, 0xca, 0xda, 0x58, 0xb7, 0x4d, 0x55, 0xfd, 0xff, 0x50, 0x85, 0x0b, 0x03, 0x6f,
	0x33, 0x8d, 0x93, 0xc0, 0x13, 0x4c, 0x72, 0x26, 0xa3, 0x68, 0x36, 0x5f, 0x17, 0xce, 0x3f, 0x14,
	0xd9, 0xd5, 0x2b, 0x67, 0x2f, 0x9f, 0xb1, 0x98, 0xb5, 0x13, 0xa8, 0x36, 0xa1, 0x1b, 0xd3, 0x34,
	0x8a, 0xda, 0xd7, 0x49, 0x56, 0xbb, 0x30, 0x57, 0xa3, 0x13, 0x17, 0xa6, 0x7e, 0x08, 0x2b, 0x47,
	0xee, 0x88, 0xc5, 0x66, 0x12, 0x98, 0xae, 0xff, 0x73, 0x66, 0x27, 0x2a, 0x15, 0x78, 0x6f, 0x8a,
	0xc7, 0x2a, 0x99, 0xd3, 0x9d, 0xc7, 0xee, 0x88, 0x1d, 0x04, 0xdb, 0xd8, 0xda, 0x58, 0x42, 0x74,
	0xf2, 0x91, 0x1f, 0xc5, 0xf5, 0x9f, 0x42, 0x5b, 0x05, 0x41, 0x79, 0x84, 0x8c, 0x42, 0x8a, 0x22,
	0x1c, 0xa8, 0x08, 0xf5, 0xe0, 0x9c, 0x89, 0x61, 0x71, 0xe2, 0xfa, 0xd8, 0x0b, 0x41, 0xd1, 0x36,
	0x58, 0x54, 0xca, 0xd1, 0x9a, 0xfe, 0xbb, 0xe8, 0x8c, 0x32, 0xe9, 0x80, 0xa4, 0xaf, 0xc0, 0x3c,
	0xd9, 0x7b, 0xe8, 0x20, 0xd1, 0x83, 0xfe, 0xa0, 0xa0, 0x5f, 0xbf, 0xf9, 0xa5, 0x7e, 0x4c, 0xaa,
	0x8a, 0xfd, 0x8a, 0xb8, 0x1d, 0xd0, 0x1c, 0x9a, 0x8e, 0x24, 0x65, 0x27, 0x22, 0xa2, 0x55, 0xfb,
	0xbf, 0x57, 0x81, 0x96, 0xe2, 0x66, 0xa4, 0xdf, 0x16, 0x7d, 0xd1, 0xd9, 0x58, 0x9d, 0x94, 0xba,
	0xf7, 0x9e, 0xe7, 0xb8, 0xd1, 0x28, 0x22, 0x8c, 0x54, 0x8e, 0xa0, 0x22, 0x0d, 0x61, 0xa1, 0x72,
	0xf4, 0xbb, 0xb0, 0x30, 0x66, 0xbe, 0x13, 0x44, 0xb8, 0xdb, 0xa7, 0x35, 0xae, 0x4f, 0xf6, 0x9e,
	0x0f, 0xb0, 0xde, 0x10, 0x70, 0xfd, 0x3f, 0xa8, 0x43, 0x7d, 0x37, 0x70, 0xd8, 0x93, 0xbd, 0xe7,
	0xff, 0x17, 0x87, 0xa1, 0x58, 0x73, 0x90, 0xa9, 0x20, 0x23, 0xbb, 0xb0, 0xe6, 0x20, 0x03, 0x72,
	0x01, 0x16, 0x5c, 0xdf, 0x4c, 0x63, 0x52, 0xd2, 0xe3, 0x5b, 0x7a, 0x1e, 0xa3, 0xec, 0x14, 0x1f,
	0x3a, 0x47, 0xc2, 0xb2, 0x8e, 0xbf, 0x85, 0xcc, 0x42, 0xbe, 0x54, 0xc8, 0xf3, 0xcc, 0xa3, 0xcc,
	0x82, 0x6e, 0x54, 0xc8, 0xa2, 0xa0, 0xca, 0x8a, 0xb3, 0xb7, 0x64, 0x38, 0x35, 0x94, 0x92, 0x7c,
	0x33, 0x34, 0x51, 0xd8, 0x11, 0x9b, 0x41, 0xf2, 0x90, 0x82, 0xd9, 0x41, 0x1e, 0xb2, 0x0b, 0x55,
	0xa1, 0xe4, 0x68, 0x1a, 0x55, 0xf2, 0x3f, 0x41, 0x51, 0x69, 0x18, 0xa6, 0xb1, 0xc9, 0xb9, 0x5d,
	0xdb, 0x92, 0xca, 0x8e, 0x0e, 0xb2, 0xf2, 0x03, 0x5e, 0xb3, 0x21, 0x2b, 0xf8, 0xdd, 0xe1, 0x59,
	0x2f, 0x25, 0x24, 0x0e, 0x07, 0xf5, 0x1e, 0x46, 0xd7, 0xb3, 0x5e, 0x6e, 0xe4, 0xa5, 0xfa, 0x3b,
	0xa0, 0x73, 0xc0, 0xa3, 0xc8, 0xf2, 0xd8, 0x61, 0x7a, 0x74, 0xc4, 0x22, 0x2e, 0x6a, 0x75, 0x11,
	0x56, 0xf3, 0xac, 0x97, 0x8f, 0xf3, 0x8a, 0x9d, 0x43, 0x2e, 0x21, 0x0c, 0xc3, 0xd4, 0x4c, 0x63,
	0x6b, 0xc8, 0xcc, 0x30, 0xf4, 0x90, 0xf7, 0xaf, 0x19, 0xad, 0x61, 0x98, 0x3e, 0xe7, 0x65, 0x7b,
	0xa1, 0x87, 0xdc, 0xbc, 0xeb, 0x73, 0x8c, 0xa8, 0x0c, 0x42, 0xa6, 0xbf, 0x63, 0xb4, 0x3c, 0xd7,
	0x7f, 0x2c, 0x8a, 0xf4, 0xdb, 0xc0, 0x87, 0xcc, 0x05, 0xdc, 0x70, 0x64, 0x9d, 0x9a, 0xc7, 0x5c,
	0x08, 0x41, 0xae, 0xbf, 0x83, 0x72, 0xd0, 0x16, 0x95, 0x3f, 0xe5, 0xc5, 0xfa, 0x27, 0x70, 0x29,
	0x62, 0x71, 0x30, 0x4a, 0xe9, 0x04, 0xb2, 0xa8, 0xd0, 0x0c, 0xc5, 0x80, 0xa6, 0xd1, 0xcb, 0x41,
	0xf6, 0x58, 0xa4, 0xb4, 0xd7, 0xef, 0xc2, 0xca, 0x10, 0x35, 0x7c, 0x0e, 0xa7, 0xba, 0x91, 0x39,
	0x66, 0x51, 0xcc, 0x47, 0xb5, 0x8c, 0xed, 0x74, 0xac, 0x43, 0x82, 0x1c, 0x0d, 0xa8, 0x46, 0xbf,
	0x07, 0x17, 0xd4, 0xd5, 0xc8, 0xe7, 0xba, 0x82, 0x73, 0x5d, 0x56, 0x2a, 0xd5, 0x39, 0x8f, 0x5c,
	0x9b, 0xf9, 0xb1, 0x60, 0x5d, 0x2e, 0xa0, 0xdd, 0xba, 0x25, 0xca, 0x90, 0x0d, 0xb8, 0x0d, 0x4b,
	0xcc, 0xe7, 0x57, 0xaa, 0x8a, 0x72, 0x95, 0x64, 0x3f, 0x51, 0x91, 0xa1, 0xbb, 0x0d, 0x4b, 0x0e,
	0x9b, 0x84, 0x5d, 0x23, 0x58, 0x51, 0xa1, 0xc0, 0xce, 0xa1, 0x5e, 0xb1, 0x37, 0xeb, 0x5c, 0xa1,
	0x9f, 0x2e, 0xc2, 0xf4, 0x7f, 0x71, 0x01, 0x1a, 0x03, 0xef, 0x6b, 0x38, 0xcc, 0xae, 0x41, 0x1d,
	0x25, 0xd8, 0x30, 0xc5, 0xc3, 0xd7, 0x31, 0x16, 0xb8, 0xd8, 0x1a, 0xa6, 0x45, 0x51, 0x7e, 0x6e,
	0x42, 0x94, 0x2f, 0x97, 0x7b, 0xe7, 0xb3, 0xf7, 0xfd, 0x25, 0x9e, 0xb4, 0x0b, 0xa5, 0x72, 0xbf,
	0xe2, 0x49, 0x4b, 0xac, 0xd9, 0xc5, 0x52, 0x2d, 0xcb, 0xb6, 0x7f, 0x14, 0xcc, 0xf0, 0xa3, 0x6d,
	0x7c, 0x65, 0xb9, 0xbf, 0xf9, 0x6a, 0x72, 0x7f, 0x99, 0x07, 0x2b, 0x7c, 0x55, 0x0f, 0xd6, 0x32,
	0xa7, 0xdc, 0xd6, 0x19, 0x4e, 0xb9, 0xfd, 0xa2, 0x53, 0x2e, 0xa7, 0x18, 0x35, 0x14, 0x03, 0xcf,
	0xe5, 0x97, 0xdb, 0x99, 0xed, 0x97, 0x7b, 0x05, 0x5a, 0x74, 0xb2, 0x82, 0xd8, 0xcc, 0xa4, 0x99,
	0x26, 0x16, 0x3d, 0x8b, 0xb7, 0x9d, 0x82, 0xab, 0xed, 0xe2, 0x79, 0x5d, 0x6d, 0xcb, 0x5d, 0x50,
	0xb4, 0xb3, 0x5d, 0x50, 0x7e, 0x02, 0xb7, 0xa5, 0x7c, 0x95, 0xe9, 0xcc, 0xe2, 0xdc, 0xf3, 0xfc,
	0x28, 0x88, 0x14, 0x8f, 0xf4, 0xde, 0xd2, 0xb5, 0xda, 0xad, 0xb6, 0x71, 0x43, 0xb4, 0x90, 0xea,
	0xb4, 0x58, 0x7a, 0x9c, 0x3f, 0x0e, 0xa2, 0xcc, 0x0b, 0x5d, 0xbf, 0xa8, 0x78, 0xfe, 0xea, 0x24,
	0xcb, 0x4b, 0x97, 0xdf, 0xf7, 0x61, 0x6d, 0xec, 0x71, 0x66, 0x65, 0xec, 0x65, 0x2a, 0x1a, 0xea,
	0xb9, 0xb7, 0x8c, 0xa7, 0x7f, 0x79, 0xec, 0x1d, 0x04, 0x03, 0x4f, 0x4e, 0x12, 0x3b, 0xe1, 0xc4,
	0x45, 0xec, 0xee, 0x88, 0x71, 0x81, 0x80, 0xf8, 0x0a, 0xef, 0x10, 0x89, 0xcb, 0x9c, 0xb1, 0x4c,
	0x95, 0x46, 0x5e, 0xb7, 0x73, 0x88, 0xe2, 0xa3, 0x1d, 0xa6, 0x85, 0x16, 0xc7, 0x5f, 0xa0, 0x03,
	0xed, 0x9c, 0xb1, 0xc4, 0xab, 0x14, 0xf8, 0xa7, 0x5f, 0x70, 0xf8, 0xe3, 0xc0, 0x43, 0xc5, 0xad,
	0xea, 0x3a, 0xb7, 0x4a, 0x02, 0x07, 0xaf, 0xda, 0x2c, 0xb8, 0xcf, 0x95, 0x38, 0x2f, 0xaf, 0xbd,
	0xaa, 0xf3, 0xf2, 0x26, 0xb4, 0xd8, 0xcb, 0x84, 0x5c, 0xff, 0x87, 0x71, 0xaf, 0x77, 0x6e, 0x0d,
	0x3f, 0x60, 0xb3, 0xc7, 0xbc, 0x95, 0xbe, 0x01, 0x75, 0xbe, 0xa4, 0x9c, 0x4b, 0x58, 0x2f, 0x0d,
	0x25, 0x92, 0xb4, 0xeb, 0xce, 0xc0, 0x13, 0x1a, 0x0f, 0x8c, 0x26, 0x19, 0xec, 0x18, 0x0b, 0x63,
	0x4f, 0x8a, 0xda, 0xf9, 0xb4, 0x73, 0x3f, 0xa2, 0x4b, 0xf8, 0x46, 0x96, 0xb2, 0xaa, 0xcc, 0x7d,
	0xe8, 0x57, 0xe1, 0x6d, 0x2b, 0x44, 0xb6, 0x35, 0x76, 0x63, 0x74, 0x43, 0xca, 0xdc, 0x3c, 0xf9,
	0x69, 0x88, 0xd8, 0xe7, 0xa9, 0x1b, 0x31, 0x47, 0x1e, 0x87, 0xd7, 0x70, 0x93, 0xdf, 0xb4, 0x42,
	0xce, 0xb5, 0x8a, 0x16, 0xd2, 0x6d, 0x61, 0x37, 0x48, 0x0c, 0x01, 0x2e, 0x4e, 0xc8, 0x47, 0xd0,
	0x93, 0xfb, 0x32, 0xd7, 0x6a, 0x8b, 0xfb, 0xe7, 0x32, 0x62, 0x5a, 0x15, 0xf5, 0x4f, 0xa5, 0x3a,
	0x5b, 0xdc, 0x41, 0xb7, 0x40, 0x13, 0xaf, 0x23, 0x77, 0xd3, 0xb8, 0x82, 0x2d, 0xba, 0x54, 0x9e,
	0x79, 0x6a, 0xdc, 0x86, 0xcc, 0xfb, 0xd4, 0x74, 0xdc, 0x88, 0x40, 0xaf, 0x12, 0x8b, 0x2a, 0x2b,
	0xb6, 0xdc, 0x08, 0x61, 0x3f, 0x85, 0xd7, 0xa7, 0xce, 0x89, 0x19, 0x31, 0x32, 0xd1, 0xf1, 0xad,
	0x8c, 0x87, 0xb7, 0x77, 0x8d, 0x4c, 0x3b, 0x13, 0x07, 0xc4, 0x10, 0x70, 0x07, 0x01, 0xae, 0x39,
	0x97, 0x42, 0xd0, 0x8c, 0x20, 0x55, 0xfc, 0xbd, 0xeb, 0x05, 0x29, 0x84, 0xd7, 0x49, 0x0d, 0xb9,
	0x7e, 0x80, 0x67, 0x25, 0xf3, 0x3a, 0x51, 0x77, 0x5a, 0x1f, 0x77, 0xca, 0x95, 0xb3, 0x3d, 0x4c,
	0xf8, 0x59, 0x2a, 0x14, 0xe0, 0xbb, 0xbb, 0x01, 0xdd, 0xb1, 0x67, 0x06, 0xa8, 0xc4, 0x20, 0x69,
	0xe9, 0x75, 0x92, 0x2a, 0xc7, 0x1e, 0x69, 0x36, 0x50, 0x5a, 0xba, 0x04, 0xcd, 0x43, 0x37, 0x88,
	0xe9, 0x0c, 0xdc, 0x20, 0x31, 0x8d, 0x17, 0xe0, 0xd6, 0xbf, 0x0a, 0xad, 0xf1, 0xd0, 0xc2, 0xd7,
	0x1f, 0x8c, 0x58, 0xef, 0x0d, 0xe2, 0xd8, 0xc6, 0x43, 0x6b, 0x93, 0x4a, 0x50, 0x25, 0xea, 0xa9,
	0xee, 0x91, 0x37, 0x49, 0xda, 0x1d, 0x7b, 0xb9, 0x6b, 0xe4, 0x0e, 0xb4, 0x85, 0x70, 0x4b, 0x0c,
	0xcf, 0x9b, 0xb8, 0x77, 0x6f, 0x4f, 0x12, 0xbb, 0x92, 0x38, 0xa5, 0x3b, 0xf4, 0xcf, 0x68, 0xc5,
	0x79, 0x99, 0xfe, 0x23, 0x68, 0xc5, 0x49, 0x10, 0x4a, 0x6c, 0xb7, 0x4a, 0xcd, 0xfe, 0x25, 0x41,
	0x4a, 0x12, 0x19, 0xc4, 0x59, 0x11, 0x27, 0x37, 0x44, 0x43, 0x4d, 0xe7, 0xd4, 0xb7, 0x3c, 0xd7,
	0x36, 0x89, 0xc0, 0xf4, 0xde, 0xc2, 0x99, 0x2e, 0x53, 0xe5, 0x16, 0xd5, 0xed, 0x60, 0x55, 0x59,
	0xc8, 0xc0, 0xed, 0xb2, 0x90, 0x81, 0x01, 0x5c, 0x08, 0x83, 0x17, 0x2c, 0x12, 0x61, 0x4b, 0x1e,
	0xb3, 0x8f, 0x2d, 0xdf, 0x8d, 0xbd, 0xde, 0xdb, 0x38, 0xe2, 0xc9, 0xc3, 0x8f, 0x01, 0x6a, 0x18,
	0xbe, 0xb4, 0x23, 0x21, 0x8d, 0xe5, 0x70, 0xba, 0x90, 0x5f, 0x46, 0xfe, 0x30, 0x11, 0xb4, 0xdf,
	0x8c, 0xed, 0xc8, 0x0d, 0x13, 0x93, 0xbd, 0x64, 0x76, 0xef, 0x1d, 0x1a, 0xb4, 0x3f, 0x4c, 0x88,
	0xf2, 0xef, 0x63, 0xdd, 0xa3, 0x97, 0xcc, 0xd6, 0x1f, 0xc0, 0x3a, 0x6f, 0x74, 0x64, 0xb9, 0x23,
	0x33, 0xf0, 0x65, 0x2b, 0xfe, 0x98, 0x46, 0xac, 0xf7, 0x1d, 0xf2, 0x04, 0xf3, 0x87, 0xc9, 0x63,
	0xcb, 0x1d, 0x3d, 0xf3, 0xa9, 0xe1, 0x63, 0xaa, 0xe5, 0x42, 0x37, 0x7f, 0xc7, 0x9c, 0x38, 0x11,
	0xdf, 0x73, 0x87, 0x18, 0x8e, 0xb1, 0xf7, 0x24, 0x2b, 0x9b, 0xa9, 0x4c, 0x7f, 0x37, 0xe3, 0xc0,
	0xbf, 0x4c, 0x99, 0x7e, 0xf7, 0x5c, 0xca, 0xf4, 0xf7, 0x4a, 0x95, 0xe9, 0x93, 0xc1, 0x13, 0xf7,
	0xca, 0x83, 0x27, 0xca, 0x74, 0xee, 0xf7, 0xcb, 0x75, 0xee, 0xd3, 0x0a, 0xf5, 0xf7, 0x67, 0x2a,
	0xd4, 0x9f, 0xc1, 0x02, 0x11, 0x5c, 0xd4, 0x41, 0x0a, 0x92, 0x2b, 0xfc, 0xba, 0x36, 0x07, 0x3b,
	0x22, 0x84, 0x6e, 0xe3, 0xf1, 0xfe, 0x60, 0x47, 0xab, 0xa1, 0x5c, 0xba, 0xc7, 0x8b, 0x29, 0xf6,
	0x70, 0xb0, 0xb7, 0x3b, 0xd8, 0xd1, 0xe6, 0xf1, 0xf7, 0xce, 0xfe, 0xde, 0x60, 0x47, 0x5b, 0xe8,
	0xff, 0x7e, 0x15, 0x1a, 0x99, 0xe9, 0x62, 0x03, 0x16, 0xc2, 0x60, 0xe4, 0xda, 0xa7, 0x33, 0xe2,
	0x47, 0x25, 0xe0, 0x9d, 0x3d, 0x84, 0x7a, 0xd0, 0x3c, 0xc9, 0xf8, 0x06, 0xd1, 0x50, 0xdf, 0x06,
	0xe0, 0x47, 0x38, 0x89, 0x2c, 0xd7, 0x4f, 0x84, 0x50, 0xdd, 0x9f, 0x85, 0x66, 0x33, 0x83, 0x7c,
	0x30, 0x7f, 0xb2, 0x93, 0xc6, 0x89, 0xa1, 0x34, 0xd6, 0x2f, 0x03, 0x64, 0x06, 0xab, 0x18, 0x95,
	0x0f, 0x6d, 0xa3, 0x29, 0x2d, 0x56, 0x71, 0xff, 0x36, 0x2c, 0xd0, 0x30, 0xc8, 0x61, 0x41, 0xe0,
	0xd4, 0x2a, 0x14, 0x3f, 0xe9, 0x27, 0x6e, 0x56, 0x54, 0xed, 0xdf, 0x00, 0xc8, 0xfb, 0xc2, 0x65,
	0xe1, 0xbd, 0x49, 0x71, 0xfd, 0x38, 0x48, 0x47, 0x8e, 0x56, 0xed, 0xff, 0x69, 0x05, 0x56, 0x06,
	0x05, 0x4e, 0x21, 0xe3, 0x1a, 0xd5, 0x49, 0x55, 0xce, 0x3d, 0x29, 0x89, 0xbb, 0x30, 0xad, 0x47,
	0xd9, 0x22, 0x57, 0xcf, 0xb5, 0xc8, 0xc5, 0xc9, 0x64, 0x0b, 0x2d, 0x65, 0x86, 0x9a, 0x22, 0x33,
	0x5c, 0x83, 0xf6, 0xd8, 0xa3, 0xbb, 0x04, 0x29, 0xfa, 0x1c, 0xae, 0x19, 0x8c, 0x3d, 0xbe, 0x62,
	0x9c, 0x50, 0xf7, 0x4f, 0x60, 0x59, 0xe8, 0xa4, 0x1f, 0xf9, 0x89, 0x9b, 0x9c, 0xf2, 0x03, 0x9f,
	0xc6, 0xfd, 0x03, 0x58, 0xa0, 0x5f, 0xb8, 0x20, 0xbb, 0x41, 0xb2, 0xcf, 0x12, 0xa1, 0xe7, 0x7e,
	0xee, 0x9f, 0xf8, 0xc1, 0x0b, 0x5f, 0xab, 0xea, 0x75, 0xa8, 0x9d, 0x3c, 0x3b, 0xd1, 0x6a, 0xe8,
	0x11, 0xf2, 0xd4, 0x8a, 0xf7, 0xa2, 0xe0, 0x70, 0xc4, 0x3c, 0x6d, 0x4e, 0xbf, 0x00, 0x4b, 0x27,
	0x3b, 0xee, 0xf0, 0x38, 0x79, 0x6a, 0x8d, 0x99, 0x2c, 0x9e, 0xef, 0xff, 0x63, 0x0c, 0xa7, 0x51,
	0xd7, 0x13, 0x7d, 0x30, 0x5e, 0x87, 0x4e, 0x81, 0x4b, 0x93, 0x9a, 0x35, 0x4b, 0x61, 0xcf, 0xb2,
	0xe9, 0x55, 0x95, 0xe9, 0x7d, 0x98, 0xad, 0x5c, 0xed, 0x3c, 0x2b, 0x97, 0x2d, 0xd5, 0xc3, 0xc2,
	0xeb, 0x9b, 0x3b, 0xef, 0xeb, 0x2b, 0xbc, 0xb5, 0x1e, 0xd4, 0x25, 0x0b, 0x4c, 0xb6, 0x72, 0xf9,
	0xc8, 0x0f, 0x4d, 0x8c, 0x6b, 0x27, 0xfc, 0x49, 0x26, 0xef, 0x87, 0x92, 0xf5, 0xbe, 0x43, 0xff,
	0x0c, 0xd1, 0x50, 0xc6, 0xd8, 0xd6, 0xb3, 0x18, 0xdb, 0xfe, 0x1f, 0xa2, 0x5d, 0x3b, 0xb7, 0xe8,
	0xe2, 0xc2, 0x95, 0x18, 0x8b, 0x2b, 0xdf, 0x92, 0xb1, 0x58, 0x87, 0xb9, 0x4c, 0xd1, 0xda, 0x36,
	0xf0, 0x77, 0xff, 0xcf, 0x2a, 0x50, 0x17, 0x61, 0xaf, 0xfd, 0x7f, 0x5d, 0x81, 0x79, 0xfc, 0x55,
	0xd8, 0x23, 0x44, 0x87, 0x26, 0x22, 0xa1, 0x5d, 0x7f, 0xf8, 0xcc, 0xd7, 0x6a, 0xb4, 0x7d, 0x7c,
	0x6d, 0x0e, 0xcf, 0xe7, 0xfe, 0x71, 0x9a, 0x24, 0xae, 0x3f, 0xc4, 0x10, 0xdd, 0x79, 0xf4, 0x51,
	0xca, 0x80, 0x8f, 0x8e, 0xb4, 0x05, 0xf2, 0x7c, 0xb2, 0xd2, 0xd8, 0xf5, 0x87, 0x5a, 0x1d, 0x77,
	0x25, 0x46, 0x4e, 0x3b, 0x22, 0x18, 0x5a, 0x84, 0x4e, 0xf3, 0xda, 0xa6, 0xde, 0x05, 0x90, 0x05,
	0xcc, 0xd1, 0x00, 0xe9, 0x01, 0x46, 0x53, 0xf3, 0xea, 0x16, 0x56, 0x63, 0x08, 0x36, 0xef, 0x50,
	0x6b, 0xe3, 0xf3, 0x8e, 0x3b, 0xe4, 0xcb, 0xe3, 0x0f, 0xb5, 0x0e, 0x05, 0x36, 0x60, 0xa8, 0x74,
	0xb7, 0xff, 0x7d, 0x58, 0x46, 0xa2, 0x7a, 0x10, 0x04, 0xa3, 0xf8, 0x59, 0x28, 0xae, 0x9c, 0xfe,
	0x1b, 0xd0, 0xcc, 0x1e, 0x88, 0x7c, 0x06, 0xa9, 0x9f, 0x9f, 0x10, 0x0f, 0x9f, 0xaa, 0xfd, 0xdf,
	0x16, 0x04, 0x24, 0x18, 0xc5, 0x22, 0xa6, 0x59, 0x9c, 0xaf, 0x9f, 0x67, 0xe7, 0xab, 0xb8, 0x5c,
	0x57, 0xe1, 0xd2, 0x49, 0xde, 0x1f, 0xbf, 0x3e, 0x53, 0x3e, 0x28, 0xba, 0x14, 0x63, 0xad, 0xaa,
	0x5f, 0x84, 0x0b, 0x0a, 0x00, 0xe7, 0x6b, 0x45, 0xac, 0x74, 0x0d, 0xcd, 0x4e, 0x79, 0x95, 0x2c,
	0x9f, 0xeb, 0xff, 0xbd, 0x6a, 0x36, 0x08, 0xc1, 0xc3, 0x8a, 0x41, 0xfc, 0xa2, 0x3a, 0x63, 0x14,
	0xeb, 0xb0, 0xaa, 0x60, 0x7a, 0x38, 0xb2, 0xec, 0x13, 0x4e, 0x3e, 0xd0, 0xfb, 0xab, 0xd8, 0xcb,
	0x66, 0x1a, 0x45, 0xcc, 0x4f, 0xb4, 0xda, 0x44, 0x9b, 0x5d, 0xc6, 0x9c, 0xe7, 0xe1, 0x30, 0xb2,
	0x1c, 0xa6, 0xcd, 0xe9, 0x97, 0x60, 0xad, 0x38, 0x68, 0xa1, 0x02, 0x67, 0x8e, 0x36, 0x3f, 0x51,
	0x99, 0xb9, 0xa5, 0xed, 0xb2, 0x17, 0xda, 0xc2, 0xac, 0xca, 0x67, 0x23, 0x47, 0xab, 0x23, 0x95,
	0xc9, 0x2b, 0x0f, 0x82, 0x80, 0xb7, 0x69, 0x4c, 0x17, 0x73, 0xe8, 0xa6, 0xde, 0x83, 0x15, 0xa5,
	0xf8, 0xb9, 0x2f, 0x4c, 0x8a, 0x1a, 0xf4, 0xff, 0x4b, 0x05, 0xba, 0x03, 0x4f, 0xca, 0x0a, 0x92,
	0x24, 0x65, 0xac, 0xbb, 0x62, 0x44, 0x6e, 0xcb, 0x42, 0x24, 0x49, 0x0f, 0xa0, 0x39, 0xf6, 0x8a,
	0x6a, 0xf5, 0xcb, 0xd3, 0x52, 0x91, 0xea, 0x74, 0xdf, 0x18, 0x4f, 0x6a, 0x78, 0x6a, 0x33, 0x35,
	0x3c, 0x73, 0x53, 0x1a, 0x9e, 0xef, 0x80, 0x46, 0x4e, 0xfb, 0x8a, 0x85, 0x7a, 0x1e, 0x75, 0x06,
	0xd5, 0xef, 0xbc, 0x67, 0x2c, 0x52, 0x5d, 0x6e, 0xa4, 0x5e, 0x43, 0x91, 0x4d, 0x09, 0x47, 0x5b,
	0x20, 0xba, 0xdf, 0xff, 0xf7, 0x75, 0xce, 0x34, 0xe0, 0x3c, 0x15, 0x98, 0x8a, 0x0a, 0xa3, 0xbf,
	0x5b, 0x66, 0x0e, 0xaf, 0x66, 0x9d, 0x4d, 0x9b, 0xc4, 0xdf, 0x85, 0x05, 0xb1, 0x12, 0xb5, 0x52,
	0x85, 0x82, 0x94, 0x0f, 0x0d, 0x01, 0xa6, 0xff, 0x10, 0x20, 0xa7, 0x31, 0xc2, 0x85, 0xe9, 0xea,
	0x54, 0xa3, 0x22, 0xc5, 0x33, 0x94, 0x26, 0x45, 0xff, 0x95, 0xf9, 0x09, 0xff, 0x95, 0x7b, 0x30,
	0x8f, 0xbc, 0xef, 0x4c, 0x9f, 0x3e, 0x24, 0x56, 0x48, 0x77, 0x99, 0x41, 0xa0, 0xfa, 0xfb, 0xb0,
	0xaa, 0x90, 0xd3, 0x38, 0x64, 0xb6, 0x7b, 0xe4, 0xda, 0xa6, 0x4b, 0xb1, 0x39, 0x6d, 0x63, 0x25,
	0xaf, 0xdd, 0x17, 0x95, 0xdb, 0x8e, 0xfe, 0x21, 0xac, 0x25, 0x7c, 0x47, 0x49, 0x93, 0x0f, 0x8b,
	0x4c, 0x3c, 0xfe, 0x32, 0x3c, 0xc7, 0xb8, 0x80, 0xd5, 0x72, 0xcb, 0x47, 0x3b, 0x54, 0xa9, 0xff,
	0x1a, 0xac, 0x50, 0xbb, 0x88, 0x4e, 0xaa, 0x29, 0x2e, 0x8d, 0x66, 0xa9, 0x88, 0x52, 0x46, 0x45,
	0xe4, 0xad, 0xa1, 0x27, 0x53, 0x55, 0x39, 0x76, 0x21, 0xd4, 0x4a, 0xec, 0x70, 0x16, 0xf6, 0x02,
	0x79, 0x28, 0x62, 0x2f, 0x54, 0xe9, 0xf7, 0x40, 0x27, 0x0e, 0x75, 0xe4, 0x8e, 0x99, 0xe9, 0x21,
	0xed, 0x64, 0xc2, 0x09, 0x86, 0xb8, 0x54, 0x0d, 0xeb, 0x3f, 0x73, 0xc7, 0x8c, 0x28, 0x2b, 0xd3,
	0xdf, 0x83, 0xc6, 0x30, 0x4c, 0xd5, 0x18, 0xf1, 0x49, 0x85, 0xa8, 0x30, 0x47, 0x18, 0xf5, 0x61,
	0x98, 0xa2, 0x14, 0x39, 0x4b, 0x41, 0xdc, 0x99, 0xa9, 0x20, 0xbe, 0x0b, 0x4b, 0x7c, 0xbb, 0x9a,
	0xf1, 0xa9, 0x6f, 0x67, 0x2a, 0xaa, 0xae, 0x32, 0xae, 0x45, 0x5e, 0xbd, 0x7f, 0xea, 0xdb, 0x52,
	0x41, 0x45, 0x27, 0x00, 0x45, 0xf3, 0x45, 0xf2, 0xb9, 0x1f, 0x7b, 0x28, 0x91, 0x1f, 0x80, 0xae,
	0xec, 0x86, 0xb1, 0x47, 0x5e, 0xa4, 0xda, 0x8c, 0x50, 0x12, 0xbe, 0x3b, 0x95, 0x3b, 0x94, 0x0a,
	0x0c, 0xed, 0x78, 0xa2, 0x44, 0xbf, 0x07, 0xab, 0x6e, 0xcc, 0xb1, 0x25, 0x56, 0x7c, 0x62, 0x52,
	0x5c, 0xd0, 0x10, 0x6d, 0xaa, 0x14, 0x21, 0xae, 0xbb, 0xf1, 0xc0, 0x3b, 0xb0, 0xe2, 0x93, 0x6d,
	0x7e, 0x51, 0x63, 0xcd, 0xfa, 0x87, 0xa0, 0x4d, 0x62, 0xe6, 0x22, 0x4c, 0x64, 0xbd, 0x30, 0x73,
	0xfa, 0x23, 0x22, 0x45, 0x22, 0xeb, 0x85, 0x3c, 0x69, 0xfd, 0x3f, 0xaa, 0x01, 0xd0, 0xed, 0x8e,
	0x4d, 0xee, 0xc3, 0xaa, 0x37, 0xf4, 0x12, 0x69, 0xec, 0x56, 0xfc, 0x67, 0xa9, 0xed, 0x32, 0xaf,
	0x15, 0xf0, 0x99, 0x27, 0xed, 0x6d, 0xe8, 0xb8, 0xb1, 0x19, 0xb1, 0x21, 0xa7, 0xff, 0x91, 0x74,
	0x9b, 0xc9, 0x54, 0x09, 0x6e, 0x6c, 0x64, 0x55, 0x68, 0xcb, 0x89, 0xe2, 0x6c, 0xd9, 0xc9, 0x69,
	0x17, 0x9c, 0x28, 0x96, 0x6b, 0xfd, 0xab, 0xb0, 0xc6, 0x01, 0x1c, 0x76, 0x64, 0xa5, 0xa3, 0x84,
	0x0f, 0xfe, 0x90, 0x1d, 0x5b, 0x63, 0x57, 0x9c, 0xff, 0xee, 0x94, 0x56, 0x6b, 0x2b, 0x8a, 0x1f,
	0x0a, 0x88, 0x07, 0xd9, 0x05, 0x65, 0xac, 0x38, 0x51, 0xbc, 0x45, 0x38, 0x06, 0x9e, 0xac, 0x47,
	0xe9, 0xc0, 0x32, 0x8b, 0x3c, 0x59, 0xf3, 0xd8, 0x7a, 0x94, 0x71, 0x65, 0x17, 0x2d, 0xc7, 0x73,
	0xe3, 0x98, 0xcc, 0xe7, 0x7e, 0x12, 0x05, 0xa3, 0x0c, 0xba, 0xe0, 0xc0, 0xb8, 0x96, 0xc1, 0x6d,
	0x12, 0x98, 0x44, 0x91, 0x9b, 0xa2, 0xc8, 0xa1, 0x46, 0x98, 0xa2, 0xfa, 0xd0, 0xb1, 0x59, 0x24,
	0x82, 0xe4, 0xe2, 0x24, 0x92, 0x6e, 0x34, 0xbc, 0xf0, 0xb1, 0x3b, 0x62, 0xfb, 0x49, 0xc4, 0x19,
	0xf1, 0x13, 0x76, 0x9a, 0x83, 0x50, 0x1c, 0x07, 0x9c, 0xb0, 0x53, 0x01, 0xd1, 0xff, 0xcf, 0xef,
	0x43, 0x75, 0xe0, 0xe9, 0xd7, 0xa1, 0x63, 0x5a, 0x91, 0x9b, 0x1c, 0x7b, 0xa8, 0xba, 0x35, 0xa5,
	0xe1, 0x73, 0x43, 0x94, 0x6d, 0x3b, 0x67, 0x90, 0x29, 0xe2, 0x8d, 0xcb, 0xc9, 0x14, 0xed, 0x73,
	0xe5, 0xce, 0x59, 0x18, 0x7b, 0x68, 0x60, 0xeb, 0x43, 0x27, 0xd3, 0x15, 0x2b, 0x36, 0xb8, 0x96,
	0xd0, 0x16, 0x23, 0x4c, 0xc1, 0x84, 0x80, 0x57, 0x8e, 0x62, 0x42, 0x10, 0xe2, 0x77, 0x6e, 0x42,
	0x88, 0x03, 0xfb, 0x84, 0x25, 0x22, 0xfe, 0x71, 0x49, 0x31, 0x22, 0xec, 0x63, 0x85, 0xfe, 0x0e,
	0xe8, 0x25, 0x3a, 0x53, 0xf2, 0xb5, 0xd3, 0xa6, 0x54, 0xa6, 0xb7, 0x61, 0x49, 0x35, 0x3a, 0x90,
	0xfb, 0x57, 0x83, 0x0c, 0x2e, 0xb9, 0xdd, 0x81, 0x22, 0x1a, 0x27, 0x55, 0xb8, 0xcc, 0x29, 0xc4,
	0x3e, 0x16, 0x54, 0xb8, 0xcc, 0xa1, 0x36, 0x57, 0xa1, 0xa5, 0xe8, 0x4a, 0x84, 0xa5, 0x0f, 0x72,
	0xed, 0x07, 0xbe, 0xf6, 0xd8, 0xb4, 0xc7, 0x1e, 0x12, 0xb8, 0x9a, 0x31, 0xef, 0xc6, 0x9b, 0x63,
	0x4f, 0xbf, 0x01, 0x5d, 0x5e, 0x7c, 0x18, 0x49, 0xbd, 0x3c, 0xe9, 0xef, 0xf9, 0x99, 0xd8, 0x3c,
	0x8c, 0x84, 0x3e, 0x5e, 0xbf, 0x09, 0x8b, 0x6e, 0x6c, 0x5a, 0x76, 0x14, 0x70, 0xd9, 0x83, 0x9f,
	0x7c, 0xe1, 0xe3, 0xd7, 0x71, 0xe3, 0x0d, 0x59, 0x3a, 0xf0, 0xce, 0x50, 0xf3, 0x77, 0x67, 0xab,
	0xf9, 0xdf, 0x9c, 0xe6, 0xff, 0x89, 0x86, 0x4d, 0x72, 0xef, 0x6b, 0x50, 0xf7, 0x03, 0x07, 0x4d,
	0xb6, 0x1a, 0xbd, 0x7c, 0xfe, 0xb8, 0x4d, 0x52, 0x15, 0x29, 0xde, 0x89, 0x0d, 0x09, 0x1c, 0x7a,
	0xd9, 0x1c, 0x18, 0x37, 0x03, 0xd9, 0xf0, 0x1a, 0xbc, 0x00, 0x77, 0xc2, 0x6d, 0x58, 0x22, 0x4c,
	0x6a, 0x50, 0x04, 0x19, 0xec, 0x16, 0x11, 0xa7, 0x12, 0x18, 0xf1, 0x3a, 0x74, 0xd4, 0x80, 0xd8,
	0xb8, 0xb7, 0x82, 0xaa, 0xde, 0xb6, 0x12, 0x11, 0x1b, 0x97, 0xfb, 0xdd, 0x5d, 0x98, 0xe1, 0x77,
	0x77, 0x11, 0x1a, 0x89, 0x35, 0xcc, 0x23, 0x60, 0x9a, 0x46, 0x3d, 0xb1, 0x48, 0xe3, 0x78, 0x19,
	0x80, 0xbf, 0x55, 0x61, 0x98, 0x5e, 0x23, 0x8b, 0x87, 0x28, 0x41, 0xcb, 0x34, 0x6e, 0xd2, 0xdc,
	0x69, 0x07, 0xe3, 0x2b, 0x62, 0x34, 0xcd, 0xd5, 0x0c, 0xdd, 0x4f, 0xbd, 0x5d, 0xe9, 0xb8, 0x43,
	0x35, 0x14, 0xd6, 0x21, 0xa7, 0xc8, 0xe2, 0xde, 0x45, 0xb2, 0x1b, 0x66, 0x41, 0x06, 0x94, 0x23,
	0x40, 0x2a, 0x6d, 0x7d, 0x3c, 0x81, 0x71, 0x6f, 0x1d, 0xa1, 0x3a, 0xa2, 0x78, 0x97, 0x1f, 0xbd,
	0xf8, 0x4c, 0x65, 0xf3, 0x25, 0x1c, 0xc0, 0x2c, 0x65, 0x73, 0x41, 0x43, 0xfa, 0xda, 0x84, 0x86,
	0xf4, 0x4d, 0xcc, 0x62, 0x81, 0xf6, 0x56, 0xf9, 0x26, 0x48, 0x75, 0xdd, 0x15, 0xc5, 0xf2, 0x45,
	0xbc, 0x0d, 0x4b, 0x61, 0x14, 0x24, 0x8c, 0x22, 0x05, 0x9c, 0xc0, 0xb3, 0x5c, 0x5f, 0xe8, 0xac,
	0xb5, 0xbc, 0x62, 0x0b, 0xcb, 0x39, 0x79, 0x99, 0x02, 0xa6, 0xbd, 0x40, 0xaa, 0xeb, 0x95, 0xc9,
	0x16, 0xb8, 0x2f, 0xde, 0x86, 0xa5, 0x4c, 0x51, 0x6f, 0x9f, 0x92, 0x56, 0x16, 0xb5, 0xd5, 0x4d,
	0x43, 0x53, 0x2a, 0x50, 0x33, 0xcb, 0xbb, 0x98, 0x02, 0xa6, 0x2e, 0xae, 0x53, 0x17, 0x93, 0x2d,
	0xb0, 0x8b, 0x2d, 0xb8, 0x2a, 0x6e, 0x07, 0x54, 0x57, 0x1f, 0x5a, 0x31, 0x73, 0x4c, 0x55, 0x69,
	0x1e, 0xa3, 0xc6, 0xba, 0x69, 0x5c, 0x12, 0x60, 0xbb, 0x47, 0xf1, 0x43, 0x0e, 0x34, 0xc8, 0xb5,
	0xe5, 0xb1, 0xbe, 0x03, 0x37, 0xce, 0xc6, 0x22, 0xd4, 0x4b, 0xaf, 0x23, 0xaa, 0xab, 0xb3, 0x51,
	0x91, 0xd1, 0xe8, 0x29, 0x5c, 0x97, 0xe8, 0x28, 0x07, 0x47, 0xd9, 0xb0, 0x6e, 0x20, 0xae, 0xcb,
	0x02, 0x10, 0xb3, 0x71, 0x4c, 0x0f, 0xec, 0xc7, 0x70, 0xf3, 0xcb, 0x30, 0x89, 0xa1, 0xbd, 0x81,
	0xe8, 0xae, 0x9f, 0x85, 0x8e, 0x06, 0xd7, 0x83, 0xba, 0x3d, 0x4a, 0xf9, 0xed, 0x8c, 0xba, 0xf1,
	0xa6, 0x21, 0x1f, 0x31, 0x56, 0x9d, 0x7e, 0xd2, 0xba, 0xbf, 0x29, 0xae, 0x2c, 0x2a, 0xc3, 0xe5,
	0xbe, 0x0a, 0xad, 0x5c, 0xd7, 0xeb, 0xa0, 0xae, 0xbb, 0x66, 0x40, 0xa6, 0xe0, 0xc5, 0xd8, 0x6d,
	0x0e, 0xe0, 0xc6, 0x41, 0xc6, 0xf0, 0xbe, 0x45, 0xa4, 0xcd, 0x1f, 0x26, 0xdb, 0x71, 0x20, 0x19,
	0x5d, 0x1f, 0x3e, 0x10, 0xf7, 0xed, 0x08, 0xa9, 0x6c, 0x10, 0x59, 0x43, 0x2e, 0xc2, 0xb0, 0xc8,
	0x44, 0x6f, 0x25, 0x53, 0xe6, 0xdb, 0x63, 0xa8, 0x8c, 0xf5, 0x33, 0xa2, 0x7d, 0x1b, 0xb1, 0xbd,
	0x9b, 0x37, 0xde, 0xa7, 0xb6, 0x07, 0x2e, 0x8b, 0xd0, 0xf1, 0x69, 0x33, 0x6b, 0xb8, 0x87, 0xed,
	0x88, 0xa0, 0xc7, 0xf0, 0xd1, 0xac, 0xfe, 0x1c, 0x2b, 0x36, 0x63, 0x2b, 0xb1, 0x66, 0x76, 0xf9,
	0x36, 0x76, 0xf9, 0x5e, 0x69, 0x97, 0x5b, 0x56, 0xbc, 0x6f, 0x25, 0x56, 0x79, 0xa7, 0x3f, 0x87,
	0xfb, 0xb3, 0x3a, 0x8d, 0xe3, 0xd9, 0x53, 0x7c, 0x07, 0xfb, 0xfb, 0x4e, 0x69, 0x7f, 0xfb, 0xf1,
	0x8c, 0x09, 0xbe, 0x01, 0x5d, 0x7e, 0x47, 0xd8, 0x6e, 0x72, 0x2a, 0xd0, 0x7c, 0x87, 0xd6, 0x5d,
	0x96, 0x66, 0xe1, 0xfd, 0x32, 0x71, 0x19, 0xaa, 0xc2, 0x9b, 0x46, 0x7d, 0x4c, 0x62, 0xcf, 0x59,
	0x32, 0xcb, 0x7b, 0x67, 0xc9, 0x2c, 0x77, 0x67, 0xc8, 0x2c, 0xf7, 0x88, 0x21, 0x2f, 0x91, 0x43,
	0xce, 0x30, 0xc5, 0xde, 0x9f, 0x6d, 0x8a, 0xbd, 0x3b, 0x43, 0x7a, 0x79, 0x5f, 0xe9, 0xa7, 0x28,
	0x91, 0x90, 0xa1, 0x40, 0x11, 0x9f, 0x3f, 0x20, 0x1d, 0xe2, 0xd8, 0xdb, 0xc8, 0x05, 0xe8, 0xef,
	0xc1, 0x3a, 0x86, 0xe9, 0x53, 0x1c, 0xbf, 0x99, 0x85, 0x9f, 0x10, 0x81, 0xff, 0x10, 0xc7, 0xb3,
	0x86, 0x10, 0x18, 0x57, 0xa4, 0x04, 0x9f, 0xb0, 0x58, 0x7f, 0x13, 0x3a, 0x87, 0x96, 0x7d, 0x92,
	0x86, 0xa6, 0xd0, 0x39, 0x7e, 0x37, 0x0b, 0x7c, 0x6d, 0x53, 0x85, 0xd0, 0x3e, 0xbf, 0x09, 0x8b,
	0x45, 0xf3, 0x6e, 0xdc, 0xfb, 0x08, 0x51, 0x77, 0x0b, 0xa9, 0x51, 0xf8, 0x2c, 0x75, 0x37, 0x56,
	0x45, 0x28, 0xe4, 0x22, 0x3e, 0xce, 0x85, 0x6c, 0x37, 0xce, 0x05, 0x28, 0xe4, 0x26, 0xc8, 0x84,
	0x2a, 0x77, 0x52, 0x26, 0x4e, 0x3d, 0xc8, 0x4c, 0xa8, 0xa2, 0xea, 0x89, 0x10, 0xa0, 0xae, 0x40,
	0x0b, 0xbd, 0x92, 0x04, 0xdb, 0xfa, 0x3d, 0xca, 0x00, 0xc1, 0x8b, 0xb6, 0x91, 0x75, 0xbd, 0x0b,
	0x0a, 0x35, 0x37, 0xa3, 0x74, 0x24, 0x82, 0xea, 0xbf, 0x4f, 0xeb, 0x9c, 0xd7, 0x19, 0xe9, 0x88,
	0xc9, 0x3b, 0x47, 0x69, 0x81, 0x2c, 0xc7, 0x27, 0x74, 0xe7, 0xe4, 0xc5, 0xc8, 0x72, 0x7c, 0x4f,
	0x09, 0x17, 0x9a, 0x70, 0x89, 0xf8, 0x41, 0xee, 0x12, 0x71, 0x41, 0xc2, 0x6c, 0x16, 0x1c, 0x23,
	0x3e, 0x82, 0x1e, 0x27, 0x2d, 0x76, 0xe0, 0x79, 0xa9, 0xef, 0xda, 0xc4, 0x23, 0x5a, 0x76, 0xe2,
	0x8e, 0x59, 0xef, 0x87, 0x74, 0x61, 0xfa, 0xc3, 0x64, 0x53, 0xad, 0xde, 0xc0, 0x5a, 0xce, 0x01,
	0x22, 0x51, 0x92, 0x0a, 0xa6, 0xec, 0x9e, 0xfd, 0x65, 0x62, 0xa3, 0x38, 0x69, 0x92, 0x75, 0xf2,
	0x92, 0xbd, 0x03, 0xcb, 0xd8, 0x9b, 0x20, 0x88, 0xb2, 0xc5, 0x06, 0xf9, 0x80, 0xf3, 0x8e, 0xa8,
	0x46, 0xc2, 0xbf, 0x0d, 0x3a, 0x87, 0x1f, 0x7b, 0xe6, 0x38, 0xce, 0xc5, 0x9d, 0x87, 0x22, 0x56,
	0x64, 0x98, 0x0c, 0xbc, 0x41, 0x9c, 0xc9, 0x3c, 0x62, 0x2a, 0x02, 0xca, 0xb4, 0x42, 0xca, 0x97,
	0xe7, 0x06, 0x7e, 0xdc, 0xdb, 0xc4, 0xf7, 0xb6, 0x9a, 0xd3, 0xd4, 0x0d, 0xa5, 0x56, 0xd2, 0xd7,
	0xa3, 0x51, 0x94, 0xf5, 0xb1, 0x95, 0xd1, 0xd7, 0xc7, 0xa3, 0x48, 0xf6, 0x70, 0x0d, 0xda, 0x1c,
	0x4e, 0x32, 0xf1, 0xbd, 0x47, 0xc4, 0xc1, 0xfa, 0xc3, 0xe4, 0x09, 0xb1, 0xf0, 0x98, 0x56, 0x00,
	0x29, 0x35, 0xbf, 0x56, 0xdc, 0xcf, 0xfd, 0xde, 0x63, 0x11, 0x58, 0xcb, 0xe9, 0xb4, 0x1d, 0xbb,
	0xdb, 0x9f, 0xfb, 0xe8, 0xa8, 0x3c, 0xb2, 0x92, 0xa3, 0x20, 0x12, 0x66, 0xfe, 0x27, 0x74, 0x80,
	0x64, 0x21, 0xbe, 0xd4, 0x07, 0x70, 0xd1, 0xcb, 0x14, 0xc7, 0x99, 0xd7, 0xb4, 0x6d, 0x73, 0xf2,
	0xd0, 0x7b, 0x8a, 0x0d, 0xd6, 0xbc, 0x09, 0xcd, 0xf2, 0x06, 0x55, 0xf3, 0xfb, 0x04, 0xdf, 0x8a,
	0x4f, 0x1c, 0xda, 0x36, 0x8d, 0x52, 0x16, 0x61, 0x60, 0x70, 0xc3, 0xf5, 0x38, 0xd5, 0x74, 0x9d,
	0xde, 0x8f, 0x88, 0x5e, 0xe1, 0xf3, 0xb6, 0xc3, 0x07, 0x97, 0xb5, 0xc5, 0xc1, 0x7d, 0x4a, 0x83,
	0x93, 0x85, 0x38, 0xb8, 0x9b, 0xb0, 0x18, 0xa6, 0x87, 0x23, 0xd7, 0x36, 0x1d, 0x5f, 0x88, 0x32,
	0x9f, 0x51, 0x2e, 0x11, 0x2a, 0xde, 0xf2, 0x63, 0xc9, 0xc2, 0x0a, 0x38, 0x45, 0x04, 0xde, 0x21,
	0x16, 0x96, 0x2a, 0xb6, 0xd5, 0x40, 0xd2, 0x30, 0x72, 0xc7, 0x98, 0xaf, 0x51, 0x22, 0xdd, 0x95,
	0xfb, 0x1d, 0xcb, 0x25, 0xd6, 0x77, 0x40, 0x97, 0x90, 0x0a, 0xda, 0x67, 0x92, 0xc9, 0xc2, 0x9a,
	0x1c, 0xef, 0x2a, 0x2c, 0x70, 0x99, 0x3a, 0xf0, 0x7b, 0x7b, 0xc4, 0x8f, 0xd3, 0x13, 0x5f, 0xa4,
	0x91, 0x95, 0xfa, 0xf6, 0x31, 0x9e, 0x96, 0xde, 0x8f, 0x69, 0x91, 0xa8, 0x88, 0x9f, 0x0e, 0x3e,
	0xa0, 0x48, 0x89, 0x39, 0xc4, 0xc5, 0x30, 0x68, 0x40, 0x51, 0x21, 0xc2, 0xb0, 0xb0, 0x66, 0x38,
	0xee, 0xfd, 0xe2, 0x9a, 0xe1, 0xa8, 0x2f, 0x03, 0x90, 0xda, 0x90, 0x5f, 0x48, 0xbd, 0x03, 0xe2,
	0x9a, 0x45, 0xc9, 0xc3, 0x53, 0xce, 0xd5, 0x59, 0x63, 0xcb, 0x1d, 0x59, 0x87, 0xee, 0x88, 0x13,
	0x6e, 0x3c, 0xbe, 0xcf, 0x69, 0x4e, 0x6a, 0xc5, 0x4f, 0xf9, 0xa1, 0xbd, 0x48, 0x0a, 0x1e, 0x1c,
	0xd2, 0x80, 0xde, 0xdf, 0x30, 0x4c, 0x71, 0x2c, 0xb3, 0x14, 0x39, 0xbf, 0x32, 0x53, 0x91, 0xf3,
	0x31, 0x5c, 0x1c, 0xb1, 0xa1, 0x65, 0x9f, 0x9a, 0xa8, 0xe3, 0xcb, 0xae, 0x0e, 0xa4, 0x77, 0x3f,
	0xa1, 0x73, 0x43, 0x00, 0x4f, 0x83, 0x38, 0x91, 0xb7, 0x07, 0x12, 0xbd, 0x4f, 0xe0, 0x92, 0x6d,
	0x25, 0x6c, 0xc8, 0xc5, 0xc0, 0x92, 0xc6, 0xff, 0x0f, 0x36, 0xee, 0x49, 0x90, 0xa9, 0xe6, 0x98,
	0x14, 0x2a, 0x73, 0x35, 0xe9, 0xfd, 0x14, 0xc1, 0x61, 0x9c, 0xe9, 0x87, 0xb9, 0xe0, 0x47, 0xa7,
	0xc9, 0x94, 0xa1, 0x44, 0xbf, 0x4a, 0x82, 0x1f, 0x1e, 0xa7, 0x2d, 0x11, 0x4f, 0xf4, 0x21, 0xac,
	0x4d, 0x92, 0x56, 0x39, 0xeb, 0x5f, 0x43, 0xf0, 0x0b, 0x45, 0xea, 0x2a, 0x27, 0xbe, 0x96, 0x3b,
	0xda, 0xfc, 0xba, 0x94, 0xd3, 0x71, 0x0d, 0x3f, 0x86, 0x8b, 0x48, 0x48, 0xe2, 0x97, 0x62, 0x15,
	0xf3, 0xdb, 0xdb, 0xe9, 0xfd, 0x46, 0x46, 0x14, 0x1f, 0xc5, 0x2f, 0x69, 0x25, 0xb3, 0xdb, 0xdb,
	0x91, 0x4d, 0x4f, 0xc6, 0x5e, 0x49, 0x53, 0x33, 0x6b, 0xfa, 0xe9, 0xd8, 0x9b, 0x6a, 0xba, 0x0b,
	0x37, 0x78, 0x53, 0x8c, 0x25, 0x0a, 0x2d, 0xcc, 0xd5, 0x9a, 0xd1, 0xb2, 0x23, 0xcc, 0x0e, 0xcc,
	0x37, 0x5c, 0xdc, 0xfb, 0x19, 0x62, 0xb9, 0xe6, 0x0f, 0x93, 0x1d, 0x05, 0x54, 0x90, 0xa8, 0xc7,
	0x41, 0x44, 0x1b, 0x33, 0x2e, 0xf3, 0x60, 0xb0, 0xca, 0x93, 0x1e, 0x2e, 0x2b, 0xde, 0x1f, 0x19,
	0x01, 0x3c, 0x24, 0x9d, 0x42, 0xee, 0x05, 0x22, 0x89, 0xe0, 0x3b, 0xa0, 0xab, 0xb1, 0xb8, 0x42,
	0x29, 0x66, 0xe3, 0xcb, 0xd3, 0xf2, 0x30, 0xdb, 0xcc, 0xef, 0xba, 0x24, 0x72, 0xd7, 0x41, 0xe0,
	0xa9, 0x98, 0xdc, 0xeb, 0xd0, 0x56, 0x3c, 0x04, 0xe3, 0x1e, 0x23, 0x39, 0x30, 0x77, 0xfd, 0x43,
	0x2a, 0xa1, 0x3a, 0x11, 0xa6, 0xd1, 0x28, 0xee, 0x1d, 0xd1, 0x95, 0x9f, 0x83, 0x3d, 0x8f, 0x46,
	0x31, 0xba, 0x04, 0x29, 0x90, 0x98, 0xa3, 0xba, 0x37, 0xa4, 0x8e, 0x73, 0x50, 0xfe, 0xbe, 0x51,
	0x99, 0x51, 0xee, 0xc4, 0x71, 0x4c, 0x57, 0xd9, 0xab, 0x39, 0x68, 0xb8, 0xa4, 0x01, 0x79, 0x75,
	0x07, 0x8d, 0x9f, 0x67, 0xfb, 0xa3, 0xcc, 0x41, 0xe3, 0x07, 0xf0, 0x5a, 0x81, 0xa5, 0xca, 0x33,
	0xf3, 0xd0, 0x69, 0x3b, 0xa1, 0xd3, 0xa6, 0x30, 0x55, 0x59, 0xa2, 0x9e, 0x8c, 0x43, 0x51, 0x3c,
	0x15, 0x47, 0x93, 0x9e, 0x8a, 0xd7, 0xa1, 0xad, 0xe6, 0x41, 0xeb, 0x79, 0xb4, 0xfa, 0x4a, 0x0a,
	0x34, 0x2e, 0x4d, 0xf2, 0xe1, 0x4b, 0xd1, 0xde, 0xf5, 0x13, 0x16, 0x1d, 0x59, 0x7c, 0x53, 0xfa,
	0x08, 0xbc, 0xe2, 0x0f, 0x13, 0x99, 0x7d, 0x21, 0xab, 0xe3, 0x03, 0x17, 0xbe, 0x4e, 0xaa, 0x38,
	0x98, 0xbb, 0x74, 0x05, 0xe4, 0xbc, 0x4c, 0x30, 0xbb, 0x99, 0x14, 0x98, 0x39, 0x77, 0xfd, 0x18,
	0x6e, 0xba, 0xb1, 0x39, 0xcb, 0x67, 0x4b, 0x39, 0x26, 0xbd, 0x10, 0x17, 0xf0, 0xba, 0x1b, 0x0f,
	0xca, 0xbc, 0xb6, 0xf2, 0x53, 0xa2, 0x7f, 0xc0, 0x59, 0xa6, 0x09, 0x9c, 0x18, 0xd6, 0x1f, 0xf7,
	0x3e, 0x47, 0x1c, 0x2b, 0xc7, 0x96, 0x8a, 0x04, 0x63, 0xf9, 0x63, 0xfd, 0x09, 0x5c, 0x53, 0xb4,
	0x40, 0x47, 0x2c, 0x11, 0xb7, 0x07, 0xaa, 0x4c, 0x38, 0xdf, 0x67, 0xc7, 0xbd, 0x08, 0xdb, 0x5f,
	0xce, 0xe1, 0x1e, 0x73, 0xb0, 0x4c, 0xb1, 0xf2, 0x9c, 0x03, 0xf1, 0x33, 0x54, 0xe2, 0xe0, 0x19,
	0x8b, 0xe0, 0xc1, 0xaf, 0xe7, 0xd9, 0x99, 0xe0, 0xab, 0x38, 0x9f, 0x67, 0xe7, 0x0d, 0xe8, 0x66,
	0xc9, 0xda, 0x88, 0x1f, 0x4d, 0xe9, 0xea, 0x92, 0xa9, 0xd8, 0x90, 0x13, 0xbd, 0x0d, 0x4b, 0x94,
	0x5d, 0x0c, 0x35, 0xb9, 0x42, 0xa9, 0x31, 0x26, 0x8f, 0x1a, 0x4c, 0x31, 0xc6, 0xcb, 0x85, 0x4e,
	0xe3, 0x32, 0xc0, 0xe7, 0x41, 0x2c, 0x19, 0xf7, 0x17, 0xb4, 0xc9, 0x3e, 0x0f, 0x62, 0xc1, 0xb1,
	0xbf, 0xc5, 0x6f, 0xf9, 0x2c, 0x0b, 0x97, 0xe9, 0x06, 0x61, 0xdc, 0x7b, 0x49, 0xec, 0x9c, 0x52,
	0xbe, 0x1d, 0x84, 0x28, 0x7b, 0x25, 0xc7, 0x51, 0x90, 0x24, 0x23, 0x09, 0x78, 0x4a, 0x3c, 0x59,
	0x56, 0x8a, 0x60, 0x13, 0xe9, 0x76, 0xbf, 0x98, 0x4a, 0xb7, 0x7b, 0x05, 0x5a, 0x6e, 0x6c, 0x66,
	0x0e, 0xac, 0xff, 0x2f, 0x71, 0xe6, 0x6e, 0xbc, 0x21, 0x5c, 0x58, 0x67, 0xf9, 0x34, 0xfd, 0xe6,
	0xac, 0x00, 0xe1, 0xdb, 0xb0, 0xa4, 0xea, 0xa2, 0x48, 0xee, 0xf8, 0xff, 0x88, 0xb2, 0xe4, 0xda,
	0x28, 0x12, 0x3c, 0x14, 0x58, 0x0c, 0x19, 0x40, 0xd8, 0xff, 0xbf, 0x00, 0xfb, 0x24, 0x4c, 0x09,
	0x76, 0xca, 0x57, 0xea, 0x2f, 0x4d, 0xfb, 0x4a, 0xbd, 0x05, 0x9a, 0x95, 0x26, 0x81, 0xa9, 0xfa,
	0xc6, 0xfd, 0x65, 0x52, 0x5c, 0x77, 0x79, 0x45, 0xee, 0x08, 0xa7, 0x7f, 0x00, 0xab, 0x82, 0x38,
	0x4d, 0x7a, 0x57, 0xfd, 0x56, 0x85, 0x32, 0x96, 0x52, 0xf5, 0x66, 0xd1, 0xc9, 0xea, 0xe6, 0x84,
	0x93, 0xd5, 0x6f, 0x57, 0x66, 0xa5, 0xa8, 0x9d, 0xf6, 0xb2, 0xfa, 0x9d, 0x4a, 0xb9, 0x9b, 0xd5,
	0x6b, 0x6a, 0xb2, 0x85, 0xbf, 0x42, 0x40, 0x79, 0x9a, 0x85, 0xbb, 0xb0, 0x82, 0xb5, 0x93, 0xf1,
	0xfe, 0xbf, 0xa0, 0x79, 0x2d, 0xf1, 0xca, 0x5d, 0x35, 0xe8, 0x9f, 0x4f, 0x4d, 0x5a, 0x36, 0x26,
	0xdc, 0x7b, 0x7f, 0x97, 0xda, 0xac, 0x88, 0xea, 0xa2, 0x8b, 0x6f, 0x69, 0x33, 0x64, 0xd8, 0xfe,
	0xea, 0x8c, 0x66, 0xc8, 0xb9, 0xbd, 0x0f, 0xab, 0x22, 0x4b, 0xb7, 0x79, 0xc4, 0x29, 0x6f, 0x6e,
	0x0a, 0xfd, 0x3d, 0x61, 0xce, 0x11, 0xd5, 0x8f, 0xa3, 0xc0, 0x7b, 0x2a, 0xcd, 0xa2, 0xd7, 0x8a,
	0x59, 0x1e, 0x7e, 0xbf, 0x32, 0x95, 0xe6, 0xe1, 0x11, 0x5c, 0x0a, 0x22, 0x77, 0xe8, 0xfa, 0x82,
	0x29, 0x34, 0x29, 0x6d, 0xf8, 0xd8, 0x66, 0x9c, 0x76, 0xf6, 0xfe, 0x5a, 0x21, 0x36, 0xbb, 0x97,
	0x83, 0x3e, 0x3c, 0xc5, 0x94, 0xea, 0x03, 0x82, 0xd3, 0x7f, 0x1d, 0xde, 0x09, 0x83, 0x38, 0x76,
	0xf9, 0x9b, 0x50, 0x88, 0x8a, 0x50, 0x7e, 0x14, 0x08, 0x07, 0xde, 0x13, 0x7f, 0xbd, 0x82, 0xdb,
	0xef, 0xa6, 0x6c, 0x94, 0x51, 0x03, 0x52, 0x7c, 0x28, 0x54, 0x0f, 0xaf, 0x8d, 0x1f, 0xce, 0x4e,
	0x46, 0xf1, 0x37, 0x2a, 0xe7, 0xc8, 0x46, 0xc1, 0x25, 0x19, 0xb9, 0x51, 0x44, 0x46, 0x95, 0x17,
	0xc7, 0xae, 0x8c, 0x6e, 0xfd, 0x03, 0x1a, 0xcc, 0xaa, 0x80, 0xa0, 0xb4, 0x36, 0xbf, 0xc2, 0xeb,
	0xb1, 0xf3, 0xb7, 0xa7, 0xfc, 0xf3, 0xfe, 0x66, 0x65, 0x96, 0x83, 0x9e, 0xfe, 0x4e, 0x66, 0xbe,
	0x08, 0xc6, 0x2c, 0xe2, 0x12, 0xad, 0x9b, 0xf4, 0xfe, 0x16, 0xad, 0xbb, 0x46, 0x35, 0xcf, 0xb2,
	0x8a, 0xfc, 0xce, 0x0f, 0x7c, 0xe1, 0x0e, 0x2a, 0x34, 0x3c, 0x7f, 0x9b, 0x72, 0xbc, 0xea, 0x21,
	0x7d, 0x68, 0x80, 0xfc, 0x41, 0x49, 0xcf, 0xf3, 0x1e, 0xac, 0x78, 0xae, 0xef, 0x7a, 0xa9, 0x57,
	0x6c, 0xf2, 0x87, 0xa2, 0x89, 0xa8, 0x54, 0x9a, 0xf4, 0xff, 0x6b, 0x1b, 0x5a, 0xca, 0x92, 0xea,
	0x5d, 0xa8, 0x8e, 0x3d, 0x61, 0x6a, 0xaa, 0x8e, 0x4b, 0xac, 0x50, 0xd5, 0x29, 0x2b, 0xd4, 0x35,
	0x68, 0x5b, 0x49, 0x62, 0xd9, 0xc7, 0x68, 0x1a, 0x75, 0x84, 0x51, 0x09, 0xa8, 0x6c, 0xe0, 0x89,
	0x24, 0xc6, 0x45, 0x35, 0xd5, 0x5c, 0x99, 0x9a, 0xea, 0xba, 0x48, 0x09, 0x2d, 0x45, 0xa6, 0x79,
	0x92, 0x4d, 0x1d, 0x25, 0x2f, 0xac, 0x9a, 0x7c, 0x91, 0xac, 0x4a, 0x59, 0xf2, 0xc5, 0xc9, 0xa4,
	0x9b, 0xf5, 0xe9, 0xa4, 0x9b, 0x94, 0x5b, 0x8b, 0x1e, 0x85, 0x6d, 0x2e, 0x2f, 0xe0, 0x0c, 0xa9,
	0x98, 0x47, 0x26, 0x7c, 0x92, 0x71, 0xae, 0x43, 0xc5, 0xdb, 0x42, 0x04, 0xbd, 0x0f, 0xab, 0x72,
	0xbe, 0x6a, 0x5e, 0xd6, 0x2c, 0x36, 0x6c, 0x59, 0xcc, 0x3c, 0x67, 0x4c, 0xb6, 0x31, 0x8b, 0xd1,
	0x38, 0x27, 0x1d, 0x94, 0x17, 0xa7, 0x39, 0xce, 0xd2, 0xcb, 0x96, 0xd8, 0x6f, 0xda, 0xa5, 0xf6,
	0x9b, 0xf7, 0xe0, 0x42, 0x39, 0x97, 0x22, 0x2c, 0xe1, 0xfe, 0x34, 0x7f, 0xf2, 0x01, 0xac, 0x15,
	0xd5, 0xc9, 0x79, 0x23, 0xb2, 0x28, 0xad, 0xa8, 0xfa, 0xe3, 0xac, 0xd9, 0x47, 0x70, 0x51, 0x36,
	0x0b, 0x5d, 0x7f, 0xa2, 0x37, 0x32, 0x2e, 0xc9, 0xa1, 0xec, 0xb9, 0xbe, 0xda, 0xe1, 0xf7, 0xe1,
	0x92, 0x35, 0x1a, 0x15, 0x8f, 0x76, 0xd6, 0x34, 0xee, 0x69, 0xa4, 0x5d, 0xb3, 0x46, 0x23, 0x65,
	0xe3, 0xc9, 0xc6, 0xb1, 0xbe, 0x0d, 0x7d, 0x25, 0xe1, 0x68, 0x3c, 0x83, 0x29, 0x5b, 0x22, 0x45,
	0x7a, 0x9e, 0x73, 0x34, 0x2e, 0xe1, 0xcc, 0xb6, 0x0a, 0xb9, 0x4b, 0x73, 0x54, 0xf4, 0x26, 0x84,
	0x55, 0x0b, 0xed, 0x04, 0xd3, 0x78, 0x06, 0xbc, 0x08, 0xe9, 0xab, 0xa2, 0x3b, 0x5f, 0x3e, 0x5b,
	0x77, 0xbe, 0x32, 0xad, 0x3b, 0xff, 0xca, 0x2a, 0xef, 0x0b, 0x7f, 0xf1, 0x2a, 0xef, 0xd5, 0xbf,
	0x60, 0x95, 0xf7, 0xda, 0x57, 0x51, 0x79, 0x6f, 0xc2, 0x15, 0xa5, 0xaf, 0x24, 0x48, 0xb8, 0x04,
	0x25, 0xee, 0x12, 0xb2, 0xb1, 0x90, 0x21, 0xef, 0x52, 0x0e, 0x75, 0xc0, 0x81, 0xc4, 0xed, 0x81,
	0x20, 0x93, 0x99, 0x43, 0x2f, 0xaa, 0xb1, 0xa6, 0x32, 0xe9, 0x8d, 0x1b, 0x9b, 0x22, 0xb9, 0xef,
	0x3a, 0x31, 0x04, 0x6e, 0xbc, 0x4f, 0xe9, 0x7d, 0xb9, 0xe8, 0x46, 0x5c, 0x29, 0x11, 0x0a, 0xc4,
	0x71, 0x49, 0x44, 0x73, 0x60, 0x05, 0x92, 0x0a, 0x44, 0x74, 0x1e, 0x96, 0xfc, 0xb5, 0xf3, 0xb0,
	0xe4, 0x85, 0x2c, 0xdb, 0xb8, 0xdb, 0xc8, 0x6c, 0xd7, 0x29, 0x84, 0xcb, 0x94, 0xa5, 0xd1, 0xbd,
	0x5a, 0x92, 0x46, 0x77, 0x6a, 0x0e, 0x88, 0xf1, 0xda, 0xd4, 0x1c, 0x76, 0xa7, 0xbd, 0xd1, 0xae,
	0x4f, 0x79, 0xa3, 0x95, 0x4b, 0x0b, 0xfd, 0x72, 0x69, 0xa1, 0xff, 0x47, 0x75, 0x80, 0x41, 0xc6,
	0x5a, 0x16, 0x74, 0x45, 0x95, 0xa2, 0xae, 0xe8, 0x1c, 0x77, 0x4f, 0x21, 0x06, 0x59, 0x26, 0xff,
	0x97, 0x31, 0xc8, 0x57, 0xa1, 0x45, 0xb1, 0xc5, 0x85, 0x88, 0x62, 0x2a, 0x92, 0x86, 0x2d, 0x35,
	0xe4, 0x78, 0x7e, 0x2a, 0xe4, 0xf8, 0x5c, 0xb1, 0xc5, 0x4d, 0x25, 0xb6, 0xb8, 0x84, 0x8e, 0x37,
	0x4a, 0xe9, 0xf8, 0x32, 0xcc, 0xd3, 0x6d, 0x49, 0x57, 0xcc, 0xdc, 0x98, 0xdf, 0x93, 0x74, 0xf9,
	0x42, 0x76, 0xf9, 0x2a, 0x94, 0xa7, 0x75, 0x36, 0xe5, 0x69, 0x4f, 0x53, 0x9e, 0xdc, 0x47, 0xa5,
	0x23, 0x9c, 0x15, 0xa4, 0xa2, 0xbf, 0x54, 0x01, 0xd7, 0x3d, 0x4b, 0x01, 0x87, 0x8a, 0x9a, 0x9c,
	0x9c, 0x2b, 0xf1, 0xc0, 0x8b, 0x42, 0x27, 0x90, 0x7a, 0x39, 0x31, 0xcf, 0xc3, 0x82, 0xdf, 0x80,
	0xae, 0x67, 0xbd, 0x34, 0xf3, 0xb8, 0x5f, 0xe1, 0x74, 0xd0, 0xf1, 0xac, 0x97, 0x46, 0x56, 0xa8,
	0xaf, 0x43, 0x23, 0x0b, 0x44, 0x5e, 0x22, 0x9f, 0x12, 0xf9, 0xcc, 0x6f, 0x2f, 0x8c, 0xe5, 0x35,
	0x45, 0xa4, 0xaf, 0xe2, 0xfa, 0xa1, 0x93, 0x28, 0x8c, 0xd5, 0x0f, 0xb1, 0x36, 0xf7, 0xff, 0x98,
	0x8c, 0xf5, 0x5d, 0x9e, 0x8e, 0xf5, 0x15, 0x3b, 0x0f, 0x85, 0xd2, 0x95, 0x6c, 0xe7, 0xed, 0x4c,
	0x87, 0x88, 0x13, 0x29, 0x56, 0x43, 0xc4, 0x67, 0x04, 0x7a, 0xaf, 0x66, 0x22, 0xd9, 0x97, 0x07,
	0x7a, 0x13, 0xf1, 0x9b, 0x0c, 0xf4, 0xce, 0x62, 0xcf, 0x7b, 0xf2, 0x9d, 0x39, 0xec, 0xe5, 0xb9,
	0x88, 0xc8, 0xc5, 0xf3, 0x10, 0x91, 0x77, 0x61, 0x85, 0x8f, 0x43, 0x2a, 0x7e, 0x45, 0x9c, 0xaf,
	0x87, 0x14, 0xae, 0x66, 0x2c, 0x79, 0xd6, 0xcb, 0x6d, 0x59, 0xb5, 0xc7, 0xa2, 0x81, 0xd7, 0xff,
	0xb7, 0x8d, 0xec, 0xb0, 0xee, 0xba, 0xf6, 0x57, 0xe1, 0x0e, 0x67, 0xfb, 0x28, 0xd5, 0xce, 0xf0,
	0x51, 0x2a, 0x39, 0x47, 0x73, 0xa5, 0xe7, 0xe8, 0xba, 0xc8, 0x7c, 0x2b, 0xa1, 0x04, 0xcf, 0x28,
	0xca, 0x10, 0xe4, 0x2a, 0xb4, 0x94, 0x34, 0xad, 0xe2, 0x2c, 0x43, 0x9e, 0x76, 0x95, 0xef, 0x52,
	0xd5, 0x89, 0x85, 0x51, 0xce, 0xc6, 0xa6, 0xd1, 0x51, 0x72, 0x7b, 0x32, 0x09, 0xf6, 0xa1, 0x02,
	0xd6, 0xc8, 0xc0, 0x3e, 0xcc, 0xc1, 0xae, 0x41, 0x1b, 0x25, 0x30, 0xe9, 0x07, 0xd2, 0x24, 0xb5,
	0x31, 0x2f, 0x13, 0x4e, 0x20, 0x37, 0xa0, 0x9b, 0x41, 0x90, 0xc4, 0x0d, 0xe4, 0x0e, 0x23, 0x60,
	0x48, 0xdc, 0xbe, 0x04, 0x4d, 0xd4, 0x0c, 0xe2, 0xf9, 0x16, 0xa9, 0xaf, 0x79, 0x01, 0x1e, 0x6e,
	0x25, 0xa7, 0x2a, 0xf9, 0x1a, 0xc9, 0x9c, 0xaa, 0x97, 0xa0, 0xe9, 0x25, 0xa9, 0x38, 0x20, 0x74,
	0xf0, 0x1b, 0x5e, 0x92, 0xd2, 0xa1, 0x50, 0xe8, 0x49, 0xf7, 0x6c, 0x7a, 0xb2, 0x38, 0x4d, 0x4f,
	0xde, 0x54, 0x5c, 0x5c, 0x48, 0x87, 0x26, 0x0e, 0x73, 0x57, 0x2a, 0x15, 0xa8, 0x54, 0xff, 0x10,
	0xd6, 0x2c, 0x91, 0x12, 0xd4, 0x9c, 0x58, 0x57, 0xe2, 0xda, 0x2e, 0xc8, 0xea, 0xed, 0xc2, 0xfa,
	0x4e, 0xb4, 0x53, 0x17, 0x5a, 0x9f, 0x6a, 0xa7, 0x2c, 0xf8, 0x45, 0x8a, 0x16, 0xc7, 0xd7, 0x2f,
	0x18, 0x34, 0x5f, 0x24, 0xf8, 0xfd, 0xf8, 0xac, 0x14, 0xc2, 0x74, 0xe6, 0xbf, 0x62, 0x6e, 0xe0,
	0x0b, 0xa4, 0x14, 0x9c, 0x99, 0x9f, 0x93, 0xdf, 0x12, 0x7c, 0x03, 0xe0, 0x61, 0x5e, 0x15, 0x7e,
	0x72, 0xae, 0x4d, 0x29, 0xe4, 0xb3, 0xec, 0xd5, 0x6b, 0x6a, 0xf6, 0xea, 0xf3, 0x9c, 0xf2, 0xde,
	0x79, 0x4e, 0x79, 0x21, 0xd3, 0xe6, 0xc5, 0xf2, 0x4c, 0x9b, 0x97, 0xd4, 0x6c, 0xa7, 0xeb, 0xb4,
	0xbb, 0xb2, 0x34, 0xa6, 0xb7, 0x61, 0x49, 0xa6, 0x31, 0x45, 0x20, 0x25, 0x3a, 0x57, 0xe6, 0x31,
	0x1d, 0x8c, 0x2c, 0xca, 0xc0, 0x74, 0xab, 0x24, 0x09, 0x32, 0xb9, 0x27, 0x4d, 0x66, 0x36, 0x56,
	0x72, 0x5a, 0x5f, 0xa6, 0x3d, 0x4b, 0x39, 0xad, 0xfb, 0xff, 0xa8, 0x06, 0xdd, 0x41, 0x71, 0x0f,
	0xc9, 0x64, 0xbb, 0x32, 0x19, 0x92, 0xf0, 0x69, 0xe5, 0x65, 0x4f, 0xa8, 0x08, 0xad, 0x88, 0x1c,
	0x24, 0x4e, 0x0f, 0x7d, 0x96, 0x48, 0xca, 0xc3, 0x8b, 0xf6, 0xb1, 0x44, 0x3d, 0x23, 0xd2, 0xcf,
	0x91, 0xce, 0x88, 0xf4, 0xb8, 0x9f, 0x53, 0x3c, 0xee, 0x4b, 0x08, 0xce, 0x7c, 0x29, 0xc1, 0xa1,
	0x9c, 0x1f, 0x0b, 0x59, 0xce, 0x8f, 0xeb, 0x13, 0x09, 0xcd, 0xea, 0x32, 0x2d, 0x5e, 0x9e, 0xde,
	0x4b, 0x39, 0x5c, 0x59, 0x96, 0xc7, 0xfc, 0x70, 0x65, 0x5f, 0x02, 0x52, 0xcf, 0x5f, 0x73, 0xfa,
	0xfc, 0x4d, 0xd1, 0x5a, 0x98, 0xa2, 0xb5, 0xd3, 0x29, 0xcc, 0x14, 0xe2, 0x51, 0x4c, 0x61, 0x86,
	0x28, 0x2f, 0x42, 0x23, 0xe4, 0xbb, 0xd4, 0x4f, 0x3d, 0x41, 0x46, 0xea, 0xfc, 0x79, 0x37, 0xf5,
	0x30, 0xe9, 0x8e, 0x92, 0x05, 0xad, 0x23, 0x92, 0xee, 0xe4, 0xe9, 0xcf, 0xfe, 0x47, 0x15, 0x20,
	0x0f, 0x95, 0x38, 0x8f, 0xb7, 0x6a, 0x59, 0xdc, 0x56, 0x91, 0xb5, 0xac, 0x4d, 0xb1, 0x96, 0x22,
	0xfc, 0x89, 0xd4, 0x05, 0xf8, 0x89, 0xc1, 0x8c, 0x71, 0x9a, 0x9f, 0x62, 0x9c, 0x16, 0xb2, 0x7b,
	0xe9, 0x36, 0x2c, 0x29, 0xf1, 0x11, 0xe2, 0xec, 0x88, 0x14, 0x8e, 0x79, 0x70, 0x04, 0x9d, 0x96,
	0x73, 0xb3, 0x6c, 0x0a, 0xf5, 0x6c, 0x9e, 0x4d, 0x3d, 0x61, 0xfa, 0xed, 0x9d, 0xe7, 0x70, 0xb7,
	0xce, 0x71, 0xb8, 0xfb, 0xff, 0xad, 0x09, 0x73, 0xbb, 0xc2, 0x39, 0xd3, 0x16, 0xec, 0xcb, 0x48,
	0x7e, 0x7a, 0xca, 0x26, 0xfe, 0x65, 0x54, 0xee, 0x2a, 0x5b, 0x2d, 0x77, 0x95, 0xbd, 0x05, 0x1a,
	0x47, 0x74, 0x84, 0x39, 0x95, 0x7d, 0xfb, 0xd4, 0x3c, 0xfe, 0x42, 0xa4, 0x3b, 0xec, 0xda, 0x61,
	0xfa, 0x58, 0x16, 0x3f, 0xfd, 0x42, 0x9a, 0xec, 0x38, 0x34, 0x79, 0xf6, 0x66, 0x8a, 0x1c, 0x4a,
	0x30, 0x42, 0x5e, 0xbd, 0xe4, 0x65, 0x20, 0xe0, 0xd0, 0x17, 0x58, 0x38, 0x0a, 0xb7, 0x08, 0x0a,
	0x7d, 0x80, 0x55, 0x5c, 0x42, 0xb5, 0x2d, 0x14, 0x3a, 0x02, 0x97, 0x50, 0x6a, 0x73, 0x7e, 0x55,
	0x5d, 0xb8, 0x74, 0x34, 0xa2, 0x35, 0xa6, 0x73, 0xa6, 0x38, 0xe6, 0x3f, 0x4e, 0x47, 0x23, 0x29,
	0x02, 0xa1, 0x49, 0x4f, 0x79, 0xf5, 0xe4, 0x24, 0xdc, 0xe1, 0xc5, 0x67, 0xbe, 0xf8, 0x66, 0xe9,
	0x8b, 0x2f, 0xb8, 0xc1, 0xc2, 0x84, 0x1b, 0x2c, 0xbf, 0x7d, 0x52, 0xcf, 0x3c, 0x3e, 0xb4, 0xe4,
	0x0b, 0xac, 0xfb, 0xa9, 0xf7, 0xf4, 0xd0, 0x8a, 0x65, 0x95, 0xef, 0xda, 0xb1, 0x3c, 0x5e, 0x7e,
	0xea, 0xed, 0xba, 0x36, 0xb2, 0x00, 0x58, 0x95, 0xdb, 0x3e, 0x3b, 0xc2, 0x72, 0x9c, 0x7a, 0xbb,
	0x99, 0xe9, 0xd3, 0x80, 0x9b, 0x9c, 0x5d, 0x8b, 0x65, 0xb0, 0x93, 0x39, 0xd3, 0x77, 0xb4, 0x8b,
	0xad, 0xfb, 0x9e, 0xf5, 0x32, 0x8b, 0x8c, 0x1a, 0x94, 0xfb, 0x91, 0x4e, 0x33, 0x3b, 0x8b, 0x65,
	0xcc, 0xce, 0x0d, 0xe8, 0x9e, 0xb0, 0xc8, 0x67, 0xb9, 0x3f, 0x2b, 0xa9, 0x6d, 0xda, 0x54, 0x2a,
	0x38, 0x99, 0x49, 0x5e, 0x67, 0x69, 0x8a, 0xd7, 0x99, 0xa2, 0x0b, 0xfa, 0x14, 0x5d, 0x10, 0xe9,
	0x6a, 0xc6, 0x1e, 0xb9, 0x0f, 0xd7, 0x30, 0x5d, 0xcd, 0xc0, 0x43, 0x86, 0x2b, 0xc2, 0x4f, 0x90,
	0x9a, 0x22, 0xa0, 0x4f, 0x24, 0xf7, 0xe9, 0x50, 0xe9, 0x1e, 0xcb, 0x12, 0x93, 0xe2, 0x20, 0xe4,
	0x5a, 0x10, 0xbb, 0xde, 0xe2, 0x65, 0x72, 0xd2, 0x3f, 0x84, 0xd7, 0x8e, 0x2c, 0x77, 0x14, 0x8c,
	0x51, 0xed, 0x22, 0x4e, 0x2a, 0x7f, 0xa5, 0xc2, 0x9b, 0x6c, 0x15, 0x07, 0x75, 0x51, 0xc2, 0x08,
	0x2f, 0x1f, 0xfe, 0x12, 0xb2, 0x30, 0x97, 0x0b, 0x53, 0x08, 0x8e, 0x3e, 0x77, 0x7c, 0x71, 0x83,
	0x2f, 0x4f, 0xb4, 0x7c, 0xfc, 0xb9, 0x83, 0xce, 0x44, 0x4a, 0x7c, 0x03, 0xf2, 0xf8, 0x7c, 0x78,
	0x3d, 0xa2, 0xc6, 0x8e, 0x0c, 0x5b, 0xf8, 0x4c, 0x54, 0xf0, 0x9d, 0x9e, 0xc1, 0x1f, 0x3b, 0x79,
	0x03, 0xd2, 0x4e, 0xe8, 0xb2, 0xc1, 0xb1, 0x93, 0xb5, 0xf8, 0x00, 0xd6, 0x94, 0x1e, 0x0a, 0xda,
	0xcf, 0xf5, 0x82, 0xc1, 0x00, 0x03, 0x41, 0x32, 0x35, 0xe8, 0xc7, 0x70, 0xb1, 0xb4, 0x99, 0xa2,
	0xc7, 0x58, 0x9d, 0x6e, 0x88, 0xf7, 0xd4, 0x77, 0xa1, 0xa7, 0x8e, 0xb1, 0xd0, 0x25, 0xdd, 0xfa,
	0x17, 0xf2, 0x71, 0xaa, 0x7d, 0x7e, 0x0f, 0xd6, 0xcb, 0x1b, 0x62, 0xa7, 0xe4, 0xac, 0xbc, 0x56,
	0xd2, 0x14, 0xef, 0x9a, 0x7f, 0x51, 0x83, 0xd6, 0xc0, 0xcb, 0x76, 0x1e, 0xdf, 0x31, 0xf8, 0xc6,
	0xb3, 0x00, 0xe1, 0x05, 0xfe, 0x48, 0x5b, 0x49, 0xb2, 0x18, 0xd5, 0xc2, 0x67, 0x33, 0xa4, 0x77,
	0x7b, 0x4d, 0xf1, 0x6e, 0x9f, 0xdc, 0xbc, 0x73, 0xe7, 0x60, 0xd4, 0xe7, 0x4b, 0x18, 0xf5, 0x2f,
	0x95, 0x2f, 0x0a, 0x3c, 0x79, 0x7d, 0x82, 0x27, 0x9f, 0x3e, 0x8f, 0x8d, 0xf3, 0x09, 0x1f, 0xcd,
	0x32, 0xe1, 0xe3, 0x1c, 0x4c, 0xc2, 0x35, 0x68, 0x39, 0x8c, 0x2c, 0xfb, 0x79, 0x8a, 0x56, 0xb5,
	0x08, 0x3f, 0x6b, 0x45, 0xe7, 0x82, 0xd4, 0x0a, 0x32, 0x16, 0xf9, 0x3a, 0xb4, 0x31, 0x47, 0xa6,
	0xd4, 0xf0, 0x10, 0xc9, 0x6a, 0xf1, 0x32, 0xc5, 0x13, 0x78, 0xe4, 0xfa, 0x27, 0x5c, 0xce, 0x63,
	0x8e, 0x79, 0x72, 0x18, 0xc6, 0x82, 0x34, 0x75, 0x78, 0xf1, 0x3e, 0x2f, 0xfd, 0xf4, 0x30, 0x8c,
	0xfb, 0xff, 0x6b, 0x0e, 0xea, 0x4f, 0x69, 0x11, 0x8b, 0x82, 0x4e, 0x65, 0x5a, 0xd0, 0x91, 0xaf,
	0xba, 0x5a, 0x78, 0xd5, 0x65, 0x6f, 0x74, 0xe2, 0x4d, 0xcc, 0x9d, 0x43, 0xd2, 0x9b, 0x3f, 0xdf,
	0x62, 0x2f, 0x94, 0x2d, 0x76, 0xc9, 0x64, 0xeb, 0x25, 0x93, 0xd5, 0xbf, 0x03, 0xba, 0xe3, 0xc6,
	0x36, 0xa7, 0x0f, 0xa7, 0x26, 0x7e, 0x2b, 0xdc, 0x0e, 0x46, 0x82, 0xc9, 0x58, 0xca, 0x6a, 0xf6,
	0x44, 0x05, 0xbf, 0x3d, 0x05, 0xeb, 0xe5, 0xb0, 0x71, 0xae, 0x22, 0x12, 0xfc, 0xd8, 0x16, 0x1b,
	0x6f, 0xe3, 0x97, 0x0b, 0x05, 0x8c, 0xdc, 0xef, 0x20, 0x0c, 0xe3, 0x58, 0xba, 0x47, 0xbb, 0xfe,
	0x23, 0xe8, 0x09, 0xa8, 0xec, 0xc2, 0x90, 0x4e, 0x7c, 0xe2, 0xbd, 0xaf, 0x52, 0xbd, 0xbc, 0x24,
	0xf6, 0x44, 0xad, 0x7e, 0x1f, 0x44, 0x8d, 0x89, 0x81, 0x62, 0x13, 0x1f, 0x79, 0x69, 0x1a, 0xcb,
	0x54, 0xbb, 0x33, 0xf4, 0x92, 0xdc, 0x95, 0x2d, 0x1f, 0x94, 0xe4, 0xbb, 0xc5, 0xa5, 0x46, 0xa5,
	0x03, 0xe2, 0xbe, 0xa7, 0xb6, 0x68, 0xf7, 0xcb, 0xb6, 0xe8, 0xe2, 0x59, 0x5b, 0x54, 0x3b, 0x73,
	0x8b, 0x2e, 0x4d, 0x6d, 0xd1, 0xfe, 0x11, 0xb4, 0xf8, 0xb9, 0xdd, 0xb1, 0xc2, 0x90, 0xdf, 0x1e,
	0xef, 0xc3, 0x6a, 0xe6, 0xed, 0x68, 0x0d, 0xfd, 0x20, 0x4e, 0xc4, 0x61, 0x17, 0x5b, 0x71, 0x45,
	0xd6, 0x6e, 0x88, 0x4a, 0xc9, 0xaf, 0x7b, 0x84, 0xc0, 0xcc, 0x52, 0x44, 0x22, 0xd7, 0x8f, 0x65,
	0xf8, 0x71, 0x82, 0x47, 0xd0, 0x7e, 0xf5, 0xdc, 0x06, 0x82, 0xdf, 0xad, 0xe6, 0xe1, 0xfe, 0xff,
	0xbb, 0x01, 0x8d, 0xc1, 0xce, 0x0e, 0x4b, 0x22, 0xd7, 0xe6, 0xe4, 0x57, 0x61, 0x59, 0xec, 0x42,
	0x92, 0xbf, 0x0a, 0xf9, 0x92, 0xe5, 0xf5, 0x9b, 0x4a, 0xba, 0xbf, 0x4f, 0xe0, 0x92, 0xd2, 0x50,
	0xb0, 0x86, 0x79, 0x5b, 0xe2, 0x0c, 0x15, 0xdc, 0x64, 0x22, 0xcc, 0x9a, 0x6f, 0x80, 0xc2, 0x95,
	0x72, 0xae, 0xc5, 0x8c, 0x98, 0xcd, 0xdc, 0x3c, 0xaa, 0x8a, 0xf8, 0xc5, 0xf5, 0x1c, 0x68, 0x37,
	0xf5, 0x0c, 0x01, 0x42, 0x74, 0xae, 0xc8, 0x00, 0xa3, 0x47, 0x43, 0x64, 0xf9, 0xb1, 0xe7, 0x26,
	0x49, 0x86, 0x65, 0x6e, 0x92, 0x01, 0xde, 0x4d, 0xbd, 0x83, 0x1c, 0x8a, 0x10, 0xfd, 0x10, 0x5e,
	0x2b, 0x46, 0x63, 0x22, 0x1b, 0x1d, 0x5a, 0xbe, 0xe0, 0xf5, 0x88, 0xd7, 0xbc, 0xa8, 0xc6, 0x5b,
	0x1e, 0x08, 0x08, 0xe2, 0xfb, 0x8a, 0x23, 0x11, 0x6b, 0x91, 0x69, 0x1e, 0x68, 0x24, 0x0b, 0x93,
	0x23, 0xa1, 0x05, 0x91, 0x9f, 0x3a, 0xa1, 0x91, 0xfc, 0x72, 0x61, 0x55, 0x28, 0x90, 0xcd, 0x72,
	0x4e, 0x89, 0xf1, 0xe4, 0xcb, 0x5a, 0x9f, 0x1c, 0xca, 0x66, 0x98, 0x1a, 0x1c, 0x84, 0x0f, 0x88,
	0xaf, 0xab, 0x05, 0x77, 0xa6, 0x87, 0x72, 0x68, 0x8d, 0x46, 0x41, 0xe0, 0xf3, 0x25, 0x1e, 0x59,
	0xae, 0x27, 0xbf, 0xe5, 0xaa, 0x86, 0xbb, 0xbd, 0x35, 0x39, 0xb0, 0x87, 0xd4, 0xc6, 0xa0, 0x26,
	0xf4, 0x81, 0x57, 0x1a, 0xe4, 0x4f, 0xe0, 0xad, 0x2f, 0xed, 0x62, 0x22, 0x38, 0xee, 0x8d, 0xb3,
	0xb1, 0xcb, 0xe9, 0xff, 0xa0, 0xf0, 0x22, 0xe2, 0x17, 0x56, 0x68, 0xba, 0xbe, 0x19, 0x71, 0xa9,
	0xeb, 0xe4, 0x61, 0x18, 0x8b, 0x2f, 0x4b, 0x2b, 0x9b, 0x6a, 0xff, 0x85, 0x15, 0x6e, 0xfb, 0x86,
	0x95, 0xb0, 0x4f, 0x1f, 0x86, 0x93, 0xcb, 0x87, 0xed, 0x83, 0x34, 0x51, 0x10, 0xb4, 0x26, 0x97,
	0x8f, 0x23, 0x78, 0x96, 0x26, 0x19, 0x06, 0x03, 0x6e, 0x96, 0x6f, 0x4b, 0x33, 0xb4, 0x50, 0x12,
	0x31, 0x9d, 0x28, 0x08, 0x43, 0x26, 0x95, 0x64, 0xfd, 0xb2, 0xfd, 0xb9, 0x47, 0xa0, 0x5b, 0x04,
	0xa9, 0x1f, 0xc0, 0x9b, 0x33, 0xf6, 0xe9, 0x14, 0x52, 0xa2, 0x6e, 0xaf, 0x97, 0x6e, 0xd7, 0x09,
	0xac, 0xb7, 0x40, 0x9b, 0x3a, 0x74, 0x5d, 0xa1, 0x01, 0x2e, 0x1e, 0xb5, 0xb7, 0x65, 0x48, 0x64,
	0x61, 0x27, 0x2d, 0x0a, 0xd9, 0x75, 0x62, 0xff, 0xd8, 0x70, 0x57, 0x15, 0x61, 0xd0, 0x18, 0x96,
	0x53, 0x05, 0x8a, 0x7f, 0x76, 0x7d, 0x9b, 0x7c, 0x3c, 0xc4, 0xf9, 0xd0, 0x26, 0x77, 0x10, 0x9a,
	0xc7, 0x24, 0xb1, 0xe0, 0x98, 0xf7, 0x79, 0x93, 0x87, 0x41, 0x90, 0x90, 0xc4, 0xf9, 0xc7, 0x9c,
	0xfb, 0xda, 0x72, 0xe3, 0x13, 0x41, 0x84, 0x1e, 0xc0, 0x45, 0xb5, 0xd3, 0xe2, 0xe9, 0x23, 0x2a,
	0xb4, 0xa6, 0x60, 0x2f, 0x9c, 0xbd, 0xfb, 0x05, 0x6d, 0x30, 0xbd, 0x31, 0xcb, 0x31, 0xdd, 0x40,
	0x90, 0xa0, 0xe5, 0x89, 0x37, 0x64, 0x39, 0xdb, 0x01, 0x17, 0x66, 0x27, 0x1a, 0xb9, 0x81, 0xa0,
	0x38, 0x8b, 0x05, 0xf8, 0xed, 0x40, 0xdf, 0x81, 0x1b, 0x53, 0x2b, 0x22, 0xba, 0x20, 0x51, 0xf8,
	0x44, 0x25, 0x35, 0x57, 0x27, 0x56, 0x81, 0x3a, 0xe4, 0xa2, 0xf1, 0xa7, 0x08, 0xa6, 0x6f, 0xc1,
	0xd5, 0x29, 0x74, 0x13, 0x98, 0x88, 0xde, 0x5c, 0x9a, 0xc0, 0x54, 0xc0, 0xf2, 0x29, 0xbc, 0x3e,
	0x73, 0x50, 0x8a, 0x94, 0x4a, 0x44, 0xe7, 0x4a, 0xe9, 0x98, 0x72, 0xb1, 0xf5, 0x21, 0x5c, 0x29,
	0x1b, 0xd2, 0x94, 0xa2, 0x63, 0x7d, 0x6a, 0x44, 0x19, 0x8e, 0xfe, 0x9f, 0xd4, 0x01, 0x06, 0xbb,
	0xdb, 0x9b, 0xe2, 0x8d, 0x7e, 0x0f, 0xd6, 0xa5, 0xae, 0x33, 0xa3, 0xeb, 0xf9, 0x31, 0x14, 0xaf,
	0x54, 0x40, 0x48, 0xaa, 0x9e, 0x1d, 0xc2, 0xf7, 0x61, 0x75, 0xaa, 0xb1, 0xaa, 0x6f, 0x58, 0x99,
	0x68, 0x48, 0xc4, 0x63, 0x03, 0x2e, 0x67, 0xa9, 0xfb, 0x95, 0x7b, 0x20, 0xef, 0x55, 0xdc, 0x28,
	0x32, 0x43, 0x7f, 0x0e, 0x93, 0x75, 0xfc, 0x20, 0x57, 0xee, 0xce, 0xba, 0x4a, 0xd6, 0xa6, 0x9b,
	0x4f, 0x75, 0x2f, 0x4e, 0x73, 0x3e, 0xf8, 0xf0, 0x24, 0x91, 0x6f, 0x55, 0x76, 0x2f, 0x8e, 0xb1,
	0x9c, 0xc2, 0xde, 0x49, 0x82, 0xd7, 0xc8, 0x24, 0x0a, 0x75, 0x18, 0x88, 0x45, 0x5c, 0x23, 0x45,
	0x2c, 0xca, 0x60, 0x10, 0xd1, 0x3d, 0xb8, 0x30, 0xb5, 0x80, 0xd8, 0xba, 0x2e, 0x1c, 0x75, 0x8b,
	0xeb, 0x87, 0x6d, 0x3e, 0x82, 0x5e, 0xd9, 0xdc, 0xb1, 0x59, 0x43, 0x98, 0xe4, 0xa6, 0xa6, 0x8e,
	0x2d, 0x1f, 0xc1, 0x55, 0xd9, 0xf2, 0x30, 0x0a, 0x2c, 0xc7, 0xb6, 0xe2, 0x64, 0xa2, 0x5f, 0xba,
	0x05, 0x5e, 0x13, 0x60, 0x0f, 0x25, 0x54, 0x61, 0x00, 0x9f, 0x42, 0x7f, 0x1a, 0xcd, 0xd4, 0x50,
	0xe8, 0x0a, 0xb8, 0x3a, 0x89, 0x69, 0x72, 0x4c, 0x8a, 0xae, 0x9d, 0x45, 0x51, 0x10, 0x4d, 0x8c,
	0x87, 0xee, 0x01, 0x39, 0xe1, 0x47, 0x1c, 0xa2, 0x30, 0x96, 0x4d, 0xb8, 0x52, 0x6c, 0x3e, 0x35,
	0x0e, 0x22, 0xff, 0x97, 0x54, 0x0c, 0x67, 0xac, 0x4b, 0xf6, 0xb9, 0x8c, 0x89, 0x71, 0x74, 0x0a,
	0xeb, 0x92, 0x7d, 0x3c, 0x63, 0xd6, 0xba, 0xe4, 0x68, 0xa6, 0xc6, 0xd3, 0x2d, 0xac, 0x4b, 0x86,
	0x69, 0x72, 0x4c, 0x1f, 0xc0, 0x5a, 0xf6, 0x75, 0x34, 0xa4, 0xe8, 0xf9, 0xf1, 0x58, 0x2c, 0x9c,
	0x2d, 0x24, 0xdd, 0xf2, 0x60, 0xf4, 0xff, 0x41, 0x1d, 0x60, 0x37, 0x70, 0xd8, 0x37, 0x40, 0xaf,
	0x5f, 0x89, 0x7b, 0xa8, 0xbe, 0x0a, 0xf7, 0xf0, 0x3d, 0x58, 0x9f, 0xbc, 0xfd, 0xd3, 0x78, 0x82,
	0x9f, 0x5c, 0x2b, 0x5e, 0xfd, 0xcf, 0xe3, 0xf3, 0xb2, 0x1e, 0x73, 0x5f, 0x97, 0xf5, 0x98, 0xff,
	0xe6, 0x58, 0x8f, 0x85, 0x6f, 0x83, 0xf5, 0xa8, 0x9f, 0x9f, 0xf5, 0x38, 0x4b, 0x66, 0x68, 0x7c,
	0x0d, 0x99, 0xa1, 0xf9, 0x75, 0x65, 0x06, 0xf8, 0x46, 0x64, 0x86, 0xd6, 0x79, 0x64, 0x86, 0xe2,
	0x58, 0x0a, 0x53, 0x21, 0x2c, 0xed, 0xc9, 0xb1, 0x28, 0x93, 0x21, 0x14, 0x7b, 0xf0, 0x86, 0x35,
	0x1c, 0x46, 0x6c, 0xc8, 0xf7, 0xc8, 0x59, 0xeb, 0x42, 0x54, 0xe2, 0x7a, 0x06, 0xfc, 0x74, 0xc6,
	0x02, 0xf5, 0xff, 0xbc, 0x02, 0x2b, 0x93, 0xc9, 0xd7, 0x50, 0x52, 0xec, 0x41, 0xbd, 0x98, 0x8f,
	0x45, 0x3e, 0xe2, 0x07, 0xa4, 0x82, 0x28, 0x11, 0x27, 0x0d, 0x7f, 0x73, 0xb9, 0x12, 0xfd, 0xdb,
	0x30, 0x3a, 0x96, 0x0b, 0x8f, 0xa4, 0x11, 0x69, 0x67, 0x85, 0x9f, 0xb2, 0x53, 0x7e, 0x49, 0x4f,
	0x87, 0xeb, 0x29, 0x66, 0xf5, 0x95, 0xc9, 0x58, 0xbd, 0x52, 0xc3, 0xd5, 0xfc, 0xb4, 0xe1, 0x6a,
	0x22, 0xd3, 0xcb, 0xc2, 0x54, 0xa6, 0x97, 0xf2, 0x54, 0x29, 0xfd, 0x3f, 0xad, 0xc2, 0x22, 0x7e,
	0x7b, 0x23, 0x09, 0xb2, 0x8f, 0xb3, 0x71, 0xe1, 0x5d, 0x16, 0xe5, 0xba, 0xbd, 0x56, 0x56, 0x46,
	0x9e, 0xa4, 0x39, 0x88, 0x62, 0x4d, 0xea, 0x64, 0xa5, 0xa8, 0x35, 0x2a, 0x38, 0x4b, 0x29, 0x5f,
	0xf4, 0xef, 0x14, 0xe2, 0x6e, 0xf5, 0x7d, 0xd0, 0x14, 0x2d, 0x70, 0x9e, 0x18, 0x71, 0xfa, 0x7b,
	0xce, 0x13, 0x43, 0xbd, 0x93, 0xab, 0x86, 0x8d, 0xae, 0x9f, 0xfd, 0xc6, 0xcf, 0x57, 0xfc, 0x6e,
	0x85, 0xa8, 0xaf, 0xd0, 0x1c, 0x4b, 0xe3, 0x81, 0x92, 0x59, 0x0b, 0x8d, 0x07, 0x38, 0x80, 0xd7,
	0x31, 0xa7, 0x8e, 0x85, 0x9f, 0x91, 0x74, 0x0f, 0x47, 0x4c, 0x7c, 0x8a, 0xaa, 0xed, 0xc6, 0x1b,
	0x59, 0x19, 0x7e, 0xe1, 0x32, 0xce, 0xa2, 0xb2, 0xc5, 0x07, 0x30, 0xdd, 0x58, 0x46, 0x62, 0x67,
	0x19, 0x3d, 0x42, 0xf1, 0x2e, 0x29, 0xa3, 0x47, 0xd8, 0xff, 0xfb, 0x15, 0x68, 0xed, 0x28, 0x0a,
	0x89, 0xbf, 0x53, 0x11, 0xdf, 0xa4, 0xa8, 0x43, 0xed, 0x04, 0x53, 0x83, 0x36, 0x61, 0xfe, 0x84,
	0xb3, 0x81, 0x22, 0x37, 0xe8, 0x40, 0x7c, 0xf4, 0x19, 0x8b, 0x9f, 0xec, 0x3d, 0xd7, 0xe6, 0x30,
	0xa1, 0xde, 0x60, 0x47, 0xf9, 0xe6, 0xf3, 0x0a, 0x68, 0x27, 0x7c, 0x76, 0x7b, 0xc7, 0xa7, 0xb1,
	0x6b, 0x5b, 0x23, 0xde, 0x9a, 0x52, 0xf2, 0x89, 0x9c, 0x4d, 0x5a, 0x1d, 0x93, 0xec, 0xf1, 0x27,
	0x44, 0xdd, 0xc0, 0xc7, 0x81, 0xfc, 0x0e, 0x63, 0x93, 0xbe, 0x47, 0x4a, 0xb1, 0x3f, 0x1a, 0xf4,
	0x7f, 0x0a, 0x4d, 0x8a, 0xe2, 0xd8, 0xb1, 0x42, 0xbe, 0x99, 0x14, 0xcd, 0x90, 0x34, 0x21, 0x5a,
	0x05, 0x13, 0xa2, 0xf2, 0xa9, 0xbd, 0xa9, 0x0f, 0x79, 0xd5, 0x0a, 0x1f, 0xf2, 0xea, 0xdb, 0xa0,
	0x4f, 0x04, 0xda, 0x7c, 0x0b, 0x9d, 0x1c, 0xc2, 0xd2, 0xa0, 0x10, 0x54, 0xf1, 0xad, 0xf6, 0x21,
	0x82, 0x31, 0xbe, 0xa5, 0x3e, 0x32, 0x73, 0xee, 0xb7, 0xd4, 0x87, 0x09, 0x5d, 0xdc, 0x25, 0xdf,
	0xda, 0x24, 0x86, 0xb0, 0x5a, 0xd8, 0x9c, 0xdf, 0xda, 0x1b, 0x39, 0x82, 0x0b, 0xb8, 0xc3, 0xbf,
	0xed, 0x37, 0x7f, 0x04, 0x17, 0x8a, 0x9e, 0x11, 0xdf, 0x52, 0x3f, 0x0c, 0x56, 0xe4, 0x51, 0xc9,
	0x9c, 0x60, 0xbf, 0x85, 0x6e, 0xfe, 0x63, 0x15, 0x3a, 0x9b, 0x2c, 0x62, 0x87, 0x51, 0x20, 0xb2,
	0x97, 0x95, 0x26, 0xa4, 0xa9, 0xbc, 0x72, 0x42, 0x9a, 0xea, 0xab, 0x26, 0xa4, 0xa9, 0xbd, 0x72,
	0x42, 0x9a, 0xb9, 0x33, 0x12, 0xd2, 0xcc, 0xca, 0x9e, 0x30, 0xff, 0x2a, 0xd9, 0x13, 0x16, 0x4a,
	0xb3, 0x27, 0x9c, 0x11, 0x3d, 0x5c, 0x3f, 0x23, 0x7a, 0xb8, 0xff, 0x9f, 0xe6, 0xa1, 0xb9, 0x3b,
	0x4c, 0xc4, 0x32, 0x4f, 0xa4, 0x70, 0xa9, 0x9c, 0x27, 0x85, 0x4b, 0xb5, 0x2c, 0x85, 0xcb, 0x59,
	0xf9, 0x18, 0x6a, 0x5f, 0x2d, 0x1f, 0xc3, 0xdc, 0x2b, 0xe7, 0x63, 0x98, 0x7f, 0xb5, 0x7c, 0x0c,
	0x0b, 0xaf, 0x9e, 0x8f, 0xa1, 0xfe, 0xaa, 0xf9, 0x18, 0x1a, 0xe7, 0xc9, 0xc7, 0xd0, 0xfc, 0xf2,
	0x7c, 0x0c, 0x30, 0x9d, 0x8f, 0x61, 0x3a, 0xca, 0xbc, 0x55, 0x12, 0x65, 0x7e, 0x66, 0x50, 0x78,
	0xfb, 0xab, 0x07, 0x85, 0x77, 0xbe, 0x91, 0xa0, 0xf0, 0xee, 0x39, 0x83, 0xc2, 0x67, 0x47, 0xf0,
	0x2e, 0xce, 0x8e, 0xe0, 0xed, 0xff, 0x26, 0x34, 0x7f, 0x1c, 0xc4, 0x62, 0xab, 0x17, 0x23, 0x3c,
	0x2b, 0xe7, 0x89, 0xf0, 0xac, 0x9e, 0x37, 0xc2, 0xb3, 0x56, 0x12, 0xe1, 0x79, 0xfb, 0x09, 0xbf,
	0x39, 0x37, 0x8f, 0xdd, 0x91, 0x48, 0xe4, 0x8c, 0xc7, 0x56, 0x83, 0xf6, 0x89, 0xc2, 0x7c, 0x68,
	0x15, 0x62, 0xa5, 0xb2, 0xfb, 0x42, 0xa4, 0x41, 0xce, 0xaf, 0x75, 0xad, 0x76, 0xfb, 0x63, 0xe8,
	0x14, 0xbe, 0x30, 0x8e, 0xb9, 0x8d, 0x89, 0x11, 0x14, 0xf9, 0x84, 0x0f, 0xc8, 0xf9, 0x4e, 0xab,
	0x22, 0x53, 0xf5, 0xdc, 0x4f, 0xac, 0x21, 0x7e, 0x50, 0xf2, 0xf6, 0x16, 0x67, 0xa3, 0xa4, 0xeb,
	0x62, 0x17, 0xe0, 0x64, 0x37, 0x88, 0x3c, 0xea, 0xa8, 0xa2, 0xaf, 0xc1, 0xf2, 0xc9, 0xee, 0x94,
	0x97, 0xa3, 0x56, 0x45, 0xc0, 0x2d, 0x37, 0x62, 0x76, 0xc2, 0x9f, 0x6b, 0xb7, 0x3f, 0x81, 0xd5,
	0xdd, 0x72, 0x6f, 0x48, 0xde, 0xf9, 0xb6, 0x8f, 0x49, 0x28, 0x45, 0x6a, 0xf4, 0x47, 0xf4, 0x50,
	0xc5, 0xbc, 0xce, 0x07, 0x56, 0xa8, 0xd5, 0x6e, 0x3f, 0x87, 0x96, 0x92, 0xa6, 0x71, 0x22, 0x93,
	0x30, 0x5f, 0x90, 0xc7, 0xe9, 0x48, 0xa6, 0x50, 0x14, 0x09, 0x8c, 0x9f, 0xf9, 0xa3, 0xd3, 0xbd,
	0x91, 0x65, 0xa3, 0xe4, 0x21, 0xab, 0x6a, 0xd8, 0xc1, 0x8e, 0xe5, 0xa7, 0xd6, 0x48, 0x9b, 0xbb,
	0xfd, 0x23, 0xa8, 0x8b, 0x0f, 0x8f, 0x61, 0xe6, 0x5e, 0x25, 0x18, 0xf4, 0x49, 0x64, 0x85, 0xc7,
	0xae, 0x1d, 0x8b, 0x39, 0x2a, 0x35, 0x9b, 0x81, 0x17, 0xa6, 0x09, 0x13, 0x1f, 0x01, 0x17, 0xab,
	0xac, 0xd5, 0x6e, 0xdf, 0x81, 0x66, 0xf6, 0xe5, 0x31, 0x4a, 0x68, 0x3e, 0x76, 0x1d, 0xd7, 0xd2,
	0x2a, 0xc8, 0x00, 0xf3, 0x2d, 0x35, 0x12, 0x53, 0xda, 0xf0, 0x68, 0x5d, 0xeb, 0xe2, 0xe3, 0x4c,
	0x08, 0xfd, 0xdc, 0xc7, 0x44, 0xd3, 0xd4, 0xdd, 0xf3, 0x18, 0xb7, 0xae, 0xd2, 0xab, 0x56, 0xd5,
	0x97, 0x61, 0x51, 0x56, 0xe4, 0xbd, 0x7e, 0x17, 0x96, 0x4b, 0x3e, 0xac, 0x80, 0x7c, 0xf6, 0x53,
	0x2b, 0x72, 0x04, 0x27, 0xbe, 0x61, 0x87, 0xae, 0xe0, 0xc4, 0x91, 0x3c, 0x68, 0xb5, 0x87, 0xf5,
	0x9f, 0xce, 0xa3, 0xfc, 0xf1, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe1, 0xe7, 0x9e, 0x0c, 0xd0,
	0x9a, 0x00, 0x00,
}
