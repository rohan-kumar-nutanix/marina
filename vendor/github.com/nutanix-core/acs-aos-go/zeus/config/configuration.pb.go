// Code generated by protoc-gen-go. DO NOT EDIT.
// source: zeus/configuration.proto

package zeus_config

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	base "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/base"
	qos "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/qos"
	math "math"
	pithos "github.com/nutanix-core/acs-aos-go/pithos"
	zeus "github.com/nutanix-core/acs-aos-go/zeus"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Row CAS upgrade status
type ConfigurationProto_RowCASUpgradeStatus int32

const (
	ConfigurationProto_kNone ConfigurationProto_RowCASUpgradeStatus = 0
	// All nodes are at a Row CAS compatible version
	ConfigurationProto_kPreMigrating ConfigurationProto_RowCASUpgradeStatus = 1
	// Node is currently migrating extent group metadata from non Row CAS to
	// Row CAS format.
	ConfigurationProto_kMigrating ConfigurationProto_RowCASUpgradeStatus = 2
	// All extent group metadata has been migrated to Row CAS format on this
	// cluster.
	ConfigurationProto_kMigrated ConfigurationProto_RowCASUpgradeStatus = 3
	// All Row CAS migration operations are complete and it is safe to use the
	// new Row CAS CF format.
	ConfigurationProto_kMigrationComplete ConfigurationProto_RowCASUpgradeStatus = 4
)

var ConfigurationProto_RowCASUpgradeStatus_name = map[int32]string{
	0: "kNone",
	1: "kPreMigrating",
	2: "kMigrating",
	3: "kMigrated",
	4: "kMigrationComplete",
}

var ConfigurationProto_RowCASUpgradeStatus_value = map[string]int32{
	"kNone":              0,
	"kPreMigrating":      1,
	"kMigrating":         2,
	"kMigrated":          3,
	"kMigrationComplete": 4,
}

func (x ConfigurationProto_RowCASUpgradeStatus) Enum() *ConfigurationProto_RowCASUpgradeStatus {
	p := new(ConfigurationProto_RowCASUpgradeStatus)
	*p = x
	return p
}

func (x ConfigurationProto_RowCASUpgradeStatus) String() string {
	return proto.EnumName(ConfigurationProto_RowCASUpgradeStatus_name, int32(x))
}

func (x *ConfigurationProto_RowCASUpgradeStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RowCASUpgradeStatus_value, data, "ConfigurationProto_RowCASUpgradeStatus")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RowCASUpgradeStatus(value)
	return nil
}

func (ConfigurationProto_RowCASUpgradeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 0}
}

// The lowest stargate version that exists in the cluster. This is updated
// only when all stargates have moved to a new version. The values for every
// enum entry should be such that, for any particular value, all entries with
// value <= that should also be valid. Care should be taken when adding new
// stargate versions, because stargate_version.h will assign the highest
// value in this enum to kCurrentStargateVersion. If it's needed to restrict
// higher stargate versions, edit stargate_version.h.
type ConfigurationProto_StargateVersion int32

const (
	ConfigurationProto_kSingleDiskOplogVersion                              ConfigurationProto_StargateVersion = 0
	ConfigurationProto_kFirstMultiDiskOplogVersion                          ConfigurationProto_StargateVersion = 10
	ConfigurationProto_kExtendedNfsFhandleVersion                           ConfigurationProto_StargateVersion = 20
	ConfigurationProto_kOplogFlushRecordsCommitVersion                      ConfigurationProto_StargateVersion = 24
	ConfigurationProto_kNfsRelinquishReturnAttrsVersion                     ConfigurationProto_StargateVersion = 25
	ConfigurationProto_kSparseExtentWriteVersion                            ConfigurationProto_StargateVersion = 30
	ConfigurationProto_kMetroSyncStatsVersion                               ConfigurationProto_StargateVersion = 40
	ConfigurationProto_kStretchSnapshotGroupOpVersion                       ConfigurationProto_StargateVersion = 50
	ConfigurationProto_kDEPRECATEDSlaveMetadataCacheVersion                 ConfigurationProto_StargateVersion = 60
	ConfigurationProto_kDEPRECATEDRpcV2Version                              ConfigurationProto_StargateVersion = 70
	ConfigurationProto_kMigrateExtentsOptionalTarget                        ConfigurationProto_StargateVersion = 80
	ConfigurationProto_kVssUnderVscFolder                                   ConfigurationProto_StargateVersion = 90
	ConfigurationProto_kSlaveMetadataCacheVersion                           ConfigurationProto_StargateVersion = 100
	ConfigurationProto_kRpcV2Version                                        ConfigurationProto_StargateVersion = 110
	ConfigurationProto_kOplogZeroSuppression                                ConfigurationProto_StargateVersion = 120
	ConfigurationProto_kOplogPayloadHasHeadersVersion                       ConfigurationProto_StargateVersion = 130
	ConfigurationProto_kExtentStoreSliceHasMultipleChecksumVersion          ConfigurationProto_StargateVersion = 140
	ConfigurationProto_kPartitionedFileIdNamespace                          ConfigurationProto_StargateVersion = 150
	ConfigurationProto_kDEPRECATEDVDiskFirstTimeHostFlagVersion             ConfigurationProto_StargateVersion = 160
	ConfigurationProto_kVDiskFirstTimeHostFlagVersion                       ConfigurationProto_StargateVersion = 170
	ConfigurationProto_kDEPERECATEDStretchContainerHealthVersion            ConfigurationProto_StargateVersion = 175
	ConfigurationProto_kLWSStoreVersion                                     ConfigurationProto_StargateVersion = 180
	ConfigurationProto_kMixedCompressionEgroupsVersion                      ConfigurationProto_StargateVersion = 185
	ConfigurationProto_kOplogCompressionVersion                             ConfigurationProto_StargateVersion = 190
	ConfigurationProto_kNfsMasterAsyncTransactions                          ConfigurationProto_StargateVersion = 200
	ConfigurationProto_kQoSVersion                                          ConfigurationProto_StargateVersion = 210
	ConfigurationProto_kDedupExtentTwoPhaseDeletion                         ConfigurationProto_StargateVersion = 220
	ConfigurationProto_kDEPRECATEDOplogSharingVersion                       ConfigurationProto_StargateVersion = 230
	ConfigurationProto_kEgroupLZ4Version                                    ConfigurationProto_StargateVersion = 240
	ConfigurationProto_kSlaveErrorAcquiringTokenVersion                     ConfigurationProto_StargateVersion = 250
	ConfigurationProto_kStretchContainerHealthVersion                       ConfigurationProto_StargateVersion = 260
	ConfigurationProto_kTrimForwardVersion                                  ConfigurationProto_StargateVersion = 265
	ConfigurationProto_kNearSyncVersion                                     ConfigurationProto_StargateVersion = 278
	ConfigurationProto_kIscsiNaaBasedNameStringVersion                      ConfigurationProto_StargateVersion = 290
	ConfigurationProto_kFixedEgroupSliceSizeVersion                         ConfigurationProto_StargateVersion = 295
	ConfigurationProto_kDEPRECATEDSmbDeleteOnClose                          ConfigurationProto_StargateVersion = 300
	ConfigurationProto_kVDiskHostingAffinityVersion                         ConfigurationProto_StargateVersion = 310
	ConfigurationProto_kOplogSharingVersion                                 ConfigurationProto_StargateVersion = 320
	ConfigurationProto_kOplogHighestUsedEpisodeSequenceVersion              ConfigurationProto_StargateVersion = 330
	ConfigurationProto_kDEPRECATEDECInPlaceWriteVersion                     ConfigurationProto_StargateVersion = 340
	ConfigurationProto_kTwoNodeVersion                                      ConfigurationProto_StargateVersion = 350
	ConfigurationProto_kBatchPullTokensVersion                              ConfigurationProto_StargateVersion = 360
	ConfigurationProto_kDeleteEgroupWithoutDiskUsageVersion                 ConfigurationProto_StargateVersion = 370
	ConfigurationProto_kCGHostingAvailableVersion                           ConfigurationProto_StargateVersion = 375
	ConfigurationProto_kSmbDeleteOnClose                                    ConfigurationProto_StargateVersion = 380
	ConfigurationProto_kOplogFlushInterfaceChangeVersion                    ConfigurationProto_StargateVersion = 390
	ConfigurationProto_kDEPRECATEDNearSyncPersistUnlinkableEpisodesVersion  ConfigurationProto_StargateVersion = 400
	ConfigurationProto_kECInPlaceWriteVersion                               ConfigurationProto_StargateVersion = 410
	ConfigurationProto_kDEPRECATEDVscUnderSnapshotFolder                    ConfigurationProto_StargateVersion = 412
	ConfigurationProto_kDEPRECATED2VscUnderSnapshotFolder                   ConfigurationProto_StargateVersion = 413
	ConfigurationProto_kDEPRECATED2NearSyncPersistUnlinkableEpisodesVersion ConfigurationProto_StargateVersion = 415
	ConfigurationProto_kDEPRECATEDAESSupportedVersion                       ConfigurationProto_StargateVersion = 420
	ConfigurationProto_kRackAwareVersion                                    ConfigurationProto_StargateVersion = 430
	ConfigurationProto_kNearSyncPersistUnlinkableEpisodesVersion            ConfigurationProto_StargateVersion = 435
	ConfigurationProto_kFlatBufferRpcVersion                                ConfigurationProto_StargateVersion = 440
	ConfigurationProto_kGradualLwsApplyVersion                              ConfigurationProto_StargateVersion = 450
	ConfigurationProto_kDEPRECATEDStretchNfsWriteReplicateFromSlaveVersion  ConfigurationProto_StargateVersion = 460
	ConfigurationProto_kAESSupportedVersion                                 ConfigurationProto_StargateVersion = 470
	ConfigurationProto_kVDiskBlockMapInterfaceClassVersion                  ConfigurationProto_StargateVersion = 480
	ConfigurationProto_kIscsiEndianFixVersion                               ConfigurationProto_StargateVersion = 481
	ConfigurationProto_kExtentStoreWriteOpFlatBuffersRpcVersion             ConfigurationProto_StargateVersion = 490
	ConfigurationProto_kVDiskCopyUpVblockMetadataVersion                    ConfigurationProto_StargateVersion = 500
	ConfigurationProto_kAESCommitRequestBackportedVersion                   ConfigurationProto_StargateVersion = 505
	ConfigurationProto_kAESBatchedCommitBackportedVersion                   ConfigurationProto_StargateVersion = 506
	ConfigurationProto_kMasterlessSnapshotsVersion                          ConfigurationProto_StargateVersion = 510
	ConfigurationProto_kVerifyPayloadChecksumVersion                        ConfigurationProto_StargateVersion = 520
	ConfigurationProto_kAESCommitRequestVersion                             ConfigurationProto_StargateVersion = 525
	ConfigurationProto_kAESBatchedCommitVersion                             ConfigurationProto_StargateVersion = 526
	ConfigurationProto_kNearSyncLastSyncedEpisodePersistedVersion           ConfigurationProto_StargateVersion = 528
	ConfigurationProto_kNearSyncLastRecvdEpisodePersistedVersion            ConfigurationProto_StargateVersion = 529
	ConfigurationProto_kStargateDeleteEmptyECStripVersion                   ConfigurationProto_StargateVersion = 530
	ConfigurationProto_kAESECSupportedVersion                               ConfigurationProto_StargateVersion = 560
	ConfigurationProto_kInlineErasureCodingVersion                          ConfigurationProto_StargateVersion = 561
	ConfigurationProto_kRecycleBinVersion                                   ConfigurationProto_StargateVersion = 570
	ConfigurationProto_kShareMutableExtentsVersion                          ConfigurationProto_StargateVersion = 580
	ConfigurationProto_kDEPRECATEDNearSyncPersistLastSyncedEpisodeVersion   ConfigurationProto_StargateVersion = 590
	ConfigurationProto_kEgidMapDedupVersion                                 ConfigurationProto_StargateVersion = 600
	ConfigurationProto_kRF1SupportVersion                                   ConfigurationProto_StargateVersion = 610
	ConfigurationProto_kStorageProxyOverNfsVersion                          ConfigurationProto_StargateVersion = 620
	ConfigurationProto_kIscsiInterfaceMonitorVersion                        ConfigurationProto_StargateVersion = 630
	ConfigurationProto_kBlockStoreVersion                                   ConfigurationProto_StargateVersion = 640
	ConfigurationProto_kVerifyVDiskChainsVersion                            ConfigurationProto_StargateVersion = 650
	ConfigurationProto_kVDiskCopyUpWithVerificationVersion                  ConfigurationProto_StargateVersion = 660
	ConfigurationProto_kStretchNfsWriteReplicateFromSlaveVersion            ConfigurationProto_StargateVersion = 670
)

var ConfigurationProto_StargateVersion_name = map[int32]string{
	0:   "kSingleDiskOplogVersion",
	10:  "kFirstMultiDiskOplogVersion",
	20:  "kExtendedNfsFhandleVersion",
	24:  "kOplogFlushRecordsCommitVersion",
	25:  "kNfsRelinquishReturnAttrsVersion",
	30:  "kSparseExtentWriteVersion",
	40:  "kMetroSyncStatsVersion",
	50:  "kStretchSnapshotGroupOpVersion",
	60:  "kDEPRECATEDSlaveMetadataCacheVersion",
	70:  "kDEPRECATEDRpcV2Version",
	80:  "kMigrateExtentsOptionalTarget",
	90:  "kVssUnderVscFolder",
	100: "kSlaveMetadataCacheVersion",
	110: "kRpcV2Version",
	120: "kOplogZeroSuppression",
	130: "kOplogPayloadHasHeadersVersion",
	140: "kExtentStoreSliceHasMultipleChecksumVersion",
	150: "kPartitionedFileIdNamespace",
	160: "kDEPRECATEDVDiskFirstTimeHostFlagVersion",
	170: "kVDiskFirstTimeHostFlagVersion",
	175: "kDEPERECATEDStretchContainerHealthVersion",
	180: "kLWSStoreVersion",
	185: "kMixedCompressionEgroupsVersion",
	190: "kOplogCompressionVersion",
	200: "kNfsMasterAsyncTransactions",
	210: "kQoSVersion",
	220: "kDedupExtentTwoPhaseDeletion",
	230: "kDEPRECATEDOplogSharingVersion",
	240: "kEgroupLZ4Version",
	250: "kSlaveErrorAcquiringTokenVersion",
	260: "kStretchContainerHealthVersion",
	265: "kTrimForwardVersion",
	278: "kNearSyncVersion",
	290: "kIscsiNaaBasedNameStringVersion",
	295: "kFixedEgroupSliceSizeVersion",
	300: "kDEPRECATEDSmbDeleteOnClose",
	310: "kVDiskHostingAffinityVersion",
	320: "kOplogSharingVersion",
	330: "kOplogHighestUsedEpisodeSequenceVersion",
	340: "kDEPRECATEDECInPlaceWriteVersion",
	350: "kTwoNodeVersion",
	360: "kBatchPullTokensVersion",
	370: "kDeleteEgroupWithoutDiskUsageVersion",
	375: "kCGHostingAvailableVersion",
	380: "kSmbDeleteOnClose",
	390: "kOplogFlushInterfaceChangeVersion",
	400: "kDEPRECATEDNearSyncPersistUnlinkableEpisodesVersion",
	410: "kECInPlaceWriteVersion",
	412: "kDEPRECATEDVscUnderSnapshotFolder",
	413: "kDEPRECATED2VscUnderSnapshotFolder",
	415: "kDEPRECATED2NearSyncPersistUnlinkableEpisodesVersion",
	420: "kDEPRECATEDAESSupportedVersion",
	430: "kRackAwareVersion",
	435: "kNearSyncPersistUnlinkableEpisodesVersion",
	440: "kFlatBufferRpcVersion",
	450: "kGradualLwsApplyVersion",
	460: "kDEPRECATEDStretchNfsWriteReplicateFromSlaveVersion",
	470: "kAESSupportedVersion",
	480: "kVDiskBlockMapInterfaceClassVersion",
	481: "kIscsiEndianFixVersion",
	490: "kExtentStoreWriteOpFlatBuffersRpcVersion",
	500: "kVDiskCopyUpVblockMetadataVersion",
	505: "kAESCommitRequestBackportedVersion",
	506: "kAESBatchedCommitBackportedVersion",
	510: "kMasterlessSnapshotsVersion",
	520: "kVerifyPayloadChecksumVersion",
	525: "kAESCommitRequestVersion",
	526: "kAESBatchedCommitVersion",
	528: "kNearSyncLastSyncedEpisodePersistedVersion",
	529: "kNearSyncLastRecvdEpisodePersistedVersion",
	530: "kStargateDeleteEmptyECStripVersion",
	560: "kAESECSupportedVersion",
	561: "kInlineErasureCodingVersion",
	570: "kRecycleBinVersion",
	580: "kShareMutableExtentsVersion",
	590: "kDEPRECATEDNearSyncPersistLastSyncedEpisodeVersion",
	600: "kEgidMapDedupVersion",
	610: "kRF1SupportVersion",
	620: "kStorageProxyOverNfsVersion",
	630: "kIscsiInterfaceMonitorVersion",
	640: "kBlockStoreVersion",
	650: "kVerifyVDiskChainsVersion",
	660: "kVDiskCopyUpWithVerificationVersion",
	670: "kStretchNfsWriteReplicateFromSlaveVersion",
}

var ConfigurationProto_StargateVersion_value = map[string]int32{
	"kSingleDiskOplogVersion":                              0,
	"kFirstMultiDiskOplogVersion":                          10,
	"kExtendedNfsFhandleVersion":                           20,
	"kOplogFlushRecordsCommitVersion":                      24,
	"kNfsRelinquishReturnAttrsVersion":                     25,
	"kSparseExtentWriteVersion":                            30,
	"kMetroSyncStatsVersion":                               40,
	"kStretchSnapshotGroupOpVersion":                       50,
	"kDEPRECATEDSlaveMetadataCacheVersion":                 60,
	"kDEPRECATEDRpcV2Version":                              70,
	"kMigrateExtentsOptionalTarget":                        80,
	"kVssUnderVscFolder":                                   90,
	"kSlaveMetadataCacheVersion":                           100,
	"kRpcV2Version":                                        110,
	"kOplogZeroSuppression":                                120,
	"kOplogPayloadHasHeadersVersion":                       130,
	"kExtentStoreSliceHasMultipleChecksumVersion":          140,
	"kPartitionedFileIdNamespace":                          150,
	"kDEPRECATEDVDiskFirstTimeHostFlagVersion":             160,
	"kVDiskFirstTimeHostFlagVersion":                       170,
	"kDEPERECATEDStretchContainerHealthVersion":            175,
	"kLWSStoreVersion":                                     180,
	"kMixedCompressionEgroupsVersion":                      185,
	"kOplogCompressionVersion":                             190,
	"kNfsMasterAsyncTransactions":                          200,
	"kQoSVersion":                                          210,
	"kDedupExtentTwoPhaseDeletion":                         220,
	"kDEPRECATEDOplogSharingVersion":                       230,
	"kEgroupLZ4Version":                                    240,
	"kSlaveErrorAcquiringTokenVersion":                     250,
	"kStretchContainerHealthVersion":                       260,
	"kTrimForwardVersion":                                  265,
	"kNearSyncVersion":                                     278,
	"kIscsiNaaBasedNameStringVersion":                      290,
	"kFixedEgroupSliceSizeVersion":                         295,
	"kDEPRECATEDSmbDeleteOnClose":                          300,
	"kVDiskHostingAffinityVersion":                         310,
	"kOplogSharingVersion":                                 320,
	"kOplogHighestUsedEpisodeSequenceVersion":              330,
	"kDEPRECATEDECInPlaceWriteVersion":                     340,
	"kTwoNodeVersion":                                      350,
	"kBatchPullTokensVersion":                              360,
	"kDeleteEgroupWithoutDiskUsageVersion":                 370,
	"kCGHostingAvailableVersion":                           375,
	"kSmbDeleteOnClose":                                    380,
	"kOplogFlushInterfaceChangeVersion":                    390,
	"kDEPRECATEDNearSyncPersistUnlinkableEpisodesVersion":  400,
	"kECInPlaceWriteVersion":                               410,
	"kDEPRECATEDVscUnderSnapshotFolder":                    412,
	"kDEPRECATED2VscUnderSnapshotFolder":                   413,
	"kDEPRECATED2NearSyncPersistUnlinkableEpisodesVersion": 415,
	"kDEPRECATEDAESSupportedVersion":                       420,
	"kRackAwareVersion":                                    430,
	"kNearSyncPersistUnlinkableEpisodesVersion":            435,
	"kFlatBufferRpcVersion":                                440,
	"kGradualLwsApplyVersion":                              450,
	"kDEPRECATEDStretchNfsWriteReplicateFromSlaveVersion":  460,
	"kAESSupportedVersion":                                 470,
	"kVDiskBlockMapInterfaceClassVersion":                  480,
	"kIscsiEndianFixVersion":                               481,
	"kExtentStoreWriteOpFlatBuffersRpcVersion":             490,
	"kVDiskCopyUpVblockMetadataVersion":                    500,
	"kAESCommitRequestBackportedVersion":                   505,
	"kAESBatchedCommitBackportedVersion":                   506,
	"kMasterlessSnapshotsVersion":                          510,
	"kVerifyPayloadChecksumVersion":                        520,
	"kAESCommitRequestVersion":                             525,
	"kAESBatchedCommitVersion":                             526,
	"kNearSyncLastSyncedEpisodePersistedVersion":           528,
	"kNearSyncLastRecvdEpisodePersistedVersion":            529,
	"kStargateDeleteEmptyECStripVersion":                   530,
	"kAESECSupportedVersion":                               560,
	"kInlineErasureCodingVersion":                          561,
	"kRecycleBinVersion":                                   570,
	"kShareMutableExtentsVersion":                          580,
	"kDEPRECATEDNearSyncPersistLastSyncedEpisodeVersion":   590,
	"kEgidMapDedupVersion":                                 600,
	"kRF1SupportVersion":                                   610,
	"kStorageProxyOverNfsVersion":                          620,
	"kIscsiInterfaceMonitorVersion":                        630,
	"kBlockStoreVersion":                                   640,
	"kVerifyVDiskChainsVersion":                            650,
	"kVDiskCopyUpWithVerificationVersion":                  660,
	"kStretchNfsWriteReplicateFromSlaveVersion":            670,
}

func (x ConfigurationProto_StargateVersion) Enum() *ConfigurationProto_StargateVersion {
	p := new(ConfigurationProto_StargateVersion)
	*p = x
	return p
}

func (x ConfigurationProto_StargateVersion) String() string {
	return proto.EnumName(ConfigurationProto_StargateVersion_name, int32(x))
}

func (x *ConfigurationProto_StargateVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_StargateVersion_value, data, "ConfigurationProto_StargateVersion")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_StargateVersion(value)
	return nil
}

func (ConfigurationProto_StargateVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 1}
}

type ConfigurationProto_ClusterFunctions int32

const (
	// Regular NDFS serving user IOs.
	ConfigurationProto_kNDFS ConfigurationProto_ClusterFunctions = 1
	// Multicluster analytics and management.
	ConfigurationProto_kMulticluster ConfigurationProto_ClusterFunctions = 2
	// Cloud backup and DR gateway.
	ConfigurationProto_kCloudDataGateway ConfigurationProto_ClusterFunctions = 4
	// Cloud Analytics VM.
	ConfigurationProto_kAVM ConfigurationProto_ClusterFunctions = 8
	// Minerva cluster for file server.
	ConfigurationProto_kMinerva ConfigurationProto_ClusterFunctions = 16
	// Witness VM cluster.
	ConfigurationProto_kWitnessVM ConfigurationProto_ClusterFunctions = 32
	// Extension Store VM cluster.
	ConfigurationProto_kExtensionStoreVM ConfigurationProto_ClusterFunctions = 64
	// Xi VM cluster.
	ConfigurationProto_kXiVM ConfigurationProto_ClusterFunctions = 128
	// AGS VM cluster.
	ConfigurationProto_kAGSCluster ConfigurationProto_ClusterFunctions = 256
	// JumpBox VM.
	ConfigurationProto_kJumpBoxVM ConfigurationProto_ClusterFunctions = 512
	// Two node cluster.
	ConfigurationProto_kTwoNodeCluster ConfigurationProto_ClusterFunctions = 1024
	// Single node backup cluster.
	ConfigurationProto_kOneNodeCluster ConfigurationProto_ClusterFunctions = 2048
	// IAM VM cluster
	ConfigurationProto_kIAMCluster ConfigurationProto_ClusterFunctions = 4096
	// Poseidon cluster for object store.
	ConfigurationProto_kPoseidon ConfigurationProto_ClusterFunctions = 8192
	// Clusters on AWS cluster
	ConfigurationProto_kClustersOnAWS ConfigurationProto_ClusterFunctions = 16384
)

var ConfigurationProto_ClusterFunctions_name = map[int32]string{
	1:     "kNDFS",
	2:     "kMulticluster",
	4:     "kCloudDataGateway",
	8:     "kAVM",
	16:    "kMinerva",
	32:    "kWitnessVM",
	64:    "kExtensionStoreVM",
	128:   "kXiVM",
	256:   "kAGSCluster",
	512:   "kJumpBoxVM",
	1024:  "kTwoNodeCluster",
	2048:  "kOneNodeCluster",
	4096:  "kIAMCluster",
	8192:  "kPoseidon",
	16384: "kClustersOnAWS",
}

var ConfigurationProto_ClusterFunctions_value = map[string]int32{
	"kNDFS":             1,
	"kMulticluster":     2,
	"kCloudDataGateway": 4,
	"kAVM":              8,
	"kMinerva":          16,
	"kWitnessVM":        32,
	"kExtensionStoreVM": 64,
	"kXiVM":             128,
	"kAGSCluster":       256,
	"kJumpBoxVM":        512,
	"kTwoNodeCluster":   1024,
	"kOneNodeCluster":   2048,
	"kIAMCluster":       4096,
	"kPoseidon":         8192,
	"kClustersOnAWS":    16384,
}

func (x ConfigurationProto_ClusterFunctions) Enum() *ConfigurationProto_ClusterFunctions {
	p := new(ConfigurationProto_ClusterFunctions)
	*p = x
	return p
}

func (x ConfigurationProto_ClusterFunctions) String() string {
	return proto.EnumName(ConfigurationProto_ClusterFunctions_name, int32(x))
}

func (x *ConfigurationProto_ClusterFunctions) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ClusterFunctions_value, data, "ConfigurationProto_ClusterFunctions")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ClusterFunctions(value)
	return nil
}

func (ConfigurationProto_ClusterFunctions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 2}
}

// Schedule type to add the cronjob to run Saltstack.
type ConfigurationProto_SaltstackSchedule int32

const (
	ConfigurationProto_kHourly  ConfigurationProto_SaltstackSchedule = 0
	ConfigurationProto_kDaily   ConfigurationProto_SaltstackSchedule = 1
	ConfigurationProto_kWeekly  ConfigurationProto_SaltstackSchedule = 2
	ConfigurationProto_kMonthly ConfigurationProto_SaltstackSchedule = 3
)

var ConfigurationProto_SaltstackSchedule_name = map[int32]string{
	0: "kHourly",
	1: "kDaily",
	2: "kWeekly",
	3: "kMonthly",
}

var ConfigurationProto_SaltstackSchedule_value = map[string]int32{
	"kHourly":  0,
	"kDaily":   1,
	"kWeekly":  2,
	"kMonthly": 3,
}

func (x ConfigurationProto_SaltstackSchedule) Enum() *ConfigurationProto_SaltstackSchedule {
	p := new(ConfigurationProto_SaltstackSchedule)
	*p = x
	return p
}

func (x ConfigurationProto_SaltstackSchedule) String() string {
	return proto.EnumName(ConfigurationProto_SaltstackSchedule_name, int32(x))
}

func (x *ConfigurationProto_SaltstackSchedule) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_SaltstackSchedule_value, data, "ConfigurationProto_SaltstackSchedule")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_SaltstackSchedule(value)
	return nil
}

func (ConfigurationProto_SaltstackSchedule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 3}
}

// Operation mode.
type ConfigurationProto_OperationMode int32

const (
	ConfigurationProto_kNormal ConfigurationProto_OperationMode = 0
	// Indicates that this entity is operating in read only mode.
	ConfigurationProto_kReadOnly ConfigurationProto_OperationMode = 1
	// Indicates that only one node is operational in the cluster.
	// This is valid only for single node or two node clusters.
	ConfigurationProto_kStandAlone ConfigurationProto_OperationMode = 2
	// Indicates that we are moving from single node to two node
	// cluster.
	ConfigurationProto_kSwitchToTwoNode ConfigurationProto_OperationMode = 3
	// Indicates that this entity is operating in override mode. This is valid
	// only for single node cluster. If the user wants to run vms when the
	// single node cluster has gone to read only mode, he can set the cluster
	// operation mode to kOverride. Writes will be allowed in override mode.
	ConfigurationProto_kOverride ConfigurationProto_OperationMode = 4
)

var ConfigurationProto_OperationMode_name = map[int32]string{
	0: "kNormal",
	1: "kReadOnly",
	2: "kStandAlone",
	3: "kSwitchToTwoNode",
	4: "kOverride",
}

var ConfigurationProto_OperationMode_value = map[string]int32{
	"kNormal":          0,
	"kReadOnly":        1,
	"kStandAlone":      2,
	"kSwitchToTwoNode": 3,
	"kOverride":        4,
}

func (x ConfigurationProto_OperationMode) Enum() *ConfigurationProto_OperationMode {
	p := new(ConfigurationProto_OperationMode)
	*p = x
	return p
}

func (x ConfigurationProto_OperationMode) String() string {
	return proto.EnumName(ConfigurationProto_OperationMode_name, int32(x))
}

func (x *ConfigurationProto_OperationMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_OperationMode_value, data, "ConfigurationProto_OperationMode")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_OperationMode(value)
	return nil
}

func (ConfigurationProto_OperationMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4}
}

// The cluster architecture.
type ConfigurationProto_ClusterArch int32

const (
	ConfigurationProto_kX86_64  ConfigurationProto_ClusterArch = 0
	ConfigurationProto_kPpc64le ConfigurationProto_ClusterArch = 1
)

var ConfigurationProto_ClusterArch_name = map[int32]string{
	0: "kX86_64",
	1: "kPpc64le",
}

var ConfigurationProto_ClusterArch_value = map[string]int32{
	"kX86_64":  0,
	"kPpc64le": 1,
}

func (x ConfigurationProto_ClusterArch) Enum() *ConfigurationProto_ClusterArch {
	p := new(ConfigurationProto_ClusterArch)
	*p = x
	return p
}

func (x ConfigurationProto_ClusterArch) String() string {
	return proto.EnumName(ConfigurationProto_ClusterArch_name, int32(x))
}

func (x *ConfigurationProto_ClusterArch) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ClusterArch_value, data, "ConfigurationProto_ClusterArch")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ClusterArch(value)
	return nil
}

func (ConfigurationProto_ClusterArch) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 5}
}

type ConfigurationProto_KMSType int32

const (
	// This value indicates that the Key Encryption Keys (KEK) are stored in an
	// external key manager. The Data Encryption Keys (DEK) are encrypted by
	// KEKs and stored locally.
	ConfigurationProto_kEKM ConfigurationProto_KMSType = 0
	// This value indicates that the DEKs as well as KEKs are stored locally in
	// the cluster. The KEKs are encrypted by a master key which is split using
	// Shamir secret sharing algorithm and stored on the individual nodes in
	// the cluster.
	ConfigurationProto_kLKM ConfigurationProto_KMSType = 1
	// This is similar to 'kLKM' except that the master key is further secured
	// using information stored on the PC cluster if this is a PE registered to
	// the PC. If this is a PC cluster, then the master key is secured using
	// information stored on the underlying PE.
	ConfigurationProto_kPCKM ConfigurationProto_KMSType = 2
)

var ConfigurationProto_KMSType_name = map[int32]string{
	0: "kEKM",
	1: "kLKM",
	2: "kPCKM",
}

var ConfigurationProto_KMSType_value = map[string]int32{
	"kEKM":  0,
	"kLKM":  1,
	"kPCKM": 2,
}

func (x ConfigurationProto_KMSType) Enum() *ConfigurationProto_KMSType {
	p := new(ConfigurationProto_KMSType)
	*p = x
	return p
}

func (x ConfigurationProto_KMSType) String() string {
	return proto.EnumName(ConfigurationProto_KMSType_name, int32(x))
}

func (x *ConfigurationProto_KMSType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_KMSType_value, data, "ConfigurationProto_KMSType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_KMSType(value)
	return nil
}

func (ConfigurationProto_KMSType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 6}
}

type ConfigurationProto_MantleVersion int32

const (
	ConfigurationProto_kInitialMantleVersion ConfigurationProto_MantleVersion = 0
	ConfigurationProto_kMantleForwardingRPC  ConfigurationProto_MantleVersion = 5
)

var ConfigurationProto_MantleVersion_name = map[int32]string{
	0: "kInitialMantleVersion",
	5: "kMantleForwardingRPC",
}

var ConfigurationProto_MantleVersion_value = map[string]int32{
	"kInitialMantleVersion": 0,
	"kMantleForwardingRPC":  5,
}

func (x ConfigurationProto_MantleVersion) Enum() *ConfigurationProto_MantleVersion {
	p := new(ConfigurationProto_MantleVersion)
	*p = x
	return p
}

func (x ConfigurationProto_MantleVersion) String() string {
	return proto.EnumName(ConfigurationProto_MantleVersion_name, int32(x))
}

func (x *ConfigurationProto_MantleVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_MantleVersion_value, data, "ConfigurationProto_MantleVersion")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_MantleVersion(value)
	return nil
}

func (ConfigurationProto_MantleVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 7}
}

// Type of disks in this tier.
type ConfigurationProto_StorageTier_StorageType int32

const (
	ConfigurationProto_StorageTier_kPcieSSD ConfigurationProto_StorageTier_StorageType = 0
	ConfigurationProto_StorageTier_kSataSSD ConfigurationProto_StorageTier_StorageType = 1
	ConfigurationProto_StorageTier_kHDD     ConfigurationProto_StorageTier_StorageType = 2
	ConfigurationProto_StorageTier_kSAN     ConfigurationProto_StorageTier_StorageType = 3
	ConfigurationProto_StorageTier_kNAS     ConfigurationProto_StorageTier_StorageType = 4
	ConfigurationProto_StorageTier_kCloud   ConfigurationProto_StorageTier_StorageType = 5
)

var ConfigurationProto_StorageTier_StorageType_name = map[int32]string{
	0: "kPcieSSD",
	1: "kSataSSD",
	2: "kHDD",
	3: "kSAN",
	4: "kNAS",
	5: "kCloud",
}

var ConfigurationProto_StorageTier_StorageType_value = map[string]int32{
	"kPcieSSD": 0,
	"kSataSSD": 1,
	"kHDD":     2,
	"kSAN":     3,
	"kNAS":     4,
	"kCloud":   5,
}

func (x ConfigurationProto_StorageTier_StorageType) Enum() *ConfigurationProto_StorageTier_StorageType {
	p := new(ConfigurationProto_StorageTier_StorageType)
	*p = x
	return p
}

func (x ConfigurationProto_StorageTier_StorageType) String() string {
	return proto.EnumName(ConfigurationProto_StorageTier_StorageType_name, int32(x))
}

func (x *ConfigurationProto_StorageTier_StorageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_StorageTier_StorageType_value, data, "ConfigurationProto_StorageTier_StorageType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_StorageTier_StorageType(value)
	return nil
}

func (ConfigurationProto_StorageTier_StorageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 1, 0}
}

// The following is used only when disk status 'to_remove' is set. This is
// a bitmap whose relevant portions are set to 1 when the corresponding
// data from the disk has been migrated/replicated. Once all data from the
// disk has been migrated/replicated then 'data_migrated' flag is set to
// 'kAllDataMigrated'.
type ConfigurationProto_Disk_DataMigrationStatus int32

const (
	ConfigurationProto_Disk_kDataNotMigrated ConfigurationProto_Disk_DataMigrationStatus = 0
	// Indicates that the extent store data has been migrated.
	ConfigurationProto_Disk_kEstoreDataMigrated ConfigurationProto_Disk_DataMigrationStatus = 1
	// Indicates that there is no oplog data remaining in the disk. This flag
	// will be set only if the oplog_disk_size field is set.
	ConfigurationProto_Disk_kOplogDataDrained ConfigurationProto_Disk_DataMigrationStatus = 16
	// Indicates that the Cassandra metadata on this disk has been fully
	// replicated on other replica nodes. Once this field is set, the data
	// from this disk can be lost and still the quorum reads/writes of
	// metadata will remain consistent.
	// This flag will be set only if the contains_metadata field is true.
	ConfigurationProto_Disk_kCassandraDataReplicated ConfigurationProto_Disk_DataMigrationStatus = 256
	// Indicates that there is no near sync oplog data remaining in the disk.
	// This flag will be set only if the lws_store_disk_size field is set.
	ConfigurationProto_Disk_kNearSyncOplogDataExpired ConfigurationProto_Disk_DataMigrationStatus = 4096
	// In case we need to add more acknowledgements, maybe from other or
	// future components, we should modify this flag appropriately.
	ConfigurationProto_Disk_kAllDataMigrated ConfigurationProto_Disk_DataMigrationStatus = 4369
)

var ConfigurationProto_Disk_DataMigrationStatus_name = map[int32]string{
	0:    "kDataNotMigrated",
	1:    "kEstoreDataMigrated",
	16:   "kOplogDataDrained",
	256:  "kCassandraDataReplicated",
	4096: "kNearSyncOplogDataExpired",
	4369: "kAllDataMigrated",
}

var ConfigurationProto_Disk_DataMigrationStatus_value = map[string]int32{
	"kDataNotMigrated":          0,
	"kEstoreDataMigrated":       1,
	"kOplogDataDrained":         16,
	"kCassandraDataReplicated":  256,
	"kNearSyncOplogDataExpired": 4096,
	"kAllDataMigrated":          4369,
}

func (x ConfigurationProto_Disk_DataMigrationStatus) Enum() *ConfigurationProto_Disk_DataMigrationStatus {
	p := new(ConfigurationProto_Disk_DataMigrationStatus)
	*p = x
	return p
}

func (x ConfigurationProto_Disk_DataMigrationStatus) String() string {
	return proto.EnumName(ConfigurationProto_Disk_DataMigrationStatus_name, int32(x))
}

func (x *ConfigurationProto_Disk_DataMigrationStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Disk_DataMigrationStatus_value, data, "ConfigurationProto_Disk_DataMigrationStatus")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Disk_DataMigrationStatus(value)
	return nil
}

func (ConfigurationProto_Disk_DataMigrationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 2, 0}
}

// The protocol used to communicate with network peer.
type ConfigurationProto_NetworkEntity_ProtocolType int32

const (
	// TCP protocol.
	ConfigurationProto_NetworkEntity_kTcp ConfigurationProto_NetworkEntity_ProtocolType = 0
	// UDP protocol.
	ConfigurationProto_NetworkEntity_kUdp ConfigurationProto_NetworkEntity_ProtocolType = 1
)

var ConfigurationProto_NetworkEntity_ProtocolType_name = map[int32]string{
	0: "kTcp",
	1: "kUdp",
}

var ConfigurationProto_NetworkEntity_ProtocolType_value = map[string]int32{
	"kTcp": 0,
	"kUdp": 1,
}

func (x ConfigurationProto_NetworkEntity_ProtocolType) Enum() *ConfigurationProto_NetworkEntity_ProtocolType {
	p := new(ConfigurationProto_NetworkEntity_ProtocolType)
	*p = x
	return p
}

func (x ConfigurationProto_NetworkEntity_ProtocolType) String() string {
	return proto.EnumName(ConfigurationProto_NetworkEntity_ProtocolType_name, int32(x))
}

func (x *ConfigurationProto_NetworkEntity_ProtocolType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_NetworkEntity_ProtocolType_value, data, "ConfigurationProto_NetworkEntity_ProtocolType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_NetworkEntity_ProtocolType(value)
	return nil
}

func (ConfigurationProto_NetworkEntity_ProtocolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 3, 0}
}

// The proxy to send this type of outgoing traffic.
type ConfigurationProto_NetworkEntity_ProxyType int32

const (
	// HTTP proxy.
	ConfigurationProto_NetworkEntity_kHttp ConfigurationProto_NetworkEntity_ProxyType = 0
	// HTTPS proxy.
	ConfigurationProto_NetworkEntity_kHttps ConfigurationProto_NetworkEntity_ProxyType = 1
	// Socket Secure proxy.
	ConfigurationProto_NetworkEntity_kSocks ConfigurationProto_NetworkEntity_ProxyType = 2
)

var ConfigurationProto_NetworkEntity_ProxyType_name = map[int32]string{
	0: "kHttp",
	1: "kHttps",
	2: "kSocks",
}

var ConfigurationProto_NetworkEntity_ProxyType_value = map[string]int32{
	"kHttp":  0,
	"kHttps": 1,
	"kSocks": 2,
}

func (x ConfigurationProto_NetworkEntity_ProxyType) Enum() *ConfigurationProto_NetworkEntity_ProxyType {
	p := new(ConfigurationProto_NetworkEntity_ProxyType)
	*p = x
	return p
}

func (x ConfigurationProto_NetworkEntity_ProxyType) String() string {
	return proto.EnumName(ConfigurationProto_NetworkEntity_ProxyType_name, int32(x))
}

func (x *ConfigurationProto_NetworkEntity_ProxyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_NetworkEntity_ProxyType_value, data, "ConfigurationProto_NetworkEntity_ProxyType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_NetworkEntity_ProxyType(value)
	return nil
}

func (ConfigurationProto_NetworkEntity_ProxyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 3, 1}
}

// Node status
type ConfigurationProto_Node_Status int32

const (
	ConfigurationProto_Node_kNormal ConfigurationProto_Node_Status = 0
	// Intent to remove this node. The curator will migrate data off of this
	// node.
	ConfigurationProto_Node_kToBeRemoved ConfigurationProto_Node_Status = 1
	// Indicates that the node with this status can be physically taken off
	// the cluster and its data purged off the configuration in Zeus.
	ConfigurationProto_Node_kOkToBeRemoved ConfigurationProto_Node_Status = 2
	// New node
	ConfigurationProto_Node_kNewNode ConfigurationProto_Node_Status = 3
)

var ConfigurationProto_Node_Status_name = map[int32]string{
	0: "kNormal",
	1: "kToBeRemoved",
	2: "kOkToBeRemoved",
	3: "kNewNode",
}

var ConfigurationProto_Node_Status_value = map[string]int32{
	"kNormal":        0,
	"kToBeRemoved":   1,
	"kOkToBeRemoved": 2,
	"kNewNode":       3,
}

func (x ConfigurationProto_Node_Status) Enum() *ConfigurationProto_Node_Status {
	p := new(ConfigurationProto_Node_Status)
	*p = x
	return p
}

func (x ConfigurationProto_Node_Status) String() string {
	return proto.EnumName(ConfigurationProto_Node_Status_name, int32(x))
}

func (x *ConfigurationProto_Node_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_Status_value, data, "ConfigurationProto_Node_Status")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_Status(value)
	return nil
}

func (ConfigurationProto_Node_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 0}
}

// The following is used only when node_status is 'kToBeRemoved'. This is
// a bitmap whose relevant portions are set to 1 when the node is ok to
// be removed from the corresponding component's perspective. The
// components that need to acknowledge a node's removal are curator,
// cassandra, acropolis, zookeeper and mantle. The component that last updates
// this bitmap and finds all bits set (using kAllOkToRemove) shall update
// the node_status to kOkToBeRemoved.
type ConfigurationProto_Node_NodeRemovalAck int32

const (
	ConfigurationProto_Node_kCuratorOkToRemove   ConfigurationProto_Node_NodeRemovalAck = 1
	ConfigurationProto_Node_kCassandraOkToRemove ConfigurationProto_Node_NodeRemovalAck = 16
	ConfigurationProto_Node_kZookeeperOkToRemove ConfigurationProto_Node_NodeRemovalAck = 256
	ConfigurationProto_Node_kAcropolisOkToRemove ConfigurationProto_Node_NodeRemovalAck = 4096
	ConfigurationProto_Node_kMantleOkToRemove    ConfigurationProto_Node_NodeRemovalAck = 65536
	ConfigurationProto_Node_kGenesisOkToRemove   ConfigurationProto_Node_NodeRemovalAck = 1048576
	// In case we need to add more acknowledgements, maybe from other or
	// future components, we should modify this flag appropriately.
	ConfigurationProto_Node_kAllOkToRemove ConfigurationProto_Node_NodeRemovalAck = 1118481
)

var ConfigurationProto_Node_NodeRemovalAck_name = map[int32]string{
	1:       "kCuratorOkToRemove",
	16:      "kCassandraOkToRemove",
	256:     "kZookeeperOkToRemove",
	4096:    "kAcropolisOkToRemove",
	65536:   "kMantleOkToRemove",
	1048576: "kGenesisOkToRemove",
	1118481: "kAllOkToRemove",
}

var ConfigurationProto_Node_NodeRemovalAck_value = map[string]int32{
	"kCuratorOkToRemove":   1,
	"kCassandraOkToRemove": 16,
	"kZookeeperOkToRemove": 256,
	"kAcropolisOkToRemove": 4096,
	"kMantleOkToRemove":    65536,
	"kGenesisOkToRemove":   1048576,
	"kAllOkToRemove":       1118481,
}

func (x ConfigurationProto_Node_NodeRemovalAck) Enum() *ConfigurationProto_Node_NodeRemovalAck {
	p := new(ConfigurationProto_Node_NodeRemovalAck)
	*p = x
	return p
}

func (x ConfigurationProto_Node_NodeRemovalAck) String() string {
	return proto.EnumName(ConfigurationProto_Node_NodeRemovalAck_name, int32(x))
}

func (x *ConfigurationProto_Node_NodeRemovalAck) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_NodeRemovalAck_value, data, "ConfigurationProto_Node_NodeRemovalAck")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_NodeRemovalAck(value)
	return nil
}

func (ConfigurationProto_Node_NodeRemovalAck) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 1}
}

// Status of cassandra instance running on this node.
type ConfigurationProto_Node_CassandraStatus int32

const (
	// Cassandra is running in normal mode.
	ConfigurationProto_Node_kNormalMode ConfigurationProto_Node_CassandraStatus = 0
	// Cassandra is running in forwarding mode. In this mode, cassandra will
	// not accept any read/write messages from other cassandra instances in
	// the cluster. It will just accept requests from thrift and protobuf
	// clients and will forward them to the remote nodes.
	ConfigurationProto_Node_kForwardingMode ConfigurationProto_Node_CassandraStatus = 1
	// Cassandra node was detected to be down for an extended period and is
	// now being removed from Cassandra ring. In this state cassandra node
	// will be put in 'forwarding' mode while dynamic ring changer fixes
	// the keys belonging to this node. Once the ring change scans
	// finish, the state will change to 'kBeingDetachedFromRing'
	ConfigurationProto_Node_kToBeDetachedFromRing ConfigurationProto_Node_CassandraStatus = 2
	// Ring change scans for detaching node from cassandra ring have
	// finished. Now the node is being excised from the ring. The other
	// nodes in cassandra ring are acknowledging the removal. Once the
	// acknowledgment process finishes, the node status will be moved to
	// 'kDetachedFromRing'.
	ConfigurationProto_Node_kBeingDetachedFromRing ConfigurationProto_Node_CassandraStatus = 3
	// The node is no longer part of the Cassandra ring. The node has been
	// removed from the Cassandra ring. For the node to be added back to the
	// ring, it must follow the dynamic add node procedure.
	ConfigurationProto_Node_kDetachedFromRing ConfigurationProto_Node_CassandraStatus = 4
	// The node was detached from the ring before (was in
	// 'kDetachedFromRing' state) but is now healthy again.
	// This state is set once the data from cassandra's earlier incarnation
	// has been deleted. The node is now in 'PreLimbo' state waiting to be to
	// added back to the cassandra ring.
	ConfigurationProto_Node_kDataDeletedNowInPreLimbo ConfigurationProto_Node_CassandraStatus = 5
	// The node was detached from the ring. The earlier incarnation's
	// cassandra data has been deleted and cleaned up. Now the node is being
	// added back to the ring as a fresh/new node.
	ConfigurationProto_Node_kToBeAddedToRing ConfigurationProto_Node_CassandraStatus = 6
	// User can set this state on the node to force the detachment
	// from the cassandra ring
	ConfigurationProto_Node_kToBeForceDetachedFromRing ConfigurationProto_Node_CassandraStatus = 7
	// This state indicates that the node is in forwarding mode and  metadata
	// repair has been completed for the range belonging to this node.
	// cassandra_monitor will move the state to kNormalMode after cleaning up
	// any metadata residing on this node.
	ConfigurationProto_Node_kMetadataRepairDone ConfigurationProto_Node_CassandraStatus = 8
	// This state indicates that the node is in forwarding mode and metadata
	// repair needs to be performed for the range belonging to this node.
	ConfigurationProto_Node_kMetadataRepairRequired ConfigurationProto_Node_CassandraStatus = 9
	// This state indicates that the metadata shards on this node need to be
	// redistributed among the available metadata disks. As for accepting
	// reads/writes for the keys is concerned, the node is in kNormal mode.
	ConfigurationProto_Node_kMetadataShardingRequired ConfigurationProto_Node_CassandraStatus = 10
)

var ConfigurationProto_Node_CassandraStatus_name = map[int32]string{
	0:  "kNormalMode",
	1:  "kForwardingMode",
	2:  "kToBeDetachedFromRing",
	3:  "kBeingDetachedFromRing",
	4:  "kDetachedFromRing",
	5:  "kDataDeletedNowInPreLimbo",
	6:  "kToBeAddedToRing",
	7:  "kToBeForceDetachedFromRing",
	8:  "kMetadataRepairDone",
	9:  "kMetadataRepairRequired",
	10: "kMetadataShardingRequired",
}

var ConfigurationProto_Node_CassandraStatus_value = map[string]int32{
	"kNormalMode":                0,
	"kForwardingMode":            1,
	"kToBeDetachedFromRing":      2,
	"kBeingDetachedFromRing":     3,
	"kDetachedFromRing":          4,
	"kDataDeletedNowInPreLimbo":  5,
	"kToBeAddedToRing":           6,
	"kToBeForceDetachedFromRing": 7,
	"kMetadataRepairDone":        8,
	"kMetadataRepairRequired":    9,
	"kMetadataShardingRequired":  10,
}

func (x ConfigurationProto_Node_CassandraStatus) Enum() *ConfigurationProto_Node_CassandraStatus {
	p := new(ConfigurationProto_Node_CassandraStatus)
	*p = x
	return p
}

func (x ConfigurationProto_Node_CassandraStatus) String() string {
	return proto.EnumName(ConfigurationProto_Node_CassandraStatus_name, int32(x))
}

func (x *ConfigurationProto_Node_CassandraStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_CassandraStatus_value, data, "ConfigurationProto_Node_CassandraStatus")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_CassandraStatus(value)
	return nil
}

func (ConfigurationProto_Node_CassandraStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 2}
}

type ConfigurationProto_Node_CassandraStateChangeSource int32

const (
	// Cassandra Status was changed by dynamic ring changer.
	ConfigurationProto_Node_kDynamicRingChanger ConfigurationProto_Node_CassandraStateChangeSource = 0
	// Cassandra Status was changed by cassandra_monitor.
	ConfigurationProto_Node_kCassandraMonitor ConfigurationProto_Node_CassandraStateChangeSource = 1
	// Node is being removed from the cluster.
	ConfigurationProto_Node_kNodeRemoval ConfigurationProto_Node_CassandraStateChangeSource = 2
	// Cassandra node was marked to be detached due to frequent restarts.
	ConfigurationProto_Node_kDetachDueToFrequentRestarts ConfigurationProto_Node_CassandraStateChangeSource = 3
	// Cassandra node was marked to be detached since it was down for a long
	// time.
	ConfigurationProto_Node_kDetachDueToServiceDown ConfigurationProto_Node_CassandraStateChangeSource = 4
	// Cassandra node was marked to be force detached.
	ConfigurationProto_Node_kForcedDetach ConfigurationProto_Node_CassandraStateChangeSource = 5
	// Cassandra node was manually marked to be added back to the ring by
	// executing the ncli host enable-metadata-store command.
	ConfigurationProto_Node_kEnableMetadataStoreNcli ConfigurationProto_Node_CassandraStateChangeSource = 6
	// Cassandra node was automatically marked to be added back to the ring
	// after it was stable for a long time.
	ConfigurationProto_Node_kAutoAdd ConfigurationProto_Node_CassandraStateChangeSource = 7
	// The metadata disk on this node was marked for disk replacement.
	ConfigurationProto_Node_kDiskReplace ConfigurationProto_Node_CassandraStateChangeSource = 8
	// Health warnings received from cassandra daemon.
	ConfigurationProto_Node_kCassandraHealthWarnings ConfigurationProto_Node_CassandraStateChangeSource = 9
	// The operation was initiated as part of automatic ring fix operation.
	ConfigurationProto_Node_kAutoRingFix ConfigurationProto_Node_CassandraStateChangeSource = 10
	// The operation was initiated because the node was partially degraded.
	ConfigurationProto_Node_kDegradedNode ConfigurationProto_Node_CassandraStateChangeSource = 11
	// Cassandra node was marked to repair metadata forcibly.
	ConfigurationProto_Node_kForceMetadataRepair ConfigurationProto_Node_CassandraStateChangeSource = 12
	// Cassandra status change source is not known.
	ConfigurationProto_Node_kUnknown ConfigurationProto_Node_CassandraStateChangeSource = 13
	// The operation was initiated because disk usage on metadata disk has
	// exceeded threshold limits.
	ConfigurationProto_Node_kDiskFull ConfigurationProto_Node_CassandraStateChangeSource = 14
)

var ConfigurationProto_Node_CassandraStateChangeSource_name = map[int32]string{
	0:  "kDynamicRingChanger",
	1:  "kCassandraMonitor",
	2:  "kNodeRemoval",
	3:  "kDetachDueToFrequentRestarts",
	4:  "kDetachDueToServiceDown",
	5:  "kForcedDetach",
	6:  "kEnableMetadataStoreNcli",
	7:  "kAutoAdd",
	8:  "kDiskReplace",
	9:  "kCassandraHealthWarnings",
	10: "kAutoRingFix",
	11: "kDegradedNode",
	12: "kForceMetadataRepair",
	13: "kUnknown",
	14: "kDiskFull",
}

var ConfigurationProto_Node_CassandraStateChangeSource_value = map[string]int32{
	"kDynamicRingChanger":          0,
	"kCassandraMonitor":            1,
	"kNodeRemoval":                 2,
	"kDetachDueToFrequentRestarts": 3,
	"kDetachDueToServiceDown":      4,
	"kForcedDetach":                5,
	"kEnableMetadataStoreNcli":     6,
	"kAutoAdd":                     7,
	"kDiskReplace":                 8,
	"kCassandraHealthWarnings":     9,
	"kAutoRingFix":                 10,
	"kDegradedNode":                11,
	"kForceMetadataRepair":         12,
	"kUnknown":                     13,
	"kDiskFull":                    14,
}

func (x ConfigurationProto_Node_CassandraStateChangeSource) Enum() *ConfigurationProto_Node_CassandraStateChangeSource {
	p := new(ConfigurationProto_Node_CassandraStateChangeSource)
	*p = x
	return p
}

func (x ConfigurationProto_Node_CassandraStateChangeSource) String() string {
	return proto.EnumName(ConfigurationProto_Node_CassandraStateChangeSource_name, int32(x))
}

func (x *ConfigurationProto_Node_CassandraStateChangeSource) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_CassandraStateChangeSource_value, data, "ConfigurationProto_Node_CassandraStateChangeSource")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_CassandraStateChangeSource(value)
	return nil
}

func (ConfigurationProto_Node_CassandraStateChangeSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 3}
}

// Node Type
type ConfigurationProto_Node_NodeType int32

const (
	ConfigurationProto_Node_kRegular ConfigurationProto_Node_NodeType = 1
	// Acroplis no uvms node
	ConfigurationProto_Node_kAhvNeverSchedulable ConfigurationProto_Node_NodeType = 2
)

var ConfigurationProto_Node_NodeType_name = map[int32]string{
	1: "kRegular",
	2: "kAhvNeverSchedulable",
}

var ConfigurationProto_Node_NodeType_value = map[string]int32{
	"kRegular":             1,
	"kAhvNeverSchedulable": 2,
}

func (x ConfigurationProto_Node_NodeType) Enum() *ConfigurationProto_Node_NodeType {
	p := new(ConfigurationProto_Node_NodeType)
	*p = x
	return p
}

func (x ConfigurationProto_Node_NodeType) String() string {
	return proto.EnumName(ConfigurationProto_Node_NodeType_name, int32(x))
}

func (x *ConfigurationProto_Node_NodeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_NodeType_value, data, "ConfigurationProto_Node_NodeType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_NodeType(value)
	return nil
}

func (ConfigurationProto_Node_NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 4}
}

type ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState int32

const (
	// Node is normal and it is okay to schedule VMs on this node.
	ConfigurationProto_Node_AcropolisStatus_kAcropolisNormal ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 1
	// Node is entering maintenance mode.
	ConfigurationProto_Node_AcropolisStatus_kEnteringMaintenanceMode ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 2
	// Node has entered maintenance mode.
	ConfigurationProto_Node_AcropolisStatus_kEnteredMaintenanceMode ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 3
	// Node is reserved for HA failover.
	ConfigurationProto_Node_AcropolisStatus_kReservedForHAFailover ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 4
	// Special state indicating that we are in the process of
	// entering maintenance mode for a host that was reserved for
	// HA failover.
	ConfigurationProto_Node_AcropolisStatus_kEnteringMaintenanceModeFromHAFailover ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 5
	// Node is in the process of being reserved for HA failover
	ConfigurationProto_Node_AcropolisStatus_kReservingForHAFailover ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 6
	// Node is the source of HA failover.
	ConfigurationProto_Node_AcropolisStatus_kHAFailoverSource ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 7
	// Node is the target of HA failover.
	ConfigurationProto_Node_AcropolisStatus_kHAFailoverTarget ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 8
	// Node is in the process of migrating its VMs off, and will
	// soon be back to kReservedForHAFailover.
	ConfigurationProto_Node_AcropolisStatus_kHAHealingSource ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 9
	// Node is in the process of having VMs migrated back to it
	// after coming back from the dead.
	ConfigurationProto_Node_AcropolisStatus_kHAHealingTarget ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = 10
)

var ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState_name = map[int32]string{
	1:  "kAcropolisNormal",
	2:  "kEnteringMaintenanceMode",
	3:  "kEnteredMaintenanceMode",
	4:  "kReservedForHAFailover",
	5:  "kEnteringMaintenanceModeFromHAFailover",
	6:  "kReservingForHAFailover",
	7:  "kHAFailoverSource",
	8:  "kHAFailoverTarget",
	9:  "kHAHealingSource",
	10: "kHAHealingTarget",
}

var ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState_value = map[string]int32{
	"kAcropolisNormal":                       1,
	"kEnteringMaintenanceMode":               2,
	"kEnteredMaintenanceMode":                3,
	"kReservedForHAFailover":                 4,
	"kEnteringMaintenanceModeFromHAFailover": 5,
	"kReservingForHAFailover":                6,
	"kHAFailoverSource":                      7,
	"kHAFailoverTarget":                      8,
	"kHAHealingSource":                       9,
	"kHAHealingTarget":                       10,
}

func (x ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState) Enum() *ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState {
	p := new(ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState)
	*p = x
	return p
}

func (x ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState) String() string {
	return proto.EnumName(ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState_name, int32(x))
}

func (x *ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState_value, data, "ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState(value)
	return nil
}

func (ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 1, 0}
}

// Status of Acropolis connection to hypervisor.
type ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState int32

const (
	ConfigurationProto_Node_AcropolisStatus_kDisconnected ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState = 1
	ConfigurationProto_Node_AcropolisStatus_kConnected    ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState = 2
)

var ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState_name = map[int32]string{
	1: "kDisconnected",
	2: "kConnected",
}

var ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState_value = map[string]int32{
	"kDisconnected": 1,
	"kConnected":    2,
}

func (x ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState) Enum() *ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState {
	p := new(ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState)
	*p = x
	return p
}

func (x ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState) String() string {
	return proto.EnumName(ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState_name, int32(x))
}

func (x *ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState_value, data, "ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState(value)
	return nil
}

func (ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 1, 1}
}

type ConfigurationProto_EncryptionParams_EncryptionScope int32

const (
	// In non-AHV clusters, all containers are encrypted. Any new container
	// created is encrypted by default. In AHV, all VMs are encrypted.
	ConfigurationProto_EncryptionParams_kCluster ConfigurationProto_EncryptionParams_EncryptionScope = 0
	// This is a valid setting only in non-AHV clusters. This will allow a
	// mix of encrypted and unencrypted containers.
	ConfigurationProto_EncryptionParams_kContainer ConfigurationProto_EncryptionParams_EncryptionScope = 1
)

var ConfigurationProto_EncryptionParams_EncryptionScope_name = map[int32]string{
	0: "kCluster",
	1: "kContainer",
}

var ConfigurationProto_EncryptionParams_EncryptionScope_value = map[string]int32{
	"kCluster":   0,
	"kContainer": 1,
}

func (x ConfigurationProto_EncryptionParams_EncryptionScope) Enum() *ConfigurationProto_EncryptionParams_EncryptionScope {
	p := new(ConfigurationProto_EncryptionParams_EncryptionScope)
	*p = x
	return p
}

func (x ConfigurationProto_EncryptionParams_EncryptionScope) String() string {
	return proto.EnumName(ConfigurationProto_EncryptionParams_EncryptionScope_name, int32(x))
}

func (x *ConfigurationProto_EncryptionParams_EncryptionScope) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_EncryptionParams_EncryptionScope_value, data, "ConfigurationProto_EncryptionParams_EncryptionScope")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_EncryptionParams_EncryptionScope(value)
	return nil
}

func (ConfigurationProto_EncryptionParams_EncryptionScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 6, 0}
}

// Bitmap of components that have been encrypted. This is used when users
// enable encryption on unencrypted entities like cluster or container.
// This will only be set in the container's EncryptionParams. The reason is
// this field is used internally to keep track of the component status and
// does not need to be up aggregate to upper level entity like cluster.
// Once the 'encrypted' field is set to true, the bitamp will be cleared
// because the bitmap is no longer needed and to reduce confusion since new
// components can be added in future software releases.
type ConfigurationProto_EncryptionParams_EncryptionComponents int32

const (
	// Extent store.
	ConfigurationProto_EncryptionParams_kExtentStore ConfigurationProto_EncryptionParams_EncryptionComponents = 1
	// NFS metadata.
	ConfigurationProto_EncryptionParams_kNFSMetadata ConfigurationProto_EncryptionParams_EncryptionComponents = 2
	// Oplog.
	ConfigurationProto_EncryptionParams_kOplog ConfigurationProto_EncryptionParams_EncryptionComponents = 4
	// NFS master WAL.
	ConfigurationProto_EncryptionParams_kNFSMasterWAL ConfigurationProto_EncryptionParams_EncryptionComponents = 8
	// Nearsync oplog.
	ConfigurationProto_EncryptionParams_kNearSyncOplog ConfigurationProto_EncryptionParams_EncryptionComponents = 16
	// Content cache.
	ConfigurationProto_EncryptionParams_kContentCache ConfigurationProto_EncryptionParams_EncryptionComponents = 32
	// Bits that represent all the components. This should be modified when
	// new components are added.
	ConfigurationProto_EncryptionParams_kAllComponents ConfigurationProto_EncryptionParams_EncryptionComponents = 63
)

var ConfigurationProto_EncryptionParams_EncryptionComponents_name = map[int32]string{
	1:  "kExtentStore",
	2:  "kNFSMetadata",
	4:  "kOplog",
	8:  "kNFSMasterWAL",
	16: "kNearSyncOplog",
	32: "kContentCache",
	63: "kAllComponents",
}

var ConfigurationProto_EncryptionParams_EncryptionComponents_value = map[string]int32{
	"kExtentStore":   1,
	"kNFSMetadata":   2,
	"kOplog":         4,
	"kNFSMasterWAL":  8,
	"kNearSyncOplog": 16,
	"kContentCache":  32,
	"kAllComponents": 63,
}

func (x ConfigurationProto_EncryptionParams_EncryptionComponents) Enum() *ConfigurationProto_EncryptionParams_EncryptionComponents {
	p := new(ConfigurationProto_EncryptionParams_EncryptionComponents)
	*p = x
	return p
}

func (x ConfigurationProto_EncryptionParams_EncryptionComponents) String() string {
	return proto.EnumName(ConfigurationProto_EncryptionParams_EncryptionComponents_name, int32(x))
}

func (x *ConfigurationProto_EncryptionParams_EncryptionComponents) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_EncryptionParams_EncryptionComponents_value, data, "ConfigurationProto_EncryptionParams_EncryptionComponents")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_EncryptionParams_EncryptionComponents(value)
	return nil
}

func (ConfigurationProto_EncryptionParams_EncryptionComponents) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 6, 1}
}

type ConfigurationProto_ContainerParams_EncryptionType int32

const (
	ConfigurationProto_ContainerParams_kWeak   ConfigurationProto_ContainerParams_EncryptionType = 0
	ConfigurationProto_ContainerParams_kStrong ConfigurationProto_ContainerParams_EncryptionType = 1
)

var ConfigurationProto_ContainerParams_EncryptionType_name = map[int32]string{
	0: "kWeak",
	1: "kStrong",
}

var ConfigurationProto_ContainerParams_EncryptionType_value = map[string]int32{
	"kWeak":   0,
	"kStrong": 1,
}

func (x ConfigurationProto_ContainerParams_EncryptionType) Enum() *ConfigurationProto_ContainerParams_EncryptionType {
	p := new(ConfigurationProto_ContainerParams_EncryptionType)
	*p = x
	return p
}

func (x ConfigurationProto_ContainerParams_EncryptionType) String() string {
	return proto.EnumName(ConfigurationProto_ContainerParams_EncryptionType_name, int32(x))
}

func (x *ConfigurationProto_ContainerParams_EncryptionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ContainerParams_EncryptionType_value, data, "ConfigurationProto_ContainerParams_EncryptionType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ContainerParams_EncryptionType(value)
	return nil
}

func (ConfigurationProto_ContainerParams_EncryptionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 7, 0}
}

type ConfigurationProto_ContainerParams_CompressionType int32

const (
	ConfigurationProto_ContainerParams_kNone   ConfigurationProto_ContainerParams_CompressionType = -1
	ConfigurationProto_ContainerParams_kLow    ConfigurationProto_ContainerParams_CompressionType = 0
	ConfigurationProto_ContainerParams_kMedium ConfigurationProto_ContainerParams_CompressionType = 1
	ConfigurationProto_ContainerParams_kHigh   ConfigurationProto_ContainerParams_CompressionType = 2
)

var ConfigurationProto_ContainerParams_CompressionType_name = map[int32]string{
	-1: "kNone",
	0:  "kLow",
	1:  "kMedium",
	2:  "kHigh",
}

var ConfigurationProto_ContainerParams_CompressionType_value = map[string]int32{
	"kNone":   -1,
	"kLow":    0,
	"kMedium": 1,
	"kHigh":   2,
}

func (x ConfigurationProto_ContainerParams_CompressionType) Enum() *ConfigurationProto_ContainerParams_CompressionType {
	p := new(ConfigurationProto_ContainerParams_CompressionType)
	*p = x
	return p
}

func (x ConfigurationProto_ContainerParams_CompressionType) String() string {
	return proto.EnumName(ConfigurationProto_ContainerParams_CompressionType_name, int32(x))
}

func (x *ConfigurationProto_ContainerParams_CompressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ContainerParams_CompressionType_value, data, "ConfigurationProto_ContainerParams_CompressionType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ContainerParams_CompressionType(value)
	return nil
}

func (ConfigurationProto_ContainerParams_CompressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 7, 1}
}

// During a READDIRPLUS call, we do not return inode attributes along with
// the response in order to reduce latency and other performance impact
// arising due to additional master-slave chatter.
// However we may need to enable this for certain NFS non-compliant
// application to run. We can enable this feature on per container basis
// using the following setting. The meaning of each value is explained
// inline.
type ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType int32

const (
	// This is the default value. We don't need to return any attributes for
	// current container.
	ConfigurationProto_ContainerParams_kNoAttributes ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType = 0
	// Return the attributes for all the inodes in the current directory.
	// Note that this may return potentially stale attributes for .lck files
	// as they may have outstanding medusa update from slave (even when slave
	// has been acknowledged the write, due to performance optimization). The
	// first write to the .lck file will change the file size from 0 bytes to
	// 84 bytes. With this option, we may still return 0 bytes as file size
	// for .lck file. This problem doesn't exist for any other file in the
	// system as long as NFS client has serialized metadata updates (setattr/
	// file extension) with READDIRPLUS call (in case of a race, we either
	// return old or new attributes only).
	ConfigurationProto_ContainerParams_kAllAttributes ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType = 1
	// If returning potentially stale attributes for .lck file is causing
	// operational or correctness issues on NFS client, enable this option to
	// ensure that we only return attributes if we are guaranteed to be up to
	// date. If there are any outstanding medusa updates on .lck file, we
	// will not return attributes for that entry.
	ConfigurationProto_ContainerParams_kOnlyUpToDateAttributes ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType = 2
)

var ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType_name = map[int32]string{
	0: "kNoAttributes",
	1: "kAllAttributes",
	2: "kOnlyUpToDateAttributes",
}

var ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType_value = map[string]int32{
	"kNoAttributes":           0,
	"kAllAttributes":          1,
	"kOnlyUpToDateAttributes": 2,
}

func (x ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType) Enum() *ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType {
	p := new(ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType)
	*p = x
	return p
}

func (x ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType) String() string {
	return proto.EnumName(ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType_name, int32(x))
}

func (x *ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType_value, data, "ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType(value)
	return nil
}

func (ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 7, 2}
}

// Type of the hypervisor management server. A management server can be
// just the hypervisor itself, or a datacenter management tool that
// manages multiple hypervisors.
type ConfigurationProto_ManagementServer_HypervisorType int32

const (
	ConfigurationProto_ManagementServer_kVMware            ConfigurationProto_ManagementServer_HypervisorType = 0
	ConfigurationProto_ManagementServer_kXen               ConfigurationProto_ManagementServer_HypervisorType = 1
	ConfigurationProto_ManagementServer_kHyperv            ConfigurationProto_ManagementServer_HypervisorType = 2
	ConfigurationProto_ManagementServer_kKvm               ConfigurationProto_ManagementServer_HypervisorType = 3
	ConfigurationProto_ManagementServer_kAmazonWebServices ConfigurationProto_ManagementServer_HypervisorType = 100
	ConfigurationProto_ManagementServer_kVCenter           ConfigurationProto_ManagementServer_HypervisorType = 1000
	ConfigurationProto_ManagementServer_kAcropolis         ConfigurationProto_ManagementServer_HypervisorType = 1001
	ConfigurationProto_ManagementServer_kSCVMM             ConfigurationProto_ManagementServer_HypervisorType = 1002
	ConfigurationProto_ManagementServer_kNull              ConfigurationProto_ManagementServer_HypervisorType = 9999
)

var ConfigurationProto_ManagementServer_HypervisorType_name = map[int32]string{
	0:    "kVMware",
	1:    "kXen",
	2:    "kHyperv",
	3:    "kKvm",
	100:  "kAmazonWebServices",
	1000: "kVCenter",
	1001: "kAcropolis",
	1002: "kSCVMM",
	9999: "kNull",
}

var ConfigurationProto_ManagementServer_HypervisorType_value = map[string]int32{
	"kVMware":            0,
	"kXen":               1,
	"kHyperv":            2,
	"kKvm":               3,
	"kAmazonWebServices": 100,
	"kVCenter":           1000,
	"kAcropolis":         1001,
	"kSCVMM":             1002,
	"kNull":              9999,
}

func (x ConfigurationProto_ManagementServer_HypervisorType) Enum() *ConfigurationProto_ManagementServer_HypervisorType {
	p := new(ConfigurationProto_ManagementServer_HypervisorType)
	*p = x
	return p
}

func (x ConfigurationProto_ManagementServer_HypervisorType) String() string {
	return proto.EnumName(ConfigurationProto_ManagementServer_HypervisorType_name, int32(x))
}

func (x *ConfigurationProto_ManagementServer_HypervisorType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ManagementServer_HypervisorType_value, data, "ConfigurationProto_ManagementServer_HypervisorType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ManagementServer_HypervisorType(value)
	return nil
}

func (ConfigurationProto_ManagementServer_HypervisorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 9, 0}
}

// Compression algorithm for the data transferred to this remote. Absence
// of this field means that data will not be compressed by Stargate before
// sending to the remote site. Each value in this enum is a bit-field.
// This allows Cerebro to determine which compression algorithm to use
// in case the local and remote sites are on differing software versions.
// We only allow 64 possible algorithms in this enum. Beyond this,
// the 'compression_algorithm' field will need to become a repeated field.
type ConfigurationProto_RemoteSite_CompressionAlgorithm int32

const (
	ConfigurationProto_RemoteSite_kSnappy ConfigurationProto_RemoteSite_CompressionAlgorithm = 1
	ConfigurationProto_RemoteSite_kZlib   ConfigurationProto_RemoteSite_CompressionAlgorithm = 2
	ConfigurationProto_RemoteSite_kBzip2  ConfigurationProto_RemoteSite_CompressionAlgorithm = 4
	ConfigurationProto_RemoteSite_kLZ4    ConfigurationProto_RemoteSite_CompressionAlgorithm = 8
	ConfigurationProto_RemoteSite_kLZ4HC  ConfigurationProto_RemoteSite_CompressionAlgorithm = 16
)

var ConfigurationProto_RemoteSite_CompressionAlgorithm_name = map[int32]string{
	1:  "kSnappy",
	2:  "kZlib",
	4:  "kBzip2",
	8:  "kLZ4",
	16: "kLZ4HC",
}

var ConfigurationProto_RemoteSite_CompressionAlgorithm_value = map[string]int32{
	"kSnappy": 1,
	"kZlib":   2,
	"kBzip2":  4,
	"kLZ4":    8,
	"kLZ4HC":  16,
}

func (x ConfigurationProto_RemoteSite_CompressionAlgorithm) Enum() *ConfigurationProto_RemoteSite_CompressionAlgorithm {
	p := new(ConfigurationProto_RemoteSite_CompressionAlgorithm)
	*p = x
	return p
}

func (x ConfigurationProto_RemoteSite_CompressionAlgorithm) String() string {
	return proto.EnumName(ConfigurationProto_RemoteSite_CompressionAlgorithm_name, int32(x))
}

func (x *ConfigurationProto_RemoteSite_CompressionAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RemoteSite_CompressionAlgorithm_value, data, "ConfigurationProto_RemoteSite_CompressionAlgorithm")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RemoteSite_CompressionAlgorithm(value)
	return nil
}

func (ConfigurationProto_RemoteSite_CompressionAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 0}
}

type ConfigurationProto_RemoteSite_RemoteSiteType int32

const (
	// Remote site created by 'legacy' Cerebro workflows.
	ConfigurationProto_RemoteSite_kLegacy ConfigurationProto_RemoteSite_RemoteSiteType = 1
	// Remote site created by 'entity centric' Cerebro workflows.
	ConfigurationProto_RemoteSite_kEntityCentric ConfigurationProto_RemoteSite_RemoteSiteType = 2
)

var ConfigurationProto_RemoteSite_RemoteSiteType_name = map[int32]string{
	1: "kLegacy",
	2: "kEntityCentric",
}

var ConfigurationProto_RemoteSite_RemoteSiteType_value = map[string]int32{
	"kLegacy":        1,
	"kEntityCentric": 2,
}

func (x ConfigurationProto_RemoteSite_RemoteSiteType) Enum() *ConfigurationProto_RemoteSite_RemoteSiteType {
	p := new(ConfigurationProto_RemoteSite_RemoteSiteType)
	*p = x
	return p
}

func (x ConfigurationProto_RemoteSite_RemoteSiteType) String() string {
	return proto.EnumName(ConfigurationProto_RemoteSite_RemoteSiteType_name, int32(x))
}

func (x *ConfigurationProto_RemoteSite_RemoteSiteType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RemoteSite_RemoteSiteType_value, data, "ConfigurationProto_RemoteSite_RemoteSiteType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RemoteSite_RemoteSiteType(value)
	return nil
}

func (ConfigurationProto_RemoteSite_RemoteSiteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 1}
}

// Bitmap of remote site's cluster properies.
type ConfigurationProto_RemoteSite_Capabilities_ClusterProperties int32

const (
	ConfigurationProto_RemoteSite_Capabilities_kOneNodeBackupCluster    ConfigurationProto_RemoteSite_Capabilities_ClusterProperties = 1
	ConfigurationProto_RemoteSite_Capabilities_kLightComputeCluster     ConfigurationProto_RemoteSite_Capabilities_ClusterProperties = 2
	ConfigurationProto_RemoteSite_Capabilities_kOneNodeDRCapableCluster ConfigurationProto_RemoteSite_Capabilities_ClusterProperties = 4
)

var ConfigurationProto_RemoteSite_Capabilities_ClusterProperties_name = map[int32]string{
	1: "kOneNodeBackupCluster",
	2: "kLightComputeCluster",
	4: "kOneNodeDRCapableCluster",
}

var ConfigurationProto_RemoteSite_Capabilities_ClusterProperties_value = map[string]int32{
	"kOneNodeBackupCluster":    1,
	"kLightComputeCluster":     2,
	"kOneNodeDRCapableCluster": 4,
}

func (x ConfigurationProto_RemoteSite_Capabilities_ClusterProperties) Enum() *ConfigurationProto_RemoteSite_Capabilities_ClusterProperties {
	p := new(ConfigurationProto_RemoteSite_Capabilities_ClusterProperties)
	*p = x
	return p
}

func (x ConfigurationProto_RemoteSite_Capabilities_ClusterProperties) String() string {
	return proto.EnumName(ConfigurationProto_RemoteSite_Capabilities_ClusterProperties_name, int32(x))
}

func (x *ConfigurationProto_RemoteSite_Capabilities_ClusterProperties) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RemoteSite_Capabilities_ClusterProperties_value, data, "ConfigurationProto_RemoteSite_Capabilities_ClusterProperties")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RemoteSite_Capabilities_ClusterProperties(value)
	return nil
}

func (ConfigurationProto_RemoteSite_Capabilities_ClusterProperties) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 1, 0}
}

type ConfigurationProto_Aegis_SmtpServerType int32

const (
	ConfigurationProto_Aegis_kPlain    ConfigurationProto_Aegis_SmtpServerType = 0
	ConfigurationProto_Aegis_kStartTLS ConfigurationProto_Aegis_SmtpServerType = 1
	ConfigurationProto_Aegis_kSSL      ConfigurationProto_Aegis_SmtpServerType = 2
)

var ConfigurationProto_Aegis_SmtpServerType_name = map[int32]string{
	0: "kPlain",
	1: "kStartTLS",
	2: "kSSL",
}

var ConfigurationProto_Aegis_SmtpServerType_value = map[string]int32{
	"kPlain":    0,
	"kStartTLS": 1,
	"kSSL":      2,
}

func (x ConfigurationProto_Aegis_SmtpServerType) Enum() *ConfigurationProto_Aegis_SmtpServerType {
	p := new(ConfigurationProto_Aegis_SmtpServerType)
	*p = x
	return p
}

func (x ConfigurationProto_Aegis_SmtpServerType) String() string {
	return proto.EnumName(ConfigurationProto_Aegis_SmtpServerType_name, int32(x))
}

func (x *ConfigurationProto_Aegis_SmtpServerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Aegis_SmtpServerType_value, data, "ConfigurationProto_Aegis_SmtpServerType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Aegis_SmtpServerType(value)
	return nil
}

func (ConfigurationProto_Aegis_SmtpServerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 0}
}

// Verbosity level settings for populating support information protobuf.
type ConfigurationProto_Aegis_SupportInformationVerbosityLevel int32

const (
	// Send nothing.
	ConfigurationProto_Aegis_kNothing ConfigurationProto_Aegis_SupportInformationVerbosityLevel = 0
	// Send basic information - skip core dump and esx stats information.
	ConfigurationProto_Aegis_kBasic ConfigurationProto_Aegis_SupportInformationVerbosityLevel = 1
	// Send basic and core dump information.
	ConfigurationProto_Aegis_kBasicPlusCoreDump ConfigurationProto_Aegis_SupportInformationVerbosityLevel = 2
	// Send all information as specified in the protobuf.
	ConfigurationProto_Aegis_kAll ConfigurationProto_Aegis_SupportInformationVerbosityLevel = 3
)

var ConfigurationProto_Aegis_SupportInformationVerbosityLevel_name = map[int32]string{
	0: "kNothing",
	1: "kBasic",
	2: "kBasicPlusCoreDump",
	3: "kAll",
}

var ConfigurationProto_Aegis_SupportInformationVerbosityLevel_value = map[string]int32{
	"kNothing":           0,
	"kBasic":             1,
	"kBasicPlusCoreDump": 2,
	"kAll":               3,
}

func (x ConfigurationProto_Aegis_SupportInformationVerbosityLevel) Enum() *ConfigurationProto_Aegis_SupportInformationVerbosityLevel {
	p := new(ConfigurationProto_Aegis_SupportInformationVerbosityLevel)
	*p = x
	return p
}

func (x ConfigurationProto_Aegis_SupportInformationVerbosityLevel) String() string {
	return proto.EnumName(ConfigurationProto_Aegis_SupportInformationVerbosityLevel_name, int32(x))
}

func (x *ConfigurationProto_Aegis_SupportInformationVerbosityLevel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Aegis_SupportInformationVerbosityLevel_value, data, "ConfigurationProto_Aegis_SupportInformationVerbosityLevel")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Aegis_SupportInformationVerbosityLevel(value)
	return nil
}

func (ConfigurationProto_Aegis_SupportInformationVerbosityLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 1}
}

// Level of applying PII(Personal Identification Information) scrubbing
// on pulse data.
type ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel int32

const (
	// When set to None, collectors will perform PII scrubbing on complete
	// pulse data. No identification releated data like entity names,
	// Email addresses and IPV4 addresses will be collected through Pulse.
	ConfigurationProto_Aegis_AutoSupportConfig_kAll ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel = 0
	// When set to Partial, collectors will perform PII scrubbing on partial
	// pulse data. For example, PII is applies only for Email addresses and
	// IPV4 addresses, but not to entity names.
	ConfigurationProto_Aegis_AutoSupportConfig_kPartial ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel = 1
	// When set to All, no PII scrubbing is performed on complete pulse data.
	// For example, all entity names, email addresses and IPV4 addresses
	// will be left as it is in the data collected.
	ConfigurationProto_Aegis_AutoSupportConfig_kNone ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel = 2
	// Anytime user enables pulse either from ui or from ncli,
	// we default the PII setting to Auto unless it is specified exclusively.
	// kAuto is equivalent to kPartial, but shows a new UI for Pulse Settings on Prism
	ConfigurationProto_Aegis_AutoSupportConfig_kAuto ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel = 3
)

var ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel_name = map[int32]string{
	0: "kAll",
	1: "kPartial",
	2: "kNone",
	3: "kAuto",
}

var ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel_value = map[string]int32{
	"kAll":     0,
	"kPartial": 1,
	"kNone":    2,
	"kAuto":    3,
}

func (x ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel) Enum() *ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel {
	p := new(ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel)
	*p = x
	return p
}

func (x ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel) String() string {
	return proto.EnumName(ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel_name, int32(x))
}

func (x *ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel_value, data, "ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel(value)
	return nil
}

func (ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 2, 0}
}

type ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType int32

const (
	// An Ipv4 address.
	ConfigurationProto_Aegis_HttpProxyWhitelist_kIpv4Address ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType = 1
	// We support network mask of format nnn.nnn.nnn.nnn/aaa.aaa.aaa.aaa
	// but not cidr notation.
	ConfigurationProto_Aegis_HttpProxyWhitelist_kIpv4NetworkMask ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType = 2
	// Domain name suffix should always start with '*.'
	ConfigurationProto_Aegis_HttpProxyWhitelist_kDomainNameSuffix ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType = 3
	// This should be a fully qualified domain name or a host name.
	ConfigurationProto_Aegis_HttpProxyWhitelist_kHostName ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType = 4
	// An Ipv6 address.
	ConfigurationProto_Aegis_HttpProxyWhitelist_kIpv6Address ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType = 5
)

var ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType_name = map[int32]string{
	1: "kIpv4Address",
	2: "kIpv4NetworkMask",
	3: "kDomainNameSuffix",
	4: "kHostName",
	5: "kIpv6Address",
}

var ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType_value = map[string]int32{
	"kIpv4Address":      1,
	"kIpv4NetworkMask":  2,
	"kDomainNameSuffix": 3,
	"kHostName":         4,
	"kIpv6Address":      5,
}

func (x ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType) Enum() *ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType {
	p := new(ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType)
	*p = x
	return p
}

func (x ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType) String() string {
	return proto.EnumName(ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType_name, int32(x))
}

func (x *ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType_value, data, "ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType(value)
	return nil
}

func (ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 3, 0}
}

// Nutanix model family of the rackable unit.
type ConfigurationProto_RackableUnit_Model int32

const (
	// Desktop cluster.
	ConfigurationProto_RackableUnit_kDesktop ConfigurationProto_RackableUnit_Model = 1
	// 2000 series. This includes NX-2x00 and NX-2x50.
	ConfigurationProto_RackableUnit_kNX2000 ConfigurationProto_RackableUnit_Model = 2
	// NX-3000 series has two variants, Quanta and SuperMicro
	// NX-3x00 (Quanta).
	ConfigurationProto_RackableUnit_kNX3000 ConfigurationProto_RackableUnit_Model = 3
	// NX-3x50 (SuperMicro).
	ConfigurationProto_RackableUnit_kNX3050 ConfigurationProto_RackableUnit_Model = 4
	// NX-6x5x (Storage heavy base).
	ConfigurationProto_RackableUnit_kNX6050 ConfigurationProto_RackableUnit_Model = 5
	// NX-6x7x (Storage heavy + faster CPU).
	ConfigurationProto_RackableUnit_kNX6070 ConfigurationProto_RackableUnit_Model = 6
	// Baby bear.
	ConfigurationProto_RackableUnit_kNX1050 ConfigurationProto_RackableUnit_Model = 7
	// NX-3x6x (3x50 Ivy Bridge).
	ConfigurationProto_RackableUnit_kNX3060 ConfigurationProto_RackableUnit_Model = 8
	// NX-6x6x (6x5x Ivy Bridge).
	ConfigurationProto_RackableUnit_kNX6060 ConfigurationProto_RackableUnit_Model = 9
	// NX-6x8x (6x7x Ivy Bridge).
	ConfigurationProto_RackableUnit_kNX6080 ConfigurationProto_RackableUnit_Model = 10
	// NX-6x2x (Ivy Bridge Storage heavy + low compute).
	ConfigurationProto_RackableUnit_kNX6020 ConfigurationProto_RackableUnit_Model = 11
	// NX-711x (GPU node).
	ConfigurationProto_RackableUnit_kNX7110 ConfigurationProto_RackableUnit_Model = 12
	// NX-1x2x (Jaguar).
	ConfigurationProto_RackableUnit_kNX1020 ConfigurationProto_RackableUnit_Model = 13
	// NX-9x4x (All flash).
	ConfigurationProto_RackableUnit_kNX9040 ConfigurationProto_RackableUnit_Model = 14
	// Use hardware config for model information. Model is picked up from the
	// rackable_unit_model_name field.
	ConfigurationProto_RackableUnit_kUseLayout ConfigurationProto_RackableUnit_Model = 100
	// Null hypervisor mode, where the model cannot be determined.
	ConfigurationProto_RackableUnit_kNull ConfigurationProto_RackableUnit_Model = 9999
)

var ConfigurationProto_RackableUnit_Model_name = map[int32]string{
	1:    "kDesktop",
	2:    "kNX2000",
	3:    "kNX3000",
	4:    "kNX3050",
	5:    "kNX6050",
	6:    "kNX6070",
	7:    "kNX1050",
	8:    "kNX3060",
	9:    "kNX6060",
	10:   "kNX6080",
	11:   "kNX6020",
	12:   "kNX7110",
	13:   "kNX1020",
	14:   "kNX9040",
	100:  "kUseLayout",
	9999: "kNull",
}

var ConfigurationProto_RackableUnit_Model_value = map[string]int32{
	"kDesktop":   1,
	"kNX2000":    2,
	"kNX3000":    3,
	"kNX3050":    4,
	"kNX6050":    5,
	"kNX6070":    6,
	"kNX1050":    7,
	"kNX3060":    8,
	"kNX6060":    9,
	"kNX6080":    10,
	"kNX6020":    11,
	"kNX7110":    12,
	"kNX1020":    13,
	"kNX9040":    14,
	"kUseLayout": 100,
	"kNull":      9999,
}

func (x ConfigurationProto_RackableUnit_Model) Enum() *ConfigurationProto_RackableUnit_Model {
	p := new(ConfigurationProto_RackableUnit_Model)
	*p = x
	return p
}

func (x ConfigurationProto_RackableUnit_Model) String() string {
	return proto.EnumName(ConfigurationProto_RackableUnit_Model_name, int32(x))
}

func (x *ConfigurationProto_RackableUnit_Model) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RackableUnit_Model_value, data, "ConfigurationProto_RackableUnit_Model")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RackableUnit_Model(value)
	return nil
}

func (ConfigurationProto_RackableUnit_Model) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 13, 0}
}

// Protocols supported for snmp transport.
type ConfigurationProto_SnmpInfo_Protocol int32

const (
	// UDP.
	ConfigurationProto_SnmpInfo_kUDP ConfigurationProto_SnmpInfo_Protocol = 1
	// UDP over IPv6.
	ConfigurationProto_SnmpInfo_kUDP6 ConfigurationProto_SnmpInfo_Protocol = 2
	// TCP.
	ConfigurationProto_SnmpInfo_kTCP ConfigurationProto_SnmpInfo_Protocol = 3
	// TCP over IPv6.
	ConfigurationProto_SnmpInfo_kTCP6 ConfigurationProto_SnmpInfo_Protocol = 4
)

var ConfigurationProto_SnmpInfo_Protocol_name = map[int32]string{
	1: "kUDP",
	2: "kUDP6",
	3: "kTCP",
	4: "kTCP6",
}

var ConfigurationProto_SnmpInfo_Protocol_value = map[string]int32{
	"kUDP":  1,
	"kUDP6": 2,
	"kTCP":  3,
	"kTCP6": 4,
}

func (x ConfigurationProto_SnmpInfo_Protocol) Enum() *ConfigurationProto_SnmpInfo_Protocol {
	p := new(ConfigurationProto_SnmpInfo_Protocol)
	*p = x
	return p
}

func (x ConfigurationProto_SnmpInfo_Protocol) String() string {
	return proto.EnumName(ConfigurationProto_SnmpInfo_Protocol_name, int32(x))
}

func (x *ConfigurationProto_SnmpInfo_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_SnmpInfo_Protocol_value, data, "ConfigurationProto_SnmpInfo_Protocol")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_SnmpInfo_Protocol(value)
	return nil
}

func (ConfigurationProto_SnmpInfo_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 0}
}

// SNMP versions.
type ConfigurationProto_SnmpInfo_SnmpVersion int32

const (
	// Snmp version 2.
	ConfigurationProto_SnmpInfo_kV2 ConfigurationProto_SnmpInfo_SnmpVersion = 1
	// Snmp verison 3.
	ConfigurationProto_SnmpInfo_kV3 ConfigurationProto_SnmpInfo_SnmpVersion = 2
)

var ConfigurationProto_SnmpInfo_SnmpVersion_name = map[int32]string{
	1: "kV2",
	2: "kV3",
}

var ConfigurationProto_SnmpInfo_SnmpVersion_value = map[string]int32{
	"kV2": 1,
	"kV3": 2,
}

func (x ConfigurationProto_SnmpInfo_SnmpVersion) Enum() *ConfigurationProto_SnmpInfo_SnmpVersion {
	p := new(ConfigurationProto_SnmpInfo_SnmpVersion)
	*p = x
	return p
}

func (x ConfigurationProto_SnmpInfo_SnmpVersion) String() string {
	return proto.EnumName(ConfigurationProto_SnmpInfo_SnmpVersion_name, int32(x))
}

func (x *ConfigurationProto_SnmpInfo_SnmpVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_SnmpInfo_SnmpVersion_value, data, "ConfigurationProto_SnmpInfo_SnmpVersion")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_SnmpInfo_SnmpVersion(value)
	return nil
}

func (ConfigurationProto_SnmpInfo_SnmpVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 1}
}

// Authentication type for the user.
type ConfigurationProto_SnmpInfo_User_AuthType int32

const (
	// MD5 authentication.
	ConfigurationProto_SnmpInfo_User_kMD5 ConfigurationProto_SnmpInfo_User_AuthType = 1
	// SHA authentication.
	ConfigurationProto_SnmpInfo_User_kSHA ConfigurationProto_SnmpInfo_User_AuthType = 2
)

var ConfigurationProto_SnmpInfo_User_AuthType_name = map[int32]string{
	1: "kMD5",
	2: "kSHA",
}

var ConfigurationProto_SnmpInfo_User_AuthType_value = map[string]int32{
	"kMD5": 1,
	"kSHA": 2,
}

func (x ConfigurationProto_SnmpInfo_User_AuthType) Enum() *ConfigurationProto_SnmpInfo_User_AuthType {
	p := new(ConfigurationProto_SnmpInfo_User_AuthType)
	*p = x
	return p
}

func (x ConfigurationProto_SnmpInfo_User_AuthType) String() string {
	return proto.EnumName(ConfigurationProto_SnmpInfo_User_AuthType_name, int32(x))
}

func (x *ConfigurationProto_SnmpInfo_User_AuthType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_SnmpInfo_User_AuthType_value, data, "ConfigurationProto_SnmpInfo_User_AuthType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_SnmpInfo_User_AuthType(value)
	return nil
}

func (ConfigurationProto_SnmpInfo_User_AuthType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 0, 0}
}

// Encryption type to be used.
type ConfigurationProto_SnmpInfo_User_PrivType int32

const (
	// DES encrytption.
	ConfigurationProto_SnmpInfo_User_kDES ConfigurationProto_SnmpInfo_User_PrivType = 1
	// AES encryption.
	ConfigurationProto_SnmpInfo_User_kAES ConfigurationProto_SnmpInfo_User_PrivType = 2
)

var ConfigurationProto_SnmpInfo_User_PrivType_name = map[int32]string{
	1: "kDES",
	2: "kAES",
}

var ConfigurationProto_SnmpInfo_User_PrivType_value = map[string]int32{
	"kDES": 1,
	"kAES": 2,
}

func (x ConfigurationProto_SnmpInfo_User_PrivType) Enum() *ConfigurationProto_SnmpInfo_User_PrivType {
	p := new(ConfigurationProto_SnmpInfo_User_PrivType)
	*p = x
	return p
}

func (x ConfigurationProto_SnmpInfo_User_PrivType) String() string {
	return proto.EnumName(ConfigurationProto_SnmpInfo_User_PrivType_name, int32(x))
}

func (x *ConfigurationProto_SnmpInfo_User_PrivType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_SnmpInfo_User_PrivType_value, data, "ConfigurationProto_SnmpInfo_User_PrivType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_SnmpInfo_User_PrivType(value)
	return nil
}

func (ConfigurationProto_SnmpInfo_User_PrivType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 0, 1}
}

// Type of authentication used.
type ConfigurationProto_AuthConfig_AuthSourceType int32

const (
	ConfigurationProto_AuthConfig_kLOCAL             ConfigurationProto_AuthConfig_AuthSourceType = 0
	ConfigurationProto_AuthConfig_kDIRECTORY_SERVICE ConfigurationProto_AuthConfig_AuthSourceType = 1
)

var ConfigurationProto_AuthConfig_AuthSourceType_name = map[int32]string{
	0: "kLOCAL",
	1: "kDIRECTORY_SERVICE",
}

var ConfigurationProto_AuthConfig_AuthSourceType_value = map[string]int32{
	"kLOCAL":             0,
	"kDIRECTORY_SERVICE": 1,
}

func (x ConfigurationProto_AuthConfig_AuthSourceType) Enum() *ConfigurationProto_AuthConfig_AuthSourceType {
	p := new(ConfigurationProto_AuthConfig_AuthSourceType)
	*p = x
	return p
}

func (x ConfigurationProto_AuthConfig_AuthSourceType) String() string {
	return proto.EnumName(ConfigurationProto_AuthConfig_AuthSourceType_name, int32(x))
}

func (x *ConfigurationProto_AuthConfig_AuthSourceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AuthConfig_AuthSourceType_value, data, "ConfigurationProto_AuthConfig_AuthSourceType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AuthConfig_AuthSourceType(value)
	return nil
}

func (ConfigurationProto_AuthConfig_AuthSourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0}
}

// Type of directory service.
type ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType int32

const (
	ConfigurationProto_AuthConfig_DirectoryConfig_kACTIVE_DIRECTORY ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType = 0
	ConfigurationProto_AuthConfig_DirectoryConfig_kOPEN_LDAP        ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType = 1
)

var ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType_name = map[int32]string{
	0: "kACTIVE_DIRECTORY",
	1: "kOPEN_LDAP",
}

var ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType_value = map[string]int32{
	"kACTIVE_DIRECTORY": 0,
	"kOPEN_LDAP":        1,
}

func (x ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType) Enum() *ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType {
	p := new(ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType)
	*p = x
	return p
}

func (x ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType) String() string {
	return proto.EnumName(ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType_name, int32(x))
}

func (x *ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType_value, data, "ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType(value)
	return nil
}

func (ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0, 0}
}

// Type of connection used to connect to the directory service.
type ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType int32

const (
	ConfigurationProto_AuthConfig_DirectoryConfig_kLDAP     ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType = 0
	ConfigurationProto_AuthConfig_DirectoryConfig_kKERBEROS ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType = 1
)

var ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType_name = map[int32]string{
	0: "kLDAP",
	1: "kKERBEROS",
}

var ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType_value = map[string]int32{
	"kLDAP":     0,
	"kKERBEROS": 1,
}

func (x ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType) Enum() *ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType {
	p := new(ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType)
	*p = x
	return p
}

func (x ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType) String() string {
	return proto.EnumName(ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType_name, int32(x))
}

func (x *ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType_value, data, "ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType(value)
	return nil
}

func (ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0, 1}
}

// Type of search to perform for group lookups.
type ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType int32

const (
	ConfigurationProto_AuthConfig_DirectoryConfig_kRECURSIVE     ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType = 0
	ConfigurationProto_AuthConfig_DirectoryConfig_kNON_RECURSIVE ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType = 1
)

var ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType_name = map[int32]string{
	0: "kRECURSIVE",
	1: "kNON_RECURSIVE",
}

var ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType_value = map[string]int32{
	"kRECURSIVE":     0,
	"kNON_RECURSIVE": 1,
}

func (x ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType) Enum() *ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType {
	p := new(ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType)
	*p = x
	return p
}

func (x ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType) String() string {
	return proto.EnumName(ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType_name, int32(x))
}

func (x *ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType_value, data, "ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType(value)
	return nil
}

func (ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0, 2}
}

// Types of ssh keys possible are:
// 1) node key - key generated by node.
// 2) external key - any key which is not generated by node.
// 3) remote tunnel key - keys generated by node for external access.
type ConfigurationProto_SSHKey_SshKeyType int32

const (
	ConfigurationProto_SSHKey_kNodeKey         ConfigurationProto_SSHKey_SshKeyType = 1
	ConfigurationProto_SSHKey_kExternalKey     ConfigurationProto_SSHKey_SshKeyType = 2
	ConfigurationProto_SSHKey_kRemoteTunnelKey ConfigurationProto_SSHKey_SshKeyType = 3
)

var ConfigurationProto_SSHKey_SshKeyType_name = map[int32]string{
	1: "kNodeKey",
	2: "kExternalKey",
	3: "kRemoteTunnelKey",
}

var ConfigurationProto_SSHKey_SshKeyType_value = map[string]int32{
	"kNodeKey":         1,
	"kExternalKey":     2,
	"kRemoteTunnelKey": 3,
}

func (x ConfigurationProto_SSHKey_SshKeyType) Enum() *ConfigurationProto_SSHKey_SshKeyType {
	p := new(ConfigurationProto_SSHKey_SshKeyType)
	*p = x
	return p
}

func (x ConfigurationProto_SSHKey_SshKeyType) String() string {
	return proto.EnumName(ConfigurationProto_SSHKey_SshKeyType_name, int32(x))
}

func (x *ConfigurationProto_SSHKey_SshKeyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_SSHKey_SshKeyType_value, data, "ConfigurationProto_SSHKey_SshKeyType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_SSHKey_SshKeyType(value)
	return nil
}

func (ConfigurationProto_SSHKey_SshKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 20, 0}
}

// The following tracks the readiness of each component while the cluster
// is preparing itself to handle the desired max fault tolerance and is
// set only when
// 'current_max_fault_tolerance' != 'desired_max_fault_tolerance'.
// This is a bitmap whose relevant portions are set to 1 when the
// corresponding component is prepared to handle the desired fault
// tolerance.
//
// The component that last updates this bitmap and finds all bits set
// (using kAllPrepareDone) shall update the 'current_max_fault_tolerance'
// to 'desired_max_fault_tolerance'.
type ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck int32

const (
	ConfigurationProto_FaultToleranceState_kZookeeperPrepareDone ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck = 1
	ConfigurationProto_FaultToleranceState_kCassandraPrepareDone ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck = 16
	// In case we need to add more acknowledgements, maybe from other or
	// future components, we should modify this flag appropriately.
	ConfigurationProto_FaultToleranceState_kAllPrepareDone ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck = 17
)

var ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck_name = map[int32]string{
	1:  "kZookeeperPrepareDone",
	16: "kCassandraPrepareDone",
	17: "kAllPrepareDone",
}

var ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck_value = map[string]int32{
	"kZookeeperPrepareDone": 1,
	"kCassandraPrepareDone": 16,
	"kAllPrepareDone":       17,
}

func (x ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck) Enum() *ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck {
	p := new(ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck)
	*p = x
	return p
}

func (x ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck) String() string {
	return proto.EnumName(ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck_name, int32(x))
}

func (x *ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck_value, data, "ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck(value)
	return nil
}

func (ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 21, 0}
}

// Priority of messages to be sent to remote syslog server. Debug is
// lowest priority and emergency is highest priority.
type ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority int32

const (
	// Debug priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kDebug ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 0
	// Info priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kInfo ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 1
	// Notice priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kNotice ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 2
	// Warning priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kWarning ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 3
	// Error priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kError ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 4
	// Critical priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kCritical ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 5
	// Alert priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kAlert ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 6
	// Emergency priority
	ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kEmergency ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority = 7
)

var ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority_name = map[int32]string{
	0: "kDebug",
	1: "kInfo",
	2: "kNotice",
	3: "kWarning",
	4: "kError",
	5: "kCritical",
	6: "kAlert",
	7: "kEmergency",
}

var ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority_value = map[string]int32{
	"kDebug":     0,
	"kInfo":      1,
	"kNotice":    2,
	"kWarning":   3,
	"kError":     4,
	"kCritical":  5,
	"kAlert":     6,
	"kEmergency": 7,
}

func (x ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority) Enum() *ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority {
	p := new(ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority)
	*p = x
	return p
}

func (x ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority) String() string {
	return proto.EnumName(ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority_name, int32(x))
}

func (x *ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority_value, data, "ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority(value)
	return nil
}

func (ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 22, 0, 0, 0}
}

// 'ring_fixer_source' will denote the owner of ring fix operation.
type ConfigurationProto_AutoRingFixState_RingFixerSource int32

const (
	// Skew fixer.
	ConfigurationProto_AutoRingFixState_kSkewFixer ConfigurationProto_AutoRingFixState_RingFixerSource = 0
	// Domain aware fixer.
	ConfigurationProto_AutoRingFixState_kDomainAwarenessFixer ConfigurationProto_AutoRingFixState_RingFixerSource = 1
)

var ConfigurationProto_AutoRingFixState_RingFixerSource_name = map[int32]string{
	0: "kSkewFixer",
	1: "kDomainAwarenessFixer",
}

var ConfigurationProto_AutoRingFixState_RingFixerSource_value = map[string]int32{
	"kSkewFixer":            0,
	"kDomainAwarenessFixer": 1,
}

func (x ConfigurationProto_AutoRingFixState_RingFixerSource) Enum() *ConfigurationProto_AutoRingFixState_RingFixerSource {
	p := new(ConfigurationProto_AutoRingFixState_RingFixerSource)
	*p = x
	return p
}

func (x ConfigurationProto_AutoRingFixState_RingFixerSource) String() string {
	return proto.EnumName(ConfigurationProto_AutoRingFixState_RingFixerSource_name, int32(x))
}

func (x *ConfigurationProto_AutoRingFixState_RingFixerSource) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AutoRingFixState_RingFixerSource_value, data, "ConfigurationProto_AutoRingFixState_RingFixerSource")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AutoRingFixState_RingFixerSource(value)
	return nil
}

func (ConfigurationProto_AutoRingFixState_RingFixerSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 26, 0}
}

// 'operation_state' will be set to these values to indicate the
// current state of the ring fixer operation.
type ConfigurationProto_AutoRingFixState_RingFixerOperationState int32

const (
	// Ring fixer operation has been initialized.
	ConfigurationProto_AutoRingFixState_kRingFixerInitialized ConfigurationProto_AutoRingFixState_RingFixerOperationState = 0
	// Ring fixer operation has been aborted.
	ConfigurationProto_AutoRingFixState_kRingFixerAborted ConfigurationProto_AutoRingFixState_RingFixerOperationState = 1
	// Ring fixer operation is currently running.
	ConfigurationProto_AutoRingFixState_kRingFixerRunning ConfigurationProto_AutoRingFixState_RingFixerOperationState = 2
	// All detach add node operations listed in 'svm_and_token' are
	// completed.
	ConfigurationProto_AutoRingFixState_kDetachAddNodeCompleted ConfigurationProto_AutoRingFixState_RingFixerOperationState = 3
)

var ConfigurationProto_AutoRingFixState_RingFixerOperationState_name = map[int32]string{
	0: "kRingFixerInitialized",
	1: "kRingFixerAborted",
	2: "kRingFixerRunning",
	3: "kDetachAddNodeCompleted",
}

var ConfigurationProto_AutoRingFixState_RingFixerOperationState_value = map[string]int32{
	"kRingFixerInitialized":   0,
	"kRingFixerAborted":       1,
	"kRingFixerRunning":       2,
	"kDetachAddNodeCompleted": 3,
}

func (x ConfigurationProto_AutoRingFixState_RingFixerOperationState) Enum() *ConfigurationProto_AutoRingFixState_RingFixerOperationState {
	p := new(ConfigurationProto_AutoRingFixState_RingFixerOperationState)
	*p = x
	return p
}

func (x ConfigurationProto_AutoRingFixState_RingFixerOperationState) String() string {
	return proto.EnumName(ConfigurationProto_AutoRingFixState_RingFixerOperationState_name, int32(x))
}

func (x *ConfigurationProto_AutoRingFixState_RingFixerOperationState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AutoRingFixState_RingFixerOperationState_value, data, "ConfigurationProto_AutoRingFixState_RingFixerOperationState")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AutoRingFixState_RingFixerOperationState(value)
	return nil
}

func (ConfigurationProto_AutoRingFixState_RingFixerOperationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 26, 1}
}

type ConfigurationProto_AcropolisHAConfig_AcropolisHAState int32

const (
	ConfigurationProto_AcropolisHAConfig_kAcropolisHAHighlyAvailable ConfigurationProto_AcropolisHAConfig_AcropolisHAState = 1
	// kAcropolisHAInFailover = 2; // Deprecated.
	ConfigurationProto_AcropolisHAConfig_kAcropolisHAHealing    ConfigurationProto_AcropolisHAConfig_AcropolisHAState = 3
	ConfigurationProto_AcropolisHAConfig_kAcropolisHABestEffort ConfigurationProto_AcropolisHAConfig_AcropolisHAState = 4
	ConfigurationProto_AcropolisHAConfig_kAcropolisHADisabled   ConfigurationProto_AcropolisHAConfig_AcropolisHAState = 5
)

var ConfigurationProto_AcropolisHAConfig_AcropolisHAState_name = map[int32]string{
	1: "kAcropolisHAHighlyAvailable",
	3: "kAcropolisHAHealing",
	4: "kAcropolisHABestEffort",
	5: "kAcropolisHADisabled",
}

var ConfigurationProto_AcropolisHAConfig_AcropolisHAState_value = map[string]int32{
	"kAcropolisHAHighlyAvailable": 1,
	"kAcropolisHAHealing":         3,
	"kAcropolisHABestEffort":      4,
	"kAcropolisHADisabled":        5,
}

func (x ConfigurationProto_AcropolisHAConfig_AcropolisHAState) Enum() *ConfigurationProto_AcropolisHAConfig_AcropolisHAState {
	p := new(ConfigurationProto_AcropolisHAConfig_AcropolisHAState)
	*p = x
	return p
}

func (x ConfigurationProto_AcropolisHAConfig_AcropolisHAState) String() string {
	return proto.EnumName(ConfigurationProto_AcropolisHAConfig_AcropolisHAState_name, int32(x))
}

func (x *ConfigurationProto_AcropolisHAConfig_AcropolisHAState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AcropolisHAConfig_AcropolisHAState_value, data, "ConfigurationProto_AcropolisHAConfig_AcropolisHAState")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AcropolisHAConfig_AcropolisHAState(value)
	return nil
}

func (ConfigurationProto_AcropolisHAConfig_AcropolisHAState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 29, 0}
}

type ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType int32

const (
	// Reserve entire hosts for HA failover.
	ConfigurationProto_AcropolisHAConfig_kAcropolisHAReserveHosts ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType = 1
	// Reserve segments distributed on hosts throughout the cluster for
	// HA failover.
	ConfigurationProto_AcropolisHAConfig_kAcropolisHAReserveSegments ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType = 2
	// Best effort.
	ConfigurationProto_AcropolisHAConfig_kAcropolisHANoReservations ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType = 3
)

var ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType_name = map[int32]string{
	1: "kAcropolisHAReserveHosts",
	2: "kAcropolisHAReserveSegments",
	3: "kAcropolisHANoReservations",
}

var ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType_value = map[string]int32{
	"kAcropolisHAReserveHosts":    1,
	"kAcropolisHAReserveSegments": 2,
	"kAcropolisHANoReservations":  3,
}

func (x ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType) Enum() *ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType {
	p := new(ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType)
	*p = x
	return p
}

func (x ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType) String() string {
	return proto.EnumName(ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType_name, int32(x))
}

func (x *ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType_value, data, "ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType(value)
	return nil
}

func (ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 29, 1}
}

// Endianess of SCSI PR key in medusa. Before 5.9, the PR keys were stored
// in big endian format in medusa. In 5.9, this was changes to store and
// interpret PR keys in little endian format. This caused upgrades to
// 5.9/5.9.1 to break since big endian keys stored prior to 5.9 were now
// interpreted as little endian. Thus all new keys stored in 5.9/5.9.1 are
// in little endian. To prevent the clusters in 5.9/5.9.1 to break again
// during a future upgrade, the SCSI PR keys in these clusters are kept in
// little endian format forever. For the clusters that never went through a
// 5.9/5.9.1 upgrade, the SCSI PR keys are stored in big endian.
type ConfigurationProto_IscsiConfig_ScsiPREndianState int32

const (
	ConfigurationProto_IscsiConfig_kUnknownEndian ConfigurationProto_IscsiConfig_ScsiPREndianState = 0
	ConfigurationProto_IscsiConfig_kBigEndian     ConfigurationProto_IscsiConfig_ScsiPREndianState = 1
	ConfigurationProto_IscsiConfig_kLittleEndian  ConfigurationProto_IscsiConfig_ScsiPREndianState = 2
)

var ConfigurationProto_IscsiConfig_ScsiPREndianState_name = map[int32]string{
	0: "kUnknownEndian",
	1: "kBigEndian",
	2: "kLittleEndian",
}

var ConfigurationProto_IscsiConfig_ScsiPREndianState_value = map[string]int32{
	"kUnknownEndian": 0,
	"kBigEndian":     1,
	"kLittleEndian":  2,
}

func (x ConfigurationProto_IscsiConfig_ScsiPREndianState) Enum() *ConfigurationProto_IscsiConfig_ScsiPREndianState {
	p := new(ConfigurationProto_IscsiConfig_ScsiPREndianState)
	*p = x
	return p
}

func (x ConfigurationProto_IscsiConfig_ScsiPREndianState) String() string {
	return proto.EnumName(ConfigurationProto_IscsiConfig_ScsiPREndianState_name, int32(x))
}

func (x *ConfigurationProto_IscsiConfig_ScsiPREndianState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_IscsiConfig_ScsiPREndianState_value, data, "ConfigurationProto_IscsiConfig_ScsiPREndianState")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_IscsiConfig_ScsiPREndianState(value)
	return nil
}

func (ConfigurationProto_IscsiConfig_ScsiPREndianState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 34, 0}
}

// Enumeration describing the state of the LWS store.
type ConfigurationProto_LWSStoreConfig_State int32

const (
	// No LWS store exists.
	ConfigurationProto_LWSStoreConfig_kAbsent ConfigurationProto_LWSStoreConfig_State = 0
	// LWS store is being prepared.
	ConfigurationProto_LWSStoreConfig_kPreparing ConfigurationProto_LWSStoreConfig_State = 1
	// LWS store has been prepared.
	ConfigurationProto_LWSStoreConfig_kPrepared ConfigurationProto_LWSStoreConfig_State = 2
	// LWS store in failed state.
	ConfigurationProto_LWSStoreConfig_kFailed ConfigurationProto_LWSStoreConfig_State = 3
)

var ConfigurationProto_LWSStoreConfig_State_name = map[int32]string{
	0: "kAbsent",
	1: "kPreparing",
	2: "kPrepared",
	3: "kFailed",
}

var ConfigurationProto_LWSStoreConfig_State_value = map[string]int32{
	"kAbsent":    0,
	"kPreparing": 1,
	"kPrepared":  2,
	"kFailed":    3,
}

func (x ConfigurationProto_LWSStoreConfig_State) Enum() *ConfigurationProto_LWSStoreConfig_State {
	p := new(ConfigurationProto_LWSStoreConfig_State)
	*p = x
	return p
}

func (x ConfigurationProto_LWSStoreConfig_State) String() string {
	return proto.EnumName(ConfigurationProto_LWSStoreConfig_State_name, int32(x))
}

func (x *ConfigurationProto_LWSStoreConfig_State) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_LWSStoreConfig_State_value, data, "ConfigurationProto_LWSStoreConfig_State")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_LWSStoreConfig_State(value)
	return nil
}

func (ConfigurationProto_LWSStoreConfig_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 37, 0}
}

// The following is used only when the cluster operation mode changes.
// This is a bitmap whose relevant bits are set when the corresponding
// components have acknowledged that they have performed the changes
// necessary to support the new mode.
type ConfigurationProto_WitnessState_ClusterTransitionStatus int32

const (
	ConfigurationProto_WitnessState_kClusterTransitionNotStarted ConfigurationProto_WitnessState_ClusterTransitionStatus = 0
	// Indicates that curator has completed transition.
	ConfigurationProto_WitnessState_kCuratorTransitionDone ConfigurationProto_WitnessState_ClusterTransitionStatus = 1
	// Indicates that Cassandra has completed transition.
	ConfigurationProto_WitnessState_kCassandraTransitionDone ConfigurationProto_WitnessState_ClusterTransitionStatus = 16
	// Indicates that all components have completed transition.
	ConfigurationProto_WitnessState_kTransitionComplete ConfigurationProto_WitnessState_ClusterTransitionStatus = 256
)

var ConfigurationProto_WitnessState_ClusterTransitionStatus_name = map[int32]string{
	0:   "kClusterTransitionNotStarted",
	1:   "kCuratorTransitionDone",
	16:  "kCassandraTransitionDone",
	256: "kTransitionComplete",
}

var ConfigurationProto_WitnessState_ClusterTransitionStatus_value = map[string]int32{
	"kClusterTransitionNotStarted": 0,
	"kCuratorTransitionDone":       1,
	"kCassandraTransitionDone":     16,
	"kTransitionComplete":          256,
}

func (x ConfigurationProto_WitnessState_ClusterTransitionStatus) Enum() *ConfigurationProto_WitnessState_ClusterTransitionStatus {
	p := new(ConfigurationProto_WitnessState_ClusterTransitionStatus)
	*p = x
	return p
}

func (x ConfigurationProto_WitnessState_ClusterTransitionStatus) String() string {
	return proto.EnumName(ConfigurationProto_WitnessState_ClusterTransitionStatus_name, int32(x))
}

func (x *ConfigurationProto_WitnessState_ClusterTransitionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_WitnessState_ClusterTransitionStatus_value, data, "ConfigurationProto_WitnessState_ClusterTransitionStatus")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_WitnessState_ClusterTransitionStatus(value)
	return nil
}

func (ConfigurationProto_WitnessState_ClusterTransitionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 38, 0}
}

type ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason int32

const (
	// Denotes that this transition was invoked by manual intervention.
	ConfigurationProto_WitnessState_WitnessStateHistory_kManual ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 1
	// Denotes that the cluster changed state due to node failures.
	ConfigurationProto_WitnessState_WitnessStateHistory_kAuto ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 2
	// Denotes that this transition was invoked due to cluster upgrade.
	ConfigurationProto_WitnessState_WitnessStateHistory_kUpgrade ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 3
	// Denotes that this transition was invoked due to planned node
	// removal.
	ConfigurationProto_WitnessState_WitnessStateHistory_kNodeRemoval ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 4
	// Denotes that this transition was invoked due to stargate/HA
	// forwarding.
	ConfigurationProto_WitnessState_WitnessStateHistory_kStargate ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 5
	// Denotes that this transition was invoked due to cassandra going into
	// kForwarding state on one of the nodes.
	ConfigurationProto_WitnessState_WitnessStateHistory_kCassandra ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 6
	// Denotes that this transition was invoked due to host upgrade.
	ConfigurationProto_WitnessState_WitnessStateHistory_kHostUpgrade ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 7
	// Denotes that this transition was invoked due to firmware upgrade.
	ConfigurationProto_WitnessState_WitnessStateHistory_kFirmwareUpgrade ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 8
	// Denotes that this transition was invoked due to some other planned
	// outage.
	ConfigurationProto_WitnessState_WitnessStateHistory_kOtherPlannedOutage ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 9
	// Denotes that this transition was invoked due to logical timestamp
	// sync up between witness vm and cluster.
	ConfigurationProto_WitnessState_WitnessStateHistory_kWitnessSyncOp ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason = 10
)

var ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason_name = map[int32]string{
	1:  "kManual",
	2:  "kAuto",
	3:  "kUpgrade",
	4:  "kNodeRemoval",
	5:  "kStargate",
	6:  "kCassandra",
	7:  "kHostUpgrade",
	8:  "kFirmwareUpgrade",
	9:  "kOtherPlannedOutage",
	10: "kWitnessSyncOp",
}

var ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason_value = map[string]int32{
	"kManual":             1,
	"kAuto":               2,
	"kUpgrade":            3,
	"kNodeRemoval":        4,
	"kStargate":           5,
	"kCassandra":          6,
	"kHostUpgrade":        7,
	"kFirmwareUpgrade":    8,
	"kOtherPlannedOutage": 9,
	"kWitnessSyncOp":      10,
}

func (x ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason) Enum() *ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason {
	p := new(ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason)
	*p = x
	return p
}

func (x ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason) String() string {
	return proto.EnumName(ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason_name, int32(x))
}

func (x *ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason_value, data, "ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason(value)
	return nil
}

func (ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 38, 0, 0}
}

type ConfigurationProto_ExternalRepository_Protocol int32

const (
	ConfigurationProto_ExternalRepository_kNfs ConfigurationProto_ExternalRepository_Protocol = 0
)

var ConfigurationProto_ExternalRepository_Protocol_name = map[int32]string{
	0: "kNfs",
}

var ConfigurationProto_ExternalRepository_Protocol_value = map[string]int32{
	"kNfs": 0,
}

func (x ConfigurationProto_ExternalRepository_Protocol) Enum() *ConfigurationProto_ExternalRepository_Protocol {
	p := new(ConfigurationProto_ExternalRepository_Protocol)
	*p = x
	return p
}

func (x ConfigurationProto_ExternalRepository_Protocol) String() string {
	return proto.EnumName(ConfigurationProto_ExternalRepository_Protocol_name, int32(x))
}

func (x *ConfigurationProto_ExternalRepository_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ExternalRepository_Protocol_value, data, "ConfigurationProto_ExternalRepository_Protocol")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ExternalRepository_Protocol(value)
	return nil
}

func (ConfigurationProto_ExternalRepository_Protocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 43, 0}
}

type ConfigurationProto_ExternalRepository_NfsExport_AccessMode int32

const (
	// Read-only access.
	ConfigurationProto_ExternalRepository_NfsExport_kReadOnly ConfigurationProto_ExternalRepository_NfsExport_AccessMode = 0
	// Read-write access.
	ConfigurationProto_ExternalRepository_NfsExport_kReadWrite ConfigurationProto_ExternalRepository_NfsExport_AccessMode = 1
)

var ConfigurationProto_ExternalRepository_NfsExport_AccessMode_name = map[int32]string{
	0: "kReadOnly",
	1: "kReadWrite",
}

var ConfigurationProto_ExternalRepository_NfsExport_AccessMode_value = map[string]int32{
	"kReadOnly":  0,
	"kReadWrite": 1,
}

func (x ConfigurationProto_ExternalRepository_NfsExport_AccessMode) Enum() *ConfigurationProto_ExternalRepository_NfsExport_AccessMode {
	p := new(ConfigurationProto_ExternalRepository_NfsExport_AccessMode)
	*p = x
	return p
}

func (x ConfigurationProto_ExternalRepository_NfsExport_AccessMode) String() string {
	return proto.EnumName(ConfigurationProto_ExternalRepository_NfsExport_AccessMode_name, int32(x))
}

func (x *ConfigurationProto_ExternalRepository_NfsExport_AccessMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ExternalRepository_NfsExport_AccessMode_value, data, "ConfigurationProto_ExternalRepository_NfsExport_AccessMode")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ExternalRepository_NfsExport_AccessMode(value)
	return nil
}

func (ConfigurationProto_ExternalRepository_NfsExport_AccessMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 43, 0, 0}
}

// The following enum is used to indicate the cluster hibernate mode.
type ConfigurationProto_ClusterHibernateState_HibernateMode int32

const (
	// Denotes that the cluster is not in a hibernate or restore mode.
	ConfigurationProto_ClusterHibernateState_kNone ConfigurationProto_ClusterHibernateState_HibernateMode = 0
	// Denotes that the cluster has entered into a hibernate mode.
	ConfigurationProto_ClusterHibernateState_kHibernate ConfigurationProto_ClusterHibernateState_HibernateMode = 1
	// Denotes that the cluster has entered into a restore mode.
	ConfigurationProto_ClusterHibernateState_kRestore ConfigurationProto_ClusterHibernateState_HibernateMode = 2
)

var ConfigurationProto_ClusterHibernateState_HibernateMode_name = map[int32]string{
	0: "kNone",
	1: "kHibernate",
	2: "kRestore",
}

var ConfigurationProto_ClusterHibernateState_HibernateMode_value = map[string]int32{
	"kNone":      0,
	"kHibernate": 1,
	"kRestore":   2,
}

func (x ConfigurationProto_ClusterHibernateState_HibernateMode) Enum() *ConfigurationProto_ClusterHibernateState_HibernateMode {
	p := new(ConfigurationProto_ClusterHibernateState_HibernateMode)
	*p = x
	return p
}

func (x ConfigurationProto_ClusterHibernateState_HibernateMode) String() string {
	return proto.EnumName(ConfigurationProto_ClusterHibernateState_HibernateMode_name, int32(x))
}

func (x *ConfigurationProto_ClusterHibernateState_HibernateMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ClusterHibernateState_HibernateMode_value, data, "ConfigurationProto_ClusterHibernateState_HibernateMode")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ClusterHibernateState_HibernateMode(value)
	return nil
}

func (ConfigurationProto_ClusterHibernateState_HibernateMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 46, 0}
}

// The following is used to track the status of the current
// hibernate/restore operation. This is a bitmap whose relevant bits are
// set when the corresponding components have acknowledged that they have
// completed the actions necessary to carry out the hibernate/restore
// operation.
type ConfigurationProto_ClusterHibernateState_HibernateTaskStatus int32

const (
	ConfigurationProto_ClusterHibernateState_kTaskNotStarted ConfigurationProto_ClusterHibernateState_HibernateTaskStatus = 0
	// Indicates that Cassandra has completed the necessary operations.
	ConfigurationProto_ClusterHibernateState_kCassandraTaskDone ConfigurationProto_ClusterHibernateState_HibernateTaskStatus = 1
	// Indicates that Stargate has quiesced all the user IO.
	ConfigurationProto_ClusterHibernateState_kUserIOQuiesced ConfigurationProto_ClusterHibernateState_HibernateTaskStatus = 2
	// Indicates that Curator has verified that there are no outstanding
	// vdisk oplog episodes that need to be drained to extent store.
	ConfigurationProto_ClusterHibernateState_kOplogDataDrained ConfigurationProto_ClusterHibernateState_HibernateTaskStatus = 4
	// Indicates that Curator has verified that all the data from extent
	// store has been addressed.
	ConfigurationProto_ClusterHibernateState_kEstoreDataMigrated ConfigurationProto_ClusterHibernateState_HibernateTaskStatus = 8
	// Indicates that all hibernate specific tasks have completed.
	ConfigurationProto_ClusterHibernateState_kAllTasksCompleted ConfigurationProto_ClusterHibernateState_HibernateTaskStatus = 15
)

var ConfigurationProto_ClusterHibernateState_HibernateTaskStatus_name = map[int32]string{
	0:  "kTaskNotStarted",
	1:  "kCassandraTaskDone",
	2:  "kUserIOQuiesced",
	4:  "kOplogDataDrained",
	8:  "kEstoreDataMigrated",
	15: "kAllTasksCompleted",
}

var ConfigurationProto_ClusterHibernateState_HibernateTaskStatus_value = map[string]int32{
	"kTaskNotStarted":     0,
	"kCassandraTaskDone":  1,
	"kUserIOQuiesced":     2,
	"kOplogDataDrained":   4,
	"kEstoreDataMigrated": 8,
	"kAllTasksCompleted":  15,
}

func (x ConfigurationProto_ClusterHibernateState_HibernateTaskStatus) Enum() *ConfigurationProto_ClusterHibernateState_HibernateTaskStatus {
	p := new(ConfigurationProto_ClusterHibernateState_HibernateTaskStatus)
	*p = x
	return p
}

func (x ConfigurationProto_ClusterHibernateState_HibernateTaskStatus) String() string {
	return proto.EnumName(ConfigurationProto_ClusterHibernateState_HibernateTaskStatus_name, int32(x))
}

func (x *ConfigurationProto_ClusterHibernateState_HibernateTaskStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_ClusterHibernateState_HibernateTaskStatus_value, data, "ConfigurationProto_ClusterHibernateState_HibernateTaskStatus")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_ClusterHibernateState_HibernateTaskStatus(value)
	return nil
}

func (ConfigurationProto_ClusterHibernateState_HibernateTaskStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 46, 1}
}

type ConfigurationProto_RecycleBinState_Status int32

const (
	// Recycle bin has exceeded its space threshold.
	ConfigurationProto_RecycleBinState_kSpaceThresholdExceeded ConfigurationProto_RecycleBinState_Status = 1
)

var ConfigurationProto_RecycleBinState_Status_name = map[int32]string{
	1: "kSpaceThresholdExceeded",
}

var ConfigurationProto_RecycleBinState_Status_value = map[string]int32{
	"kSpaceThresholdExceeded": 1,
}

func (x ConfigurationProto_RecycleBinState_Status) Enum() *ConfigurationProto_RecycleBinState_Status {
	p := new(ConfigurationProto_RecycleBinState_Status)
	*p = x
	return p
}

func (x ConfigurationProto_RecycleBinState_Status) String() string {
	return proto.EnumName(ConfigurationProto_RecycleBinState_Status_name, int32(x))
}

func (x *ConfigurationProto_RecycleBinState_Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigurationProto_RecycleBinState_Status_value, data, "ConfigurationProto_RecycleBinState_Status")
	if err != nil {
		return err
	}
	*x = ConfigurationProto_RecycleBinState_Status(value)
	return nil
}

func (ConfigurationProto_RecycleBinState_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 47, 0}
}

type ConfigurationProto struct {
	// The optional symbolic link message in case the real configuration is split
	// up into multiple chunks. This will not be visible to any client of
	// Zeus. If this is set, none of the fields below other than the logical
	// timestamp will be set.
	SymbolicLink *ConfigurationProto_SymbolicLink `protobuf:"bytes,1000,opt,name=symbolic_link,json=symbolicLink" json:"symbolic_link,omitempty"`
	// Unique id assigned to this configuration. A configuration is updated in
	// Zookeeper only if the new configuration being updated has a
	// configuration_id that is one more than the one already in Zookeeper.
	// Otherwise, Zookeeper would reject the update (thinking that there is
	// a race in attempting to update the configuration).
	LogicalTimestamp *int64 `protobuf:"varint,1,req,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// The internal and external subnets used within the appliance. iSCSI
	// requests generated internally within the appliance (by user VMs or VMFS)
	// are sent to the internal subnet. Cross server communication happens on
	// the external subnet. The internal subnet is local to every server - its
	// not visible outside. The format is IP/netmask for each.
	InternalSubnet  *string                           `protobuf:"bytes,2,opt,name=internal_subnet,json=internalSubnet,def=192.168.5.0/255.255.255.0" json:"internal_subnet,omitempty"`
	ExternalSubnet  *string                           `protobuf:"bytes,3,opt,name=external_subnet,json=externalSubnet,def=172.16.0.0/255.240.0.0" json:"external_subnet,omitempty"`
	StorageTierList []*ConfigurationProto_StorageTier `protobuf:"bytes,4,rep,name=storage_tier_list,json=storageTierList" json:"storage_tier_list,omitempty"`
	// The various QoS principals that exist in the system. This'll define the
	// QoS principal hierarchy that'll be used for providing QoS in the system.
	// If qos_principals are not specified, all scheduling becomes FIFO.
	QosPrincipals []*qos.QosPrincipalProto `protobuf:"bytes,5,rep,name=qos_principals,json=qosPrincipals" json:"qos_principals,omitempty"`
	// Name of the catch all QoS principal. This principal (if specified) must
	// exist in qos_principals as a leaf principal. If not specified, then
	// we require that each vdisk (or its container) have a well defined
	// qos_principal_name specified that appears in qos_principals (unless
	// no qos_principals are specified - in which case everything is taken to
	// be FIFO).
	QosCatchallPrincipalName *string `protobuf:"bytes,6,opt,name=qos_catchall_principal_name,json=qosCatchallPrincipalName" json:"qos_catchall_principal_name,omitempty"`
	// Name of the system QoS principal. Background activities that cannot be
	// attributed to other principals are assigned to this principal. This
	// principal name is required to be specified and must be present in
	// qos_principals (unless qos_principals is empty in which case everything
	// is taken to be FIFO).
	QosSystemPrincipalName *string                    `protobuf:"bytes,7,opt,name=qos_system_principal_name,json=qosSystemPrincipalName" json:"qos_system_principal_name,omitempty"`
	DiskList               []*ConfigurationProto_Disk `protobuf:"bytes,8,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	NodeList               []*ConfigurationProto_Node `protobuf:"bytes,9,rep,name=node_list,json=nodeList" json:"node_list,omitempty"`
	// The list of all storage pools.
	StoragePoolList []*ConfigurationProto_StoragePool `protobuf:"bytes,10,rep,name=storage_pool_list,json=storagePoolList" json:"storage_pool_list,omitempty"`
	// The list of all containers.
	ContainerList []*ConfigurationProto_Container `protobuf:"bytes,11,rep,name=container_list,json=containerList" json:"container_list,omitempty"`
	// List of all vdisks configured in the Nutanix appliance. This field is
	// deprecated and should not be used. Older code used to keep the list of
	// vdisks here - now the vdisks are kept in Pithos. For now this field just
	// exists so that zookeeper_init can put vdisks here during smoke tests -
	// Pithos server would then empty this field  and move these to Pithos (just
	// as it would do during an upgrade).
	DeprecatedVdiskList []*pithos.VDiskConfig `protobuf:"bytes,12,rep,name=deprecated_vdisk_list,json=deprecatedVdiskList" json:"deprecated_vdisk_list,omitempty"`
	// List of hypervisor management servers.
	ManagementServerList []*ConfigurationProto_ManagementServer `protobuf:"bytes,13,rep,name=management_server_list,json=managementServerList" json:"management_server_list,omitempty"`
	// List of all configured VZones.
	VzoneList      []*ConfigurationProto_VZone      `protobuf:"bytes,14,rep,name=vzone_list,json=vzoneList" json:"vzone_list,omitempty"`
	RemoteSiteList []*ConfigurationProto_RemoteSite `protobuf:"bytes,15,rep,name=remote_site_list,json=remoteSiteList" json:"remote_site_list,omitempty"`
	// The cluster incarnation id. This is typically set to the wall time every
	// time the cluster is initialized from scratch. Thus, while a clean-data
	// preserves the cluster id, the cluster incarnation id will end up getting
	// changed.
	ClusterIncarnationId *int64 `protobuf:"varint,16,opt,name=cluster_incarnation_id,json=clusterIncarnationId" json:"cluster_incarnation_id,omitempty"`
	// The globally unique id that identifies the cluster.
	ClusterId *int64 `protobuf:"varint,18,opt,name=cluster_id,json=clusterId" json:"cluster_id,omitempty"`
	// The name assigned to the cluster by the admin. This is not globally
	// unique.
	// Some UI elements expect cluster to have a name. Hence we are assigning
	// a default name to cluster.
	ClusterName *string `protobuf:"bytes,19,opt,name=cluster_name,json=clusterName,def=Unnamed" json:"cluster_name,omitempty"`
	// Comma separated list of subnets (of the form "a.b.c.d/l.m.n.o") that are
	// allowed to send NFS requests. If not specified, all subnets are
	// disallowed. The internal subnet is always automatically considered part
	// of the whitelist, even if the field below does not explicitly specify it.
	// Similarly, all the hypervisor IPs are considered part of the whitelist (to
	// allow the case where requests are forwarded from a hypervisor to a remote
	// SVM). Finally, to permit debugging, all of the SVM's local IPs are
	// considered to be implicitly part of the whitelist (thus one can locally
	// mount NFS on an SVM).
	NfsSubnetWhitelist *string                   `protobuf:"bytes,20,opt,name=nfs_subnet_whitelist,json=nfsSubnetWhitelist" json:"nfs_subnet_whitelist,omitempty"`
	Aegis              *ConfigurationProto_Aegis `protobuf:"bytes,25,opt,name=aegis" json:"aegis,omitempty"`
	// Whether the VDisk list has been move to Pithos. If true, then 'vdisk_list'
	// will be empty and clients must use Pithos for VDisk configuration data.
	VdiskListInPithos *bool `protobuf:"varint,26,opt,name=vdisk_list_in_pithos,json=vdiskListInPithos" json:"vdisk_list_in_pithos,omitempty"`
	// The IP address of the default gateway to be assigned to the SVM's external
	// interface. Genesis learns this value and applies locally on each SVM.
	DefaultGatewayIp *string `protobuf:"bytes,27,opt,name=default_gateway_ip,json=defaultGatewayIp" json:"default_gateway_ip,omitempty"`
	// The list of IP addresses or FQDNs of the NTP servers.
	// Genesis learns this value and applies locally on each SVM.
	NtpServerList []string `protobuf:"bytes,28,rep,name=ntp_server_list,json=ntpServerList" json:"ntp_server_list,omitempty"`
	// The list of IP addresses of the name servers.
	// Genesis learns this value and applies locally on each SVM.
	NameServerIpList []string `protobuf:"bytes,29,rep,name=name_server_ip_list,json=nameServerIpList" json:"name_server_ip_list,omitempty"`
	// The list of all rackable units.
	RackableUnitList    []*ConfigurationProto_RackableUnit        `protobuf:"bytes,30,rep,name=rackable_unit_list,json=rackableUnitList" json:"rackable_unit_list,omitempty"`
	DynRingChangeInfo   *ConfigurationProto_DynamicRingChangeInfo `protobuf:"bytes,31,opt,name=dyn_ring_change_info,json=dynRingChangeInfo" json:"dyn_ring_change_info,omitempty"`
	SnmpInfo            *ConfigurationProto_SnmpInfo              `protobuf:"bytes,32,opt,name=snmp_info,json=snmpInfo" json:"snmp_info,omitempty"`
	RowCasUpgradeStatus *ConfigurationProto_RowCASUpgradeStatus   `protobuf:"varint,33,opt,name=row_cas_upgrade_status,json=rowCasUpgradeStatus,enum=nutanix.zeus.ConfigurationProto_RowCASUpgradeStatus,def=0" json:"row_cas_upgrade_status,omitempty"`
	// Timestamp of the RowCASUpgradeStatus state change.
	RowCasUpgradeTimestamp *int64 `protobuf:"varint,34,opt,name=row_cas_upgrade_timestamp,json=rowCasUpgradeTimestamp" json:"row_cas_upgrade_timestamp,omitempty"`
	// Version of the nutanix core package for which the schema in cassandra
	// was previously created/updated. If this does not match the current
	// version, then the schema need to be updated.
	CassandraSchemaVersion *string                        `protobuf:"bytes,35,opt,name=cassandra_schema_version,json=cassandraSchemaVersion" json:"cassandra_schema_version,omitempty"`
	AuthConfig             *ConfigurationProto_AuthConfig `protobuf:"bytes,36,opt,name=auth_config,json=authConfig" json:"auth_config,omitempty"`
	// Global list of vstores in the system.
	VstoreList             []*ConfigurationProto_VStore             `protobuf:"bytes,37,rep,name=vstore_list,json=vstoreList" json:"vstore_list,omitempty"`
	VirtualStorageTierList []*ConfigurationProto_VirtualStorageTier `protobuf:"bytes,38,rep,name=virtual_storage_tier_list,json=virtualStorageTierList" json:"virtual_storage_tier_list,omitempty"`
	// For all containers created prior to the release with vstore support, we
	// need to add a default vstore. This flag tracks whether this change has
	// been done.
	VstoreUpgradeDone *bool `protobuf:"varint,39,opt,name=vstore_upgrade_done,json=vstoreUpgradeDone,def=0" json:"vstore_upgrade_done,omitempty"`
	// String that indicates the current release version for the cluster. Each of
	// the nodes in the cluster should be at this release version or upgrading to
	// this version.
	ReleaseVersion *string `protobuf:"bytes,40,opt,name=release_version,json=releaseVersion" json:"release_version,omitempty"`
	// List of valid ssh keys for the cluster.
	SshKeyList []*ConfigurationProto_SSHKey `protobuf:"bytes,41,rep,name=ssh_key_list,json=sshKeyList" json:"ssh_key_list,omitempty"`
	// Percentage of our disk capacity that can have fingerprints in the extent
	// group metadata to be used by the content cache.
	ClusterContentCacheFingerprintPct *int32 `protobuf:"varint,42,opt,name=cluster_content_cache_fingerprint_pct,json=clusterContentCacheFingerprintPct,def=100" json:"cluster_content_cache_fingerprint_pct,omitempty"`
	// If true, disables fingerprinting for any new writes at a cluster wide
	// level. This is currently used when Curator master detects that a metadata
	// disk's metadata usage has gone above a safe threshold (as determined by
	// the gflag curator_metadata_usage_pct_to_disable_fingerprints).
	DisableFingerprinting *bool `protobuf:"varint,43,opt,name=disable_fingerprinting,json=disableFingerprinting" json:"disable_fingerprinting,omitempty"`
	// List of serial ids of disks which were removed and tombstoned.
	DiskTombstoneList []string `protobuf:"bytes,44,rep,name=disk_tombstone_list,json=diskTombstoneList" json:"disk_tombstone_list,omitempty"`
	// The local IP of cluster visible externally. This IP can change over time.
	// The IP is hosted on the same node as the prism leader.  The string is in
	// x.x.x.x format.
	ClusterExternalIp          *string                                 `protobuf:"bytes,45,opt,name=cluster_external_ip,json=clusterExternalIp" json:"cluster_external_ip,omitempty"`
	ClusterFaultToleranceState *ConfigurationProto_FaultToleranceState `protobuf:"bytes,46,opt,name=cluster_fault_tolerance_state,json=clusterFaultToleranceState" json:"cluster_fault_tolerance_state,omitempty"`
	DomainFaultToleranceState  *zeus.DomainFaultToleranceState         `protobuf:"bytes,47,opt,name=domain_fault_tolerance_state,json=domainFaultToleranceState" json:"domain_fault_tolerance_state,omitempty"`
	RsyslogConfig              *ConfigurationProto_RSyslogConfig       `protobuf:"bytes,48,opt,name=rsyslog_config,json=rsyslogConfig" json:"rsyslog_config,omitempty"`
	// Whether dynamic shadow clones should be enabled on the cluster. If true,
	// we will detect NFS files which are being accessed primarily for reads from
	// multiple nodes and redirect those requests to dynamically created shadow
	// vdisks which can be locally hosted on each node.
	ShadowClonesEnabled *bool `protobuf:"varint,49,opt,name=shadow_clones_enabled,json=shadowClonesEnabled,def=1" json:"shadow_clones_enabled,omitempty"`
	// Whether or not password SSH into cluster is enabled, enforced by Genesis.
	PasswordRemoteLoginEnabled *bool `protobuf:"varint,50,opt,name=password_remote_login_enabled,json=passwordRemoteLoginEnabled,def=1" json:"password_remote_login_enabled,omitempty"`
	// Logical timestamp when the metadata was snapshotted. In case of a Nutanix
	// instance in the cloud, we might optionally snapshot the metadata to
	// recover from a metadata disk failure. This logical timestamp helps to
	// implement a 2-phase delete of extent group id map entries. This ensures
	// that on recovery from a metadata disk failure, the extent group id map
	// metadata is consistent with extent group data on disk.
	MetadataSnapshotLogicalTimestamp *int64 `protobuf:"varint,51,opt,name=metadata_snapshot_logical_timestamp,json=metadataSnapshotLogicalTimestamp" json:"metadata_snapshot_logical_timestamp,omitempty"`
	// The default value must always be the lowest supported stargate version.
	StargateVersion  *int32  `protobuf:"varint,52,opt,name=stargate_version,json=stargateVersion,def=110" json:"stargate_version,omitempty"`
	ClusterFunctions *uint32 `protobuf:"fixed32,53,opt,name=cluster_functions,json=clusterFunctions,def=1" json:"cluster_functions,omitempty"`
	// UUID of the current cluster in human readable format, e.g.:
	// 550e8400-e29b-41d4-a716-446655440000
	// For all intents and purposes it is unique for every cluster incarnation.
	// We prefer cluster_uuid for identifying the cluster rather
	// than the old (cluster_id, cluster_incarnation_id) tuple.
	ClusterUuid *string `protobuf:"bytes,54,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// In the case where metadata lives on disks with higher than expected
	// failure rates, (eg. in the case of the Amazon EC2 cloud VM, the metadata
	// lives on EBS), we take periodic snapshots of the metadata volume in order
	// to recover from a metadata disk failure. This flag specifies whether
	// metadata snapshots are enabled.
	MetadataSnapshotsEnabled *bool `protobuf:"varint,55,opt,name=metadata_snapshots_enabled,json=metadataSnapshotsEnabled" json:"metadata_snapshots_enabled,omitempty"`
	// Timezone of the cluster.
	Timezone *string `protobuf:"bytes,56,opt,name=timezone" json:"timezone,omitempty"`
	// If true, disables on_disk deduplication for any new writes at a cluster
	// wide level.
	DisableOnDiskDedup      *bool                                     `protobuf:"varint,57,opt,name=disable_on_disk_dedup,json=disableOnDiskDedup" json:"disable_on_disk_dedup,omitempty"`
	KeyManagementServerList []*ConfigurationProto_KeyManagementServer `protobuf:"bytes,58,rep,name=key_management_server_list,json=keyManagementServerList" json:"key_management_server_list,omitempty"`
	// List of certificate authorities trusted by the cluster.
	TrustedCertificateAuthorityList []*ConfigurationProto_CertificateAuthority `protobuf:"bytes,59,rep,name=trusted_certificate_authority_list,json=trustedCertificateAuthorityList" json:"trusted_certificate_authority_list,omitempty"`
	// Whether the extended NFS file handle that contains the cluster's id and
	// incarnation should be used in NFS.
	//
	// Even though the cluster's stargate version may support this feature, it is
	// disabled by default due to issues that may be encountered by VMs after
	// upgrading to the new file handle format. Since only a minority of clusters
	// require this feature (e.g., those using stretched vstores), its enablement
	// should be handled explicitly by an administrator at a planned time.
	ExtendedNfsFhandleEnabled *bool `protobuf:"varint,60,opt,name=extended_nfs_fhandle_enabled,json=extendedNfsFhandleEnabled" json:"extended_nfs_fhandle_enabled,omitempty"`
	// Cloud Site information for the cloud where this cluster is running in.
	CloudSiteInfo            *zeus.CloudSiteInfo                          `protobuf:"bytes,61,opt,name=cloud_site_info,json=cloudSiteInfo" json:"cloud_site_info,omitempty"`
	CertificationSigningInfo *ConfigurationProto_CertificationSigningInfo `protobuf:"bytes,62,opt,name=certification_signing_info,json=certificationSigningInfo" json:"certification_signing_info,omitempty"`
	// Maintains current state of Cassandra automatic ring fixer operation.
	RingFixState *ConfigurationProto_AutoRingFixState `protobuf:"bytes,63,opt,name=ring_fix_state,json=ringFixState" json:"ring_fix_state,omitempty"`
	// If true, we will disable compressing any new extent group, as the metadata
	// size has grown beyond a safe threshold.
	DisableCompression  *bool                                   `protobuf:"varint,64,opt,name=disable_compression,json=disableCompression" json:"disable_compression,omitempty"`
	BlockIscsiTargetIps *ConfigurationProto_BlockIscsiTargetIPs `protobuf:"bytes,65,opt,name=block_iscsi_target_ips,json=blockIscsiTargetIps" json:"block_iscsi_target_ips,omitempty"`
	CuratorScanInfo     *ConfigurationProto_CuratorScanInfo     `protobuf:"bytes,66,opt,name=curator_scan_info,json=curatorScanInfo" json:"curator_scan_info,omitempty"`
	AcropolisHaConfig   *ConfigurationProto_AcropolisHAConfig   `protobuf:"bytes,67,opt,name=acropolis_ha_config,json=acropolisHaConfig" json:"acropolis_ha_config,omitempty"`
	// If true, use lower preferred tier to honor rackable unit
	// (block) aware placement, if space is not available on higher
	// tiers.
	UseLowerTierToEnforceRuAwarePlacement *bool `protobuf:"varint,68,opt,name=use_lower_tier_to_enforce_ru_aware_placement,json=useLowerTierToEnforceRuAwarePlacement,def=0" json:"use_lower_tier_to_enforce_ru_aware_placement,omitempty"`
	// The ClickstreamConfig message.
	ClickstreamConfig *ConfigurationProto_ClickstreamConfig `protobuf:"bytes,69,opt,name=clickstream_config,json=clickstreamConfig" json:"clickstream_config,omitempty"`
	// DEPRECATED: ncc_version. NCC version is kept in arithmos and idf now.
	// String that indicates the current NCC version for the cluster. Each of
	// the nodes in the cluster should be at this NCC version or upgrading to
	// this version.
	NccVersion                  *string                                      `protobuf:"bytes,70,opt,name=ncc_version,json=nccVersion" json:"ncc_version,omitempty"` // Deprecated: Do not use.
	CvmSecurityComplianceConfig *ConfigurationProto_SecurityComplianceConfig `protobuf:"bytes,71,opt,name=cvm_security_compliance_config,json=cvmSecurityComplianceConfig" json:"cvm_security_compliance_config,omitempty"`
	// Configuration for periodic scheduling of Curator maintenance mode.
	// In this mode, Curator assumes that the cluster is relatively idle and
	// performs aggressive scans which may generate substantial amount of work
	// in terms of background and foreground tasks.
	CuratorMaintenanceModeConfig *zeus.PeriodicScheduleConfig `protobuf:"bytes,72,opt,name=curator_maintenance_mode_config,json=curatorMaintenanceModeConfig" json:"curator_maintenance_mode_config,omitempty"`
	// HypervisorSecurityComplianceConfig is only for KVM hypervisor.
	HypervisorSecurityComplianceConfig *ConfigurationProto_HypervisorSecurityComplianceConfig `protobuf:"bytes,73,opt,name=hypervisor_security_compliance_config,json=hypervisorSecurityComplianceConfig" json:"hypervisor_security_compliance_config,omitempty"`
	// The IP of the cluster in the x.x.x.x format that will provide
	// external entities access to various cluster data services.
	ClusterExternalDataServicesIp *string `protobuf:"bytes,74,opt,name=cluster_external_data_services_ip,json=clusterExternalDataServicesIp" json:"cluster_external_data_services_ip,omitempty"`
	// Configuration for the intra-cluster backplane network.
	BackplaneNetworkConfig *ConfigurationProto_NetworkConfig `protobuf:"bytes,75,opt,name=backplane_network_config,json=backplaneNetworkConfig" json:"backplane_network_config,omitempty"`
	// Configuration for the intra-cluster RDMA network.
	RdmaNetworkConfig *ConfigurationProto_NetworkConfig `protobuf:"bytes,94,opt,name=rdma_network_config,json=rdmaNetworkConfig" json:"rdma_network_config,omitempty"`
	// If true, disables detection of degraded nodes in the cluster which might
	// have services alive but not making progress.
	DisableDegradedNodeMonitoring *bool                             `protobuf:"varint,76,opt,name=disable_degraded_node_monitoring,json=disableDegradedNodeMonitoring,def=0" json:"disable_degraded_node_monitoring,omitempty"`
	ClusterOperationMode          *ConfigurationProto_OperationMode `protobuf:"varint,77,opt,name=cluster_operation_mode,json=clusterOperationMode,enum=nutanix.zeus.ConfigurationProto_OperationMode,def=0" json:"cluster_operation_mode,omitempty"`
	// Knob to enable/disable Common Criteria (CC) mode.
	CommonCriteriaMode *bool `protobuf:"varint,78,opt,name=common_criteria_mode,json=commonCriteriaMode,def=0" json:"common_criteria_mode,omitempty"`
	// Iscsi related cluster wide configuration.
	IscsiConfig                   *ConfigurationProto_IscsiConfig                   `protobuf:"bytes,79,opt,name=iscsi_config,json=iscsiConfig" json:"iscsi_config,omitempty"`
	CuratorStargateProtocolConfig *ConfigurationProto_CuratorStargateProtocolConfig `protobuf:"bytes,80,opt,name=curator_stargate_protocol_config,json=curatorStargateProtocolConfig" json:"curator_stargate_protocol_config,omitempty"`
	// If true, indicates that enable_dedup_extents_two_phase_deletion field from
	// CuratorStargateProtocolConfig is initialized by Curator. This field is
	// used to ensure that Curator enables two phase deletion protocol only once.
	// If we have explicitly disabled two phase deletion by manually editing this
	// config and this field is set, then Curator will not enable two phase
	// deletion when StargateVersion is updated to kDedupExtentTwoPhaseDeletion
	// by Stargate.
	InitializedDedupExtentsTwoPhaseDeletion *bool `protobuf:"varint,81,opt,name=initialized_dedup_extents_two_phase_deletion,json=initializedDedupExtentsTwoPhaseDeletion" json:"initialized_dedup_extents_two_phase_deletion,omitempty"`
	// Container id for NutanixManagementShare, to be used by image service
	// and other internal services.
	ManagementShareContainerId *int64 `protobuf:"varint,82,opt,name=management_share_container_id,json=managementShareContainerId" json:"management_share_container_id,omitempty"`
	// Container id for the default SSP container.
	DefaultSspContainerId *int64                        `protobuf:"varint,83,opt,name=default_ssp_container_id,json=defaultSspContainerId" json:"default_ssp_container_id,omitempty"`
	AdsConfig             *ConfigurationProto_AdsConfig `protobuf:"bytes,84,opt,name=ads_config,json=adsConfig" json:"ads_config,omitempty"`
	// The cluster NAT'd or proxy IP which maps to the cluster local IP.
	// The string is in x.x.x.x format.
	ClusterMasqueradingIp *string `protobuf:"bytes,85,opt,name=cluster_masquerading_ip,json=clusterMasqueradingIp" json:"cluster_masquerading_ip,omitempty"`
	// The port to connect to the cluster when using cluster_masquerading_ip,
	// such as proxy port, or NAT port forwarding
	ClusterMasqueradingPort *int32 `protobuf:"varint,86,opt,name=cluster_masquerading_port,json=clusterMasqueradingPort" json:"cluster_masquerading_port,omitempty"`
	// List of containers to pause erasure coding encode tasks on.
	PauseEcEncodeContainersList []int64 `protobuf:"varint,87,rep,name=pause_ec_encode_containers_list,json=pauseEcEncodeContainersList" json:"pause_ec_encode_containers_list,omitempty"`
	// Whether the entity centric DR enabled on the cluster.
	EntityCentricDrEnabled *bool                              `protobuf:"varint,88,opt,name=entity_centric_dr_enabled,json=entityCentricDrEnabled" json:"entity_centric_dr_enabled,omitempty"`
	LwsStoreConfig         *ConfigurationProto_LWSStoreConfig `protobuf:"bytes,89,opt,name=lws_store_config,json=lwsStoreConfig" json:"lws_store_config,omitempty"`
	// Whether the cluster is the owner of ssp config. For Prism Central, the
	// value is always True; for Prism Element, default is False.
	SspConfigOwner *bool `protobuf:"varint,90,opt,name=ssp_config_owner,json=sspConfigOwner" json:"ssp_config_owner,omitempty"`
	// Whether VMWare Fault Tolerance should be supported on the cluster.
	FtSupportEnabled *bool `protobuf:"varint,91,opt,name=ft_support_enabled,json=ftSupportEnabled,def=0" json:"ft_support_enabled,omitempty"`
	// Whether network connection stats collection is enabled on the cluster.
	NetworkConnectionStatsCollectionEnabled *bool `protobuf:"varint,92,opt,name=network_connection_stats_collection_enabled,json=networkConnectionStatsCollectionEnabled,def=0" json:"network_connection_stats_collection_enabled,omitempty"`
	// State of a two-node cluster.
	WitnessState *ConfigurationProto_WitnessState `protobuf:"bytes,93,opt,name=witness_state,json=witnessState" json:"witness_state,omitempty"`
	// Parameters for cluster level encryption. If the encryption parameters are
	// not specified at the container level, then these parameters can be used to
	// encrypt data in the cluster. These parameters are also used to encrypt NFS
	// metadata and NFS WAL.
	ClusterEncryptionParams *ConfigurationProto_EncryptionParams `protobuf:"bytes,95,opt,name=cluster_encryption_params,json=clusterEncryptionParams" json:"cluster_encryption_params,omitempty"`
	ClusterArch             *ConfigurationProto_ClusterArch      `protobuf:"varint,96,opt,name=cluster_arch,json=clusterArch,enum=nutanix.zeus.ConfigurationProto_ClusterArch" json:"cluster_arch,omitempty"`
	// The list of all racks across which the cluster spans.
	RackList []*ConfigurationProto_Rack `protobuf:"bytes,97,rep,name=rack_list,json=rackList" json:"rack_list,omitempty"`
	// Indicates whether image conversion from pithos to edb has completed
	ImageConversionCompleteObelix *bool `protobuf:"varint,98,opt,name=image_conversion_complete_obelix,json=imageConversionCompleteObelix" json:"image_conversion_complete_obelix,omitempty"`
	// Indicates cluster is under catalog ownership change phase.
	CatalogChangeOwnerInProgress *bool `protobuf:"varint,99,opt,name=catalog_change_owner_in_progress,json=catalogChangeOwnerInProgress,def=0" json:"catalog_change_owner_in_progress,omitempty"`
	// Indicates whether the PE catalog item manager is done quiescing
	// catalog tasks and is ready to get mastered at PC
	CatalogPeRegistered *bool `protobuf:"varint,100,opt,name=catalog_pe_registered,json=catalogPeRegistered" json:"catalog_pe_registered,omitempty"`
	// Indicates whether the scheduler corruption that can be caused by bugs in
	// AOS 5.1.1 has been completed.
	AcropolisSchedulerCleanupDone *bool `protobuf:"varint,101,opt,name=acropolis_scheduler_cleanup_done,json=acropolisSchedulerCleanupDone" json:"acropolis_scheduler_cleanup_done,omitempty"`
	// Information about ongoing cluster conversion operation on cluster.
	ClusterConversionStatus *ConfigurationProto_ClusterConversionStatus `protobuf:"bytes,102,opt,name=cluster_conversion_status,json=clusterConversionStatus" json:"cluster_conversion_status,omitempty"`
	// List of compute only nodes.
	ComputeNodeList []*ConfigurationProto_Node `protobuf:"bytes,103,rep,name=compute_node_list,json=computeNodeList" json:"compute_node_list,omitempty"`
	// Indicates if STIG standard is enabled.
	StigEnabled *bool `protobuf:"varint,104,opt,name=stig_enabled,json=stigEnabled,def=0" json:"stig_enabled,omitempty"`
	// This field is deprecated.
	// Amount of user space memory overhead reserved per host in megabytes.
	AcropolisBaselineUserMemoryMbX86 *uint64 `protobuf:"varint,105,opt,name=acropolis_baseline_user_memory_mb_x86,json=acropolisBaselineUserMemoryMbX86,def=1536" json:"acropolis_baseline_user_memory_mb_x86,omitempty"` // Deprecated: Do not use.
	// This field is deprecated.
	// Amount of kernel space memory overhead reserved per host in megabytes.
	AcropolisBaselineKernelMemoryMbX86 *uint64 `protobuf:"varint,106,opt,name=acropolis_baseline_kernel_memory_mb_x86,json=acropolisBaselineKernelMemoryMbX86,def=1024" json:"acropolis_baseline_kernel_memory_mb_x86,omitempty"` // Deprecated: Do not use.
	// List of per host memory reservations requested per component in Acropolis.
	MemoryReservationsPerComponentList []*ConfigurationProto_MemoryReservationsPerComponent `protobuf:"bytes,107,rep,name=memory_reservations_per_component_list,json=memoryReservationsPerComponentList" json:"memory_reservations_per_component_list,omitempty"`
	// HypervisorLldpConfig is only for KVM hypervisor.
	HypervisorLldpConfig *ConfigurationProto_HypervisorLldpConfig `protobuf:"bytes,108,opt,name=hypervisor_lldp_config,json=hypervisorLldpConfig" json:"hypervisor_lldp_config,omitempty"`
	// If true, then on-disk dedup is disabled during Curator's full scan because
	// the average number of dedup ExtentIdMap entries per node have exceeded the
	// threshold.
	EidMapEntriesPerNodeDedupThresholdExceeded *bool `protobuf:"varint,109,opt,name=eid_map_entries_per_node_dedup_threshold_exceeded,json=eidMapEntriesPerNodeDedupThresholdExceeded" json:"eid_map_entries_per_node_dedup_threshold_exceeded,omitempty"`
	// Cell FQDN List, For Xi should be populated on PE by DCM &
	// populated on PC by Deployment.
	CellFqdnList []string `protobuf:"bytes,110,rep,name=cell_fqdn_list,json=cellFqdnList" json:"cell_fqdn_list,omitempty"`
	// Bitmap for storing current cerebro features.
	CerebroFeaturesBitmap *uint64 `protobuf:"varint,111,opt,name=cerebro_features_bitmap,json=cerebroFeaturesBitmap" json:"cerebro_features_bitmap,omitempty"`
	// This field indicates type of KMS configured.
	KmsType                       *ConfigurationProto_KMSType `protobuf:"varint,112,opt,name=kms_type,json=kmsType,enum=nutanix.zeus.ConfigurationProto_KMSType,def=0" json:"kms_type,omitempty"`
	CatalogSubsetMigrationEnabled *bool                       `protobuf:"varint,113,opt,name=catalog_subset_migration_enabled,json=catalogSubsetMigrationEnabled" json:"catalog_subset_migration_enabled,omitempty"`
	// Indicates whether the acropolis scheduler corruption caused by bugs in hot
	// plugging memory or cpu has been cleaned up.
	AcropolisSchedulerHotAddCleanupDone *bool `protobuf:"varint,114,opt,name=acropolis_scheduler_hot_add_cleanup_done,json=acropolisSchedulerHotAddCleanupDone" json:"acropolis_scheduler_hot_add_cleanup_done,omitempty"`
	// Indicates whether we've cleared VMs' ha_priority fields that were set to
	// -1 by AOS 5.10.9 or earlier.
	AcropolisHaPriorityCleanupDone *bool `protobuf:"varint,115,opt,name=acropolis_ha_priority_cleanup_done,json=acropolisHaPriorityCleanupDone" json:"acropolis_ha_priority_cleanup_done,omitempty"`
	// A bool that indicates if a release is categorized as Long Term Support or
	// not.
	IsLts *bool `protobuf:"varint,116,opt,name=is_lts,json=isLts" json:"is_lts,omitempty"`
	// The highest component id at the point when the cluster was upgraded to a
	// version where Autonomous Extent Store (AES) was enabled. This allows
	// Stargate to identify entities such as containers, vdisks and extent groups
	// that were created prior to the upgrade.
	AesSupportedVersionLogicalTimestamp *int64 `protobuf:"varint,117,opt,name=aes_supported_version_logical_timestamp,json=aesSupportedVersionLogicalTimestamp" json:"aes_supported_version_logical_timestamp,omitempty"`
	// If true, the Curator will use logical checksums to select the dedup
	// candidates.
	UseChecksumBasedDedup *bool `protobuf:"varint,118,opt,name=use_checksum_based_dedup,json=useChecksumBasedDedup" json:"use_checksum_based_dedup,omitempty"`
	// The FQDN of cluster visible externally. This FQDN will always resolve to
	// external ip address of cluster so cluster_external_ip can't be empty.
	ClusterFullyQualifiedDomainName *string `protobuf:"bytes,119,opt,name=cluster_fully_qualified_domain_name,json=clusterFullyQualifiedDomainName" json:"cluster_fully_qualified_domain_name,omitempty"`
	// If true, this enables downsampling of metrics syncing between
	// Prism Element and Prism Central to 5 mins.
	EnableEfficientMetricSync *bool `protobuf:"varint,120,opt,name=enable_efficient_metric_sync,json=enableEfficientMetricSync" json:"enable_efficient_metric_sync,omitempty"`
	// If true, scheduler is enabled on PC. Clients are expected to call scheduler
	// based on the value of this field.
	UseScheduler *bool `protobuf:"varint,121,opt,name=use_scheduler,json=useScheduler" json:"use_scheduler,omitempty"`
	// List of external storage systems.
	ExternalRepositoryList []*ConfigurationProto_ExternalRepository `protobuf:"bytes,122,rep,name=external_repository_list,json=externalRepositoryList" json:"external_repository_list,omitempty"`
	// The highest component id at the point when the cluster was upgraded to a
	// newer stargate version. This allows Stargate to identify entities such as
	// containers, vdisks and extent groups that were created prior to the
	// upgrade. It's value will be set/change when the stargate upgrade
	// completes.
	StargateUpgradeLogicalTimestamp *int64 `protobuf:"varint,123,opt,name=stargate_upgrade_logical_timestamp,json=stargateUpgradeLogicalTimestamp" json:"stargate_upgrade_logical_timestamp,omitempty"`
	// Cluster usage threshold for warning alert. Its value is in range [0..99]
	ClusterUsageWarningAlertThresholdPct *int32 `protobuf:"varint,124,opt,name=cluster_usage_warning_alert_threshold_pct,json=clusterUsageWarningAlertThresholdPct,def=75" json:"cluster_usage_warning_alert_threshold_pct,omitempty"`
	// Cluster usage threshold for critical alert. Its value is in range [0..99]
	ClusterUsageCriticalAlertThresholdPct *int32 `protobuf:"varint,125,opt,name=cluster_usage_critical_alert_threshold_pct,json=clusterUsageCriticalAlertThresholdPct,def=90" json:"cluster_usage_critical_alert_threshold_pct,omitempty"`
	// This field represents if the dedup checksum collision ratio has exceeded
	// the collision threshold defined by Curator.
	DedupChecksumCollisionExceeded *bool `protobuf:"varint,126,opt,name=dedup_checksum_collision_exceeded,json=dedupChecksumCollisionExceeded,def=0" json:"dedup_checksum_collision_exceeded,omitempty"`
	// The local IP with or without prefix length of cluster visible externally.
	// This IP can change over time. The IP is hosted on the same node as the
	// prism leader. The string format is in IPv6 or IPv6/prefix_length format.
	ClusterExternalIpv6 *string `protobuf:"bytes,127,opt,name=cluster_external_ipv6,json=clusterExternalIpv6" json:"cluster_external_ipv6,omitempty"`
	// The capabilities of services in this cluster.
	ClusterCapabilities *ConfigurationProto_ClusterCapabilities `protobuf:"bytes,130,opt,name=cluster_capabilities,json=clusterCapabilities" json:"cluster_capabilities,omitempty"`
	// The Previous Ipv4 Virual IP hosted on the same node as the prism leader.
	PreviousClusterExternalIp *string `protobuf:"bytes,131,opt,name=previous_cluster_external_ip,json=previousClusterExternalIp" json:"previous_cluster_external_ip,omitempty"`
	// The Previous Ipv6 Virual IP hosted on the same node as the prism leader.
	PreviousClusterExternalIpv6 *string `protobuf:"bytes,132,opt,name=previous_cluster_external_ipv6,json=previousClusterExternalIpv6" json:"previous_cluster_external_ipv6,omitempty"`
	// Catalog Support for multiple files enabled
	MultiFileSupportEnabled *bool `protobuf:"varint,133,opt,name=multi_file_support_enabled,json=multiFileSupportEnabled,def=0" json:"multi_file_support_enabled,omitempty"`
	// This parameter controls the recycle bin feature. The value of this
	// parameter is the time to live value (in seconds) of a file in recycle bin
	// directory. The file in recycle bin will be deleted after this duration. If
	// this is set to -1, then the recycle bin feature is disabled.
	RecycleBinTtlSecs *int32 `protobuf:"varint,134,opt,name=recycle_bin_ttl_secs,json=recycleBinTtlSecs,def=86400" json:"recycle_bin_ttl_secs,omitempty"`
	// Indicates whether we've converted VMs before 5.18 with negative ha_priority
	// to agent VMs.
	AcropolisAgentVmConversionDone *bool `protobuf:"varint,135,opt,name=acropolis_agent_vm_conversion_done,json=acropolisAgentVmConversionDone" json:"acropolis_agent_vm_conversion_done,omitempty"`
	// This parameter holds the value for alert threshold for storage provisioning,
	// added as part of ENG-280373.
	AlertThresholdStorageProvisioning *float64 `protobuf:"fixed64,136,opt,name=alert_threshold_storage_provisioning,json=alertThresholdStorageProvisioning" json:"alert_threshold_storage_provisioning,omitempty"`
	// This field is set to current version only on cluster create. Helps in
	// determining if cluster was upgraded or created in the current version.
	InitialStargateVersion *int32 `protobuf:"varint,137,opt,name=initial_stargate_version,json=initialStargateVersion" json:"initial_stargate_version,omitempty"`
	// The current version of the Pithos master and the current version that the
	// pithos backend is compatible with.
	PithosVersionInfo *pithos.PithosVersionInformation `protobuf:"bytes,138,opt,name=pithos_version_info,json=pithosVersionInfo" json:"pithos_version_info,omitempty"`
	// Whether block store is enabled in the cluster. If any disk in the cluster
	// is formatted with block store, this field must be set to true.
	// Additionally, when set to false, a new disk added to the cluster either
	// through disk addition to an existing node or through a new node addition
	// will NOT be eligible to be formatted with block store. The field can be
	// used to prevent enabling block store on a cluster which has potentially
	// been running without any block store functionality for a while as a risk
	// mitigation stretegy. A future release can set the field to true if the
	// cluster meets all block store constraints.
	BlockStoreEnabled *bool `protobuf:"varint,139,opt,name=block_store_enabled,json=blockStoreEnabled" json:"block_store_enabled,omitempty"`
	// IPv6 external subnet of the cluster which will be assigned to eth0.
	ExternalV6Subnet *string `protobuf:"bytes,140,opt,name=external_v6_subnet,json=externalV6Subnet" json:"external_v6_subnet,omitempty"`
	// The DNS configuration of the current cluster.
	DnsConfig *ConfigurationProto_DnsConfig `protobuf:"bytes,141,opt,name=dns_config,json=dnsConfig" json:"dns_config,omitempty"`
	// File server UUID: It is only valid when the cluster type is kMinerva.
	FileServerUuid *string `protobuf:"bytes,142,opt,name=file_server_uuid,json=fileServerUuid" json:"file_server_uuid,omitempty"`
	// The lowest mantle version that exists in the cluster.
	MantleVersion *int32 `protobuf:"varint,143,opt,name=mantle_version,json=mantleVersion,def=0" json:"mantle_version,omitempty"`
	// PE scheduler memory model version for AHV. This attribute is used by PC
	// lazan for VM memory overhead calculation.
	AhvMemoryModelVersion *int32 `protobuf:"varint,144,opt,name=ahv_memory_model_version,json=ahvMemoryModelVersion" json:"ahv_memory_model_version,omitempty"`
	// Whether replication factor 1 container support is enabled in the cluster.
	// This field must be set to 'true' to allow users create containers with
	// replication factor 1 officially.
	Rf1ContainerEnabled *bool `protobuf:"varint,145,opt,name=rf1_container_enabled,json=rf1ContainerEnabled" json:"rf1_container_enabled,omitempty"`
	// State of cluster hibernate operation.
	HibernateState *ConfigurationProto_ClusterHibernateState `protobuf:"bytes,146,opt,name=hibernate_state,json=hibernateState" json:"hibernate_state,omitempty"`
	// Current cluster level state of the recycle bin. The time-to-live for the
	// recycle bin entities is described separately in 'recycle_bin_ttl_secs'.
	RecycleBinState      *ConfigurationProto_RecycleBinState `protobuf:"bytes,148,opt,name=recycle_bin_state,json=recycleBinState" json:"recycle_bin_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ConfigurationProto) Reset()         { *m = ConfigurationProto{} }
func (m *ConfigurationProto) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto) ProtoMessage()    {}
func (*ConfigurationProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0}
}

func (m *ConfigurationProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto.Unmarshal(m, b)
}
func (m *ConfigurationProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto.Merge(m, src)
}
func (m *ConfigurationProto) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto.Size(m)
}
func (m *ConfigurationProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto proto.InternalMessageInfo

const Default_ConfigurationProto_InternalSubnet string = "192.168.5.0/255.255.255.0"
const Default_ConfigurationProto_ExternalSubnet string = "172.16.0.0/255.240.0.0"
const Default_ConfigurationProto_ClusterName string = "Unnamed"
const Default_ConfigurationProto_RowCasUpgradeStatus ConfigurationProto_RowCASUpgradeStatus = ConfigurationProto_kNone
const Default_ConfigurationProto_VstoreUpgradeDone bool = false
const Default_ConfigurationProto_ClusterContentCacheFingerprintPct int32 = 100
const Default_ConfigurationProto_ShadowClonesEnabled bool = true
const Default_ConfigurationProto_PasswordRemoteLoginEnabled bool = true
const Default_ConfigurationProto_StargateVersion int32 = 110
const Default_ConfigurationProto_ClusterFunctions uint32 = 1
const Default_ConfigurationProto_UseLowerTierToEnforceRuAwarePlacement bool = false
const Default_ConfigurationProto_DisableDegradedNodeMonitoring bool = false
const Default_ConfigurationProto_ClusterOperationMode ConfigurationProto_OperationMode = ConfigurationProto_kNormal
const Default_ConfigurationProto_CommonCriteriaMode bool = false
const Default_ConfigurationProto_FtSupportEnabled bool = false
const Default_ConfigurationProto_NetworkConnectionStatsCollectionEnabled bool = false
const Default_ConfigurationProto_CatalogChangeOwnerInProgress bool = false
const Default_ConfigurationProto_StigEnabled bool = false
const Default_ConfigurationProto_AcropolisBaselineUserMemoryMbX86 uint64 = 1536
const Default_ConfigurationProto_AcropolisBaselineKernelMemoryMbX86 uint64 = 1024
const Default_ConfigurationProto_KmsType ConfigurationProto_KMSType = ConfigurationProto_kEKM
const Default_ConfigurationProto_ClusterUsageWarningAlertThresholdPct int32 = 75
const Default_ConfigurationProto_ClusterUsageCriticalAlertThresholdPct int32 = 90
const Default_ConfigurationProto_DedupChecksumCollisionExceeded bool = false
const Default_ConfigurationProto_MultiFileSupportEnabled bool = false
const Default_ConfigurationProto_RecycleBinTtlSecs int32 = 86400
const Default_ConfigurationProto_MantleVersion int32 = 0

func (m *ConfigurationProto) GetSymbolicLink() *ConfigurationProto_SymbolicLink {
	if m != nil {
		return m.SymbolicLink
	}
	return nil
}

func (m *ConfigurationProto) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *ConfigurationProto) GetInternalSubnet() string {
	if m != nil && m.InternalSubnet != nil {
		return *m.InternalSubnet
	}
	return Default_ConfigurationProto_InternalSubnet
}

func (m *ConfigurationProto) GetExternalSubnet() string {
	if m != nil && m.ExternalSubnet != nil {
		return *m.ExternalSubnet
	}
	return Default_ConfigurationProto_ExternalSubnet
}

func (m *ConfigurationProto) GetStorageTierList() []*ConfigurationProto_StorageTier {
	if m != nil {
		return m.StorageTierList
	}
	return nil
}

func (m *ConfigurationProto) GetQosPrincipals() []*qos.QosPrincipalProto {
	if m != nil {
		return m.QosPrincipals
	}
	return nil
}

func (m *ConfigurationProto) GetQosCatchallPrincipalName() string {
	if m != nil && m.QosCatchallPrincipalName != nil {
		return *m.QosCatchallPrincipalName
	}
	return ""
}

func (m *ConfigurationProto) GetQosSystemPrincipalName() string {
	if m != nil && m.QosSystemPrincipalName != nil {
		return *m.QosSystemPrincipalName
	}
	return ""
}

func (m *ConfigurationProto) GetDiskList() []*ConfigurationProto_Disk {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *ConfigurationProto) GetNodeList() []*ConfigurationProto_Node {
	if m != nil {
		return m.NodeList
	}
	return nil
}

func (m *ConfigurationProto) GetStoragePoolList() []*ConfigurationProto_StoragePool {
	if m != nil {
		return m.StoragePoolList
	}
	return nil
}

func (m *ConfigurationProto) GetContainerList() []*ConfigurationProto_Container {
	if m != nil {
		return m.ContainerList
	}
	return nil
}

func (m *ConfigurationProto) GetDeprecatedVdiskList() []*pithos.VDiskConfig {
	if m != nil {
		return m.DeprecatedVdiskList
	}
	return nil
}

func (m *ConfigurationProto) GetManagementServerList() []*ConfigurationProto_ManagementServer {
	if m != nil {
		return m.ManagementServerList
	}
	return nil
}

func (m *ConfigurationProto) GetVzoneList() []*ConfigurationProto_VZone {
	if m != nil {
		return m.VzoneList
	}
	return nil
}

func (m *ConfigurationProto) GetRemoteSiteList() []*ConfigurationProto_RemoteSite {
	if m != nil {
		return m.RemoteSiteList
	}
	return nil
}

func (m *ConfigurationProto) GetClusterIncarnationId() int64 {
	if m != nil && m.ClusterIncarnationId != nil {
		return *m.ClusterIncarnationId
	}
	return 0
}

func (m *ConfigurationProto) GetClusterId() int64 {
	if m != nil && m.ClusterId != nil {
		return *m.ClusterId
	}
	return 0
}

func (m *ConfigurationProto) GetClusterName() string {
	if m != nil && m.ClusterName != nil {
		return *m.ClusterName
	}
	return Default_ConfigurationProto_ClusterName
}

func (m *ConfigurationProto) GetNfsSubnetWhitelist() string {
	if m != nil && m.NfsSubnetWhitelist != nil {
		return *m.NfsSubnetWhitelist
	}
	return ""
}

func (m *ConfigurationProto) GetAegis() *ConfigurationProto_Aegis {
	if m != nil {
		return m.Aegis
	}
	return nil
}

func (m *ConfigurationProto) GetVdiskListInPithos() bool {
	if m != nil && m.VdiskListInPithos != nil {
		return *m.VdiskListInPithos
	}
	return false
}

func (m *ConfigurationProto) GetDefaultGatewayIp() string {
	if m != nil && m.DefaultGatewayIp != nil {
		return *m.DefaultGatewayIp
	}
	return ""
}

func (m *ConfigurationProto) GetNtpServerList() []string {
	if m != nil {
		return m.NtpServerList
	}
	return nil
}

func (m *ConfigurationProto) GetNameServerIpList() []string {
	if m != nil {
		return m.NameServerIpList
	}
	return nil
}

func (m *ConfigurationProto) GetRackableUnitList() []*ConfigurationProto_RackableUnit {
	if m != nil {
		return m.RackableUnitList
	}
	return nil
}

func (m *ConfigurationProto) GetDynRingChangeInfo() *ConfigurationProto_DynamicRingChangeInfo {
	if m != nil {
		return m.DynRingChangeInfo
	}
	return nil
}

func (m *ConfigurationProto) GetSnmpInfo() *ConfigurationProto_SnmpInfo {
	if m != nil {
		return m.SnmpInfo
	}
	return nil
}

func (m *ConfigurationProto) GetRowCasUpgradeStatus() ConfigurationProto_RowCASUpgradeStatus {
	if m != nil && m.RowCasUpgradeStatus != nil {
		return *m.RowCasUpgradeStatus
	}
	return Default_ConfigurationProto_RowCasUpgradeStatus
}

func (m *ConfigurationProto) GetRowCasUpgradeTimestamp() int64 {
	if m != nil && m.RowCasUpgradeTimestamp != nil {
		return *m.RowCasUpgradeTimestamp
	}
	return 0
}

func (m *ConfigurationProto) GetCassandraSchemaVersion() string {
	if m != nil && m.CassandraSchemaVersion != nil {
		return *m.CassandraSchemaVersion
	}
	return ""
}

func (m *ConfigurationProto) GetAuthConfig() *ConfigurationProto_AuthConfig {
	if m != nil {
		return m.AuthConfig
	}
	return nil
}

func (m *ConfigurationProto) GetVstoreList() []*ConfigurationProto_VStore {
	if m != nil {
		return m.VstoreList
	}
	return nil
}

func (m *ConfigurationProto) GetVirtualStorageTierList() []*ConfigurationProto_VirtualStorageTier {
	if m != nil {
		return m.VirtualStorageTierList
	}
	return nil
}

func (m *ConfigurationProto) GetVstoreUpgradeDone() bool {
	if m != nil && m.VstoreUpgradeDone != nil {
		return *m.VstoreUpgradeDone
	}
	return Default_ConfigurationProto_VstoreUpgradeDone
}

func (m *ConfigurationProto) GetReleaseVersion() string {
	if m != nil && m.ReleaseVersion != nil {
		return *m.ReleaseVersion
	}
	return ""
}

func (m *ConfigurationProto) GetSshKeyList() []*ConfigurationProto_SSHKey {
	if m != nil {
		return m.SshKeyList
	}
	return nil
}

func (m *ConfigurationProto) GetClusterContentCacheFingerprintPct() int32 {
	if m != nil && m.ClusterContentCacheFingerprintPct != nil {
		return *m.ClusterContentCacheFingerprintPct
	}
	return Default_ConfigurationProto_ClusterContentCacheFingerprintPct
}

func (m *ConfigurationProto) GetDisableFingerprinting() bool {
	if m != nil && m.DisableFingerprinting != nil {
		return *m.DisableFingerprinting
	}
	return false
}

func (m *ConfigurationProto) GetDiskTombstoneList() []string {
	if m != nil {
		return m.DiskTombstoneList
	}
	return nil
}

func (m *ConfigurationProto) GetClusterExternalIp() string {
	if m != nil && m.ClusterExternalIp != nil {
		return *m.ClusterExternalIp
	}
	return ""
}

func (m *ConfigurationProto) GetClusterFaultToleranceState() *ConfigurationProto_FaultToleranceState {
	if m != nil {
		return m.ClusterFaultToleranceState
	}
	return nil
}

func (m *ConfigurationProto) GetDomainFaultToleranceState() *zeus.DomainFaultToleranceState {
	if m != nil {
		return m.DomainFaultToleranceState
	}
	return nil
}

func (m *ConfigurationProto) GetRsyslogConfig() *ConfigurationProto_RSyslogConfig {
	if m != nil {
		return m.RsyslogConfig
	}
	return nil
}

func (m *ConfigurationProto) GetShadowClonesEnabled() bool {
	if m != nil && m.ShadowClonesEnabled != nil {
		return *m.ShadowClonesEnabled
	}
	return Default_ConfigurationProto_ShadowClonesEnabled
}

func (m *ConfigurationProto) GetPasswordRemoteLoginEnabled() bool {
	if m != nil && m.PasswordRemoteLoginEnabled != nil {
		return *m.PasswordRemoteLoginEnabled
	}
	return Default_ConfigurationProto_PasswordRemoteLoginEnabled
}

func (m *ConfigurationProto) GetMetadataSnapshotLogicalTimestamp() int64 {
	if m != nil && m.MetadataSnapshotLogicalTimestamp != nil {
		return *m.MetadataSnapshotLogicalTimestamp
	}
	return 0
}

func (m *ConfigurationProto) GetStargateVersion() int32 {
	if m != nil && m.StargateVersion != nil {
		return *m.StargateVersion
	}
	return Default_ConfigurationProto_StargateVersion
}

func (m *ConfigurationProto) GetClusterFunctions() uint32 {
	if m != nil && m.ClusterFunctions != nil {
		return *m.ClusterFunctions
	}
	return Default_ConfigurationProto_ClusterFunctions
}

func (m *ConfigurationProto) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *ConfigurationProto) GetMetadataSnapshotsEnabled() bool {
	if m != nil && m.MetadataSnapshotsEnabled != nil {
		return *m.MetadataSnapshotsEnabled
	}
	return false
}

func (m *ConfigurationProto) GetTimezone() string {
	if m != nil && m.Timezone != nil {
		return *m.Timezone
	}
	return ""
}

func (m *ConfigurationProto) GetDisableOnDiskDedup() bool {
	if m != nil && m.DisableOnDiskDedup != nil {
		return *m.DisableOnDiskDedup
	}
	return false
}

func (m *ConfigurationProto) GetKeyManagementServerList() []*ConfigurationProto_KeyManagementServer {
	if m != nil {
		return m.KeyManagementServerList
	}
	return nil
}

func (m *ConfigurationProto) GetTrustedCertificateAuthorityList() []*ConfigurationProto_CertificateAuthority {
	if m != nil {
		return m.TrustedCertificateAuthorityList
	}
	return nil
}

func (m *ConfigurationProto) GetExtendedNfsFhandleEnabled() bool {
	if m != nil && m.ExtendedNfsFhandleEnabled != nil {
		return *m.ExtendedNfsFhandleEnabled
	}
	return false
}

func (m *ConfigurationProto) GetCloudSiteInfo() *zeus.CloudSiteInfo {
	if m != nil {
		return m.CloudSiteInfo
	}
	return nil
}

func (m *ConfigurationProto) GetCertificationSigningInfo() *ConfigurationProto_CertificationSigningInfo {
	if m != nil {
		return m.CertificationSigningInfo
	}
	return nil
}

func (m *ConfigurationProto) GetRingFixState() *ConfigurationProto_AutoRingFixState {
	if m != nil {
		return m.RingFixState
	}
	return nil
}

func (m *ConfigurationProto) GetDisableCompression() bool {
	if m != nil && m.DisableCompression != nil {
		return *m.DisableCompression
	}
	return false
}

func (m *ConfigurationProto) GetBlockIscsiTargetIps() *ConfigurationProto_BlockIscsiTargetIPs {
	if m != nil {
		return m.BlockIscsiTargetIps
	}
	return nil
}

func (m *ConfigurationProto) GetCuratorScanInfo() *ConfigurationProto_CuratorScanInfo {
	if m != nil {
		return m.CuratorScanInfo
	}
	return nil
}

func (m *ConfigurationProto) GetAcropolisHaConfig() *ConfigurationProto_AcropolisHAConfig {
	if m != nil {
		return m.AcropolisHaConfig
	}
	return nil
}

func (m *ConfigurationProto) GetUseLowerTierToEnforceRuAwarePlacement() bool {
	if m != nil && m.UseLowerTierToEnforceRuAwarePlacement != nil {
		return *m.UseLowerTierToEnforceRuAwarePlacement
	}
	return Default_ConfigurationProto_UseLowerTierToEnforceRuAwarePlacement
}

func (m *ConfigurationProto) GetClickstreamConfig() *ConfigurationProto_ClickstreamConfig {
	if m != nil {
		return m.ClickstreamConfig
	}
	return nil
}

// Deprecated: Do not use.
func (m *ConfigurationProto) GetNccVersion() string {
	if m != nil && m.NccVersion != nil {
		return *m.NccVersion
	}
	return ""
}

func (m *ConfigurationProto) GetCvmSecurityComplianceConfig() *ConfigurationProto_SecurityComplianceConfig {
	if m != nil {
		return m.CvmSecurityComplianceConfig
	}
	return nil
}

func (m *ConfigurationProto) GetCuratorMaintenanceModeConfig() *zeus.PeriodicScheduleConfig {
	if m != nil {
		return m.CuratorMaintenanceModeConfig
	}
	return nil
}

func (m *ConfigurationProto) GetHypervisorSecurityComplianceConfig() *ConfigurationProto_HypervisorSecurityComplianceConfig {
	if m != nil {
		return m.HypervisorSecurityComplianceConfig
	}
	return nil
}

func (m *ConfigurationProto) GetClusterExternalDataServicesIp() string {
	if m != nil && m.ClusterExternalDataServicesIp != nil {
		return *m.ClusterExternalDataServicesIp
	}
	return ""
}

func (m *ConfigurationProto) GetBackplaneNetworkConfig() *ConfigurationProto_NetworkConfig {
	if m != nil {
		return m.BackplaneNetworkConfig
	}
	return nil
}

func (m *ConfigurationProto) GetRdmaNetworkConfig() *ConfigurationProto_NetworkConfig {
	if m != nil {
		return m.RdmaNetworkConfig
	}
	return nil
}

func (m *ConfigurationProto) GetDisableDegradedNodeMonitoring() bool {
	if m != nil && m.DisableDegradedNodeMonitoring != nil {
		return *m.DisableDegradedNodeMonitoring
	}
	return Default_ConfigurationProto_DisableDegradedNodeMonitoring
}

func (m *ConfigurationProto) GetClusterOperationMode() ConfigurationProto_OperationMode {
	if m != nil && m.ClusterOperationMode != nil {
		return *m.ClusterOperationMode
	}
	return Default_ConfigurationProto_ClusterOperationMode
}

func (m *ConfigurationProto) GetCommonCriteriaMode() bool {
	if m != nil && m.CommonCriteriaMode != nil {
		return *m.CommonCriteriaMode
	}
	return Default_ConfigurationProto_CommonCriteriaMode
}

func (m *ConfigurationProto) GetIscsiConfig() *ConfigurationProto_IscsiConfig {
	if m != nil {
		return m.IscsiConfig
	}
	return nil
}

func (m *ConfigurationProto) GetCuratorStargateProtocolConfig() *ConfigurationProto_CuratorStargateProtocolConfig {
	if m != nil {
		return m.CuratorStargateProtocolConfig
	}
	return nil
}

func (m *ConfigurationProto) GetInitializedDedupExtentsTwoPhaseDeletion() bool {
	if m != nil && m.InitializedDedupExtentsTwoPhaseDeletion != nil {
		return *m.InitializedDedupExtentsTwoPhaseDeletion
	}
	return false
}

func (m *ConfigurationProto) GetManagementShareContainerId() int64 {
	if m != nil && m.ManagementShareContainerId != nil {
		return *m.ManagementShareContainerId
	}
	return 0
}

func (m *ConfigurationProto) GetDefaultSspContainerId() int64 {
	if m != nil && m.DefaultSspContainerId != nil {
		return *m.DefaultSspContainerId
	}
	return 0
}

func (m *ConfigurationProto) GetAdsConfig() *ConfigurationProto_AdsConfig {
	if m != nil {
		return m.AdsConfig
	}
	return nil
}

func (m *ConfigurationProto) GetClusterMasqueradingIp() string {
	if m != nil && m.ClusterMasqueradingIp != nil {
		return *m.ClusterMasqueradingIp
	}
	return ""
}

func (m *ConfigurationProto) GetClusterMasqueradingPort() int32 {
	if m != nil && m.ClusterMasqueradingPort != nil {
		return *m.ClusterMasqueradingPort
	}
	return 0
}

func (m *ConfigurationProto) GetPauseEcEncodeContainersList() []int64 {
	if m != nil {
		return m.PauseEcEncodeContainersList
	}
	return nil
}

func (m *ConfigurationProto) GetEntityCentricDrEnabled() bool {
	if m != nil && m.EntityCentricDrEnabled != nil {
		return *m.EntityCentricDrEnabled
	}
	return false
}

func (m *ConfigurationProto) GetLwsStoreConfig() *ConfigurationProto_LWSStoreConfig {
	if m != nil {
		return m.LwsStoreConfig
	}
	return nil
}

func (m *ConfigurationProto) GetSspConfigOwner() bool {
	if m != nil && m.SspConfigOwner != nil {
		return *m.SspConfigOwner
	}
	return false
}

func (m *ConfigurationProto) GetFtSupportEnabled() bool {
	if m != nil && m.FtSupportEnabled != nil {
		return *m.FtSupportEnabled
	}
	return Default_ConfigurationProto_FtSupportEnabled
}

func (m *ConfigurationProto) GetNetworkConnectionStatsCollectionEnabled() bool {
	if m != nil && m.NetworkConnectionStatsCollectionEnabled != nil {
		return *m.NetworkConnectionStatsCollectionEnabled
	}
	return Default_ConfigurationProto_NetworkConnectionStatsCollectionEnabled
}

func (m *ConfigurationProto) GetWitnessState() *ConfigurationProto_WitnessState {
	if m != nil {
		return m.WitnessState
	}
	return nil
}

func (m *ConfigurationProto) GetClusterEncryptionParams() *ConfigurationProto_EncryptionParams {
	if m != nil {
		return m.ClusterEncryptionParams
	}
	return nil
}

func (m *ConfigurationProto) GetClusterArch() ConfigurationProto_ClusterArch {
	if m != nil && m.ClusterArch != nil {
		return *m.ClusterArch
	}
	return ConfigurationProto_kX86_64
}

func (m *ConfigurationProto) GetRackList() []*ConfigurationProto_Rack {
	if m != nil {
		return m.RackList
	}
	return nil
}

func (m *ConfigurationProto) GetImageConversionCompleteObelix() bool {
	if m != nil && m.ImageConversionCompleteObelix != nil {
		return *m.ImageConversionCompleteObelix
	}
	return false
}

func (m *ConfigurationProto) GetCatalogChangeOwnerInProgress() bool {
	if m != nil && m.CatalogChangeOwnerInProgress != nil {
		return *m.CatalogChangeOwnerInProgress
	}
	return Default_ConfigurationProto_CatalogChangeOwnerInProgress
}

func (m *ConfigurationProto) GetCatalogPeRegistered() bool {
	if m != nil && m.CatalogPeRegistered != nil {
		return *m.CatalogPeRegistered
	}
	return false
}

func (m *ConfigurationProto) GetAcropolisSchedulerCleanupDone() bool {
	if m != nil && m.AcropolisSchedulerCleanupDone != nil {
		return *m.AcropolisSchedulerCleanupDone
	}
	return false
}

func (m *ConfigurationProto) GetClusterConversionStatus() *ConfigurationProto_ClusterConversionStatus {
	if m != nil {
		return m.ClusterConversionStatus
	}
	return nil
}

func (m *ConfigurationProto) GetComputeNodeList() []*ConfigurationProto_Node {
	if m != nil {
		return m.ComputeNodeList
	}
	return nil
}

func (m *ConfigurationProto) GetStigEnabled() bool {
	if m != nil && m.StigEnabled != nil {
		return *m.StigEnabled
	}
	return Default_ConfigurationProto_StigEnabled
}

// Deprecated: Do not use.
func (m *ConfigurationProto) GetAcropolisBaselineUserMemoryMbX86() uint64 {
	if m != nil && m.AcropolisBaselineUserMemoryMbX86 != nil {
		return *m.AcropolisBaselineUserMemoryMbX86
	}
	return Default_ConfigurationProto_AcropolisBaselineUserMemoryMbX86
}

// Deprecated: Do not use.
func (m *ConfigurationProto) GetAcropolisBaselineKernelMemoryMbX86() uint64 {
	if m != nil && m.AcropolisBaselineKernelMemoryMbX86 != nil {
		return *m.AcropolisBaselineKernelMemoryMbX86
	}
	return Default_ConfigurationProto_AcropolisBaselineKernelMemoryMbX86
}

func (m *ConfigurationProto) GetMemoryReservationsPerComponentList() []*ConfigurationProto_MemoryReservationsPerComponent {
	if m != nil {
		return m.MemoryReservationsPerComponentList
	}
	return nil
}

func (m *ConfigurationProto) GetHypervisorLldpConfig() *ConfigurationProto_HypervisorLldpConfig {
	if m != nil {
		return m.HypervisorLldpConfig
	}
	return nil
}

func (m *ConfigurationProto) GetEidMapEntriesPerNodeDedupThresholdExceeded() bool {
	if m != nil && m.EidMapEntriesPerNodeDedupThresholdExceeded != nil {
		return *m.EidMapEntriesPerNodeDedupThresholdExceeded
	}
	return false
}

func (m *ConfigurationProto) GetCellFqdnList() []string {
	if m != nil {
		return m.CellFqdnList
	}
	return nil
}

func (m *ConfigurationProto) GetCerebroFeaturesBitmap() uint64 {
	if m != nil && m.CerebroFeaturesBitmap != nil {
		return *m.CerebroFeaturesBitmap
	}
	return 0
}

func (m *ConfigurationProto) GetKmsType() ConfigurationProto_KMSType {
	if m != nil && m.KmsType != nil {
		return *m.KmsType
	}
	return Default_ConfigurationProto_KmsType
}

func (m *ConfigurationProto) GetCatalogSubsetMigrationEnabled() bool {
	if m != nil && m.CatalogSubsetMigrationEnabled != nil {
		return *m.CatalogSubsetMigrationEnabled
	}
	return false
}

func (m *ConfigurationProto) GetAcropolisSchedulerHotAddCleanupDone() bool {
	if m != nil && m.AcropolisSchedulerHotAddCleanupDone != nil {
		return *m.AcropolisSchedulerHotAddCleanupDone
	}
	return false
}

func (m *ConfigurationProto) GetAcropolisHaPriorityCleanupDone() bool {
	if m != nil && m.AcropolisHaPriorityCleanupDone != nil {
		return *m.AcropolisHaPriorityCleanupDone
	}
	return false
}

func (m *ConfigurationProto) GetIsLts() bool {
	if m != nil && m.IsLts != nil {
		return *m.IsLts
	}
	return false
}

func (m *ConfigurationProto) GetAesSupportedVersionLogicalTimestamp() int64 {
	if m != nil && m.AesSupportedVersionLogicalTimestamp != nil {
		return *m.AesSupportedVersionLogicalTimestamp
	}
	return 0
}

func (m *ConfigurationProto) GetUseChecksumBasedDedup() bool {
	if m != nil && m.UseChecksumBasedDedup != nil {
		return *m.UseChecksumBasedDedup
	}
	return false
}

func (m *ConfigurationProto) GetClusterFullyQualifiedDomainName() string {
	if m != nil && m.ClusterFullyQualifiedDomainName != nil {
		return *m.ClusterFullyQualifiedDomainName
	}
	return ""
}

func (m *ConfigurationProto) GetEnableEfficientMetricSync() bool {
	if m != nil && m.EnableEfficientMetricSync != nil {
		return *m.EnableEfficientMetricSync
	}
	return false
}

func (m *ConfigurationProto) GetUseScheduler() bool {
	if m != nil && m.UseScheduler != nil {
		return *m.UseScheduler
	}
	return false
}

func (m *ConfigurationProto) GetExternalRepositoryList() []*ConfigurationProto_ExternalRepository {
	if m != nil {
		return m.ExternalRepositoryList
	}
	return nil
}

func (m *ConfigurationProto) GetStargateUpgradeLogicalTimestamp() int64 {
	if m != nil && m.StargateUpgradeLogicalTimestamp != nil {
		return *m.StargateUpgradeLogicalTimestamp
	}
	return 0
}

func (m *ConfigurationProto) GetClusterUsageWarningAlertThresholdPct() int32 {
	if m != nil && m.ClusterUsageWarningAlertThresholdPct != nil {
		return *m.ClusterUsageWarningAlertThresholdPct
	}
	return Default_ConfigurationProto_ClusterUsageWarningAlertThresholdPct
}

func (m *ConfigurationProto) GetClusterUsageCriticalAlertThresholdPct() int32 {
	if m != nil && m.ClusterUsageCriticalAlertThresholdPct != nil {
		return *m.ClusterUsageCriticalAlertThresholdPct
	}
	return Default_ConfigurationProto_ClusterUsageCriticalAlertThresholdPct
}

func (m *ConfigurationProto) GetDedupChecksumCollisionExceeded() bool {
	if m != nil && m.DedupChecksumCollisionExceeded != nil {
		return *m.DedupChecksumCollisionExceeded
	}
	return Default_ConfigurationProto_DedupChecksumCollisionExceeded
}

func (m *ConfigurationProto) GetClusterExternalIpv6() string {
	if m != nil && m.ClusterExternalIpv6 != nil {
		return *m.ClusterExternalIpv6
	}
	return ""
}

func (m *ConfigurationProto) GetClusterCapabilities() *ConfigurationProto_ClusterCapabilities {
	if m != nil {
		return m.ClusterCapabilities
	}
	return nil
}

func (m *ConfigurationProto) GetPreviousClusterExternalIp() string {
	if m != nil && m.PreviousClusterExternalIp != nil {
		return *m.PreviousClusterExternalIp
	}
	return ""
}

func (m *ConfigurationProto) GetPreviousClusterExternalIpv6() string {
	if m != nil && m.PreviousClusterExternalIpv6 != nil {
		return *m.PreviousClusterExternalIpv6
	}
	return ""
}

func (m *ConfigurationProto) GetMultiFileSupportEnabled() bool {
	if m != nil && m.MultiFileSupportEnabled != nil {
		return *m.MultiFileSupportEnabled
	}
	return Default_ConfigurationProto_MultiFileSupportEnabled
}

func (m *ConfigurationProto) GetRecycleBinTtlSecs() int32 {
	if m != nil && m.RecycleBinTtlSecs != nil {
		return *m.RecycleBinTtlSecs
	}
	return Default_ConfigurationProto_RecycleBinTtlSecs
}

func (m *ConfigurationProto) GetAcropolisAgentVmConversionDone() bool {
	if m != nil && m.AcropolisAgentVmConversionDone != nil {
		return *m.AcropolisAgentVmConversionDone
	}
	return false
}

func (m *ConfigurationProto) GetAlertThresholdStorageProvisioning() float64 {
	if m != nil && m.AlertThresholdStorageProvisioning != nil {
		return *m.AlertThresholdStorageProvisioning
	}
	return 0
}

func (m *ConfigurationProto) GetInitialStargateVersion() int32 {
	if m != nil && m.InitialStargateVersion != nil {
		return *m.InitialStargateVersion
	}
	return 0
}

func (m *ConfigurationProto) GetPithosVersionInfo() *pithos.PithosVersionInformation {
	if m != nil {
		return m.PithosVersionInfo
	}
	return nil
}

func (m *ConfigurationProto) GetBlockStoreEnabled() bool {
	if m != nil && m.BlockStoreEnabled != nil {
		return *m.BlockStoreEnabled
	}
	return false
}

func (m *ConfigurationProto) GetExternalV6Subnet() string {
	if m != nil && m.ExternalV6Subnet != nil {
		return *m.ExternalV6Subnet
	}
	return ""
}

func (m *ConfigurationProto) GetDnsConfig() *ConfigurationProto_DnsConfig {
	if m != nil {
		return m.DnsConfig
	}
	return nil
}

func (m *ConfigurationProto) GetFileServerUuid() string {
	if m != nil && m.FileServerUuid != nil {
		return *m.FileServerUuid
	}
	return ""
}

func (m *ConfigurationProto) GetMantleVersion() int32 {
	if m != nil && m.MantleVersion != nil {
		return *m.MantleVersion
	}
	return Default_ConfigurationProto_MantleVersion
}

func (m *ConfigurationProto) GetAhvMemoryModelVersion() int32 {
	if m != nil && m.AhvMemoryModelVersion != nil {
		return *m.AhvMemoryModelVersion
	}
	return 0
}

func (m *ConfigurationProto) GetRf1ContainerEnabled() bool {
	if m != nil && m.Rf1ContainerEnabled != nil {
		return *m.Rf1ContainerEnabled
	}
	return false
}

func (m *ConfigurationProto) GetHibernateState() *ConfigurationProto_ClusterHibernateState {
	if m != nil {
		return m.HibernateState
	}
	return nil
}

func (m *ConfigurationProto) GetRecycleBinState() *ConfigurationProto_RecycleBinState {
	if m != nil {
		return m.RecycleBinState
	}
	return nil
}

// If the serialized configuration reaches more than the maximum allowed size
// of a Zookeeper node, we will break the serialized string into multiple
// chunks and store them in a sequence of Zookeeper nodes. This sequence of
// nodes is given a unique id called the 'chunk_set_id'. A directory under
// the configuration namespace will be created for this set and will be named
// using the chunk_set_id and the logical timestamp associated with the
// configuration.
//
// In this scenario, the Configuration node in Zookeeper will contain only
// the logical timestamp and the SymbolicLink message which could be used to
// find the associated chunks of the Configuration.
type ConfigurationProto_SymbolicLink struct {
	// The unique id that identifies the set of chunks that make up this
	// configuration object.
	ChunkSetId *int64 `protobuf:"varint,1,req,name=chunk_set_id,json=chunkSetId" json:"chunk_set_id,omitempty"`
	// Checksum for the serialized configuration proto to check consistency.
	Checksum *uint32 `protobuf:"varint,2,req,name=checksum" json:"checksum,omitempty"`
	// The number of chunks created for this version of the configuration
	// proto.
	NumChunks            *int32   `protobuf:"varint,3,req,name=num_chunks,json=numChunks" json:"num_chunks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_SymbolicLink) Reset()         { *m = ConfigurationProto_SymbolicLink{} }
func (m *ConfigurationProto_SymbolicLink) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_SymbolicLink) ProtoMessage()    {}
func (*ConfigurationProto_SymbolicLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 0}
}

func (m *ConfigurationProto_SymbolicLink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SymbolicLink.Unmarshal(m, b)
}
func (m *ConfigurationProto_SymbolicLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SymbolicLink.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SymbolicLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SymbolicLink.Merge(m, src)
}
func (m *ConfigurationProto_SymbolicLink) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SymbolicLink.Size(m)
}
func (m *ConfigurationProto_SymbolicLink) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SymbolicLink.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SymbolicLink proto.InternalMessageInfo

func (m *ConfigurationProto_SymbolicLink) GetChunkSetId() int64 {
	if m != nil && m.ChunkSetId != nil {
		return *m.ChunkSetId
	}
	return 0
}

func (m *ConfigurationProto_SymbolicLink) GetChecksum() uint32 {
	if m != nil && m.Checksum != nil {
		return *m.Checksum
	}
	return 0
}

func (m *ConfigurationProto_SymbolicLink) GetNumChunks() int32 {
	if m != nil && m.NumChunks != nil {
		return *m.NumChunks
	}
	return 0
}

// The various storage tiers. These are defined by the admin and then set
// in the configuration. By default, the Nutanix software defines the tiers
// "SSD", "DAS", "SAN", and "CLOUD". The admin can add to these tiers.
type ConfigurationProto_StorageTier struct {
	// Globally unique name assigned to the storage tier (by Admin).
	StorageTierName *string `protobuf:"bytes,1,req,name=storage_tier_name,json=storageTierName" json:"storage_tier_name,omitempty"`
	// The default random IO priority assigned to this storage tier (by Admin).
	// This can be overridden at the container level. Higher value indicates
	// higher priority.
	RandomIoPriority *int32 `protobuf:"varint,2,req,name=random_io_priority,json=randomIoPriority" json:"random_io_priority,omitempty"`
	// The default sequential IO priority assigned to this storage tier
	// (by Admin). This can be overridden at the container level. Higher
	// value indicates higher priority.
	SequentialIoPriority *int32                                      `protobuf:"varint,3,req,name=sequential_io_priority,json=sequentialIoPriority" json:"sequential_io_priority,omitempty"`
	StorageType          *ConfigurationProto_StorageTier_StorageType `protobuf:"varint,4,opt,name=storage_type,json=storageType,enum=nutanix.zeus.ConfigurationProto_StorageTier_StorageType" json:"storage_type,omitempty"`
	// Flag to denote whether this storage tier has been deleted through UI.
	Deleted *bool `protobuf:"varint,5,opt,name=deleted" json:"deleted,omitempty"`
	// Maximum size as percentage of total tier capacity until which pinning
	// configuration is allowed.
	MaxAllowedPinnedConfigPct *int32 `protobuf:"varint,6,opt,name=max_allowed_pinned_config_pct,json=maxAllowedPinnedConfigPct,def=25" json:"max_allowed_pinned_config_pct,omitempty"`
	// Maximum size as percentage of total tier capacity allowed for pinning.
	// Any usage above this threshold is eligible for down migration.
	MaxAllowedPinnedUsagePct *int32   `protobuf:"varint,7,opt,name=max_allowed_pinned_usage_pct,json=maxAllowedPinnedUsagePct,def=50" json:"max_allowed_pinned_usage_pct,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *ConfigurationProto_StorageTier) Reset()         { *m = ConfigurationProto_StorageTier{} }
func (m *ConfigurationProto_StorageTier) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_StorageTier) ProtoMessage()    {}
func (*ConfigurationProto_StorageTier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 1}
}

func (m *ConfigurationProto_StorageTier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_StorageTier.Unmarshal(m, b)
}
func (m *ConfigurationProto_StorageTier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_StorageTier.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_StorageTier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_StorageTier.Merge(m, src)
}
func (m *ConfigurationProto_StorageTier) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_StorageTier.Size(m)
}
func (m *ConfigurationProto_StorageTier) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_StorageTier.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_StorageTier proto.InternalMessageInfo

const Default_ConfigurationProto_StorageTier_MaxAllowedPinnedConfigPct int32 = 25
const Default_ConfigurationProto_StorageTier_MaxAllowedPinnedUsagePct int32 = 50

func (m *ConfigurationProto_StorageTier) GetStorageTierName() string {
	if m != nil && m.StorageTierName != nil {
		return *m.StorageTierName
	}
	return ""
}

func (m *ConfigurationProto_StorageTier) GetRandomIoPriority() int32 {
	if m != nil && m.RandomIoPriority != nil {
		return *m.RandomIoPriority
	}
	return 0
}

func (m *ConfigurationProto_StorageTier) GetSequentialIoPriority() int32 {
	if m != nil && m.SequentialIoPriority != nil {
		return *m.SequentialIoPriority
	}
	return 0
}

func (m *ConfigurationProto_StorageTier) GetStorageType() ConfigurationProto_StorageTier_StorageType {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return ConfigurationProto_StorageTier_kPcieSSD
}

func (m *ConfigurationProto_StorageTier) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *ConfigurationProto_StorageTier) GetMaxAllowedPinnedConfigPct() int32 {
	if m != nil && m.MaxAllowedPinnedConfigPct != nil {
		return *m.MaxAllowedPinnedConfigPct
	}
	return Default_ConfigurationProto_StorageTier_MaxAllowedPinnedConfigPct
}

func (m *ConfigurationProto_StorageTier) GetMaxAllowedPinnedUsagePct() int32 {
	if m != nil && m.MaxAllowedPinnedUsagePct != nil {
		return *m.MaxAllowedPinnedUsagePct
	}
	return Default_ConfigurationProto_StorageTier_MaxAllowedPinnedUsagePct
}

// An actual physical disk and its associated parameters.
type ConfigurationProto_Disk struct {
	// The globally unique id assigned to this disk.
	DiskId *int64 `protobuf:"varint,1,req,name=disk_id,json=diskId" json:"disk_id,omitempty"`
	// The unique id of the service VM at which this disk is mounted. If
	// not set, then this disk is not currently known to be mounted anywhere -
	// although it was mounted at some service VM in the past (which is how we
	// learnt about it in the first place).
	ServiceVmId *int64 `protobuf:"varint,2,opt,name=service_vm_id,json=serviceVmId" json:"service_vm_id,omitempty"`
	// If service_vm_id is not set, then the following provides the id of the
	// last service VM where this disk was mounted. One of service_vm_id or
	// last_service_vm_id is always set. Both are never set.
	LastServiceVmId *int64 `protobuf:"varint,3,opt,name=last_service_vm_id,json=lastServiceVmId" json:"last_service_vm_id,omitempty"`
	// The path on service_vm_id (or last_service_vm_id) where the disk is/was
	// mounted.
	MountPath *string `protobuf:"bytes,4,req,name=mount_path,json=mountPath" json:"mount_path,omitempty"`
	// The physical capacity (in bytes) of this disk. This may be set
	// artificially lower than the real size of the disk.
	DiskSize *int64 `protobuf:"varint,5,req,name=disk_size,json=diskSize" json:"disk_size,omitempty"`
	// The physical capacity (in bytes) of this disk as reported by statfs.
	// This is set only if it's different than disk_size.
	StatfsDiskSize *int64 `protobuf:"varint,6,opt,name=statfs_disk_size,json=statfsDiskSize" json:"statfs_disk_size,omitempty"`
	// Storage tier to which this disk belongs.
	StorageTier *string `protobuf:"bytes,7,req,name=storage_tier,json=storageTier" json:"storage_tier,omitempty"`
	// The number of directory sub levels used under the data directory in the
	// disk. This is used to spread around the extent group files among
	// multiple directories. If 0, then there are no subdirectories under the
	// data directory and all extent group files are placed under the data
	// directory directly.
	DataDirSublevels *int32 `protobuf:"varint,8,opt,name=data_dir_sublevels,json=dataDirSublevels" json:"data_dir_sublevels,omitempty"`
	// If data_dir_sublevels is > 0, then the following specifies the number of
	// directories at each sub level.
	DataDirSublevelDirs *int32 `protobuf:"varint,9,opt,name=data_dir_sublevel_dirs,json=dataDirSublevelDirs" json:"data_dir_sublevel_dirs,omitempty"`
	// If true, this is an intent to remove the Disk (after the curator has had
	// a chance to migrate the relevant data from it). Note that the curator
	// itself will not delete a disk from the Zeus config once all the data
	// has been migrated from it - this is because a stargate might later just
	// add that disk right back. Instead, the curator will remove the disk
	// from the corresponding storage pool once all the data has been migrated
	// off of it. Also, it'll set the 'data_migrated' flag to true. See
	// comments below on 'data_migrated'.
	ToRemove            *bool  `protobuf:"varint,10,opt,name=to_remove,json=toRemove" json:"to_remove,omitempty"`
	DataMigrationStatus *int32 `protobuf:"varint,11,opt,name=data_migration_status,json=dataMigrationStatus" json:"data_migration_status,omitempty"`
	// Disk location in a node. The number starts from 1 till n, where n is
	// the number of disks in the node. 1 is the ESX boot disk and it will not
	// be in configuration.proto because ESX boot disk is not attached to SVM.
	// The diagram below shows the disk locations and their numbers, which are
	// labelled on the box.
	// -------------------------------------
	// |  1  |  2  |  3  |  4  |  5  |  6  |
	// -------------------------------------
	DiskLocation *int32 `protobuf:"varint,12,opt,name=disk_location,json=diskLocation" json:"disk_location,omitempty"`
	// If true, then this disk contains data from our metadata store
	// (medusa/Cassandra).
	ContainsMetadata *bool `protobuf:"varint,14,opt,name=contains_metadata,json=containsMetadata" json:"contains_metadata,omitempty"`
	// Amount of space (in bytes) on the disk reserved for the oplog.
	OplogDiskSize *int64 `protobuf:"varint,15,opt,name=oplog_disk_size,json=oplogDiskSize" json:"oplog_disk_size,omitempty"`
	// The IOPS that the disk can deliver.
	IopsRating *int32 `protobuf:"varint,16,opt,name=iops_rating,json=iopsRating" json:"iops_rating,omitempty"`
	// If true, we have converted the ssd_sata storage tier to ssd_pcie for the
	// in-memory version of the Configuration proto. This field will not be set
	// in Zookeeper. This is a quick way for the backend to treat ssd_sata
	// disks as ssd_pcie disks.
	//
	// For some mixed clusters with different Nutanix hardware models, we could
	// have nodes having ssd_pcie disks with no ssd_sata disks, while others
	// would have ssd_sata disks with no ssd_pcie disks. In such a scenario, we
	// will have to consider ssd_disks in a node with no ssd_pcie tiers as the
	// highest tier and treat it similar to the ssd_pcie disks of a node which
	// only has ssd_pcie disks. Otherwise, ILM would move data laterally from
	// the ssd_pcie disks from nodes with ssd_pcie disks to nodes with ssd_sata
	// disks.
	//
	// TODO: We will deprecate this once we create a full blown version of
	// virtual storage tiers.
	SataSsdConvertedToPcieSsd *bool `protobuf:"varint,17,opt,name=sata_ssd_converted_to_pcie_ssd,json=sataSsdConvertedToPcieSsd" json:"sata_ssd_converted_to_pcie_ssd,omitempty"`
	// The ID of the disk that hold this disk's authoritative extent store WAL.
	// If set, then all WAL entries will be written to the provided disk with
	// the desired durability. The ID must correlate to a disk residing on the
	// same node as this disk. If not set, then the disk keeps its master WAL
	// on itself.
	MasterWalDiskId *int64 `protobuf:"varint,18,opt,name=master_wal_disk_id,json=masterWalDiskId" json:"master_wal_disk_id,omitempty"`
	// The ID of the disk that hold this disk's shadow extent store WAL. If
	// set, then all WAL entries will be written *asynchronously* to the
	// provided disk, to be used as a backup in case the master WAL's disk
	// fails. The ID must correlate to a disk residing on the same node as this
	// disk. If not set, then the shadow WAL is unused.
	ShadowWalDiskId *int64 `protobuf:"varint,19,opt,name=shadow_wal_disk_id,json=shadowWalDiskId" json:"shadow_wal_disk_id,omitempty"`
	// Amount of space (in bytes) on the disk reserved for the content cache.
	// This will be set by stargate upon the selection of the disk to host the
	// content cache flash files.
	CcacheDiskSize *int64 `protobuf:"varint,20,opt,name=ccache_disk_size,json=ccacheDiskSize" json:"ccache_disk_size,omitempty"`
	// Disk serial id.
	DiskSerialId *string `protobuf:"bytes,21,opt,name=disk_serial_id,json=diskSerialId" json:"disk_serial_id,omitempty"`
	// Cloud storage that backs this disk. This will be set when the disk is
	// added to zeus configuration through prism ui.
	CloudStoreInfo *zeus.CloudStoreInfo `protobuf:"bytes,22,opt,name=cloud_store_info,json=cloudStoreInfo" json:"cloud_store_info,omitempty"`
	// The self encrypting drive metadata.
	SelfEncryptingDrive *ConfigurationProto_Disk_SelfEncryptingDrive `protobuf:"bytes,23,opt,name=self_encrypting_drive,json=selfEncryptingDrive" json:"self_encrypting_drive,omitempty"`
	// If true, then this disk contains data from our background mapreduce
	// operations done by Curator.
	// Note: There can only be one such disk per node in the cluster.
	// This has been depricated as of NOS 4.5.
	ContainsMapreduceData *bool `protobuf:"varint,24,opt,name=contains_mapreduce_data,json=containsMapreduceData" json:"contains_mapreduce_data,omitempty"`
	// The uuid assigned to this disk.
	DiskUuid *string `protobuf:"bytes,25,opt,name=disk_uuid,json=diskUuid" json:"disk_uuid,omitempty"`
	// Amount of space reserved for Curator. Curator will attempt to stay
	// below this reservation space.
	CuratorDiskReservationBytes *int64 `protobuf:"varint,28,opt,name=curator_disk_reservation_bytes,json=curatorDiskReservationBytes" json:"curator_disk_reservation_bytes,omitempty"`
	// If true, indicates that this disk is the primary disk for the local
	// Curator node.
	IsCuratorPrimary *bool `protobuf:"varint,29,opt,name=is_curator_primary,json=isCuratorPrimary" json:"is_curator_primary,omitempty"`
	// The uuid of the node that this disk is part of.
	NodeUuid *string `protobuf:"bytes,30,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// The uuid of the last node where this disk was mounted.
	LastNodeUuid *string `protobuf:"bytes,31,opt,name=last_node_uuid,json=lastNodeUuid" json:"last_node_uuid,omitempty"`
	// Whether statfs call is supported on the disk. For certain disk types,
	// such as cloud disks, which are not actually mounted on the node and
	// thus statfs based disk usage can not be done, it should be set to
	// false for such disks.
	SupportsStatfs *bool `protobuf:"varint,32,opt,name=supports_statfs,json=supportsStatfs,def=1" json:"supports_statfs,omitempty"`
	// Amount of space (in bytes) on the disk reserved for the LWS store.
	LwsStoreDiskSize *int64 `protobuf:"varint,33,opt,name=lws_store_disk_size,json=lwsStoreDiskSize" json:"lws_store_disk_size,omitempty"`
	// If true, indicates that this disk has been chosen to hold
	// metadata, but does not contain metadata yet. This field and
	// contains_metadata cannot be true at the same time.
	ChosenForMetadata *bool `protobuf:"varint,34,opt,name=chosen_for_metadata,json=chosenForMetadata,def=0" json:"chosen_for_metadata,omitempty"`
	// Amount of space reserved for metadata. Metadata usage can go beyond
	// this initial reservation.
	MetadataDiskReservationBytes *int64                                        `protobuf:"varint,35,opt,name=metadata_disk_reservation_bytes,json=metadataDiskReservationBytes" json:"metadata_disk_reservation_bytes,omitempty"`
	BlockStoreDeviceInfo         *ConfigurationProto_Disk_BlockStoreDeviceInfo `protobuf:"bytes,40,opt,name=block_store_device_info,json=blockStoreDeviceInfo" json:"block_store_device_info,omitempty"`
	// Path to the block device (e.g.: /dev/sdd) corresponding to this disk.
	BlockDevicePath *string `protobuf:"bytes,41,opt,name=block_device_path,json=blockDevicePath" json:"block_device_path,omitempty"`
	// Number of partitions present. If one, it is a Block Store only
	// partition. If two, the first partition is used as an ext4 partition
	// and the second one for BlockStore.
	NumPartitions *int32 `protobuf:"varint,42,opt,name=num_partitions,json=numPartitions,def=1" json:"num_partitions,omitempty"`
	// PCIe address of the disk (currently used for SPDK).
	PcieAddress *string `protobuf:"bytes,43,opt,name=pcie_address,json=pcieAddress" json:"pcie_address,omitempty"`
	// Introduction new attribute self_managed_nvme to determine if the node
	// is VMD capable or not. Ie. NVMe drives are managed by VMD or not
	// If value is true then nvme is backed by vmd otherwise it is false
	// DAS-SATA it is false, PCI if VMD it is true, otherwise false
	SelfManagedNvme      *bool    `protobuf:"varint,44,opt,name=self_managed_nvme,json=selfManagedNvme" json:"self_managed_nvme,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Disk) Reset()         { *m = ConfigurationProto_Disk{} }
func (m *ConfigurationProto_Disk) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Disk) ProtoMessage()    {}
func (*ConfigurationProto_Disk) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 2}
}

func (m *ConfigurationProto_Disk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Disk.Unmarshal(m, b)
}
func (m *ConfigurationProto_Disk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Disk.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Disk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Disk.Merge(m, src)
}
func (m *ConfigurationProto_Disk) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Disk.Size(m)
}
func (m *ConfigurationProto_Disk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Disk.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Disk proto.InternalMessageInfo

const Default_ConfigurationProto_Disk_SupportsStatfs bool = true
const Default_ConfigurationProto_Disk_ChosenForMetadata bool = false
const Default_ConfigurationProto_Disk_NumPartitions int32 = 1

func (m *ConfigurationProto_Disk) GetDiskId() int64 {
	if m != nil && m.DiskId != nil {
		return *m.DiskId
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetServiceVmId() int64 {
	if m != nil && m.ServiceVmId != nil {
		return *m.ServiceVmId
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetLastServiceVmId() int64 {
	if m != nil && m.LastServiceVmId != nil {
		return *m.LastServiceVmId
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetMountPath() string {
	if m != nil && m.MountPath != nil {
		return *m.MountPath
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetDiskSize() int64 {
	if m != nil && m.DiskSize != nil {
		return *m.DiskSize
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetStatfsDiskSize() int64 {
	if m != nil && m.StatfsDiskSize != nil {
		return *m.StatfsDiskSize
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetStorageTier() string {
	if m != nil && m.StorageTier != nil {
		return *m.StorageTier
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetDataDirSublevels() int32 {
	if m != nil && m.DataDirSublevels != nil {
		return *m.DataDirSublevels
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetDataDirSublevelDirs() int32 {
	if m != nil && m.DataDirSublevelDirs != nil {
		return *m.DataDirSublevelDirs
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return false
}

func (m *ConfigurationProto_Disk) GetDataMigrationStatus() int32 {
	if m != nil && m.DataMigrationStatus != nil {
		return *m.DataMigrationStatus
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetDiskLocation() int32 {
	if m != nil && m.DiskLocation != nil {
		return *m.DiskLocation
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetContainsMetadata() bool {
	if m != nil && m.ContainsMetadata != nil {
		return *m.ContainsMetadata
	}
	return false
}

func (m *ConfigurationProto_Disk) GetOplogDiskSize() int64 {
	if m != nil && m.OplogDiskSize != nil {
		return *m.OplogDiskSize
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetIopsRating() int32 {
	if m != nil && m.IopsRating != nil {
		return *m.IopsRating
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetSataSsdConvertedToPcieSsd() bool {
	if m != nil && m.SataSsdConvertedToPcieSsd != nil {
		return *m.SataSsdConvertedToPcieSsd
	}
	return false
}

func (m *ConfigurationProto_Disk) GetMasterWalDiskId() int64 {
	if m != nil && m.MasterWalDiskId != nil {
		return *m.MasterWalDiskId
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetShadowWalDiskId() int64 {
	if m != nil && m.ShadowWalDiskId != nil {
		return *m.ShadowWalDiskId
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetCcacheDiskSize() int64 {
	if m != nil && m.CcacheDiskSize != nil {
		return *m.CcacheDiskSize
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetDiskSerialId() string {
	if m != nil && m.DiskSerialId != nil {
		return *m.DiskSerialId
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetCloudStoreInfo() *zeus.CloudStoreInfo {
	if m != nil {
		return m.CloudStoreInfo
	}
	return nil
}

func (m *ConfigurationProto_Disk) GetSelfEncryptingDrive() *ConfigurationProto_Disk_SelfEncryptingDrive {
	if m != nil {
		return m.SelfEncryptingDrive
	}
	return nil
}

func (m *ConfigurationProto_Disk) GetContainsMapreduceData() bool {
	if m != nil && m.ContainsMapreduceData != nil {
		return *m.ContainsMapreduceData
	}
	return false
}

func (m *ConfigurationProto_Disk) GetDiskUuid() string {
	if m != nil && m.DiskUuid != nil {
		return *m.DiskUuid
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetCuratorDiskReservationBytes() int64 {
	if m != nil && m.CuratorDiskReservationBytes != nil {
		return *m.CuratorDiskReservationBytes
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetIsCuratorPrimary() bool {
	if m != nil && m.IsCuratorPrimary != nil {
		return *m.IsCuratorPrimary
	}
	return false
}

func (m *ConfigurationProto_Disk) GetNodeUuid() string {
	if m != nil && m.NodeUuid != nil {
		return *m.NodeUuid
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetLastNodeUuid() string {
	if m != nil && m.LastNodeUuid != nil {
		return *m.LastNodeUuid
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetSupportsStatfs() bool {
	if m != nil && m.SupportsStatfs != nil {
		return *m.SupportsStatfs
	}
	return Default_ConfigurationProto_Disk_SupportsStatfs
}

func (m *ConfigurationProto_Disk) GetLwsStoreDiskSize() int64 {
	if m != nil && m.LwsStoreDiskSize != nil {
		return *m.LwsStoreDiskSize
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetChosenForMetadata() bool {
	if m != nil && m.ChosenForMetadata != nil {
		return *m.ChosenForMetadata
	}
	return Default_ConfigurationProto_Disk_ChosenForMetadata
}

func (m *ConfigurationProto_Disk) GetMetadataDiskReservationBytes() int64 {
	if m != nil && m.MetadataDiskReservationBytes != nil {
		return *m.MetadataDiskReservationBytes
	}
	return 0
}

func (m *ConfigurationProto_Disk) GetBlockStoreDeviceInfo() *ConfigurationProto_Disk_BlockStoreDeviceInfo {
	if m != nil {
		return m.BlockStoreDeviceInfo
	}
	return nil
}

func (m *ConfigurationProto_Disk) GetBlockDevicePath() string {
	if m != nil && m.BlockDevicePath != nil {
		return *m.BlockDevicePath
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetNumPartitions() int32 {
	if m != nil && m.NumPartitions != nil {
		return *m.NumPartitions
	}
	return Default_ConfigurationProto_Disk_NumPartitions
}

func (m *ConfigurationProto_Disk) GetPcieAddress() string {
	if m != nil && m.PcieAddress != nil {
		return *m.PcieAddress
	}
	return ""
}

func (m *ConfigurationProto_Disk) GetSelfManagedNvme() bool {
	if m != nil && m.SelfManagedNvme != nil {
		return *m.SelfManagedNvme
	}
	return false
}

// Metadata for self encrypting drives.
type ConfigurationProto_Disk_SelfEncryptingDrive struct {
	// Current and tentative password are both needed for fault tolerance
	// during password changes, if a power cycle happens halfway through a
	// password change then half of the disk agents may use one and half the
	// other, so it is necessary to have both in these cases and then try to
	// get back into a consistent state during the next execution. These are
	// each repeated fields since each password is likely stored in multiple
	// key management servers for fault tolerance.
	CurrentPasswordList   []*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig `protobuf:"bytes,1,rep,name=current_password_list,json=currentPasswordList" json:"current_password_list,omitempty"`
	TentativePasswordList []*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig `protobuf:"bytes,2,rep,name=tentative_password_list,json=tentativePasswordList" json:"tentative_password_list,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                                      `json:"-"`
	XXX_unrecognized      []byte                                                        `json:"-"`
	XXX_sizecache         int32                                                         `json:"-"`
}

func (m *ConfigurationProto_Disk_SelfEncryptingDrive) Reset() {
	*m = ConfigurationProto_Disk_SelfEncryptingDrive{}
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Disk_SelfEncryptingDrive) ProtoMessage() {}
func (*ConfigurationProto_Disk_SelfEncryptingDrive) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 2, 0}
}

func (m *ConfigurationProto_Disk_SelfEncryptingDrive) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive.Unmarshal(m, b)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive.Merge(m, src)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive.Size(m)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive proto.InternalMessageInfo

func (m *ConfigurationProto_Disk_SelfEncryptingDrive) GetCurrentPasswordList() []*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig {
	if m != nil {
		return m.CurrentPasswordList
	}
	return nil
}

func (m *ConfigurationProto_Disk_SelfEncryptingDrive) GetTentativePasswordList() []*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig {
	if m != nil {
		return m.TentativePasswordList
	}
	return nil
}

type ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig struct {
	// Unique id assigned to the disk password by the key management
	// server.
	SecretUid *string `protobuf:"bytes,1,opt,name=secret_uid,json=secretUid" json:"secret_uid,omitempty"`
	// Uuid of the key management server where disk password is stored.
	KeyManagementServerUuid *string  `protobuf:"bytes,2,opt,name=key_management_server_uuid,json=keyManagementServerUuid" json:"key_management_server_uuid,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) Reset() {
	*m = ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig{}
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) ProtoMessage() {}
func (*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 2, 0, 0}
}

func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig.Merge(m, src)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig.Size(m)
}
func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig proto.InternalMessageInfo

func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) GetSecretUid() string {
	if m != nil && m.SecretUid != nil {
		return *m.SecretUid
	}
	return ""
}

func (m *ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig) GetKeyManagementServerUuid() string {
	if m != nil && m.KeyManagementServerUuid != nil {
		return *m.KeyManagementServerUuid
	}
	return ""
}

// Message containing information for devices managed by BlockStore.
type ConfigurationProto_Disk_BlockStoreDeviceInfo struct {
	// Whether the disk needs to be formatted with the BlockStore file
	// system on the dedicated block store partition.
	FormatNeeded *bool `protobuf:"varint,1,opt,name=format_needed,json=formatNeeded,def=0" json:"format_needed,omitempty"`
	// The offset in the disk where the BlockStore partition starts.
	StartOffsetBytes *int64 `protobuf:"varint,2,opt,name=start_offset_bytes,json=startOffsetBytes,def=-1" json:"start_offset_bytes,omitempty"`
	// The offset in the disk where the BlockStore partition ends.
	EndOffsetBytes       *int64   `protobuf:"varint,3,opt,name=end_offset_bytes,json=endOffsetBytes,def=-1" json:"end_offset_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) Reset() {
	*m = ConfigurationProto_Disk_BlockStoreDeviceInfo{}
}
func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Disk_BlockStoreDeviceInfo) ProtoMessage() {}
func (*ConfigurationProto_Disk_BlockStoreDeviceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 2, 1}
}

func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Disk_BlockStoreDeviceInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Disk_BlockStoreDeviceInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Disk_BlockStoreDeviceInfo.Merge(m, src)
}
func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Disk_BlockStoreDeviceInfo.Size(m)
}
func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Disk_BlockStoreDeviceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Disk_BlockStoreDeviceInfo proto.InternalMessageInfo

const Default_ConfigurationProto_Disk_BlockStoreDeviceInfo_FormatNeeded bool = false
const Default_ConfigurationProto_Disk_BlockStoreDeviceInfo_StartOffsetBytes int64 = -1
const Default_ConfigurationProto_Disk_BlockStoreDeviceInfo_EndOffsetBytes int64 = -1

func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) GetFormatNeeded() bool {
	if m != nil && m.FormatNeeded != nil {
		return *m.FormatNeeded
	}
	return Default_ConfigurationProto_Disk_BlockStoreDeviceInfo_FormatNeeded
}

func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) GetStartOffsetBytes() int64 {
	if m != nil && m.StartOffsetBytes != nil {
		return *m.StartOffsetBytes
	}
	return Default_ConfigurationProto_Disk_BlockStoreDeviceInfo_StartOffsetBytes
}

func (m *ConfigurationProto_Disk_BlockStoreDeviceInfo) GetEndOffsetBytes() int64 {
	if m != nil && m.EndOffsetBytes != nil {
		return *m.EndOffsetBytes
	}
	return Default_ConfigurationProto_Disk_BlockStoreDeviceInfo_EndOffsetBytes
}

type ConfigurationProto_NetworkEntity struct {
	// ID for the network entity, if the ID is a string.
	IdStr *string `protobuf:"bytes,1,opt,name=id_str,json=idStr" json:"id_str,omitempty"`
	// ID for the network entity, if the ID is an int64.
	IdInt *int64 `protobuf:"varint,2,opt,name=id_int,json=idInt" json:"id_int,omitempty"`
	// The type of the network entity.
	Type *int32 `protobuf:"varint,3,opt,name=type" json:"type,omitempty"`
	// The IP addresses or FQDNs of the network entity.
	// These IP addresses or FQDNs may change over time.
	AddressList []string `protobuf:"bytes,4,rep,name=address_list,json=addressList" json:"address_list,omitempty"`
	// The port on the network entity on which to connect.
	Port *int32 `protobuf:"varint,5,opt,name=port" json:"port,omitempty"`
	// The username to be used to connect to the network entity.
	Username *string `protobuf:"bytes,6,opt,name=username" json:"username,omitempty"`
	// The password to be used to connect to the network entity.
	Password *string `protobuf:"bytes,7,opt,name=password" json:"password,omitempty"`
	// The url that can be used to access the network entity.
	AccessUrl *string                                        `protobuf:"bytes,8,opt,name=access_url,json=accessUrl" json:"access_url,omitempty"`
	Protocol  *ConfigurationProto_NetworkEntity_ProtocolType `protobuf:"varint,9,opt,name=protocol,enum=nutanix.zeus.ConfigurationProto_NetworkEntity_ProtocolType" json:"protocol,omitempty"`
	// List of paths to digital certificates that identify this entity. Digital
	// certificates are stored separately in zookeeper.
	DigitalCertificateZkpathList []string                                     `protobuf:"bytes,10,rep,name=digital_certificate_zkpath_list,json=digitalCertificateZkpathList" json:"digital_certificate_zkpath_list,omitempty"`
	ProxyType                    []ConfigurationProto_NetworkEntity_ProxyType `protobuf:"varint,11,rep,name=proxy_type,json=proxyType,enum=nutanix.zeus.ConfigurationProto_NetworkEntity_ProxyType" json:"proxy_type,omitempty"`
	// Oauth token to access the network entity
	ClientOauthToken     *ConfigurationProto_NetworkEntity_ClientOauthToken `protobuf:"bytes,12,opt,name=client_oauth_token,json=clientOauthToken" json:"client_oauth_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                           `json:"-"`
	XXX_unrecognized     []byte                                             `json:"-"`
	XXX_sizecache        int32                                              `json:"-"`
}

func (m *ConfigurationProto_NetworkEntity) Reset()         { *m = ConfigurationProto_NetworkEntity{} }
func (m *ConfigurationProto_NetworkEntity) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_NetworkEntity) ProtoMessage()    {}
func (*ConfigurationProto_NetworkEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 3}
}

func (m *ConfigurationProto_NetworkEntity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_NetworkEntity.Unmarshal(m, b)
}
func (m *ConfigurationProto_NetworkEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_NetworkEntity.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_NetworkEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_NetworkEntity.Merge(m, src)
}
func (m *ConfigurationProto_NetworkEntity) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_NetworkEntity.Size(m)
}
func (m *ConfigurationProto_NetworkEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_NetworkEntity.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_NetworkEntity proto.InternalMessageInfo

func (m *ConfigurationProto_NetworkEntity) GetIdStr() string {
	if m != nil && m.IdStr != nil {
		return *m.IdStr
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity) GetIdInt() int64 {
	if m != nil && m.IdInt != nil {
		return *m.IdInt
	}
	return 0
}

func (m *ConfigurationProto_NetworkEntity) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *ConfigurationProto_NetworkEntity) GetAddressList() []string {
	if m != nil {
		return m.AddressList
	}
	return nil
}

func (m *ConfigurationProto_NetworkEntity) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *ConfigurationProto_NetworkEntity) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity) GetAccessUrl() string {
	if m != nil && m.AccessUrl != nil {
		return *m.AccessUrl
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity) GetProtocol() ConfigurationProto_NetworkEntity_ProtocolType {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ConfigurationProto_NetworkEntity_kTcp
}

func (m *ConfigurationProto_NetworkEntity) GetDigitalCertificateZkpathList() []string {
	if m != nil {
		return m.DigitalCertificateZkpathList
	}
	return nil
}

func (m *ConfigurationProto_NetworkEntity) GetProxyType() []ConfigurationProto_NetworkEntity_ProxyType {
	if m != nil {
		return m.ProxyType
	}
	return nil
}

func (m *ConfigurationProto_NetworkEntity) GetClientOauthToken() *ConfigurationProto_NetworkEntity_ClientOauthToken {
	if m != nil {
		return m.ClientOauthToken
	}
	return nil
}

type ConfigurationProto_NetworkEntity_ClientOauthToken struct {
	// Required - currently only bearer is supported.
	TokenType *string `protobuf:"bytes,1,opt,name=token_type,json=tokenType" json:"token_type,omitempty"`
	// Required - actual access token for the network entity.
	AccessToken *string `protobuf:"bytes,2,opt,name=access_token,json=accessToken" json:"access_token,omitempty"`
	// Refresh token for the network entity.
	RefreshToken *string `protobuf:"bytes,3,opt,name=refresh_token,json=refreshToken" json:"refresh_token,omitempty"`
	// Required -  token expiration time in seconds.
	ExpiresIn *uint64 `protobuf:"varint,4,opt,name=expires_in,json=expiresIn" json:"expires_in,omitempty"`
	// Required - Scopes for which the token grants.
	Scopes []string `protobuf:"bytes,5,rep,name=scopes" json:"scopes,omitempty"`
	// Required - Cient id of the network entity to assigned the token.
	ClientId *string `protobuf:"bytes,6,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// Required - Cient secret of the network entity to assigned the token.
	ClientSecret         *string  `protobuf:"bytes,7,opt,name=client_secret,json=clientSecret" json:"client_secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) Reset() {
	*m = ConfigurationProto_NetworkEntity_ClientOauthToken{}
}
func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_NetworkEntity_ClientOauthToken) ProtoMessage() {}
func (*ConfigurationProto_NetworkEntity_ClientOauthToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 3, 0}
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_NetworkEntity_ClientOauthToken.Unmarshal(m, b)
}
func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_NetworkEntity_ClientOauthToken.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_NetworkEntity_ClientOauthToken.Merge(m, src)
}
func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_NetworkEntity_ClientOauthToken.Size(m)
}
func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_NetworkEntity_ClientOauthToken.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_NetworkEntity_ClientOauthToken proto.InternalMessageInfo

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetTokenType() string {
	if m != nil && m.TokenType != nil {
		return *m.TokenType
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetAccessToken() string {
	if m != nil && m.AccessToken != nil {
		return *m.AccessToken
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetRefreshToken() string {
	if m != nil && m.RefreshToken != nil {
		return *m.RefreshToken
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetExpiresIn() uint64 {
	if m != nil && m.ExpiresIn != nil {
		return *m.ExpiresIn
	}
	return 0
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetScopes() []string {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *ConfigurationProto_NetworkEntity_ClientOauthToken) GetClientSecret() string {
	if m != nil && m.ClientSecret != nil {
		return *m.ClientSecret
	}
	return ""
}

// Node is the actual server node in a Nutanix appliance.
type ConfigurationProto_Node struct {
	// The globally unique id (within this cluster) assigned to the service VM
	// on this machine. This id also serves to provide an id for this node.
	ServiceVmId *int64 `protobuf:"varint,1,req,name=service_vm_id,json=serviceVmId" json:"service_vm_id,omitempty"`
	// The local IP of the service VM on the external subnet. This IP may
	// change over time if the service VM happens to get a new IP address.
	// However, the service_vm_id won't change.
	ServiceVmExternalIp *string                         `protobuf:"bytes,2,opt,name=service_vm_external_ip,json=serviceVmExternalIp" json:"service_vm_external_ip,omitempty"`
	NodeStatus          *ConfigurationProto_Node_Status `protobuf:"varint,3,opt,name=node_status,json=nodeStatus,enum=nutanix.zeus.ConfigurationProto_Node_Status,def=0" json:"node_status,omitempty"`
	NodeRemovalAck      *int32                          `protobuf:"varint,4,opt,name=node_removal_ack,json=nodeRemovalAck" json:"node_removal_ack,omitempty"`
	// The vzone name that this node belongs to. Only those iSCSI targets will
	// be visible on this node whose corresponding vdisks are assigned to this
	// vzone. If vzone_name is empty, it'll make all those vdisks visible that
	// are not assigned to any vzone.
	VzoneName *string `protobuf:"bytes,5,opt,name=vzone_name,json=vzoneName" json:"vzone_name,omitempty"`
	// The various disk mount paths that have been marked offline on this node.
	// Disks are marked offline when access to them hangs or when other
	// significant problems are detected on them. The disk id at this path
	// may or may not be known. One can match the previous mount_path stored
	// inside various Disk protobufs to figure out which disk it corresponds
	// to.
	//
	// Once a mount path is marked offline, Stargate will not access that
	// path. After it has been repaired, the Zeus config needs to be modified
	// to remove the corresponding path from 'offline_disk_mount_paths'.
	// Once this happens, Stargate will start re-using the disk.
	OfflineDiskMountPaths []string `protobuf:"bytes,6,rep,name=offline_disk_mount_paths,json=offlineDiskMountPaths" json:"offline_disk_mount_paths,omitempty"`
	// Hypervisor key for the host. This will be used to retrieve the host
	// details from the management server.
	HypervisorKey *string `protobuf:"bytes,7,opt,name=hypervisor_key,json=hypervisorKey" json:"hypervisor_key,omitempty"`
	// Hypervisor management server name managing this host.
	// TBD: need to deprecate in favor of management_server_id.
	ManagementServerName *string `protobuf:"bytes,8,opt,name=management_server_name,json=managementServerName" json:"management_server_name,omitempty"`
	// If true, indicates that this node also acts as a broker node in the
	// ActiveMq message broker cluster.
	ActivemqBroker *bool `protobuf:"varint,9,opt,name=activemq_broker,json=activemqBroker" json:"activemq_broker,omitempty"`
	// Local cassandra instance's token id.
	CassandraTokenId *string `protobuf:"bytes,10,opt,name=cassandra_token_id,json=cassandraTokenId" json:"cassandra_token_id,omitempty"`
	// The physical capacity (in bytes) of the disk used by the oplogs on this
	// SVM. This may be set artificially lower than the real size of the disk.
	// If it doesn't exist, then it is assumed to be infinity.
	OplogDiskSize *int64 `protobuf:"varint,11,opt,name=oplog_disk_size,json=oplogDiskSize" json:"oplog_disk_size,omitempty"`
	// The physical capacity (in bytes) of the disk used by the oplogs on
	// this SVM as reported by statfs. This is set only if it's different than
	// disk_size.
	OplogStatfsDiskSize *int64 `protobuf:"varint,12,opt,name=oplog_statfs_disk_size,json=oplogStatfsDiskSize" json:"oplog_statfs_disk_size,omitempty"`
	// The Hypervisor on which this SVM is running.
	// The hypervisor.address_list[0] contains the host external interface
	// address. If network segmentation is enabled, hypervisor.address_list[1]
	// contains the host backplane IP address which is to be used for intra
	// cluster communication.
	Hypervisor *ConfigurationProto_NetworkEntity `protobuf:"bytes,13,opt,name=hypervisor" json:"hypervisor,omitempty"`
	// The IPMI associated with the hardware on which the Hypervisor is
	// running.
	Ipmi *ConfigurationProto_NetworkEntity `protobuf:"bytes,14,opt,name=ipmi" json:"ipmi,omitempty"`
	// If true, indicates that this node should be monitored both by the
	// host agent running on the host and by the remote host monitor.
	// If false, this node will not be monitored by either.
	NeedsMonitoring *bool `protobuf:"varint,15,opt,name=needs_monitoring,json=needsMonitoring,def=1" json:"needs_monitoring,omitempty"`
	// If set, a zookeeper server with this 'myid' (unique ID of the server in
	// the ensemble) should be run on the service VM of this node.
	ZookeeperMyid *int32 `protobuf:"varint,16,opt,name=zookeeper_myid,json=zookeeperMyid" json:"zookeeper_myid,omitempty"`
	// Globally unique identifier that identifies this node across
	// all clusters. This ID is what Genesis will use to check if it should
	// try to join this cluster.
	Uuid *string `protobuf:"bytes,17,opt,name=uuid" json:"uuid,omitempty"`
	// The id of the rackable unit that the node resides in.
	RackableUnitId *int64 `protobuf:"varint,18,opt,name=rackable_unit_id,json=rackableUnitId" json:"rackable_unit_id,omitempty"`
	// Node position in a rackable unit. Interpretation of this number depends
	// on the model of this rackable unit.
	// For example, on NX-3000, node_position can be interpreted directly, but
	// on NX-2000, the integer values in node_position should be interpreted as
	//   1: Node A
	//   2: Node B
	//   3: Node C
	//   4: Node D
	NodePosition *int32 `protobuf:"varint,19,opt,name=node_position,json=nodePosition" json:"node_position,omitempty"`
	// If the node is in maintenance mode then genesis should stop services on
	// it and keep them down.
	MaintenanceMode *bool `protobuf:"varint,20,opt,name=maintenance_mode,json=maintenanceMode" json:"maintenance_mode,omitempty"`
	// If the above flag is true, then reason(s) why this node was put in
	// maintenance mode. If it is non-empty, then an alert will be raised.
	// If an alert is undesired, then only the above flag should be set and
	// the reason should not be specified.
	ReasonForMaintenanceModeList []string                                 `protobuf:"bytes,21,rep,name=reason_for_maintenance_mode_list,json=reasonForMaintenanceModeList" json:"reason_for_maintenance_mode_list,omitempty"`
	CassandraStatus              *ConfigurationProto_Node_CassandraStatus `protobuf:"varint,22,opt,name=cassandra_status,json=cassandraStatus,enum=nutanix.zeus.ConfigurationProto_Node_CassandraStatus,def=0" json:"cassandra_status,omitempty"`
	// Reason for cassandra not running in normal mode. Valid only when the
	// above status is different than kNormalMode.
	// This field is deprecated and should not be used.
	// 'cassandra_status_history' now holds information about history of
	// Cassandra node's status.
	CassandraStatusReason []string `protobuf:"bytes,23,rep,name=cassandra_status_reason,json=cassandraStatusReason" json:"cassandra_status_reason,omitempty"`
	// Software version installed on this node.
	SoftwareVersion *string `protobuf:"bytes,24,opt,name=software_version,json=softwareVersion" json:"software_version,omitempty"`
	// Node serial number.
	NodeSerial *string `protobuf:"bytes,25,opt,name=node_serial,json=nodeSerial" json:"node_serial,omitempty"`
	// Node hardware configuration zookeeper path.
	HardwareConfig *string `protobuf:"bytes,26,opt,name=hardware_config,json=hardwareConfig" json:"hardware_config,omitempty"`
	// This field is deprecated.
	// Its purpose was to identify the disk that was being used for oplog prior
	// to multi disk oplog support.
	DefaultOplogDiskId *int64 `protobuf:"varint,27,opt,name=default_oplog_disk_id,json=defaultOplogDiskId" json:"default_oplog_disk_id,omitempty"` // Deprecated: Do not use.
	// ID of management server, to look up 'management_server_list'.
	ManagementServerId *int64 `protobuf:"varint,28,opt,name=management_server_id,json=managementServerId" json:"management_server_id,omitempty"`
	// Count of the number of times this node missed acknowledging a cassandra
	// ring change. If this gets incremented while cassandra is running,
	// cassandra is shutdown and restarted and the Cassandra ring state is
	// tallied with node state in zeus config. This field is deprecated after
	// we moved to heartbeat and should no longer be used.
	CassandraMissedRingChangesCtr *int64 `protobuf:"varint,29,opt,name=cassandra_missed_ring_changes_ctr,json=cassandraMissedRingChangesCtr,def=0" json:"cassandra_missed_ring_changes_ctr,omitempty"` // Deprecated: Do not use.
	// History of Cassandra node additions and removals. The latest state
	// change information is added at the end of the list.
	CassandraStatusHistory []*ConfigurationProto_Node_CassandraStatusHistory `protobuf:"bytes,30,rep,name=cassandra_status_history,json=cassandraStatusHistory" json:"cassandra_status_history,omitempty"`
	// If true, Cassandra on this node will not automatically be marked to be
	// added back to the ring.
	CassandraAutoAddDisabled *bool `protobuf:"varint,31,opt,name=cassandra_auto_add_disabled,json=cassandraAutoAddDisabled,def=0" json:"cassandra_auto_add_disabled,omitempty"`
	// If true, Cassandra on this node will not automatically be marked to be
	// detached from the ring.
	CassandraAutoDetachDisabled *bool `protobuf:"varint,32,opt,name=cassandra_auto_detach_disabled,json=cassandraAutoDetachDisabled,def=0" json:"cassandra_auto_detach_disabled,omitempty"`
	// One or more ca-signed digital certificates that identify this
	// node. Digital certificates are stored separately in zookeeper.
	DigitalCertificateZkpathList []string `protobuf:"bytes,33,rep,name=digital_certificate_zkpath_list,json=digitalCertificateZkpathList" json:"digital_certificate_zkpath_list,omitempty"`
	// Path to zookeeper node where this node's 'Certificate Signing Request'
	// (aka CSR) is stored.
	SvmCertificateSigningRequestZkpath *string `protobuf:"bytes,34,opt,name=svm_certificate_signing_request_zkpath,json=svmCertificateSigningRequestZkpath" json:"svm_certificate_signing_request_zkpath,omitempty"`
	// Status of the Acropolis node that indicates whether Acropolis is normal
	// or entering/entered into maintenance mode.
	AcropolisStatus           *ConfigurationProto_Node_AcropolisStatus         `protobuf:"bytes,35,opt,name=acropolis_status,json=acropolisStatus" json:"acropolis_status,omitempty"`
	DigitalCertificateMapList []*ConfigurationProto_Node_DigitalCertificateMap `protobuf:"bytes,36,rep,name=digital_certificate_map_list,json=digitalCertificateMapList" json:"digital_certificate_map_list,omitempty"`
	// This field is deprecated after addition of multiple metadata disks
	// support.
	// disk_id of the current metadata disk as seen by Cassandra on this
	// node. If the metadata disk id on this node doesn't match the disk id
	// below, then this indicates that the metadata disk on the node was
	// replaced. The metadata disk replacement procedure is required to fix the
	// metadata in such a case.
	LastKnownMetadataDiskId *int64 `protobuf:"varint,37,opt,name=last_known_metadata_disk_id,json=lastKnownMetadataDiskId,def=-1" json:"last_known_metadata_disk_id,omitempty"` // Deprecated: Do not use.
	// Set to 'true' on all nodes where major compaction needs to be
	// performed. cassandra_monitor is expected to set it to 'false' once the
	// compactions are finished.
	CassandraCompactionPending *bool `protobuf:"varint,38,opt,name=cassandra_compaction_pending,json=cassandraCompactionPending,def=0" json:"cassandra_compaction_pending,omitempty"`
	// The globally unique uuid for cluster.
	ClusterUuid *string `protobuf:"bytes,40,opt,name=cluster_uuid,json=clusterUuid" json:"cluster_uuid,omitempty"`
	// The UUID of the rackable unit that the node resides in.
	RackableUnitUuid *string `protobuf:"bytes,41,opt,name=rackable_unit_uuid,json=rackableUnitUuid" json:"rackable_unit_uuid,omitempty"`
	// The UUID of the management server.
	ManagementServerUuid *string `protobuf:"bytes,42,opt,name=management_server_uuid,json=managementServerUuid" json:"management_server_uuid,omitempty"`
	// Added to accomodate FEAT-1627 (Licensing S/W Only support).  This
	// attribute will be set to a given license class which is supplied
	// via the hardware layout file during imaging.
	LicenseClass *string `protobuf:"bytes,43,opt,name=license_class,json=licenseClass" json:"license_class,omitempty"`
	// Latest logical_timestamp of the cassandra schema that has been processed
	// by Cassandra on this node.
	CassandraSchemaTimestamp *int64 `protobuf:"varint,44,opt,name=cassandra_schema_timestamp,json=cassandraSchemaTimestamp,def=-1" json:"cassandra_schema_timestamp,omitempty"`
	// If true, indicates that the node is degraded and services on the node
	// might be alive but not making progress.
	IsDegraded *bool `protobuf:"varint,45,opt,name=is_degraded,json=isDegraded" json:"is_degraded,omitempty"`
	// The IP of the controller VM interface eth2 on the cluster backplane
	// network. This is used for communication with CVM or host of other nodes
	// in the cluster.
	ControllerVmBackplaneIp *string `protobuf:"bytes,46,opt,name=controller_vm_backplane_ip,json=controllerVmBackplaneIp" json:"controller_vm_backplane_ip,omitempty"`
	// Do not use this node for automatic placement of ABS iSCSI sessions.
	// User can still set preferred_svm_id to this node.
	ExcludeAbs *bool `protobuf:"varint,47,opt,name=exclude_abs,json=excludeAbs" json:"exclude_abs,omitempty"`
	// This is current resource state of the cvm.
	// Note: Certain features which depend on availability of adequate
	// resources in the CVMs in the cluster can use this information
	// to make decisions.
	CvmResourceState *ConfigurationProto_Node_CvmResourceState `protobuf:"bytes,48,opt,name=cvm_resource_state,json=cvmResourceState" json:"cvm_resource_state,omitempty"`
	// The IP address(es) of RDMA devices used to communicate among nodes in
	// the cluster.
	RdmaBackplaneIps []string `protobuf:"bytes,49,rep,name=rdma_backplane_ips,json=rdmaBackplaneIps" json:"rdma_backplane_ips,omitempty"`
	// UUID for the node, this is intended to be only populated for our
	// uvm clusters such as PC.
	UhuraUvmUuid *string `protobuf:"bytes,50,opt,name=uhura_uvm_uuid,json=uhuraUvmUuid" json:"uhura_uvm_uuid,omitempty"`
	// The NAT IP of the service VM maps to the service VM external IP.
	ServiceVmNatIp *string `protobuf:"bytes,51,opt,name=service_vm_nat_ip,json=serviceVmNatIp" json:"service_vm_nat_ip,omitempty"`
	// The NAT port of the service VM.
	ServiceVmNatPort *int32                                  `protobuf:"varint,52,opt,name=service_vm_nat_port,json=serviceVmNatPort" json:"service_vm_nat_port,omitempty"`
	NodeType         *ConfigurationProto_Node_NodeType       `protobuf:"varint,53,opt,name=node_type,json=nodeType,enum=nutanix.zeus.ConfigurationProto_Node_NodeType,def=1" json:"node_type,omitempty"`
	FoundationInfo   *ConfigurationProto_Node_FoundationInfo `protobuf:"bytes,54,opt,name=foundation_info,json=foundationInfo" json:"foundation_info,omitempty"`
	// Timestamp when the node entered 'maintenance_mode'.
	MaintenanceModeStatusChangeTimestamp *int64 `protobuf:"varint,55,opt,name=maintenance_mode_status_change_timestamp,json=maintenanceModeStatusChangeTimestamp" json:"maintenance_mode_status_change_timestamp,omitempty"`
	// Information about node's secure boot state, set to true
	// if secure boot is enabled in UEFI, and false otherwise.
	IsSecureBooted       *bool                                    `protobuf:"varint,56,opt,name=is_secure_booted,json=isSecureBooted,def=0" json:"is_secure_booted,omitempty"`
	PlannedOutageHistory []*ConfigurationProto_Node_PlannedOutage `protobuf:"bytes,57,rep,name=planned_outage_history,json=plannedOutageHistory" json:"planned_outage_history,omitempty"`
	// Going forward we may have multiple external IPs per node. For example in
	// a dual IP stack cluster, we will have one IPv4 and one IPv6 external IP
	// per SVM. service_vm_external_ip singleton is still present for backward
	// compatibility.
	SvmExternalIpList []string `protobuf:"bytes,58,rep,name=svm_external_ip_list,json=svmExternalIpList" json:"svm_external_ip_list,omitempty"`
	// Same goes for multiple external hypervisor IPs.
	HostExternalIpList []string `protobuf:"bytes,59,rep,name=host_external_ip_list,json=hostExternalIpList" json:"host_external_ip_list,omitempty"`
	// Timestamp(in seconds) to indicate when the node became part of the
	// cluster.
	NodeConfiguredTime   *int64   `protobuf:"varint,60,opt,name=node_configured_time,json=nodeConfiguredTime" json:"node_configured_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Node) Reset()         { *m = ConfigurationProto_Node{} }
func (m *ConfigurationProto_Node) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Node) ProtoMessage()    {}
func (*ConfigurationProto_Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4}
}

func (m *ConfigurationProto_Node) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node.Merge(m, src)
}
func (m *ConfigurationProto_Node) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node.Size(m)
}
func (m *ConfigurationProto_Node) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node proto.InternalMessageInfo

const Default_ConfigurationProto_Node_NodeStatus ConfigurationProto_Node_Status = ConfigurationProto_Node_kNormal
const Default_ConfigurationProto_Node_NeedsMonitoring bool = true
const Default_ConfigurationProto_Node_CassandraStatus ConfigurationProto_Node_CassandraStatus = ConfigurationProto_Node_kNormalMode
const Default_ConfigurationProto_Node_CassandraMissedRingChangesCtr int64 = 0
const Default_ConfigurationProto_Node_CassandraAutoAddDisabled bool = false
const Default_ConfigurationProto_Node_CassandraAutoDetachDisabled bool = false
const Default_ConfigurationProto_Node_LastKnownMetadataDiskId int64 = -1
const Default_ConfigurationProto_Node_CassandraCompactionPending bool = false
const Default_ConfigurationProto_Node_CassandraSchemaTimestamp int64 = -1
const Default_ConfigurationProto_Node_NodeType ConfigurationProto_Node_NodeType = ConfigurationProto_Node_kRegular
const Default_ConfigurationProto_Node_IsSecureBooted bool = false

func (m *ConfigurationProto_Node) GetServiceVmId() int64 {
	if m != nil && m.ServiceVmId != nil {
		return *m.ServiceVmId
	}
	return 0
}

func (m *ConfigurationProto_Node) GetServiceVmExternalIp() string {
	if m != nil && m.ServiceVmExternalIp != nil {
		return *m.ServiceVmExternalIp
	}
	return ""
}

func (m *ConfigurationProto_Node) GetNodeStatus() ConfigurationProto_Node_Status {
	if m != nil && m.NodeStatus != nil {
		return *m.NodeStatus
	}
	return Default_ConfigurationProto_Node_NodeStatus
}

func (m *ConfigurationProto_Node) GetNodeRemovalAck() int32 {
	if m != nil && m.NodeRemovalAck != nil {
		return *m.NodeRemovalAck
	}
	return 0
}

func (m *ConfigurationProto_Node) GetVzoneName() string {
	if m != nil && m.VzoneName != nil {
		return *m.VzoneName
	}
	return ""
}

func (m *ConfigurationProto_Node) GetOfflineDiskMountPaths() []string {
	if m != nil {
		return m.OfflineDiskMountPaths
	}
	return nil
}

func (m *ConfigurationProto_Node) GetHypervisorKey() string {
	if m != nil && m.HypervisorKey != nil {
		return *m.HypervisorKey
	}
	return ""
}

func (m *ConfigurationProto_Node) GetManagementServerName() string {
	if m != nil && m.ManagementServerName != nil {
		return *m.ManagementServerName
	}
	return ""
}

func (m *ConfigurationProto_Node) GetActivemqBroker() bool {
	if m != nil && m.ActivemqBroker != nil {
		return *m.ActivemqBroker
	}
	return false
}

func (m *ConfigurationProto_Node) GetCassandraTokenId() string {
	if m != nil && m.CassandraTokenId != nil {
		return *m.CassandraTokenId
	}
	return ""
}

func (m *ConfigurationProto_Node) GetOplogDiskSize() int64 {
	if m != nil && m.OplogDiskSize != nil {
		return *m.OplogDiskSize
	}
	return 0
}

func (m *ConfigurationProto_Node) GetOplogStatfsDiskSize() int64 {
	if m != nil && m.OplogStatfsDiskSize != nil {
		return *m.OplogStatfsDiskSize
	}
	return 0
}

func (m *ConfigurationProto_Node) GetHypervisor() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.Hypervisor
	}
	return nil
}

func (m *ConfigurationProto_Node) GetIpmi() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.Ipmi
	}
	return nil
}

func (m *ConfigurationProto_Node) GetNeedsMonitoring() bool {
	if m != nil && m.NeedsMonitoring != nil {
		return *m.NeedsMonitoring
	}
	return Default_ConfigurationProto_Node_NeedsMonitoring
}

func (m *ConfigurationProto_Node) GetZookeeperMyid() int32 {
	if m != nil && m.ZookeeperMyid != nil {
		return *m.ZookeeperMyid
	}
	return 0
}

func (m *ConfigurationProto_Node) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *ConfigurationProto_Node) GetRackableUnitId() int64 {
	if m != nil && m.RackableUnitId != nil {
		return *m.RackableUnitId
	}
	return 0
}

func (m *ConfigurationProto_Node) GetNodePosition() int32 {
	if m != nil && m.NodePosition != nil {
		return *m.NodePosition
	}
	return 0
}

func (m *ConfigurationProto_Node) GetMaintenanceMode() bool {
	if m != nil && m.MaintenanceMode != nil {
		return *m.MaintenanceMode
	}
	return false
}

func (m *ConfigurationProto_Node) GetReasonForMaintenanceModeList() []string {
	if m != nil {
		return m.ReasonForMaintenanceModeList
	}
	return nil
}

func (m *ConfigurationProto_Node) GetCassandraStatus() ConfigurationProto_Node_CassandraStatus {
	if m != nil && m.CassandraStatus != nil {
		return *m.CassandraStatus
	}
	return Default_ConfigurationProto_Node_CassandraStatus
}

func (m *ConfigurationProto_Node) GetCassandraStatusReason() []string {
	if m != nil {
		return m.CassandraStatusReason
	}
	return nil
}

func (m *ConfigurationProto_Node) GetSoftwareVersion() string {
	if m != nil && m.SoftwareVersion != nil {
		return *m.SoftwareVersion
	}
	return ""
}

func (m *ConfigurationProto_Node) GetNodeSerial() string {
	if m != nil && m.NodeSerial != nil {
		return *m.NodeSerial
	}
	return ""
}

func (m *ConfigurationProto_Node) GetHardwareConfig() string {
	if m != nil && m.HardwareConfig != nil {
		return *m.HardwareConfig
	}
	return ""
}

// Deprecated: Do not use.
func (m *ConfigurationProto_Node) GetDefaultOplogDiskId() int64 {
	if m != nil && m.DefaultOplogDiskId != nil {
		return *m.DefaultOplogDiskId
	}
	return 0
}

func (m *ConfigurationProto_Node) GetManagementServerId() int64 {
	if m != nil && m.ManagementServerId != nil {
		return *m.ManagementServerId
	}
	return 0
}

// Deprecated: Do not use.
func (m *ConfigurationProto_Node) GetCassandraMissedRingChangesCtr() int64 {
	if m != nil && m.CassandraMissedRingChangesCtr != nil {
		return *m.CassandraMissedRingChangesCtr
	}
	return Default_ConfigurationProto_Node_CassandraMissedRingChangesCtr
}

func (m *ConfigurationProto_Node) GetCassandraStatusHistory() []*ConfigurationProto_Node_CassandraStatusHistory {
	if m != nil {
		return m.CassandraStatusHistory
	}
	return nil
}

func (m *ConfigurationProto_Node) GetCassandraAutoAddDisabled() bool {
	if m != nil && m.CassandraAutoAddDisabled != nil {
		return *m.CassandraAutoAddDisabled
	}
	return Default_ConfigurationProto_Node_CassandraAutoAddDisabled
}

func (m *ConfigurationProto_Node) GetCassandraAutoDetachDisabled() bool {
	if m != nil && m.CassandraAutoDetachDisabled != nil {
		return *m.CassandraAutoDetachDisabled
	}
	return Default_ConfigurationProto_Node_CassandraAutoDetachDisabled
}

func (m *ConfigurationProto_Node) GetDigitalCertificateZkpathList() []string {
	if m != nil {
		return m.DigitalCertificateZkpathList
	}
	return nil
}

func (m *ConfigurationProto_Node) GetSvmCertificateSigningRequestZkpath() string {
	if m != nil && m.SvmCertificateSigningRequestZkpath != nil {
		return *m.SvmCertificateSigningRequestZkpath
	}
	return ""
}

func (m *ConfigurationProto_Node) GetAcropolisStatus() *ConfigurationProto_Node_AcropolisStatus {
	if m != nil {
		return m.AcropolisStatus
	}
	return nil
}

func (m *ConfigurationProto_Node) GetDigitalCertificateMapList() []*ConfigurationProto_Node_DigitalCertificateMap {
	if m != nil {
		return m.DigitalCertificateMapList
	}
	return nil
}

// Deprecated: Do not use.
func (m *ConfigurationProto_Node) GetLastKnownMetadataDiskId() int64 {
	if m != nil && m.LastKnownMetadataDiskId != nil {
		return *m.LastKnownMetadataDiskId
	}
	return Default_ConfigurationProto_Node_LastKnownMetadataDiskId
}

func (m *ConfigurationProto_Node) GetCassandraCompactionPending() bool {
	if m != nil && m.CassandraCompactionPending != nil {
		return *m.CassandraCompactionPending
	}
	return Default_ConfigurationProto_Node_CassandraCompactionPending
}

func (m *ConfigurationProto_Node) GetClusterUuid() string {
	if m != nil && m.ClusterUuid != nil {
		return *m.ClusterUuid
	}
	return ""
}

func (m *ConfigurationProto_Node) GetRackableUnitUuid() string {
	if m != nil && m.RackableUnitUuid != nil {
		return *m.RackableUnitUuid
	}
	return ""
}

func (m *ConfigurationProto_Node) GetManagementServerUuid() string {
	if m != nil && m.ManagementServerUuid != nil {
		return *m.ManagementServerUuid
	}
	return ""
}

func (m *ConfigurationProto_Node) GetLicenseClass() string {
	if m != nil && m.LicenseClass != nil {
		return *m.LicenseClass
	}
	return ""
}

func (m *ConfigurationProto_Node) GetCassandraSchemaTimestamp() int64 {
	if m != nil && m.CassandraSchemaTimestamp != nil {
		return *m.CassandraSchemaTimestamp
	}
	return Default_ConfigurationProto_Node_CassandraSchemaTimestamp
}

func (m *ConfigurationProto_Node) GetIsDegraded() bool {
	if m != nil && m.IsDegraded != nil {
		return *m.IsDegraded
	}
	return false
}

func (m *ConfigurationProto_Node) GetControllerVmBackplaneIp() string {
	if m != nil && m.ControllerVmBackplaneIp != nil {
		return *m.ControllerVmBackplaneIp
	}
	return ""
}

func (m *ConfigurationProto_Node) GetExcludeAbs() bool {
	if m != nil && m.ExcludeAbs != nil {
		return *m.ExcludeAbs
	}
	return false
}

func (m *ConfigurationProto_Node) GetCvmResourceState() *ConfigurationProto_Node_CvmResourceState {
	if m != nil {
		return m.CvmResourceState
	}
	return nil
}

func (m *ConfigurationProto_Node) GetRdmaBackplaneIps() []string {
	if m != nil {
		return m.RdmaBackplaneIps
	}
	return nil
}

func (m *ConfigurationProto_Node) GetUhuraUvmUuid() string {
	if m != nil && m.UhuraUvmUuid != nil {
		return *m.UhuraUvmUuid
	}
	return ""
}

func (m *ConfigurationProto_Node) GetServiceVmNatIp() string {
	if m != nil && m.ServiceVmNatIp != nil {
		return *m.ServiceVmNatIp
	}
	return ""
}

func (m *ConfigurationProto_Node) GetServiceVmNatPort() int32 {
	if m != nil && m.ServiceVmNatPort != nil {
		return *m.ServiceVmNatPort
	}
	return 0
}

func (m *ConfigurationProto_Node) GetNodeType() ConfigurationProto_Node_NodeType {
	if m != nil && m.NodeType != nil {
		return *m.NodeType
	}
	return Default_ConfigurationProto_Node_NodeType
}

func (m *ConfigurationProto_Node) GetFoundationInfo() *ConfigurationProto_Node_FoundationInfo {
	if m != nil {
		return m.FoundationInfo
	}
	return nil
}

func (m *ConfigurationProto_Node) GetMaintenanceModeStatusChangeTimestamp() int64 {
	if m != nil && m.MaintenanceModeStatusChangeTimestamp != nil {
		return *m.MaintenanceModeStatusChangeTimestamp
	}
	return 0
}

func (m *ConfigurationProto_Node) GetIsSecureBooted() bool {
	if m != nil && m.IsSecureBooted != nil {
		return *m.IsSecureBooted
	}
	return Default_ConfigurationProto_Node_IsSecureBooted
}

func (m *ConfigurationProto_Node) GetPlannedOutageHistory() []*ConfigurationProto_Node_PlannedOutage {
	if m != nil {
		return m.PlannedOutageHistory
	}
	return nil
}

func (m *ConfigurationProto_Node) GetSvmExternalIpList() []string {
	if m != nil {
		return m.SvmExternalIpList
	}
	return nil
}

func (m *ConfigurationProto_Node) GetHostExternalIpList() []string {
	if m != nil {
		return m.HostExternalIpList
	}
	return nil
}

func (m *ConfigurationProto_Node) GetNodeConfiguredTime() int64 {
	if m != nil && m.NodeConfiguredTime != nil {
		return *m.NodeConfiguredTime
	}
	return 0
}

type ConfigurationProto_Node_CassandraStatusHistory struct {
	// The cassandra_status in the past.
	CassandraStatus *ConfigurationProto_Node_CassandraStatus `protobuf:"varint,1,opt,name=cassandra_status,json=cassandraStatus,enum=nutanix.zeus.ConfigurationProto_Node_CassandraStatus" json:"cassandra_status,omitempty"`
	// Reason (source) for cassandra status above.
	StateChangeSource *ConfigurationProto_Node_CassandraStateChangeSource `protobuf:"varint,2,opt,name=state_change_source,json=stateChangeSource,enum=nutanix.zeus.ConfigurationProto_Node_CassandraStateChangeSource,def=0" json:"state_change_source,omitempty"`
	// svm_id of the node that set this status.
	SvmIdSourceOfStatusChange *int64 `protobuf:"varint,3,opt,name=svm_id_source_of_status_change,json=svmIdSourceOfStatusChange" json:"svm_id_source_of_status_change,omitempty"`
	// Timestamp for last cassandra status change.
	CassandraStatusChangeTimestamp *int64 `protobuf:"varint,4,opt,name=cassandra_status_change_timestamp,json=cassandraStatusChangeTimestamp" json:"cassandra_status_change_timestamp,omitempty"`
	// Cassandra token for the node. Only set when the cassandra_status
	// is kNormalMode.
	CassandraTokenId     *string  `protobuf:"bytes,5,opt,name=cassandra_token_id,json=cassandraTokenId" json:"cassandra_token_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Node_CassandraStatusHistory) Reset() {
	*m = ConfigurationProto_Node_CassandraStatusHistory{}
}
func (m *ConfigurationProto_Node_CassandraStatusHistory) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Node_CassandraStatusHistory) ProtoMessage() {}
func (*ConfigurationProto_Node_CassandraStatusHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 0}
}

func (m *ConfigurationProto_Node_CassandraStatusHistory) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node_CassandraStatusHistory.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node_CassandraStatusHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node_CassandraStatusHistory.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node_CassandraStatusHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node_CassandraStatusHistory.Merge(m, src)
}
func (m *ConfigurationProto_Node_CassandraStatusHistory) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node_CassandraStatusHistory.Size(m)
}
func (m *ConfigurationProto_Node_CassandraStatusHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node_CassandraStatusHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node_CassandraStatusHistory proto.InternalMessageInfo

const Default_ConfigurationProto_Node_CassandraStatusHistory_StateChangeSource ConfigurationProto_Node_CassandraStateChangeSource = ConfigurationProto_Node_kDynamicRingChanger

func (m *ConfigurationProto_Node_CassandraStatusHistory) GetCassandraStatus() ConfigurationProto_Node_CassandraStatus {
	if m != nil && m.CassandraStatus != nil {
		return *m.CassandraStatus
	}
	return ConfigurationProto_Node_kNormalMode
}

func (m *ConfigurationProto_Node_CassandraStatusHistory) GetStateChangeSource() ConfigurationProto_Node_CassandraStateChangeSource {
	if m != nil && m.StateChangeSource != nil {
		return *m.StateChangeSource
	}
	return Default_ConfigurationProto_Node_CassandraStatusHistory_StateChangeSource
}

func (m *ConfigurationProto_Node_CassandraStatusHistory) GetSvmIdSourceOfStatusChange() int64 {
	if m != nil && m.SvmIdSourceOfStatusChange != nil {
		return *m.SvmIdSourceOfStatusChange
	}
	return 0
}

func (m *ConfigurationProto_Node_CassandraStatusHistory) GetCassandraStatusChangeTimestamp() int64 {
	if m != nil && m.CassandraStatusChangeTimestamp != nil {
		return *m.CassandraStatusChangeTimestamp
	}
	return 0
}

func (m *ConfigurationProto_Node_CassandraStatusHistory) GetCassandraTokenId() string {
	if m != nil && m.CassandraTokenId != nil {
		return *m.CassandraTokenId
	}
	return ""
}

type ConfigurationProto_Node_AcropolisStatus struct {
	NodeState *ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState `protobuf:"varint,1,opt,name=node_state,json=nodeState,enum=nutanix.zeus.ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState,def=1" json:"node_state,omitempty"`
	// Unique, monotonically increasing id used to serialize changes to the
	// Acropolis status.
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=1" json:"logical_timestamp,omitempty"`
	// Only set when node_state is kHAFailoverTarget.  The UUID of the
	// source host for the failover.
	FailoverSourceHostUuid *string `protobuf:"bytes,3,opt,name=failover_source_host_uuid,json=failoverSourceHostUuid" json:"failover_source_host_uuid,omitempty"`
	// Previous status of the node.  Used by HA-related tasks.
	PreviousNodeState *ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState       `protobuf:"varint,4,opt,name=previous_node_state,json=previousNodeState,enum=nutanix.zeus.ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState" json:"previous_node_state,omitempty"`
	ConnState         *ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState `protobuf:"varint,5,opt,name=conn_state,json=connState,enum=nutanix.zeus.ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState" json:"conn_state,omitempty"`
	// If False, it indicates a host has exited maintenance mode and will be
	// reset to True after restore locality task completes.
	LocalityRestored *bool `protobuf:"varint,6,opt,name=locality_restored,json=localityRestored,def=1" json:"locality_restored,omitempty"`
	// Whether hardware virtualization is enabled.
	IsHardwareVirtualized *bool `protobuf:"varint,7,opt,name=is_hardware_virtualized,json=isHardwareVirtualized" json:"is_hardware_virtualized,omitempty"`
	// Whether the CVM on this Acropolis node is in maintenance mode.
	CvmMaintenance       *bool    `protobuf:"varint,8,opt,name=cvm_maintenance,json=cvmMaintenance" json:"cvm_maintenance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Node_AcropolisStatus) Reset() {
	*m = ConfigurationProto_Node_AcropolisStatus{}
}
func (m *ConfigurationProto_Node_AcropolisStatus) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Node_AcropolisStatus) ProtoMessage()    {}
func (*ConfigurationProto_Node_AcropolisStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 1}
}

func (m *ConfigurationProto_Node_AcropolisStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node_AcropolisStatus.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node_AcropolisStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node_AcropolisStatus.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node_AcropolisStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node_AcropolisStatus.Merge(m, src)
}
func (m *ConfigurationProto_Node_AcropolisStatus) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node_AcropolisStatus.Size(m)
}
func (m *ConfigurationProto_Node_AcropolisStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node_AcropolisStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node_AcropolisStatus proto.InternalMessageInfo

const Default_ConfigurationProto_Node_AcropolisStatus_NodeState ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState = ConfigurationProto_Node_AcropolisStatus_kAcropolisNormal
const Default_ConfigurationProto_Node_AcropolisStatus_LogicalTimestamp int64 = 1
const Default_ConfigurationProto_Node_AcropolisStatus_LocalityRestored bool = true

func (m *ConfigurationProto_Node_AcropolisStatus) GetNodeState() ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState {
	if m != nil && m.NodeState != nil {
		return *m.NodeState
	}
	return Default_ConfigurationProto_Node_AcropolisStatus_NodeState
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_ConfigurationProto_Node_AcropolisStatus_LogicalTimestamp
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetFailoverSourceHostUuid() string {
	if m != nil && m.FailoverSourceHostUuid != nil {
		return *m.FailoverSourceHostUuid
	}
	return ""
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetPreviousNodeState() ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState {
	if m != nil && m.PreviousNodeState != nil {
		return *m.PreviousNodeState
	}
	return ConfigurationProto_Node_AcropolisStatus_kAcropolisNormal
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetConnState() ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState {
	if m != nil && m.ConnState != nil {
		return *m.ConnState
	}
	return ConfigurationProto_Node_AcropolisStatus_kDisconnected
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetLocalityRestored() bool {
	if m != nil && m.LocalityRestored != nil {
		return *m.LocalityRestored
	}
	return Default_ConfigurationProto_Node_AcropolisStatus_LocalityRestored
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetIsHardwareVirtualized() bool {
	if m != nil && m.IsHardwareVirtualized != nil {
		return *m.IsHardwareVirtualized
	}
	return false
}

func (m *ConfigurationProto_Node_AcropolisStatus) GetCvmMaintenance() bool {
	if m != nil && m.CvmMaintenance != nil {
		return *m.CvmMaintenance
	}
	return false
}

// Digital certificates can optionally be fixed for specific purpose.
// This message specifies the mapping between a certificate to the
// specific target service or device.
type ConfigurationProto_Node_DigitalCertificateMap struct {
	// Path to the zknode where a digital certificate is stored.
	DigitalCertificateZkpath *string `protobuf:"bytes,1,req,name=digital_certificate_zkpath,json=digitalCertificateZkpath" json:"digital_certificate_zkpath,omitempty"`
	// Uuid of the key management server that accepts the digital
	// certificate. This field is present only when a certificate is fixed
	// for specific key management server.
	KeyManagementServerUuid *string  `protobuf:"bytes,2,opt,name=key_management_server_uuid,json=keyManagementServerUuid" json:"key_management_server_uuid,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ConfigurationProto_Node_DigitalCertificateMap) Reset() {
	*m = ConfigurationProto_Node_DigitalCertificateMap{}
}
func (m *ConfigurationProto_Node_DigitalCertificateMap) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Node_DigitalCertificateMap) ProtoMessage() {}
func (*ConfigurationProto_Node_DigitalCertificateMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 2}
}

func (m *ConfigurationProto_Node_DigitalCertificateMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node_DigitalCertificateMap.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node_DigitalCertificateMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node_DigitalCertificateMap.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node_DigitalCertificateMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node_DigitalCertificateMap.Merge(m, src)
}
func (m *ConfigurationProto_Node_DigitalCertificateMap) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node_DigitalCertificateMap.Size(m)
}
func (m *ConfigurationProto_Node_DigitalCertificateMap) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node_DigitalCertificateMap.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node_DigitalCertificateMap proto.InternalMessageInfo

func (m *ConfigurationProto_Node_DigitalCertificateMap) GetDigitalCertificateZkpath() string {
	if m != nil && m.DigitalCertificateZkpath != nil {
		return *m.DigitalCertificateZkpath
	}
	return ""
}

func (m *ConfigurationProto_Node_DigitalCertificateMap) GetKeyManagementServerUuid() string {
	if m != nil && m.KeyManagementServerUuid != nil {
		return *m.KeyManagementServerUuid
	}
	return ""
}

type ConfigurationProto_Node_CvmResourceState struct {
	// Amount of memory currently allocated to cvm.
	MemoryMb             *uint64  `protobuf:"varint,1,opt,name=memory_mb,json=memoryMb" json:"memory_mb,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Node_CvmResourceState) Reset() {
	*m = ConfigurationProto_Node_CvmResourceState{}
}
func (m *ConfigurationProto_Node_CvmResourceState) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Node_CvmResourceState) ProtoMessage()    {}
func (*ConfigurationProto_Node_CvmResourceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 3}
}

func (m *ConfigurationProto_Node_CvmResourceState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node_CvmResourceState.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node_CvmResourceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node_CvmResourceState.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node_CvmResourceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node_CvmResourceState.Merge(m, src)
}
func (m *ConfigurationProto_Node_CvmResourceState) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node_CvmResourceState.Size(m)
}
func (m *ConfigurationProto_Node_CvmResourceState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node_CvmResourceState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node_CvmResourceState proto.InternalMessageInfo

func (m *ConfigurationProto_Node_CvmResourceState) GetMemoryMb() uint64 {
	if m != nil && m.MemoryMb != nil {
		return *m.MemoryMb
	}
	return 0
}

// Information about foundation versions and potentially other foundation
// related information.
type ConfigurationProto_Node_FoundationInfo struct {
	// Foundation version used to image the node.
	InstalledUsingFoundationVersion *string `protobuf:"bytes,1,opt,name=installed_using_foundation_version,json=installedUsingFoundationVersion" json:"installed_using_foundation_version,omitempty"`
	// Phoenix version used to image the node.
	InstalledUsingPhoenixVersion *string `protobuf:"bytes,2,opt,name=installed_using_phoenix_version,json=installedUsingPhoenixVersion" json:"installed_using_phoenix_version,omitempty"`
	// Foundation version currently running on the system.
	FoundationVersion    *string  `protobuf:"bytes,3,opt,name=foundation_version,json=foundationVersion" json:"foundation_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Node_FoundationInfo) Reset() {
	*m = ConfigurationProto_Node_FoundationInfo{}
}
func (m *ConfigurationProto_Node_FoundationInfo) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Node_FoundationInfo) ProtoMessage()    {}
func (*ConfigurationProto_Node_FoundationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 4}
}

func (m *ConfigurationProto_Node_FoundationInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node_FoundationInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node_FoundationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node_FoundationInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node_FoundationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node_FoundationInfo.Merge(m, src)
}
func (m *ConfigurationProto_Node_FoundationInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node_FoundationInfo.Size(m)
}
func (m *ConfigurationProto_Node_FoundationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node_FoundationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node_FoundationInfo proto.InternalMessageInfo

func (m *ConfigurationProto_Node_FoundationInfo) GetInstalledUsingFoundationVersion() string {
	if m != nil && m.InstalledUsingFoundationVersion != nil {
		return *m.InstalledUsingFoundationVersion
	}
	return ""
}

func (m *ConfigurationProto_Node_FoundationInfo) GetInstalledUsingPhoenixVersion() string {
	if m != nil && m.InstalledUsingPhoenixVersion != nil {
		return *m.InstalledUsingPhoenixVersion
	}
	return ""
}

func (m *ConfigurationProto_Node_FoundationInfo) GetFoundationVersion() string {
	if m != nil && m.FoundationVersion != nil {
		return *m.FoundationVersion
	}
	return ""
}

// Information about the Node undergoing a planned outage.
type ConfigurationProto_Node_PlannedOutage struct {
	// Time when the planned outage for the node was started.
	StartTime *int64 `protobuf:"varint,1,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// Time when the planned outage for the node was finished.
	EndTime *int64 `protobuf:"varint,2,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// Reason for the planned outage
	Reason               *string  `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Node_PlannedOutage) Reset()         { *m = ConfigurationProto_Node_PlannedOutage{} }
func (m *ConfigurationProto_Node_PlannedOutage) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Node_PlannedOutage) ProtoMessage()    {}
func (*ConfigurationProto_Node_PlannedOutage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 4, 5}
}

func (m *ConfigurationProto_Node_PlannedOutage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Node_PlannedOutage.Unmarshal(m, b)
}
func (m *ConfigurationProto_Node_PlannedOutage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Node_PlannedOutage.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Node_PlannedOutage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Node_PlannedOutage.Merge(m, src)
}
func (m *ConfigurationProto_Node_PlannedOutage) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Node_PlannedOutage.Size(m)
}
func (m *ConfigurationProto_Node_PlannedOutage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Node_PlannedOutage.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Node_PlannedOutage proto.InternalMessageInfo

func (m *ConfigurationProto_Node_PlannedOutage) GetStartTime() int64 {
	if m != nil && m.StartTime != nil {
		return *m.StartTime
	}
	return 0
}

func (m *ConfigurationProto_Node_PlannedOutage) GetEndTime() int64 {
	if m != nil && m.EndTime != nil {
		return *m.EndTime
	}
	return 0
}

func (m *ConfigurationProto_Node_PlannedOutage) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

// A storage pool consisting of a number of disks.
type ConfigurationProto_StoragePool struct {
	// Unique name assigned to this storage pool (by the admin/UI).
	StoragePoolName *string `protobuf:"bytes,1,req,name=storage_pool_name,json=storagePoolName" json:"storage_pool_name,omitempty"`
	// Unique id assigned to this storage pool (by the Nutanix software).
	StoragePoolId *int64 `protobuf:"varint,2,req,name=storage_pool_id,json=storagePoolId" json:"storage_pool_id,omitempty"`
	// All the disk ids in this storage pool.
	DiskId []int64 `protobuf:"varint,3,rep,name=disk_id,json=diskId" json:"disk_id,omitempty"`
	// If true, this is an intent to remove the StoragePool definition.
	ToRemove *bool `protobuf:"varint,4,opt,name=to_remove,json=toRemove" json:"to_remove,omitempty"`
	// The curator should not do ILM related down-migrates from one tier to
	// another unless the cumulative usage on that tier exceeds the following
	// percentage threshold. The usage only considers those disks on that
	// tier that are in this storage pool. Thus, if disks A, B, C and D
	// are in tier kHDD and only A, B and C are in this storage pool, then
	// usage is computed by summing up the usage from A, B and C only.
	//
	// The intention behind having this threshold is to prevent the curator
	// from draining a tier completely when the cluster is idle.
	IlmDownMigratePctThreshold *int32 `protobuf:"varint,5,opt,name=ilm_down_migrate_pct_threshold,json=ilmDownMigratePctThreshold,def=75" json:"ilm_down_migrate_pct_threshold,omitempty"`
	// Implicit total reserved size (in bytes) of the storage pool. This is
	// derived by summing up the reservations set on the containers that map to
	// this storage pool. The curator will periodically recalculate this value
	// to make sure it is accurate.
	TotalImplicitReservedCapacity *int64 `protobuf:"varint,6,opt,name=total_implicit_reserved_capacity,json=totalImplicitReservedCapacity" json:"total_implicit_reserved_capacity,omitempty"`
	// Uuid assigned to this storage pool (by the Nutanix software).
	StoragePoolUuid *string `protobuf:"bytes,7,opt,name=storage_pool_uuid,json=storagePoolUuid" json:"storage_pool_uuid,omitempty"`
	// All the disk UUIDs in this storage pool.
	DiskUuid             []string `protobuf:"bytes,8,rep,name=disk_uuid,json=diskUuid" json:"disk_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_StoragePool) Reset()         { *m = ConfigurationProto_StoragePool{} }
func (m *ConfigurationProto_StoragePool) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_StoragePool) ProtoMessage()    {}
func (*ConfigurationProto_StoragePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 5}
}

func (m *ConfigurationProto_StoragePool) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_StoragePool.Unmarshal(m, b)
}
func (m *ConfigurationProto_StoragePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_StoragePool.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_StoragePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_StoragePool.Merge(m, src)
}
func (m *ConfigurationProto_StoragePool) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_StoragePool.Size(m)
}
func (m *ConfigurationProto_StoragePool) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_StoragePool.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_StoragePool proto.InternalMessageInfo

const Default_ConfigurationProto_StoragePool_IlmDownMigratePctThreshold int32 = 75

func (m *ConfigurationProto_StoragePool) GetStoragePoolName() string {
	if m != nil && m.StoragePoolName != nil {
		return *m.StoragePoolName
	}
	return ""
}

func (m *ConfigurationProto_StoragePool) GetStoragePoolId() int64 {
	if m != nil && m.StoragePoolId != nil {
		return *m.StoragePoolId
	}
	return 0
}

func (m *ConfigurationProto_StoragePool) GetDiskId() []int64 {
	if m != nil {
		return m.DiskId
	}
	return nil
}

func (m *ConfigurationProto_StoragePool) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return false
}

func (m *ConfigurationProto_StoragePool) GetIlmDownMigratePctThreshold() int32 {
	if m != nil && m.IlmDownMigratePctThreshold != nil {
		return *m.IlmDownMigratePctThreshold
	}
	return Default_ConfigurationProto_StoragePool_IlmDownMigratePctThreshold
}

func (m *ConfigurationProto_StoragePool) GetTotalImplicitReservedCapacity() int64 {
	if m != nil && m.TotalImplicitReservedCapacity != nil {
		return *m.TotalImplicitReservedCapacity
	}
	return 0
}

func (m *ConfigurationProto_StoragePool) GetStoragePoolUuid() string {
	if m != nil && m.StoragePoolUuid != nil {
		return *m.StoragePoolUuid
	}
	return ""
}

func (m *ConfigurationProto_StoragePool) GetDiskUuid() []string {
	if m != nil {
		return m.DiskUuid
	}
	return nil
}

// Software Encryption configuration.
type ConfigurationProto_EncryptionParams struct {
	// Encryption algorithm type. If this is absent or 'kNone', then new data
	// written won't be encrypted. There may be existing data that is still
	// encrypted on disk. Overwrites to existing extent groups that are
	// encrypted will still be encrypted. Any new extent groups, oplog
	// episodes, NFS metadata and content cache data will be written in plain
	// text. If this is a valid encryption type, then any new extent groups or
	// oplog episodes created will be encrypted with this encryption type.
	// Once an extent group or oplog episode is created with an encryption
	// type, then that doesn't change. It will continue to be encrypted with
	// that type, even if the setting here changes.
	EncryptionType *base.DataTransformation_Type `protobuf:"varint,1,opt,name=encryption_type,json=encryptionType,enum=nutanix.DataTransformation_Type,def=1027" json:"encryption_type,omitempty"`
	// Scope of encryption. This is a required field in
	// cluster_encryption_params. Container encryption params will not set
	// this field. Currently there are 2 flavors:
	//
	// Cluster scope: All the containers in the cluster will be encrypted.
	// The encryption scope in cluster_encryption_params will be set to
	// kCluster.
	//
	// Container scope: Only some of the containers in the cluster will be
	// encrypted. The encryption scope in cluster_encryption_params will be
	// set to kContainer and the encryption_type in container's encryption
	// params will decide whether encryption is on or not. If the container
	// encryption type is kNone, encryption is disabled.
	EncryptionScope *ConfigurationProto_EncryptionParams_EncryptionScope `protobuf:"varint,2,opt,name=encryption_scope,json=encryptionScope,enum=nutanix.zeus.ConfigurationProto_EncryptionParams_EncryptionScope" json:"encryption_scope,omitempty"`
	// Cipher key UUID to be used for encryption.
	CipherKeyId []byte `protobuf:"bytes,3,opt,name=cipher_key_id,json=cipherKeyId" json:"cipher_key_id,omitempty"`
	// Adler32 checksum of the cipher key used for encryption.
	CipherKeyChecksum        *uint32 `protobuf:"varint,4,opt,name=cipher_key_checksum,json=cipherKeyChecksum" json:"cipher_key_checksum,omitempty"`
	EncryptedComponentBitmap *uint32 `protobuf:"varint,5,opt,name=encrypted_component_bitmap,json=encryptedComponentBitmap" json:"encrypted_component_bitmap,omitempty"`
	// If true, the data has been encrypted. This is used when users enable
	// encryption on unencrypted entities like cluster or container. The value
	// of this field is meaningless if encryption is not enabled at the entity.
	//
	// Cluster-scope encryption:
	// This field will be set in both cluster and container encryption params.
	//
	// Container-scope encryption:
	// This field will only be set in container encryption params. The value
	// of this field in cluster encryption params is meaningless.
	Encrypted            *bool    `protobuf:"varint,6,opt,name=encrypted,def=1" json:"encrypted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_EncryptionParams) Reset()         { *m = ConfigurationProto_EncryptionParams{} }
func (m *ConfigurationProto_EncryptionParams) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_EncryptionParams) ProtoMessage()    {}
func (*ConfigurationProto_EncryptionParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 6}
}

func (m *ConfigurationProto_EncryptionParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_EncryptionParams.Unmarshal(m, b)
}
func (m *ConfigurationProto_EncryptionParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_EncryptionParams.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_EncryptionParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_EncryptionParams.Merge(m, src)
}
func (m *ConfigurationProto_EncryptionParams) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_EncryptionParams.Size(m)
}
func (m *ConfigurationProto_EncryptionParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_EncryptionParams.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_EncryptionParams proto.InternalMessageInfo

const Default_ConfigurationProto_EncryptionParams_EncryptionType base.DataTransformation_Type = base.DataTransformation_kEncryptionAES256CTR
const Default_ConfigurationProto_EncryptionParams_Encrypted bool = true

func (m *ConfigurationProto_EncryptionParams) GetEncryptionType() base.DataTransformation_Type {
	if m != nil && m.EncryptionType != nil {
		return *m.EncryptionType
	}
	return Default_ConfigurationProto_EncryptionParams_EncryptionType
}

func (m *ConfigurationProto_EncryptionParams) GetEncryptionScope() ConfigurationProto_EncryptionParams_EncryptionScope {
	if m != nil && m.EncryptionScope != nil {
		return *m.EncryptionScope
	}
	return ConfigurationProto_EncryptionParams_kCluster
}

func (m *ConfigurationProto_EncryptionParams) GetCipherKeyId() []byte {
	if m != nil {
		return m.CipherKeyId
	}
	return nil
}

func (m *ConfigurationProto_EncryptionParams) GetCipherKeyChecksum() uint32 {
	if m != nil && m.CipherKeyChecksum != nil {
		return *m.CipherKeyChecksum
	}
	return 0
}

func (m *ConfigurationProto_EncryptionParams) GetEncryptedComponentBitmap() uint32 {
	if m != nil && m.EncryptedComponentBitmap != nil {
		return *m.EncryptedComponentBitmap
	}
	return 0
}

func (m *ConfigurationProto_EncryptionParams) GetEncrypted() bool {
	if m != nil && m.Encrypted != nil {
		return *m.Encrypted
	}
	return Default_ConfigurationProto_EncryptionParams_Encrypted
}

// The configuration parameters on a container.
type ConfigurationProto_ContainerParams struct {
	// Replication factor used for data in the container.
	ReplicationFactor *int32 `protobuf:"varint,1,opt,name=replication_factor,json=replicationFactor,def=2" json:"replication_factor,omitempty"`
	// Erasure encoding used for data in the container. Erasure
	// encoding is always applied offline - until which time the data is
	// encoded using the above replication factor. The erasure encoding
	// is specified as the string K/N where K data blocks are encoded
	// together by adding N code blocks to produce a total of K+N blocks.
	// If any K of these blocks is found, the whole group of K+N blocks can be
	// recovered. We can also specify the erasure encoding as the string */N
	// and let the system determine the value K. If the following field is not
	// set, then erasure coding is never used on this container.
	//
	// The data contraction policy governs when data is converted from regular
	// replication to erasure based replication.
	ErasureCode *string `protobuf:"bytes,2,opt,name=erasure_code,json=erasureCode" json:"erasure_code,omitempty"`
	// Sometimes different fault domain (e.g., kNode, kRackableUnitunit, kRack)
	// aware erasure coding can be supported but a lower fault domain
	// (e.g., kNode) erasure encoding can give better space savings because
	// it allows longer strip. If true, this field prefers to create the higher
	// failure domain aware strips, which might be shorter, instead of more
	// space savings.
	PreferHigherEcFaultDomain *bool `protobuf:"varint,26,opt,name=prefer_higher_ec_fault_domain,json=preferHigherEcFaultDomain" json:"prefer_higher_ec_fault_domain,omitempty"`
	// DEPRECATED: The encryption type used. Encryption is always applied inline.
	EncryptionType *ConfigurationProto_ContainerParams_EncryptionType `protobuf:"varint,3,opt,name=encryption_type,json=encryptionType,enum=nutanix.zeus.ConfigurationProto_ContainerParams_EncryptionType" json:"encryption_type,omitempty"`
	// Parameters for encrypting this container. These parameters can be
	// specified at the container level even if cluster encryption parameters
	// are specified. The purpose of having per Container encryption parameters
	// is to reduce the scope in which a particular Data Encryption Key is used.
	// This will limit the damage in case an encryption key is compromised.
	EncryptionParams *ConfigurationProto_EncryptionParams `protobuf:"bytes,25,opt,name=encryption_params,json=encryptionParams" json:"encryption_params,omitempty"`
	// The compression type used. The data contraction policy determines when
	// compression is actually applied.
	CompressionType *ConfigurationProto_ContainerParams_CompressionType `protobuf:"varint,4,opt,name=compression_type,json=compressionType,enum=nutanix.zeus.ConfigurationProto_ContainerParams_CompressionType" json:"compression_type,omitempty"`
	// Name of the leaf QoS principal to which all work done on behalf of this
	// container is accounted towards. All vdisks assigned to this container
	// inherit this principal unless they explicitly override it.
	//
	// If the qos_principal is not set, then it defaults to the catch all
	// QoS principal.
	QosPrincipalName *string `protobuf:"bytes,5,opt,name=qos_principal_name,json=qosPrincipalName" json:"qos_principal_name,omitempty"`
	// Tier preference (going from high to low) for random IO. If not
	// specified, the order used is the same as that in the top level
	// storage_tier vector.
	RandomIoTierPreference []string `protobuf:"bytes,6,rep,name=random_io_tier_preference,json=randomIoTierPreference" json:"random_io_tier_preference,omitempty"`
	// Tier preference (going from high to low) for sequential IO.
	// If not specified, the order used is the same as that in the top level
	// storage_tier vector.
	SequentialIoTierPreference []string `protobuf:"bytes,7,rep,name=sequential_io_tier_preference,json=sequentialIoTierPreference" json:"sequential_io_tier_preference,omitempty"`
	// Total reserved size (in bytes) of the container (set by Admin). This
	// also accounts for the container's replication factor. Thus, if the Admin
	// reserves R bytes in the container and the container's replication factor
	// is N, then this value will be set to (R * N). This may not be equal to
	// the total_implicit_reserved_capacity of the container, as the latter is
	// derived by summing up the reservations provisioned on all vdisks in the
	// container.  Thus, the actual reserved capacity of the container will be
	// max(total_explicit_reserved_capacity, total_implicit_reserved_capacity).
	TotalExplicitReservedCapacity *int64 `protobuf:"varint,8,opt,name=total_explicit_reserved_capacity,json=totalExplicitReservedCapacity" json:"total_explicit_reserved_capacity,omitempty"`
	// Max capacity (in bytes) of the container. This is derived by summing up
	// the capacity of all the storage pools associated with this container.
	// This value is auto-computed by Prism and updated whenever a disk is
	// added/removed from the associated storage pools.
	MaxCapacity *int64 `protobuf:"varint,9,opt,name=max_capacity,json=maxCapacity" json:"max_capacity,omitempty"`
	// Implicit total reserved size (in bytes) of the container. This is
	// derived by summing up the reservations set on the individual vdisks that
	// belong to this container. This also accounts for the container's
	// replication factor. Thus, if a vdisk has a reservation R, then its
	// contribution to the container's implicit reserved capacity will be (R *
	// N), where N is the container's replication factor. This value will be
	// updated by stargate whenever a vdisk reservation changes. The curator
	// will periodically recalculate this value to make sure it is accurate.
	TotalImplicitReservedCapacity *int64 `protobuf:"varint,10,opt,name=total_implicit_reserved_capacity,json=totalImplicitReservedCapacity" json:"total_implicit_reserved_capacity,omitempty"`
	// Max dedup extent size (in bytes) for all vdisks in the container.
	// Extent size cannot grow beyond this limit while deduping.
	MaxDedupExtentSize *int32 `protobuf:"varint,11,opt,name=max_dedup_extent_size,json=maxDedupExtentSize,def=10240" json:"max_dedup_extent_size,omitempty"`
	// Min dedup extent size (in bytes) for all vdisks in the container.
	MinDedupExtentSize *int32 `protobuf:"varint,12,opt,name=min_dedup_extent_size,json=minDedupExtentSize,def=4096" json:"min_dedup_extent_size,omitempty"`
	// Ideal dedup extent size (in bytes) for all vdisks in the container.
	IdealDedupExtentSize *int32 `protobuf:"varint,13,opt,name=ideal_dedup_extent_size,json=idealDedupExtentSize,def=8192" json:"ideal_dedup_extent_size,omitempty"`
	// If an extent group is not accessed for a threshold amount of time on
	// a tier, it is migrated to a lower preference tier by the curator.
	// Each tier can have a different threshold for when the migration is done.
	// The following vector specifies these times for each tier - these apply
	// to the random_io_tier_preference (or to the global random tiers if the
	// latter is not specified).
	//
	// Thus if ilm_down_migrate_time_secs(0) is 60, then an extent group would
	// be migrated after at least 60s from the highest priority tier applicable
	// to random IO accesses.
	//
	// The vector ilm_down_migrate_time_secs may not specify a migration
	// threshold for every tier in the random IO preference list. If a
	// migration threshold is not specified for a tier, then no down migration
	// is done from that tier. As an example, if ilm_down_migrate_time_secs has
	// no elements, no ILM down migration is done for this container.
	IlmDownMigrateTimeSecs []int32 `protobuf:"varint,14,rep,name=ilm_down_migrate_time_secs,json=ilmDownMigrateTimeSecs" json:"ilm_down_migrate_time_secs,omitempty"`
	// Default oplog settings used by each vdisk assigned to this container.
	// These settings can be overridden by any specific vdisk.
	OplogParams *pithos.VDiskConfig_Params_OplogParams `protobuf:"bytes,15,opt,name=oplog_params,json=oplogParams" json:"oplog_params,omitempty"`
	// Comma separated list of subnets (of the form "a.b.c.d/l.m.n.o") that are
	// allowed to send NFS requests to this container. If not specified,
	// the global NFS whitelist will be looked up for access permission
	// The internal subnet is always automatically considered part
	// of the whitelist, even if the field below does not explicitly specify
	// it. Similarly, all the hypervisor IPs are considered part of the
	// whitelist (to allow the case where requests are forwarded from a
	// hypervisor to a remote SVM). Finally, to permit debugging, all of the
	// SVM's local IPs are considered to be implicitly part of the whitelist
	// (thus one can locally mount this container on an SVM).
	NfsSubnetWhitelist *string `protobuf:"bytes,16,opt,name=nfs_subnet_whitelist,json=nfsSubnetWhitelist" json:"nfs_subnet_whitelist,omitempty"`
	// The data contraction policy. If a vdisk level data contraction policy is
	// provided, it will override the container level policy.
	DataContractionPolicy *pithos.VDiskConfig_Params_DataContractionPolicy `protobuf:"bytes,17,opt,name=data_contraction_policy,json=dataContractionPolicy" json:"data_contraction_policy,omitempty"`
	// Maximum IOPS desired for sequential I/O. We prefer disks with the
	// stated IOPS or less for sequential I/O.
	SequentialIoMaxRequiredIops *int32 `protobuf:"varint,18,opt,name=sequential_io_max_required_iops,json=sequentialIoMaxRequiredIops,def=36000" json:"sequential_io_max_required_iops,omitempty"`
	// Maximum IOPS requirement for random I/O. We prefer disks with the stated
	// IOPS or less for random I/O.
	RandomIoMaxRequiredIops *int32 `protobuf:"varint,19,opt,name=random_io_max_required_iops,json=randomIoMaxRequiredIops,def=36000" json:"random_io_max_required_iops,omitempty"`
	// If true, SHA1 fingerprints are computed on sequential writes. The
	// fingerprints are then used for deduping in the RAM/Flash tiers. By
	// default, fingerprinting is turned off.
	FingerprintOnWrite *bool `protobuf:"varint,20,opt,name=fingerprint_on_write,json=fingerprintOnWrite" json:"fingerprint_on_write,omitempty"`
	// Max capacity of the container as defined by the user. Prism multiplies
	// the user provided value by the replication factor of the container
	// before updating it here. This is also the maximum capacity of the
	// container advertised to the hypervisor.
	AdvertisedCapacityBytes *int64 `protobuf:"varint,22,opt,name=advertised_capacity_bytes,json=advertisedCapacityBytes" json:"advertised_capacity_bytes,omitempty"`
	// Whether this should be a nutanix managed share, and user actions in prism
	// should be inhibited slightly, similar to how users cannot fiddle with the
	// CVMs in the UI immediately
	NutanixManaged *bool `protobuf:"varint,23,opt,name=nutanix_managed,json=nutanixManaged" json:"nutanix_managed,omitempty"`
	// Whether READDIRPLUS call on this container should return attributes? If
	// so, what type of consistency guarantees does the client expect. Read the
	// note on ReaddirPlusResponseAttributesType.
	ReturnAttributesOnReaddirplus *ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType `protobuf:"varint,24,opt,name=return_attributes_on_readdirplus,json=returnAttributesOnReaddirplus,enum=nutanix.zeus.ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType,def=0" json:"return_attributes_on_readdirplus,omitempty"`
	// Whether this container is allowed to create extent groups that will use
	// the Autonomous Extent Store (AES) DB for storing their physical
	// metadata. This will be set by Stargate when the cluster and container
	// meet the required constaints.
	AesEnabled *bool `protobuf:"varint,27,opt,name=aes_enabled,json=aesEnabled" json:"aes_enabled,omitempty"`
	// Whether data written to this container should be inline erasure coded or
	// not. If true, Stargate will write data into pre-created erasure coded
	// strips. This field is examined only if 'erasure_code' is set to a
	// non-null string.
	InlineEcEnabled *bool `protobuf:"varint,28,opt,name=inline_ec_enabled,json=inlineEcEnabled" json:"inline_ec_enabled,omitempty"`
	// Whether this container is allowed to create vdisk with merged vblocks.
	// This will be set by Stargate when the cluster and container
	// meet the required constaints.
	MergedVblocksEnabled *bool `protobuf:"varint,29,opt,name=merged_vblocks_enabled,json=mergedVblocksEnabled" json:"merged_vblocks_enabled,omitempty"`
	// Replica placement policy associated with this container.
	// If no replica placement policy is associated with a vdisk, it will
	// inherit the container's policy. If this field is not explicitly set, a
	// default generated policy based on container replication factor and
	// cluster topology will be used implicitly.
	ReplicaPlacementPolicyId *int64 `protobuf:"varint,30,opt,name=replica_placement_policy_id,json=replicaPlacementPolicyId" json:"replica_placement_policy_id,omitempty"`
	// Replica placement pool associated with this container.
	// Egroup replicas must be placed on entities that are part of the pool
	// given by 'replica_placement_pool_id'. If no replica placement pool is
	// associated with a vdisk, it will inherit the container's setting. If
	// this field is not explicitly set, a default generated pool will be used
	// implicitly.
	ReplicaPlacementPoolId *int64 `protobuf:"varint,31,opt,name=replica_placement_pool_id,json=replicaPlacementPoolId" json:"replica_placement_pool_id,omitempty"`
	// Boolean indicating if the current default replica placement policy of
	// this container is under transition. When cluster topology changes,
	// replica placement policy and pool may change, and egroup replicas may be
	// in the process of being migrated to fit into the new setting.
	UnderTransition      *bool    `protobuf:"varint,32,opt,name=under_transition,json=underTransition" json:"under_transition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_ContainerParams) Reset()         { *m = ConfigurationProto_ContainerParams{} }
func (m *ConfigurationProto_ContainerParams) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_ContainerParams) ProtoMessage()    {}
func (*ConfigurationProto_ContainerParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 7}
}

func (m *ConfigurationProto_ContainerParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ContainerParams.Unmarshal(m, b)
}
func (m *ConfigurationProto_ContainerParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ContainerParams.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ContainerParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ContainerParams.Merge(m, src)
}
func (m *ConfigurationProto_ContainerParams) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ContainerParams.Size(m)
}
func (m *ConfigurationProto_ContainerParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ContainerParams.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ContainerParams proto.InternalMessageInfo

const Default_ConfigurationProto_ContainerParams_ReplicationFactor int32 = 2
const Default_ConfigurationProto_ContainerParams_MaxDedupExtentSize int32 = 10240
const Default_ConfigurationProto_ContainerParams_MinDedupExtentSize int32 = 4096
const Default_ConfigurationProto_ContainerParams_IdealDedupExtentSize int32 = 8192
const Default_ConfigurationProto_ContainerParams_SequentialIoMaxRequiredIops int32 = 36000
const Default_ConfigurationProto_ContainerParams_RandomIoMaxRequiredIops int32 = 36000
const Default_ConfigurationProto_ContainerParams_ReturnAttributesOnReaddirplus ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType = ConfigurationProto_ContainerParams_kNoAttributes

func (m *ConfigurationProto_ContainerParams) GetReplicationFactor() int32 {
	if m != nil && m.ReplicationFactor != nil {
		return *m.ReplicationFactor
	}
	return Default_ConfigurationProto_ContainerParams_ReplicationFactor
}

func (m *ConfigurationProto_ContainerParams) GetErasureCode() string {
	if m != nil && m.ErasureCode != nil {
		return *m.ErasureCode
	}
	return ""
}

func (m *ConfigurationProto_ContainerParams) GetPreferHigherEcFaultDomain() bool {
	if m != nil && m.PreferHigherEcFaultDomain != nil {
		return *m.PreferHigherEcFaultDomain
	}
	return false
}

func (m *ConfigurationProto_ContainerParams) GetEncryptionType() ConfigurationProto_ContainerParams_EncryptionType {
	if m != nil && m.EncryptionType != nil {
		return *m.EncryptionType
	}
	return ConfigurationProto_ContainerParams_kWeak
}

func (m *ConfigurationProto_ContainerParams) GetEncryptionParams() *ConfigurationProto_EncryptionParams {
	if m != nil {
		return m.EncryptionParams
	}
	return nil
}

func (m *ConfigurationProto_ContainerParams) GetCompressionType() ConfigurationProto_ContainerParams_CompressionType {
	if m != nil && m.CompressionType != nil {
		return *m.CompressionType
	}
	return ConfigurationProto_ContainerParams_kNone
}

func (m *ConfigurationProto_ContainerParams) GetQosPrincipalName() string {
	if m != nil && m.QosPrincipalName != nil {
		return *m.QosPrincipalName
	}
	return ""
}

func (m *ConfigurationProto_ContainerParams) GetRandomIoTierPreference() []string {
	if m != nil {
		return m.RandomIoTierPreference
	}
	return nil
}

func (m *ConfigurationProto_ContainerParams) GetSequentialIoTierPreference() []string {
	if m != nil {
		return m.SequentialIoTierPreference
	}
	return nil
}

func (m *ConfigurationProto_ContainerParams) GetTotalExplicitReservedCapacity() int64 {
	if m != nil && m.TotalExplicitReservedCapacity != nil {
		return *m.TotalExplicitReservedCapacity
	}
	return 0
}

func (m *ConfigurationProto_ContainerParams) GetMaxCapacity() int64 {
	if m != nil && m.MaxCapacity != nil {
		return *m.MaxCapacity
	}
	return 0
}

func (m *ConfigurationProto_ContainerParams) GetTotalImplicitReservedCapacity() int64 {
	if m != nil && m.TotalImplicitReservedCapacity != nil {
		return *m.TotalImplicitReservedCapacity
	}
	return 0
}

func (m *ConfigurationProto_ContainerParams) GetMaxDedupExtentSize() int32 {
	if m != nil && m.MaxDedupExtentSize != nil {
		return *m.MaxDedupExtentSize
	}
	return Default_ConfigurationProto_ContainerParams_MaxDedupExtentSize
}

func (m *ConfigurationProto_ContainerParams) GetMinDedupExtentSize() int32 {
	if m != nil && m.MinDedupExtentSize != nil {
		return *m.MinDedupExtentSize
	}
	return Default_ConfigurationProto_ContainerParams_MinDedupExtentSize
}

func (m *ConfigurationProto_ContainerParams) GetIdealDedupExtentSize() int32 {
	if m != nil && m.IdealDedupExtentSize != nil {
		return *m.IdealDedupExtentSize
	}
	return Default_ConfigurationProto_ContainerParams_IdealDedupExtentSize
}

func (m *ConfigurationProto_ContainerParams) GetIlmDownMigrateTimeSecs() []int32 {
	if m != nil {
		return m.IlmDownMigrateTimeSecs
	}
	return nil
}

func (m *ConfigurationProto_ContainerParams) GetOplogParams() *pithos.VDiskConfig_Params_OplogParams {
	if m != nil {
		return m.OplogParams
	}
	return nil
}

func (m *ConfigurationProto_ContainerParams) GetNfsSubnetWhitelist() string {
	if m != nil && m.NfsSubnetWhitelist != nil {
		return *m.NfsSubnetWhitelist
	}
	return ""
}

func (m *ConfigurationProto_ContainerParams) GetDataContractionPolicy() *pithos.VDiskConfig_Params_DataContractionPolicy {
	if m != nil {
		return m.DataContractionPolicy
	}
	return nil
}

func (m *ConfigurationProto_ContainerParams) GetSequentialIoMaxRequiredIops() int32 {
	if m != nil && m.SequentialIoMaxRequiredIops != nil {
		return *m.SequentialIoMaxRequiredIops
	}
	return Default_ConfigurationProto_ContainerParams_SequentialIoMaxRequiredIops
}

func (m *ConfigurationProto_ContainerParams) GetRandomIoMaxRequiredIops() int32 {
	if m != nil && m.RandomIoMaxRequiredIops != nil {
		return *m.RandomIoMaxRequiredIops
	}
	return Default_ConfigurationProto_ContainerParams_RandomIoMaxRequiredIops
}

func (m *ConfigurationProto_ContainerParams) GetFingerprintOnWrite() bool {
	if m != nil && m.FingerprintOnWrite != nil {
		return *m.FingerprintOnWrite
	}
	return false
}

func (m *ConfigurationProto_ContainerParams) GetAdvertisedCapacityBytes() int64 {
	if m != nil && m.AdvertisedCapacityBytes != nil {
		return *m.AdvertisedCapacityBytes
	}
	return 0
}

func (m *ConfigurationProto_ContainerParams) GetNutanixManaged() bool {
	if m != nil && m.NutanixManaged != nil {
		return *m.NutanixManaged
	}
	return false
}

func (m *ConfigurationProto_ContainerParams) GetReturnAttributesOnReaddirplus() ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType {
	if m != nil && m.ReturnAttributesOnReaddirplus != nil {
		return *m.ReturnAttributesOnReaddirplus
	}
	return Default_ConfigurationProto_ContainerParams_ReturnAttributesOnReaddirplus
}

func (m *ConfigurationProto_ContainerParams) GetAesEnabled() bool {
	if m != nil && m.AesEnabled != nil {
		return *m.AesEnabled
	}
	return false
}

func (m *ConfigurationProto_ContainerParams) GetInlineEcEnabled() bool {
	if m != nil && m.InlineEcEnabled != nil {
		return *m.InlineEcEnabled
	}
	return false
}

func (m *ConfigurationProto_ContainerParams) GetMergedVblocksEnabled() bool {
	if m != nil && m.MergedVblocksEnabled != nil {
		return *m.MergedVblocksEnabled
	}
	return false
}

func (m *ConfigurationProto_ContainerParams) GetReplicaPlacementPolicyId() int64 {
	if m != nil && m.ReplicaPlacementPolicyId != nil {
		return *m.ReplicaPlacementPolicyId
	}
	return 0
}

func (m *ConfigurationProto_ContainerParams) GetReplicaPlacementPoolId() int64 {
	if m != nil && m.ReplicaPlacementPoolId != nil {
		return *m.ReplicaPlacementPoolId
	}
	return 0
}

func (m *ConfigurationProto_ContainerParams) GetUnderTransition() bool {
	if m != nil && m.UnderTransition != nil {
		return *m.UnderTransition
	}
	return false
}

// A container.
type ConfigurationProto_Container struct {
	// Unique name assigned to the container (by the admin/UI). Note that
	// this name is unique across all containers. The UI may prefix the name
	// provided by an organization's admin by the name of the organization so
	// as to obtain a unique name to store here.
	ContainerName *string `protobuf:"bytes,1,req,name=container_name,json=containerName" json:"container_name,omitempty"`
	// Unique id assigned to this container by the Nutanix software.
	ContainerId *int64 `protobuf:"varint,2,req,name=container_id,json=containerId" json:"container_id,omitempty"`
	// The block size (in bytes) used by all the vdisks assigned to this
	// container. Each non-dedup'd extent of a vdisk is of this size and the
	// metadata in Medusa is also broken into units of this size.
	VdiskBlockSize *int32 `protobuf:"varint,3,opt,name=vdisk_block_size,json=vdiskBlockSize,def=1048576" json:"vdisk_block_size,omitempty"`
	// In order to keep multiple disks busy while reading/writing, the extents
	// being written are spread across several extent groups while writing.
	// The following parameter determines the amount of extent data that gets
	// written to one extent group before going over to another one. For
	// example, if extents are 8K in size, then for a 1 MB stripe width, 128
	// extents will be written to one extent group, another 128 will be written
	// to a second extent group, etc.
	StripeWidth *int32 `protobuf:"varint,4,opt,name=stripe_width,json=stripeWidth,def=1048576" json:"stripe_width,omitempty"`
	// List of storage pools ids where the data for this container may reside.
	StoragePoolId []int64 `protobuf:"varint,5,rep,name=storage_pool_id,json=storagePoolId" json:"storage_pool_id,omitempty"`
	// The configuration parameters on this container.
	Params *ConfigurationProto_ContainerParams `protobuf:"bytes,6,opt,name=params" json:"params,omitempty"`
	// If true, this is an intent to remove the container definition after the
	// curator has had a chance to garbage collect the metadata of all VDisks
	// within the container.
	ToRemove *bool `protobuf:"varint,7,opt,name=to_remove,json=toRemove" json:"to_remove,omitempty"`
	// Logical operation clocks that correspond to potentially ongoing
	// operations that last modified the container configuration. Only those
	// ops which intend to communicate that the reservation on the container
	// should not be fixed while they are alive, need to set this.
	Locs []*zeus.LogicalOperationClock `protobuf:"bytes,8,rep,name=locs" json:"locs,omitempty"`
	// UUID of the container.
	ContainerUuid *string `protobuf:"bytes,9,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// List of storage pools UUIDs where the data for this container may
	// reside.
	StoragePoolUuid []string `protobuf:"bytes,10,rep,name=storage_pool_uuid,json=storagePoolUuid" json:"storage_pool_uuid,omitempty"`
	// A unique file system identifier assigned to the container. If fsid is 0,
	// the container would share the global inode id space with other
	// containers without fsid.
	Fsid *int32 `protobuf:"varint,11,opt,name=fsid,def=0" json:"fsid,omitempty"`
	// The logical epoch of inodes belonging to this container's live
	// namespace.
	Epoch                *int32   `protobuf:"varint,12,opt,name=epoch,def=0" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Container) Reset()         { *m = ConfigurationProto_Container{} }
func (m *ConfigurationProto_Container) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Container) ProtoMessage()    {}
func (*ConfigurationProto_Container) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 8}
}

func (m *ConfigurationProto_Container) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Container.Unmarshal(m, b)
}
func (m *ConfigurationProto_Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Container.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Container) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Container.Merge(m, src)
}
func (m *ConfigurationProto_Container) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Container.Size(m)
}
func (m *ConfigurationProto_Container) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Container.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Container proto.InternalMessageInfo

const Default_ConfigurationProto_Container_VdiskBlockSize int32 = 1048576
const Default_ConfigurationProto_Container_StripeWidth int32 = 1048576
const Default_ConfigurationProto_Container_Fsid int32 = 0
const Default_ConfigurationProto_Container_Epoch int32 = 0

func (m *ConfigurationProto_Container) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *ConfigurationProto_Container) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *ConfigurationProto_Container) GetVdiskBlockSize() int32 {
	if m != nil && m.VdiskBlockSize != nil {
		return *m.VdiskBlockSize
	}
	return Default_ConfigurationProto_Container_VdiskBlockSize
}

func (m *ConfigurationProto_Container) GetStripeWidth() int32 {
	if m != nil && m.StripeWidth != nil {
		return *m.StripeWidth
	}
	return Default_ConfigurationProto_Container_StripeWidth
}

func (m *ConfigurationProto_Container) GetStoragePoolId() []int64 {
	if m != nil {
		return m.StoragePoolId
	}
	return nil
}

func (m *ConfigurationProto_Container) GetParams() *ConfigurationProto_ContainerParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *ConfigurationProto_Container) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return false
}

func (m *ConfigurationProto_Container) GetLocs() []*zeus.LogicalOperationClock {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *ConfigurationProto_Container) GetContainerUuid() string {
	if m != nil && m.ContainerUuid != nil {
		return *m.ContainerUuid
	}
	return ""
}

func (m *ConfigurationProto_Container) GetStoragePoolUuid() []string {
	if m != nil {
		return m.StoragePoolUuid
	}
	return nil
}

func (m *ConfigurationProto_Container) GetFsid() int32 {
	if m != nil && m.Fsid != nil {
		return *m.Fsid
	}
	return Default_ConfigurationProto_Container_Fsid
}

func (m *ConfigurationProto_Container) GetEpoch() int32 {
	if m != nil && m.Epoch != nil {
		return *m.Epoch
	}
	return Default_ConfigurationProto_Container_Epoch
}

// Hypervisor management server details.
// For VMware, it holds details about VCenter server. For Hyper-V, it holds
// details about Microsoft Hyper-V Server etc.
type ConfigurationProto_ManagementServer struct {
	// Hypervisor management server name or ip
	ManagementServerName *string `protobuf:"bytes,1,req,name=management_server_name,json=managementServerName" json:"management_server_name,omitempty"`
	// URL to access the services exposed by the server (if any).
	AccessUrl *string `protobuf:"bytes,2,opt,name=access_url,json=accessUrl" json:"access_url,omitempty"`
	// User name to access the services.
	UserName *string `protobuf:"bytes,3,opt,name=user_name,json=userName" json:"user_name,omitempty"`
	// Password to access the services.
	Password *string `protobuf:"bytes,4,opt,name=password" json:"password,omitempty"`
	// Type of the management server.
	ManagementServerType *ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,5,opt,name=management_server_type,json=managementServerType,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType,def=9999" json:"management_server_type,omitempty"`
	// Globally unique id assigned to this management server.
	ManagementServerId *int64 `protobuf:"varint,6,opt,name=management_server_id,json=managementServerId" json:"management_server_id,omitempty"`
	// Management server which manages this one.
	ParentManagementServerId *int64 `protobuf:"varint,7,opt,name=parent_management_server_id,json=parentManagementServerId" json:"parent_management_server_id,omitempty"`
	// Uuid of the management server.
	ManagementServerUuid *string `protobuf:"bytes,8,opt,name=management_server_uuid,json=managementServerUuid" json:"management_server_uuid,omitempty"`
	// Uuid of the management server which manages this one.
	ParentManagementServerUuid *string `protobuf:"bytes,9,opt,name=parent_management_server_uuid,json=parentManagementServerUuid" json:"parent_management_server_uuid,omitempty"`
	// Software version of management server.
	ManagementServerVersion *string  `protobuf:"bytes,10,opt,name=management_server_version,json=managementServerVersion" json:"management_server_version,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ConfigurationProto_ManagementServer) Reset()         { *m = ConfigurationProto_ManagementServer{} }
func (m *ConfigurationProto_ManagementServer) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_ManagementServer) ProtoMessage()    {}
func (*ConfigurationProto_ManagementServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 9}
}

func (m *ConfigurationProto_ManagementServer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ManagementServer.Unmarshal(m, b)
}
func (m *ConfigurationProto_ManagementServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ManagementServer.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ManagementServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ManagementServer.Merge(m, src)
}
func (m *ConfigurationProto_ManagementServer) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ManagementServer.Size(m)
}
func (m *ConfigurationProto_ManagementServer) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ManagementServer.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ManagementServer proto.InternalMessageInfo

const Default_ConfigurationProto_ManagementServer_ManagementServerType ConfigurationProto_ManagementServer_HypervisorType = ConfigurationProto_ManagementServer_kNull

func (m *ConfigurationProto_ManagementServer) GetManagementServerName() string {
	if m != nil && m.ManagementServerName != nil {
		return *m.ManagementServerName
	}
	return ""
}

func (m *ConfigurationProto_ManagementServer) GetAccessUrl() string {
	if m != nil && m.AccessUrl != nil {
		return *m.AccessUrl
	}
	return ""
}

func (m *ConfigurationProto_ManagementServer) GetUserName() string {
	if m != nil && m.UserName != nil {
		return *m.UserName
	}
	return ""
}

func (m *ConfigurationProto_ManagementServer) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *ConfigurationProto_ManagementServer) GetManagementServerType() ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.ManagementServerType != nil {
		return *m.ManagementServerType
	}
	return Default_ConfigurationProto_ManagementServer_ManagementServerType
}

func (m *ConfigurationProto_ManagementServer) GetManagementServerId() int64 {
	if m != nil && m.ManagementServerId != nil {
		return *m.ManagementServerId
	}
	return 0
}

func (m *ConfigurationProto_ManagementServer) GetParentManagementServerId() int64 {
	if m != nil && m.ParentManagementServerId != nil {
		return *m.ParentManagementServerId
	}
	return 0
}

func (m *ConfigurationProto_ManagementServer) GetManagementServerUuid() string {
	if m != nil && m.ManagementServerUuid != nil {
		return *m.ManagementServerUuid
	}
	return ""
}

func (m *ConfigurationProto_ManagementServer) GetParentManagementServerUuid() string {
	if m != nil && m.ParentManagementServerUuid != nil {
		return *m.ParentManagementServerUuid
	}
	return ""
}

func (m *ConfigurationProto_ManagementServer) GetManagementServerVersion() string {
	if m != nil && m.ManagementServerVersion != nil {
		return *m.ManagementServerVersion
	}
	return ""
}

// A vzone is a collection of SVMs. A given SVM cannot be in multiple
// vzones. Any given vdisk may be assigned to one more more vzones - only the
// SVMs in those vzones will show the vdisk to be visible as an iSCSI
// target.
type ConfigurationProto_VZone struct {
	VzoneName            *string  `protobuf:"bytes,1,req,name=vzone_name,json=vzoneName" json:"vzone_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_VZone) Reset()         { *m = ConfigurationProto_VZone{} }
func (m *ConfigurationProto_VZone) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_VZone) ProtoMessage()    {}
func (*ConfigurationProto_VZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 10}
}

func (m *ConfigurationProto_VZone) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_VZone.Unmarshal(m, b)
}
func (m *ConfigurationProto_VZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_VZone.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_VZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_VZone.Merge(m, src)
}
func (m *ConfigurationProto_VZone) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_VZone.Size(m)
}
func (m *ConfigurationProto_VZone) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_VZone.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_VZone proto.InternalMessageInfo

func (m *ConfigurationProto_VZone) GetVzoneName() string {
	if m != nil && m.VzoneName != nil {
		return *m.VzoneName
	}
	return ""
}

// Description of a remote site used by Cerebro.
type ConfigurationProto_RemoteSite struct {
	// Name assigned to the remote - needs to be unique within a cluster but
	// not globally unique across all clusters.
	RemoteName *string `protobuf:"bytes,1,req,name=remote_name,json=remoteName" json:"remote_name,omitempty"`
	// List of IPs where the cerebro instances may be running on the remote
	// cluster. This does not need to be the list of all IPs in that cluster.
	// We mostly need only one (and that one IP can tell us about the rest of
	// the cluster). We use multiple IPs here only for fault-tolerance.
	//
	// Once we start supporting a virtual IP, this list may only just contain
	// that one entry. This would be configured on a live SVM on the remote
	// side.
	RemoteCerebroIpList []string `protobuf:"bytes,2,rep,name=remote_cerebro_ip_list,json=remoteCerebroIpList" json:"remote_cerebro_ip_list,omitempty"`
	// List of ports where the cerebro instances listen for requests. The size
	// of this list should either be 0 - in which case the default cerebro port
	// is assumed. Or else the size should equal the size of
	// remote_cerebro_ip_list. In that case, the ports will be considered to
	// correspond to the IPs in remote_cerebro_ip_list.
	RemoteCerebroPortList []int32 `protobuf:"varint,3,rep,name=remote_cerebro_port_list,json=remoteCerebroPortList" json:"remote_cerebro_port_list,omitempty"`
	// If the following is set to true, then the above cerebro instances are
	// also used as proxies to communicate with other components (such as
	// stargate) at the remote site. It is also assumed that the channel to
	// them has been setup separately in a secure way (e.g., by forwarding
	// ports on an ssh connection). Any cerebro instance not in the above list
	// will also be communicated with via proxy'ing of requests.
	//
	// If this field is false, then it is assumed that all components at the
	// remote site are directly reachable.
	EnableProxy *bool `protobuf:"varint,4,opt,name=enable_proxy,json=enableProxy" json:"enable_proxy,omitempty"`
	// Mapping of vstore names on the local cluster to the vstore names
	// on the remote site. A name in local_vstore_name maps to the
	// corresponding name in remote_vstore_name. Data will be replicated to
	// the remote site accordingly. If a mapping for a local vstore name
	// doesn't exist here, it'll be assumed that the data needs to be
	// replicated to a similarly named vstore on the remote side. In other
	// words, a mapping only needs to exist here if the source and target
	// vstore names are different.
	LocalVstoreName  []string `protobuf:"bytes,5,rep,name=local_vstore_name,json=localVstoreName" json:"local_vstore_name,omitempty"`
	RemoteVstoreName []string `protobuf:"bytes,6,rep,name=remote_vstore_name,json=remoteVstoreName" json:"remote_vstore_name,omitempty"`
	// Max bandwidth (in bytes per sec) while replicating to this remote
	// site. If not specified, then there is no limit on the bandwidth.
	MaxBytesPerSec *int32 `protobuf:"varint,7,opt,name=max_bytes_per_sec,json=maxBytesPerSec" json:"max_bytes_per_sec,omitempty"`
	// The cluster id corresponding to the remote site. This is automatically
	// figured out by communicating with the remote site and is not added
	// directly through GUI/CLI commands. No replication to the remote site
	// will be started before this is figured out.
	ClusterId *int64 `protobuf:"varint,8,opt,name=cluster_id,json=clusterId" json:"cluster_id,omitempty"`
	// The cluster incarnation id corresponding to the remote site. This is
	// automatically figured out by communicating with the remote site and is
	// not added directly through GUI/CLI commands. No replication to the
	// remote site will be started before this is figured out. Note that this
	// would change on the remote site if a clean-data is done there.
	// Therefore, any RPCs that are sensitive to such a change should embed the
	// cluster incarnation id in the request so that the remote site can check
	// the RPC against the actual incarnation id on the cluster.
	ClusterIncarnationId *int64 `protobuf:"varint,9,opt,name=cluster_incarnation_id,json=clusterIncarnationId" json:"cluster_incarnation_id,omitempty"`
	// The following is set in case the cluster id and incarnation id need
	// to be refreshed.
	NeedClusterIdUpdate *bool `protobuf:"varint,10,opt,name=need_cluster_id_update,json=needClusterIdUpdate" json:"need_cluster_id_update,omitempty"`
	// If true, this remote is marked for deletion. The Cerebro master would
	// remove it whenever it is done canceling all outstanding operations
	// that are using this remote.
	ToRemove *bool `protobuf:"varint,11,opt,name=to_remove,json=toRemove" json:"to_remove,omitempty"`
	// Whether this remote is not operational due to having a conflict with
	// another remote's cluster id. That is, the cluster represented by this
	// remote already exists in another remote entry. If the conflicting entry
	// is removed, then this remote should be promoted to be active if there
	// are no other conflicts.
	IsDuplicateClusterId *bool `protobuf:"varint,12,opt,name=is_duplicate_cluster_id,json=isDuplicateClusterId" json:"is_duplicate_cluster_id,omitempty"`
	// Attribute name/value pairs associated with this remote site.
	// These fields are now deprecated and setting their values will be a
	//  no op.
	DeprecatedAttrNameVec  []string                                            `protobuf:"bytes,13,rep,name=deprecated_attr_name_vec,json=deprecatedAttrNameVec" json:"deprecated_attr_name_vec,omitempty"`
	DeprecatedAttrValueVec []string                                            `protobuf:"bytes,14,rep,name=deprecated_attr_value_vec,json=deprecatedAttrValueVec" json:"deprecated_attr_value_vec,omitempty"`
	CompressionAlgorithm   *ConfigurationProto_RemoteSite_CompressionAlgorithm `protobuf:"varint,15,opt,name=compression_algorithm,json=compressionAlgorithm,enum=nutanix.zeus.ConfigurationProto_RemoteSite_CompressionAlgorithm" json:"compression_algorithm,omitempty"`
	// If the desired compression algorithm is not available on the remote
	// site, 'compression_type' serves at a hint to Cerebro to determine the
	// appropriate compression algorithm to use.
	CompressionType *ConfigurationProto_ContainerParams_CompressionType `protobuf:"varint,16,opt,name=compression_type,json=compressionType,enum=nutanix.zeus.ConfigurationProto_ContainerParams_CompressionType" json:"compression_type,omitempty"`
	// External subnet corresponding to the remote cluster. This is used to
	// add iptables rules in order to allow direct communication to stargate
	// from the remote cluster. The format is subnet/netmask. For example,
	// "172.16.0.0/255.240.0.0".
	ExternalSubnet *string                                     `protobuf:"bytes,17,opt,name=external_subnet,json=externalSubnet" json:"external_subnet,omitempty"`
	Capabilities   *ConfigurationProto_RemoteSite_Capabilities `protobuf:"bytes,18,opt,name=capabilities" json:"capabilities,omitempty"`
	// Whether an SSH tunnel needs to be established to this remote site.
	UseSshTunnel *bool `protobuf:"varint,19,opt,name=use_ssh_tunnel,json=useSshTunnel" json:"use_ssh_tunnel,omitempty"`
	// List of remote proxies. SSH tunnel is established to these proxy end
	// points if SSH tunneling is enabled.
	ProxyList []*ConfigurationProto_NetworkEntity `protobuf:"bytes,20,rep,name=proxy_list,json=proxyList" json:"proxy_list,omitempty"`
	// Cloud site configuration for this remote site.
	CloudSiteInfo *zeus.CloudSiteInfo `protobuf:"bytes,21,opt,name=cloud_site_info,json=cloudSiteInfo" json:"cloud_site_info,omitempty"`
	// Whether the remote site should be considered unhealthy for stretch
	// purposes. This applies to sites that are stretched protection domain
	// targets, and otherwise should be ignored. It is to be used as a coarse
	// and conservative indicator for the stretch status of the remote site,
	// and may not be accurately reflective of whether a remote site is
	// reachable at the moment, or the overall stability of the connection.
	StretchIsUnhealthy *bool `protobuf:"varint,22,opt,name=stretch_is_unhealthy,json=stretchIsUnhealthy" json:"stretch_is_unhealthy,omitempty"`
	// UUID for remote site.
	RemoteSiteUuid *string `protobuf:"bytes,23,opt,name=remote_site_uuid,json=remoteSiteUuid" json:"remote_site_uuid,omitempty"`
	// Identifier of the network mapping configuration for this remote site.
	NetworkMappingUuid []byte `protobuf:"bytes,24,opt,name=network_mapping_uuid,json=networkMappingUuid" json:"network_mapping_uuid,omitempty"`
	// The lowest stargate version that exists in the remote cluster.
	StargateVersion *int32 `protobuf:"varint,25,opt,name=stargate_version,json=stargateVersion" json:"stargate_version,omitempty"`
	// Identifier of the bandwidth limit policy for this remote site.
	BandwidthPolicyUuid []byte `protobuf:"bytes,26,opt,name=bandwidth_policy_uuid,json=bandwidthPolicyUuid" json:"bandwidth_policy_uuid,omitempty"`
	// Whether bandwidth limit policy is enabled or not.
	BandwidthPolicyEnabled *bool `protobuf:"varint,27,opt,name=bandwidth_policy_enabled,json=bandwidthPolicyEnabled" json:"bandwidth_policy_enabled,omitempty"`
	// The set of rackable unit model names. If there are multiple rackable
	// units with the same name, it will be listed only one time.
	RackableUnitModelNames []string `protobuf:"bytes,28,rep,name=rackable_unit_model_names,json=rackableUnitModelNames" json:"rackable_unit_model_names,omitempty"`
	// Whether network mapping is present for local site on remote site.
	IsNetworkMappingPresentForLocalSite *bool `protobuf:"varint,29,opt,name=is_network_mapping_present_for_local_site,json=isNetworkMappingPresentForLocalSite" json:"is_network_mapping_present_for_local_site,omitempty"`
	// Data services IP of the remote site if configured.
	ClusterExternalDataServicesIp *string                                               `protobuf:"bytes,30,opt,name=cluster_external_data_services_ip,json=clusterExternalDataServicesIp" json:"cluster_external_data_services_ip,omitempty"`
	FileServerCapabilities        *ConfigurationProto_RemoteSite_FileServerCapabilities `protobuf:"bytes,31,opt,name=file_server_capabilities,json=fileServerCapabilities" json:"file_server_capabilities,omitempty"`
	// Identifier of the availability zone to which this remote site belongs.
	AvailabilityZoneUuid []byte `protobuf:"bytes,32,opt,name=availability_zone_uuid,json=availabilityZoneUuid" json:"availability_zone_uuid,omitempty"`
	// Type of the availability zone to which this remote site belongs.
	AvailabilityZoneType *zeus.AvailabilityZonePhysicalType_Type `protobuf:"varint,33,opt,name=availability_zone_type,json=availabilityZoneType,enum=nutanix.zeus.AvailabilityZonePhysicalType_Type" json:"availability_zone_type,omitempty"`
	// Status of the LWS store in this remote site.
	LwsStoreStatus *ConfigurationProto_LWSStoreConfig_State `protobuf:"varint,34,opt,name=lws_store_status,json=lwsStoreStatus,enum=nutanix.zeus.ConfigurationProto_LWSStoreConfig_State" json:"lws_store_status,omitempty"`
	// Identifier used to establish reverse connection. We will use reverse
	// connection to talk to this remote site only if this field is set. The
	// identifier is used to lookup the reverse connection server to get the
	// reverse connection.
	ReverseConnectionIdentifier *string `protobuf:"bytes,35,opt,name=reverse_connection_identifier,json=reverseConnectionIdentifier" json:"reverse_connection_identifier,omitempty"`
	// Xi tenant uuid, if 'availability_zone_type' is Xi.
	XiTenantUuid *string `protobuf:"bytes,36,opt,name=xi_tenant_uuid,json=xiTenantUuid" json:"xi_tenant_uuid,omitempty"`
	// Address of availability zone to which this remote site belongs. It will
	// be in form of IP or FQDN. Once set, this field should not be cleared,
	// until the remote site is deleted.
	RemoteAvailabilityZoneAddress *string `protobuf:"bytes,37,opt,name=remote_availability_zone_address,json=remoteAvailabilityZoneAddress" json:"remote_availability_zone_address,omitempty"`
	// Address of local availability zone. It will be in form of IP or FQDN.
	// Once set, this field should not be cleared, until the remote site is
	// deleted.
	LocalAvailabilityZoneAddress *string `protobuf:"bytes,38,opt,name=local_availability_zone_address,json=localAvailabilityZoneAddress" json:"local_availability_zone_address,omitempty"`
	// Type of the remote site.
	RemoteSiteType *ConfigurationProto_RemoteSite_RemoteSiteType `protobuf:"varint,39,opt,name=remote_site_type,json=remoteSiteType,enum=nutanix.zeus.ConfigurationProto_RemoteSite_RemoteSiteType,def=1" json:"remote_site_type,omitempty"`
	// List of containers available on the remote site.
	ContainerVec []*ConfigurationProto_RemoteSite_ContainerInfo `protobuf:"bytes,40,rep,name=container_vec,json=containerVec" json:"container_vec,omitempty"`
	// Whether an address translation is needed to communicate with this
	// remote.
	UseAddressTranslation *bool `protobuf:"varint,41,opt,name=use_address_translation,json=useAddressTranslation" json:"use_address_translation,omitempty"`
	// Whether remote is registered to management server.
	// If the hypervisor is ESX, the management server is vcentre.
	IsRegisteredToManagementServer *bool `protobuf:"varint,42,opt,name=is_registered_to_management_server,json=isRegisteredToManagementServer" json:"is_registered_to_management_server,omitempty"`
	// Indicates whether the remote site is unhealthy for 'entity centric'
	// workflows. This should be considered only for sites with
	// 'remote_site_type' set to kEntityCentric, otherwise should be ignored.
	// It indicates one of the following.
	// - Remote Availability Zone has been unpaired at PC level.
	// - Prolonged unreachability of the remote site.
	// - Remote site cluster id or incarnation id changed - kStaleCluster
	// - Remote site resources unavailability (like storage full, etc)
	IsUnhealthy  *bool                                     `protobuf:"varint,43,opt,name=is_unhealthy,json=isUnhealthy" json:"is_unhealthy,omitempty"`
	NodeInfoList []*ConfigurationProto_RemoteSite_NodeInfo `protobuf:"bytes,44,rep,name=node_info_list,json=nodeInfoList" json:"node_info_list,omitempty"`
	// Name of the availability zone to which this remote site belongs.
	AvailabilityZoneName *string `protobuf:"bytes,45,opt,name=availability_zone_name,json=availabilityZoneName" json:"availability_zone_name,omitempty"`
	// Identifier of the availability zone where remote site construct is
	// being created.
	// This availability zone info is of the PC connected to the local PE,
	// e.g. If remote site is being created at PE 'A' for target PE 'B'
	// and 'A' is connected to PC 'P' , local availability zone info contains
	// the info of PC 'P' of type kLocal.
	LocalAvailabilityZoneUuid []byte `protobuf:"bytes,46,opt,name=local_availability_zone_uuid,json=localAvailabilityZoneUuid" json:"local_availability_zone_uuid,omitempty"`
	// Name of the availability zone where remote site construct is being
	// created.
	LocalAvailabilityZoneName *string `protobuf:"bytes,47,opt,name=local_availability_zone_name,json=localAvailabilityZoneName" json:"local_availability_zone_name,omitempty"`
	// For legacy remote sites to work over a load balancer, set this field
	// with the address of the availability zone that this remote site belongs
	// to. Typical use-case is to allow a legacy protection domain to replicate
	// data between OnPrem and Xi clusters using legacy remote site objects.
	LegacyRemoteXatKey *string `protobuf:"bytes,48,opt,name=legacy_remote_xat_key,json=legacyRemoteXatKey" json:"legacy_remote_xat_key,omitempty"`
	// Flag to indicate the remote external subnet is user specified, if true
	// then the external_subnet value will not get overwritten with value
	// provided by the remote via RPC response.
	// This flag may get set when external_subnet of a RemoteSite is updated
	// by the user while adding or modifying the remote and may get reset when
	// the user specified remote_subnet is null string.
	HasUserSpecifiedExternalSubnet *bool `protobuf:"varint,49,opt,name=has_user_specified_external_subnet,json=hasUserSpecifiedExternalSubnet,def=0" json:"has_user_specified_external_subnet,omitempty"`
	// Name of the remote cluster.
	RemoteClusterName *string `protobuf:"bytes,50,opt,name=remote_cluster_name,json=remoteClusterName" json:"remote_cluster_name,omitempty"`
	// Uuid of the ReplicationTargetInfo object created during the creation of
	// the remote site.
	ReplicationTargetInfoUuid *string  `protobuf:"bytes,51,opt,name=replication_target_info_uuid,json=replicationTargetInfoUuid" json:"replication_target_info_uuid,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *ConfigurationProto_RemoteSite) Reset()         { *m = ConfigurationProto_RemoteSite{} }
func (m *ConfigurationProto_RemoteSite) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_RemoteSite) ProtoMessage()    {}
func (*ConfigurationProto_RemoteSite) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11}
}

func (m *ConfigurationProto_RemoteSite) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RemoteSite.Unmarshal(m, b)
}
func (m *ConfigurationProto_RemoteSite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RemoteSite.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RemoteSite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RemoteSite.Merge(m, src)
}
func (m *ConfigurationProto_RemoteSite) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RemoteSite.Size(m)
}
func (m *ConfigurationProto_RemoteSite) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RemoteSite.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RemoteSite proto.InternalMessageInfo

const Default_ConfigurationProto_RemoteSite_RemoteSiteType ConfigurationProto_RemoteSite_RemoteSiteType = ConfigurationProto_RemoteSite_kLegacy
const Default_ConfigurationProto_RemoteSite_HasUserSpecifiedExternalSubnet bool = false

func (m *ConfigurationProto_RemoteSite) GetRemoteName() string {
	if m != nil && m.RemoteName != nil {
		return *m.RemoteName
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetRemoteCerebroIpList() []string {
	if m != nil {
		return m.RemoteCerebroIpList
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetRemoteCerebroPortList() []int32 {
	if m != nil {
		return m.RemoteCerebroPortList
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetEnableProxy() bool {
	if m != nil && m.EnableProxy != nil {
		return *m.EnableProxy
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetLocalVstoreName() []string {
	if m != nil {
		return m.LocalVstoreName
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetRemoteVstoreName() []string {
	if m != nil {
		return m.RemoteVstoreName
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetMaxBytesPerSec() int32 {
	if m != nil && m.MaxBytesPerSec != nil {
		return *m.MaxBytesPerSec
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite) GetClusterId() int64 {
	if m != nil && m.ClusterId != nil {
		return *m.ClusterId
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite) GetClusterIncarnationId() int64 {
	if m != nil && m.ClusterIncarnationId != nil {
		return *m.ClusterIncarnationId
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite) GetNeedClusterIdUpdate() bool {
	if m != nil && m.NeedClusterIdUpdate != nil {
		return *m.NeedClusterIdUpdate
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetIsDuplicateClusterId() bool {
	if m != nil && m.IsDuplicateClusterId != nil {
		return *m.IsDuplicateClusterId
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetDeprecatedAttrNameVec() []string {
	if m != nil {
		return m.DeprecatedAttrNameVec
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetDeprecatedAttrValueVec() []string {
	if m != nil {
		return m.DeprecatedAttrValueVec
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetCompressionAlgorithm() ConfigurationProto_RemoteSite_CompressionAlgorithm {
	if m != nil && m.CompressionAlgorithm != nil {
		return *m.CompressionAlgorithm
	}
	return ConfigurationProto_RemoteSite_kSnappy
}

func (m *ConfigurationProto_RemoteSite) GetCompressionType() ConfigurationProto_ContainerParams_CompressionType {
	if m != nil && m.CompressionType != nil {
		return *m.CompressionType
	}
	return ConfigurationProto_ContainerParams_kNone
}

func (m *ConfigurationProto_RemoteSite) GetExternalSubnet() string {
	if m != nil && m.ExternalSubnet != nil {
		return *m.ExternalSubnet
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetCapabilities() *ConfigurationProto_RemoteSite_Capabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetUseSshTunnel() bool {
	if m != nil && m.UseSshTunnel != nil {
		return *m.UseSshTunnel
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetProxyList() []*ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.ProxyList
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetCloudSiteInfo() *zeus.CloudSiteInfo {
	if m != nil {
		return m.CloudSiteInfo
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetStretchIsUnhealthy() bool {
	if m != nil && m.StretchIsUnhealthy != nil {
		return *m.StretchIsUnhealthy
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetRemoteSiteUuid() string {
	if m != nil && m.RemoteSiteUuid != nil {
		return *m.RemoteSiteUuid
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetNetworkMappingUuid() []byte {
	if m != nil {
		return m.NetworkMappingUuid
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetStargateVersion() int32 {
	if m != nil && m.StargateVersion != nil {
		return *m.StargateVersion
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite) GetBandwidthPolicyUuid() []byte {
	if m != nil {
		return m.BandwidthPolicyUuid
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetBandwidthPolicyEnabled() bool {
	if m != nil && m.BandwidthPolicyEnabled != nil {
		return *m.BandwidthPolicyEnabled
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetRackableUnitModelNames() []string {
	if m != nil {
		return m.RackableUnitModelNames
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetIsNetworkMappingPresentForLocalSite() bool {
	if m != nil && m.IsNetworkMappingPresentForLocalSite != nil {
		return *m.IsNetworkMappingPresentForLocalSite
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetClusterExternalDataServicesIp() string {
	if m != nil && m.ClusterExternalDataServicesIp != nil {
		return *m.ClusterExternalDataServicesIp
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetFileServerCapabilities() *ConfigurationProto_RemoteSite_FileServerCapabilities {
	if m != nil {
		return m.FileServerCapabilities
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetAvailabilityZoneUuid() []byte {
	if m != nil {
		return m.AvailabilityZoneUuid
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetAvailabilityZoneType() zeus.AvailabilityZonePhysicalType_Type {
	if m != nil && m.AvailabilityZoneType != nil {
		return *m.AvailabilityZoneType
	}
	return zeus.AvailabilityZonePhysicalType_kPC
}

func (m *ConfigurationProto_RemoteSite) GetLwsStoreStatus() ConfigurationProto_LWSStoreConfig_State {
	if m != nil && m.LwsStoreStatus != nil {
		return *m.LwsStoreStatus
	}
	return ConfigurationProto_LWSStoreConfig_kAbsent
}

func (m *ConfigurationProto_RemoteSite) GetReverseConnectionIdentifier() string {
	if m != nil && m.ReverseConnectionIdentifier != nil {
		return *m.ReverseConnectionIdentifier
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetXiTenantUuid() string {
	if m != nil && m.XiTenantUuid != nil {
		return *m.XiTenantUuid
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetRemoteAvailabilityZoneAddress() string {
	if m != nil && m.RemoteAvailabilityZoneAddress != nil {
		return *m.RemoteAvailabilityZoneAddress
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetLocalAvailabilityZoneAddress() string {
	if m != nil && m.LocalAvailabilityZoneAddress != nil {
		return *m.LocalAvailabilityZoneAddress
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetRemoteSiteType() ConfigurationProto_RemoteSite_RemoteSiteType {
	if m != nil && m.RemoteSiteType != nil {
		return *m.RemoteSiteType
	}
	return Default_ConfigurationProto_RemoteSite_RemoteSiteType
}

func (m *ConfigurationProto_RemoteSite) GetContainerVec() []*ConfigurationProto_RemoteSite_ContainerInfo {
	if m != nil {
		return m.ContainerVec
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetUseAddressTranslation() bool {
	if m != nil && m.UseAddressTranslation != nil {
		return *m.UseAddressTranslation
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetIsRegisteredToManagementServer() bool {
	if m != nil && m.IsRegisteredToManagementServer != nil {
		return *m.IsRegisteredToManagementServer
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetIsUnhealthy() bool {
	if m != nil && m.IsUnhealthy != nil {
		return *m.IsUnhealthy
	}
	return false
}

func (m *ConfigurationProto_RemoteSite) GetNodeInfoList() []*ConfigurationProto_RemoteSite_NodeInfo {
	if m != nil {
		return m.NodeInfoList
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetAvailabilityZoneName() string {
	if m != nil && m.AvailabilityZoneName != nil {
		return *m.AvailabilityZoneName
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetLocalAvailabilityZoneUuid() []byte {
	if m != nil {
		return m.LocalAvailabilityZoneUuid
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite) GetLocalAvailabilityZoneName() string {
	if m != nil && m.LocalAvailabilityZoneName != nil {
		return *m.LocalAvailabilityZoneName
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetLegacyRemoteXatKey() string {
	if m != nil && m.LegacyRemoteXatKey != nil {
		return *m.LegacyRemoteXatKey
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetHasUserSpecifiedExternalSubnet() bool {
	if m != nil && m.HasUserSpecifiedExternalSubnet != nil {
		return *m.HasUserSpecifiedExternalSubnet
	}
	return Default_ConfigurationProto_RemoteSite_HasUserSpecifiedExternalSubnet
}

func (m *ConfigurationProto_RemoteSite) GetRemoteClusterName() string {
	if m != nil && m.RemoteClusterName != nil {
		return *m.RemoteClusterName
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite) GetReplicationTargetInfoUuid() string {
	if m != nil && m.ReplicationTargetInfoUuid != nil {
		return *m.ReplicationTargetInfoUuid
	}
	return ""
}

// Maximum virtual hardware version supported by this remote. In case of
// mixed hypervisor remote site, set the maximum virtual hardware version
// supported by all the nodes of each kind of hypervisor type.
type ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion struct {
	// Maximum virtual hardware version supported by vsphere nodes of the
	// remote site.
	VsphereMaxVirtualHardwareVersion *int32 `protobuf:"varint,1,opt,name=vsphere_max_virtual_hardware_version,json=vsphereMaxVirtualHardwareVersion" json:"vsphere_max_virtual_hardware_version,omitempty"`
	// Maximum virtual hardware version supported by hyperv nodes of the
	// remote site.
	HypervMaxVirtualHardwareVersion *int32 `protobuf:"varint,2,opt,name=hyperv_max_virtual_hardware_version,json=hypervMaxVirtualHardwareVersion" json:"hyperv_max_virtual_hardware_version,omitempty"`
	// Maximum virtual hardware version supported by kvm nodes of the
	// remote site.
	KvmMaxVirtualHardwareVersion *int32   `protobuf:"varint,3,opt,name=kvm_max_virtual_hardware_version,json=kvmMaxVirtualHardwareVersion" json:"kvm_max_virtual_hardware_version,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) Reset() {
	*m = ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion{}
}
func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) ProtoMessage() {}
func (*ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 0}
}

func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion.Unmarshal(m, b)
}
func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion.Merge(m, src)
}
func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion.Size(m)
}
func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion proto.InternalMessageInfo

func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) GetVsphereMaxVirtualHardwareVersion() int32 {
	if m != nil && m.VsphereMaxVirtualHardwareVersion != nil {
		return *m.VsphereMaxVirtualHardwareVersion
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) GetHypervMaxVirtualHardwareVersion() int32 {
	if m != nil && m.HypervMaxVirtualHardwareVersion != nil {
		return *m.HypervMaxVirtualHardwareVersion
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion) GetKvmMaxVirtualHardwareVersion() int32 {
	if m != nil && m.KvmMaxVirtualHardwareVersion != nil {
		return *m.KvmMaxVirtualHardwareVersion
	}
	return 0
}

// Capabilities for this remote site. This is used to determine what
// actions are allowed to be performed on this remote site entity
// from the local cluster.
type ConfigurationProto_RemoteSite_Capabilities struct {
	Backup                              *bool                                                    `protobuf:"varint,1,opt,name=backup,def=1" json:"backup,omitempty"`
	DisasterRecovery                    *bool                                                    `protobuf:"varint,2,opt,name=disaster_recovery,json=disasterRecovery,def=1" json:"disaster_recovery,omitempty"`
	SupportsDedupedExtents              *bool                                                    `protobuf:"varint,3,opt,name=supports_deduped_extents,json=supportsDedupedExtents" json:"supports_deduped_extents,omitempty"`
	SupportsVsphere                     *bool                                                    `protobuf:"varint,4,opt,name=supports_vsphere,json=supportsVsphere" json:"supports_vsphere,omitempty"`
	SupportsHyperv                      *bool                                                    `protobuf:"varint,5,opt,name=supports_hyperv,json=supportsHyperv" json:"supports_hyperv,omitempty"`
	SupportsKvm                         *bool                                                    `protobuf:"varint,6,opt,name=supports_kvm,json=supportsKvm" json:"supports_kvm,omitempty"`
	SupportsVstoreStretching            *bool                                                    `protobuf:"varint,7,opt,name=supports_vstore_stretching,json=supportsVstoreStretching" json:"supports_vstore_stretching,omitempty"`
	SupportsOnWireSparseExtents         *bool                                                    `protobuf:"varint,8,opt,name=supports_on_wire_sparse_extents,json=supportsOnWireSparseExtents" json:"supports_on_wire_sparse_extents,omitempty"`
	MaxVirtualHardwareVersion           *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion `protobuf:"bytes,9,opt,name=max_virtual_hardware_version,json=maxVirtualHardwareVersion" json:"max_virtual_hardware_version,omitempty"`
	SupportsVstoreResolution            *bool                                                    `protobuf:"varint,10,opt,name=supports_vstore_resolution,json=supportsVstoreResolution" json:"supports_vstore_resolution,omitempty"`
	SupportsDiffVblocks                 *bool                                                    `protobuf:"varint,11,opt,name=supports_diff_vblocks,json=supportsDiffVblocks" json:"supports_diff_vblocks,omitempty"`
	CrossHypervisorDrCapabilitiesBitmap *uint64                                                  `protobuf:"varint,12,opt,name=cross_hypervisor_dr_capabilities_bitmap,json=crossHypervisorDrCapabilitiesBitmap" json:"cross_hypervisor_dr_capabilities_bitmap,omitempty"`
	CerebroFeaturesBitmap               *uint64                                                  `protobuf:"varint,13,opt,name=cerebro_features_bitmap,json=cerebroFeaturesBitmap" json:"cerebro_features_bitmap,omitempty"`
	FileLevelRestoreCapabilitiesBitmap  *uint64                                                  `protobuf:"varint,14,opt,name=file_level_restore_capabilities_bitmap,json=fileLevelRestoreCapabilitiesBitmap" json:"file_level_restore_capabilities_bitmap,omitempty"`
	ClusterOperationMode                *ConfigurationProto_OperationMode                        `protobuf:"varint,15,opt,name=cluster_operation_mode,json=clusterOperationMode,enum=nutanix.zeus.ConfigurationProto_OperationMode,def=0" json:"cluster_operation_mode,omitempty"`
	// If this value is set to -1, the RPC timeout as defined in
	// StargateInterfaceProto::CerebroReceiveTask is used.
	CerebroReceiveRpcTimeoutMsecs *int32  `protobuf:"varint,16,opt,name=cerebro_receive_rpc_timeout_msecs,json=cerebroReceiveRpcTimeoutMsecs,def=-1" json:"cerebro_receive_rpc_timeout_msecs,omitempty"`
	ClusterPropertiesBitmap       *uint32 `protobuf:"varint,17,opt,name=cluster_properties_bitmap,json=clusterPropertiesBitmap,def=0" json:"cluster_properties_bitmap,omitempty"`
	// Minimum supported RPO in seconds for async replication.
	MinimumSupportedAsyncRpoSecs *uint64 `protobuf:"varint,18,opt,name=minimum_supported_async_rpo_secs,json=minimumSupportedAsyncRpoSecs,def=3600" json:"minimum_supported_async_rpo_secs,omitempty"`
	// Minimum supported RPO for nearsync replication in seconds. This is
	// applicable only for non-vstore protection domains.
	MinimumSupportedNearsyncRpoSecs *int64 `protobuf:"varint,19,opt,name=minimum_supported_nearsync_rpo_secs,json=minimumSupportedNearsyncRpoSecs,def=-1" json:"minimum_supported_nearsync_rpo_secs,omitempty"`
	// Architecture of remote site.
	ClusterArch *ConfigurationProto_ClusterArch `protobuf:"varint,20,opt,name=cluster_arch,json=clusterArch,enum=nutanix.zeus.ConfigurationProto_ClusterArch" json:"cluster_arch,omitempty"`
	// Mesos features bitmap.
	MesosFeaturesBitmap *uint64 `protobuf:"varint,21,opt,name=mesos_features_bitmap,json=mesosFeaturesBitmap" json:"mesos_features_bitmap,omitempty"`
	// Minimum supported RPO for nearsync vstore protection in seconds.
	MinimumSupportedNearsyncVstoreRpoSecs *int64   `protobuf:"varint,22,opt,name=minimum_supported_nearsync_vstore_rpo_secs,json=minimumSupportedNearsyncVstoreRpoSecs,def=-1" json:"minimum_supported_nearsync_vstore_rpo_secs,omitempty"`
	XXX_NoUnkeyedLiteral                  struct{} `json:"-"`
	XXX_unrecognized                      []byte   `json:"-"`
	XXX_sizecache                         int32    `json:"-"`
}

func (m *ConfigurationProto_RemoteSite_Capabilities) Reset() {
	*m = ConfigurationProto_RemoteSite_Capabilities{}
}
func (m *ConfigurationProto_RemoteSite_Capabilities) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_RemoteSite_Capabilities) ProtoMessage() {}
func (*ConfigurationProto_RemoteSite_Capabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 1}
}

func (m *ConfigurationProto_RemoteSite_Capabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_Capabilities.Unmarshal(m, b)
}
func (m *ConfigurationProto_RemoteSite_Capabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_Capabilities.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RemoteSite_Capabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RemoteSite_Capabilities.Merge(m, src)
}
func (m *ConfigurationProto_RemoteSite_Capabilities) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_Capabilities.Size(m)
}
func (m *ConfigurationProto_RemoteSite_Capabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RemoteSite_Capabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RemoteSite_Capabilities proto.InternalMessageInfo

const Default_ConfigurationProto_RemoteSite_Capabilities_Backup bool = true
const Default_ConfigurationProto_RemoteSite_Capabilities_DisasterRecovery bool = true
const Default_ConfigurationProto_RemoteSite_Capabilities_ClusterOperationMode ConfigurationProto_OperationMode = ConfigurationProto_kNormal
const Default_ConfigurationProto_RemoteSite_Capabilities_CerebroReceiveRpcTimeoutMsecs int32 = -1
const Default_ConfigurationProto_RemoteSite_Capabilities_ClusterPropertiesBitmap uint32 = 0
const Default_ConfigurationProto_RemoteSite_Capabilities_MinimumSupportedAsyncRpoSecs uint64 = 3600
const Default_ConfigurationProto_RemoteSite_Capabilities_MinimumSupportedNearsyncRpoSecs int64 = -1
const Default_ConfigurationProto_RemoteSite_Capabilities_MinimumSupportedNearsyncVstoreRpoSecs int64 = -1

func (m *ConfigurationProto_RemoteSite_Capabilities) GetBackup() bool {
	if m != nil && m.Backup != nil {
		return *m.Backup
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_Backup
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetDisasterRecovery() bool {
	if m != nil && m.DisasterRecovery != nil {
		return *m.DisasterRecovery
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_DisasterRecovery
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsDedupedExtents() bool {
	if m != nil && m.SupportsDedupedExtents != nil {
		return *m.SupportsDedupedExtents
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsVsphere() bool {
	if m != nil && m.SupportsVsphere != nil {
		return *m.SupportsVsphere
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsHyperv() bool {
	if m != nil && m.SupportsHyperv != nil {
		return *m.SupportsHyperv
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsKvm() bool {
	if m != nil && m.SupportsKvm != nil {
		return *m.SupportsKvm
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsVstoreStretching() bool {
	if m != nil && m.SupportsVstoreStretching != nil {
		return *m.SupportsVstoreStretching
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsOnWireSparseExtents() bool {
	if m != nil && m.SupportsOnWireSparseExtents != nil {
		return *m.SupportsOnWireSparseExtents
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetMaxVirtualHardwareVersion() *ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion {
	if m != nil {
		return m.MaxVirtualHardwareVersion
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsVstoreResolution() bool {
	if m != nil && m.SupportsVstoreResolution != nil {
		return *m.SupportsVstoreResolution
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetSupportsDiffVblocks() bool {
	if m != nil && m.SupportsDiffVblocks != nil {
		return *m.SupportsDiffVblocks
	}
	return false
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetCrossHypervisorDrCapabilitiesBitmap() uint64 {
	if m != nil && m.CrossHypervisorDrCapabilitiesBitmap != nil {
		return *m.CrossHypervisorDrCapabilitiesBitmap
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetCerebroFeaturesBitmap() uint64 {
	if m != nil && m.CerebroFeaturesBitmap != nil {
		return *m.CerebroFeaturesBitmap
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetFileLevelRestoreCapabilitiesBitmap() uint64 {
	if m != nil && m.FileLevelRestoreCapabilitiesBitmap != nil {
		return *m.FileLevelRestoreCapabilitiesBitmap
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetClusterOperationMode() ConfigurationProto_OperationMode {
	if m != nil && m.ClusterOperationMode != nil {
		return *m.ClusterOperationMode
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_ClusterOperationMode
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetCerebroReceiveRpcTimeoutMsecs() int32 {
	if m != nil && m.CerebroReceiveRpcTimeoutMsecs != nil {
		return *m.CerebroReceiveRpcTimeoutMsecs
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_CerebroReceiveRpcTimeoutMsecs
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetClusterPropertiesBitmap() uint32 {
	if m != nil && m.ClusterPropertiesBitmap != nil {
		return *m.ClusterPropertiesBitmap
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_ClusterPropertiesBitmap
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetMinimumSupportedAsyncRpoSecs() uint64 {
	if m != nil && m.MinimumSupportedAsyncRpoSecs != nil {
		return *m.MinimumSupportedAsyncRpoSecs
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_MinimumSupportedAsyncRpoSecs
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetMinimumSupportedNearsyncRpoSecs() int64 {
	if m != nil && m.MinimumSupportedNearsyncRpoSecs != nil {
		return *m.MinimumSupportedNearsyncRpoSecs
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_MinimumSupportedNearsyncRpoSecs
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetClusterArch() ConfigurationProto_ClusterArch {
	if m != nil && m.ClusterArch != nil {
		return *m.ClusterArch
	}
	return ConfigurationProto_kX86_64
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetMesosFeaturesBitmap() uint64 {
	if m != nil && m.MesosFeaturesBitmap != nil {
		return *m.MesosFeaturesBitmap
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_Capabilities) GetMinimumSupportedNearsyncVstoreRpoSecs() int64 {
	if m != nil && m.MinimumSupportedNearsyncVstoreRpoSecs != nil {
		return *m.MinimumSupportedNearsyncVstoreRpoSecs
	}
	return Default_ConfigurationProto_RemoteSite_Capabilities_MinimumSupportedNearsyncVstoreRpoSecs
}

type ConfigurationProto_RemoteSite_FileServerCapabilities struct {
	// AFS/Minerva file server capabilities.
	Bitmap               *uint64  `protobuf:"varint,1,opt,name=bitmap,def=0" json:"bitmap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) Reset() {
	*m = ConfigurationProto_RemoteSite_FileServerCapabilities{}
}
func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_RemoteSite_FileServerCapabilities) ProtoMessage() {}
func (*ConfigurationProto_RemoteSite_FileServerCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 2}
}

func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_FileServerCapabilities.Unmarshal(m, b)
}
func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_FileServerCapabilities.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RemoteSite_FileServerCapabilities.Merge(m, src)
}
func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_FileServerCapabilities.Size(m)
}
func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RemoteSite_FileServerCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RemoteSite_FileServerCapabilities proto.InternalMessageInfo

const Default_ConfigurationProto_RemoteSite_FileServerCapabilities_Bitmap uint64 = 0

func (m *ConfigurationProto_RemoteSite_FileServerCapabilities) GetBitmap() uint64 {
	if m != nil && m.Bitmap != nil {
		return *m.Bitmap
	}
	return Default_ConfigurationProto_RemoteSite_FileServerCapabilities_Bitmap
}

type ConfigurationProto_RemoteSite_ContainerInfo struct {
	// Name of the container.
	ContainerName *string `protobuf:"bytes,1,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	// UUID of the container.
	ContainerUuid []byte `protobuf:"bytes,2,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	// Whether this container is used as default container for Backup/DR.
	IsDefaultContainer   *bool    `protobuf:"varint,3,opt,name=is_default_container,json=isDefaultContainer" json:"is_default_container,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RemoteSite_ContainerInfo) Reset() {
	*m = ConfigurationProto_RemoteSite_ContainerInfo{}
}
func (m *ConfigurationProto_RemoteSite_ContainerInfo) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_RemoteSite_ContainerInfo) ProtoMessage() {}
func (*ConfigurationProto_RemoteSite_ContainerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 3}
}

func (m *ConfigurationProto_RemoteSite_ContainerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_ContainerInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_RemoteSite_ContainerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_ContainerInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RemoteSite_ContainerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RemoteSite_ContainerInfo.Merge(m, src)
}
func (m *ConfigurationProto_RemoteSite_ContainerInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_ContainerInfo.Size(m)
}
func (m *ConfigurationProto_RemoteSite_ContainerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RemoteSite_ContainerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RemoteSite_ContainerInfo proto.InternalMessageInfo

func (m *ConfigurationProto_RemoteSite_ContainerInfo) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *ConfigurationProto_RemoteSite_ContainerInfo) GetContainerUuid() []byte {
	if m != nil {
		return m.ContainerUuid
	}
	return nil
}

func (m *ConfigurationProto_RemoteSite_ContainerInfo) GetIsDefaultContainer() bool {
	if m != nil && m.IsDefaultContainer != nil {
		return *m.IsDefaultContainer
	}
	return false
}

// List of node information of this remote site.
type ConfigurationProto_RemoteSite_NodeInfo struct {
	// Id of SVM.
	ServiceVmId *int64 `protobuf:"varint,1,opt,name=service_vm_id,json=serviceVmId" json:"service_vm_id,omitempty"`
	// Handle to the stargate service hosted on this node.
	StargateHandle       *string  `protobuf:"bytes,2,opt,name=stargate_handle,json=stargateHandle" json:"stargate_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RemoteSite_NodeInfo) Reset() {
	*m = ConfigurationProto_RemoteSite_NodeInfo{}
}
func (m *ConfigurationProto_RemoteSite_NodeInfo) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_RemoteSite_NodeInfo) ProtoMessage()    {}
func (*ConfigurationProto_RemoteSite_NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 11, 4}
}

func (m *ConfigurationProto_RemoteSite_NodeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_NodeInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_RemoteSite_NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_NodeInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RemoteSite_NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RemoteSite_NodeInfo.Merge(m, src)
}
func (m *ConfigurationProto_RemoteSite_NodeInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RemoteSite_NodeInfo.Size(m)
}
func (m *ConfigurationProto_RemoteSite_NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RemoteSite_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RemoteSite_NodeInfo proto.InternalMessageInfo

func (m *ConfigurationProto_RemoteSite_NodeInfo) GetServiceVmId() int64 {
	if m != nil && m.ServiceVmId != nil {
		return *m.ServiceVmId
	}
	return 0
}

func (m *ConfigurationProto_RemoteSite_NodeInfo) GetStargateHandle() string {
	if m != nil && m.StargateHandle != nil {
		return *m.StargateHandle
	}
	return ""
}

// The Aegis message encapsulates all the information required
// to set up call home, remote support, and future features.
type ConfigurationProto_Aegis struct {
	// The list of service centers that can be connected to.
	ServiceCenterList []*ConfigurationProto_NetworkEntity `protobuf:"bytes,1,rep,name=service_center_list,json=serviceCenterList" json:"service_center_list,omitempty"`
	// Sometimes, to contact the Nutanix Service Center (NSC), the Nutanix
	// cluster might need to go through an HTTP Proxy.
	HttpProxyList []*ConfigurationProto_NetworkEntity `protobuf:"bytes,2,rep,name=http_proxy_list,json=httpProxyList" json:"http_proxy_list,omitempty"`
	// For remote support:
	// a) It is disabled by default.
	// b) When boolean value is false, until_time_usecs won't be
	//    applicable and 0 will be assumed.
	// c) When beyond until_time_usecs, opposite boolean value is assumed.
	RemoteSupport *ConfigurationProto_Aegis_TimedBool `protobuf:"bytes,3,opt,name=remote_support,json=remoteSupport" json:"remote_support,omitempty"`
	// For Alert emails:
	// a) If this field does not exist, we assume it is enabled.
	// b) until_time_usecs is not currently set or used.
	EmailAlerts *ConfigurationProto_Aegis_TimedBool `protobuf:"bytes,4,opt,name=email_alerts,json=emailAlerts" json:"email_alerts,omitempty"`
	// The list of email addresses where email alerts should be sent
	// by default.
	DefaultEmailAlertContactList []string                                 `protobuf:"bytes,5,rep,name=default_email_alert_contact_list,json=defaultEmailAlertContactList" json:"default_email_alert_contact_list,omitempty"`
	SmtpServer                   *ConfigurationProto_NetworkEntity        `protobuf:"bytes,6,opt,name=smtp_server,json=smtpServer" json:"smtp_server,omitempty"`
	SmtpServerType               *ConfigurationProto_Aegis_SmtpServerType `protobuf:"varint,7,opt,name=smtp_server_type,json=smtpServerType,enum=nutanix.zeus.ConfigurationProto_Aegis_SmtpServerType,def=0" json:"smtp_server_type,omitempty"`
	// Verbosity level for sending support information.
	Verbosity *ConfigurationProto_Aegis_SupportInformationVerbosityLevel `protobuf:"varint,8,opt,name=verbosity,enum=nutanix.zeus.ConfigurationProto_Aegis_SupportInformationVerbosityLevel,def=2" json:"verbosity,omitempty"`
	// NCC configuration of a cluster.
	NccConfig         *ConfigurationProto_Aegis_NccConfig         `protobuf:"bytes,9,opt,name=ncc_config,json=nccConfig" json:"ncc_config,omitempty"`
	AutoSupportConfig *ConfigurationProto_Aegis_AutoSupportConfig `protobuf:"bytes,10,opt,name=auto_support_config,json=autoSupportConfig" json:"auto_support_config,omitempty"`
	// "from" address to use for sending emails. All mails need to originate
	// from this address.
	FromAddress *string `protobuf:"bytes,11,opt,name=from_address,json=fromAddress,def=cluster@nutanix.com" json:"from_address,omitempty"`
	// Knob to control sending email alerts to nutanix.
	// The external recepient list is a constant defined in
	// alert manager.
	SendEmailAlertsExternally *bool `protobuf:"varint,12,opt,name=send_email_alerts_externally,json=sendEmailAlertsExternally,def=0" json:"send_email_alerts_externally,omitempty"`
	// Knob to control sending of alert email digest.
	SendAlertEmailDigest *bool `protobuf:"varint,13,opt,name=send_alert_email_digest,json=sendAlertEmailDigest,def=1" json:"send_alert_email_digest,omitempty"`
	// Knob to disable ipmi monitoring. If set hardware monitoring checks
	// are disabled across all the nodes on the cluster.
	DisableIpmiMonitoring *bool `protobuf:"varint,14,opt,name=disable_ipmi_monitoring,json=disableIpmiMonitoring" json:"disable_ipmi_monitoring,omitempty"`
	// Text that needs to be prepended to email alert subject.
	// The term {token} will be replaced by the token associated with an alert.
	// Tokens can be used to map nutanix alerts to an external alert tracking
	// system. Though the check schema supports multiple tokens per alert type,
	// we now only support one token (named "token") per alert type.
	// e.g. Aegis.email_alert_subject_prefix = "ServiceNow issue {token}"
	//      Alert A1024's AlertConfig.token_list = { "token" : "SN125" }
	// The resulting email subject will look like:
	// "ServiceNow issue SN125 :: A1024 : Controller VM Rebooted"
	EmailAlertSubjectPrefix *string `protobuf:"bytes,15,opt,name=email_alert_subject_prefix,json=emailAlertSubjectPrefix" json:"email_alert_subject_prefix,omitempty"`
	// Text that needs to be appended to email alert body.
	// The term {token} will be replaced by the token associated with an alert.
	// The semantics are same as the email_alert_subject_prefix except that
	// applies to the body of the alert email.
	EmailAlertBodySuffix *string                                        `protobuf:"bytes,16,opt,name=email_alert_body_suffix,json=emailAlertBodySuffix" json:"email_alert_body_suffix,omitempty"`
	HttpProxyWhitelist   []*ConfigurationProto_Aegis_HttpProxyWhitelist `protobuf:"bytes,17,rep,name=http_proxy_whitelist,json=httpProxyWhitelist" json:"http_proxy_whitelist,omitempty"`
	// Send alert email digest only if there are one or more alerts.
	SkipEmptyAlertEmailDigest *bool    `protobuf:"varint,18,opt,name=skip_empty_alert_email_digest,json=skipEmptyAlertEmailDigest,def=1" json:"skip_empty_alert_email_digest,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *ConfigurationProto_Aegis) Reset()         { *m = ConfigurationProto_Aegis{} }
func (m *ConfigurationProto_Aegis) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Aegis) ProtoMessage()    {}
func (*ConfigurationProto_Aegis) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12}
}

func (m *ConfigurationProto_Aegis) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Aegis.Unmarshal(m, b)
}
func (m *ConfigurationProto_Aegis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Aegis.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Aegis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Aegis.Merge(m, src)
}
func (m *ConfigurationProto_Aegis) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Aegis.Size(m)
}
func (m *ConfigurationProto_Aegis) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Aegis.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Aegis proto.InternalMessageInfo

const Default_ConfigurationProto_Aegis_SmtpServerType ConfigurationProto_Aegis_SmtpServerType = ConfigurationProto_Aegis_kPlain
const Default_ConfigurationProto_Aegis_Verbosity ConfigurationProto_Aegis_SupportInformationVerbosityLevel = ConfigurationProto_Aegis_kBasicPlusCoreDump
const Default_ConfigurationProto_Aegis_FromAddress string = "cluster@nutanix.com"
const Default_ConfigurationProto_Aegis_SendEmailAlertsExternally bool = false
const Default_ConfigurationProto_Aegis_SendAlertEmailDigest bool = true
const Default_ConfigurationProto_Aegis_SkipEmptyAlertEmailDigest bool = true

func (m *ConfigurationProto_Aegis) GetServiceCenterList() []*ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.ServiceCenterList
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetHttpProxyList() []*ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.HttpProxyList
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetRemoteSupport() *ConfigurationProto_Aegis_TimedBool {
	if m != nil {
		return m.RemoteSupport
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetEmailAlerts() *ConfigurationProto_Aegis_TimedBool {
	if m != nil {
		return m.EmailAlerts
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetDefaultEmailAlertContactList() []string {
	if m != nil {
		return m.DefaultEmailAlertContactList
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetSmtpServer() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.SmtpServer
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetSmtpServerType() ConfigurationProto_Aegis_SmtpServerType {
	if m != nil && m.SmtpServerType != nil {
		return *m.SmtpServerType
	}
	return Default_ConfigurationProto_Aegis_SmtpServerType
}

func (m *ConfigurationProto_Aegis) GetVerbosity() ConfigurationProto_Aegis_SupportInformationVerbosityLevel {
	if m != nil && m.Verbosity != nil {
		return *m.Verbosity
	}
	return Default_ConfigurationProto_Aegis_Verbosity
}

func (m *ConfigurationProto_Aegis) GetNccConfig() *ConfigurationProto_Aegis_NccConfig {
	if m != nil {
		return m.NccConfig
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetAutoSupportConfig() *ConfigurationProto_Aegis_AutoSupportConfig {
	if m != nil {
		return m.AutoSupportConfig
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetFromAddress() string {
	if m != nil && m.FromAddress != nil {
		return *m.FromAddress
	}
	return Default_ConfigurationProto_Aegis_FromAddress
}

func (m *ConfigurationProto_Aegis) GetSendEmailAlertsExternally() bool {
	if m != nil && m.SendEmailAlertsExternally != nil {
		return *m.SendEmailAlertsExternally
	}
	return Default_ConfigurationProto_Aegis_SendEmailAlertsExternally
}

func (m *ConfigurationProto_Aegis) GetSendAlertEmailDigest() bool {
	if m != nil && m.SendAlertEmailDigest != nil {
		return *m.SendAlertEmailDigest
	}
	return Default_ConfigurationProto_Aegis_SendAlertEmailDigest
}

func (m *ConfigurationProto_Aegis) GetDisableIpmiMonitoring() bool {
	if m != nil && m.DisableIpmiMonitoring != nil {
		return *m.DisableIpmiMonitoring
	}
	return false
}

func (m *ConfigurationProto_Aegis) GetEmailAlertSubjectPrefix() string {
	if m != nil && m.EmailAlertSubjectPrefix != nil {
		return *m.EmailAlertSubjectPrefix
	}
	return ""
}

func (m *ConfigurationProto_Aegis) GetEmailAlertBodySuffix() string {
	if m != nil && m.EmailAlertBodySuffix != nil {
		return *m.EmailAlertBodySuffix
	}
	return ""
}

func (m *ConfigurationProto_Aegis) GetHttpProxyWhitelist() []*ConfigurationProto_Aegis_HttpProxyWhitelist {
	if m != nil {
		return m.HttpProxyWhitelist
	}
	return nil
}

func (m *ConfigurationProto_Aegis) GetSkipEmptyAlertEmailDigest() bool {
	if m != nil && m.SkipEmptyAlertEmailDigest != nil {
		return *m.SkipEmptyAlertEmailDigest
	}
	return Default_ConfigurationProto_Aegis_SkipEmptyAlertEmailDigest
}

type ConfigurationProto_Aegis_TimedBool struct {
	// Whether the feature is enabled or not.
	Value *bool `protobuf:"varint,1,opt,name=value,def=0" json:"value,omitempty"`
	// The timestamp in microseconds since midnight, January 1, 1970 UTC
	// until which the current boolean value is in force. Beyond that time,
	// the opposite boolean value will be assumed.
	UntilTimeUsecs       *int64   `protobuf:"varint,2,opt,name=until_time_usecs,json=untilTimeUsecs" json:"until_time_usecs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Aegis_TimedBool) Reset()         { *m = ConfigurationProto_Aegis_TimedBool{} }
func (m *ConfigurationProto_Aegis_TimedBool) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Aegis_TimedBool) ProtoMessage()    {}
func (*ConfigurationProto_Aegis_TimedBool) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 0}
}

func (m *ConfigurationProto_Aegis_TimedBool) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Aegis_TimedBool.Unmarshal(m, b)
}
func (m *ConfigurationProto_Aegis_TimedBool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Aegis_TimedBool.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Aegis_TimedBool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Aegis_TimedBool.Merge(m, src)
}
func (m *ConfigurationProto_Aegis_TimedBool) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Aegis_TimedBool.Size(m)
}
func (m *ConfigurationProto_Aegis_TimedBool) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Aegis_TimedBool.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Aegis_TimedBool proto.InternalMessageInfo

const Default_ConfigurationProto_Aegis_TimedBool_Value bool = false

func (m *ConfigurationProto_Aegis_TimedBool) GetValue() bool {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return Default_ConfigurationProto_Aegis_TimedBool_Value
}

func (m *ConfigurationProto_Aegis_TimedBool) GetUntilTimeUsecs() int64 {
	if m != nil && m.UntilTimeUsecs != nil {
		return *m.UntilTimeUsecs
	}
	return 0
}

// Defines the configuration of Nutanix Configuration Checker module.
type ConfigurationProto_Aegis_NccConfig struct {
	// If true, sending of stats is enabled.
	SendStatsEnabled *bool `protobuf:"varint,1,opt,name=send_stats_enabled,json=sendStatsEnabled,def=0" json:"send_stats_enabled,omitempty"`
	// Defines the interval in seconds at which stats are send to the
	// Nutanix home for offsite analytics. Default interval at which
	// stats are send is 60 secs. If set to 0, stats are not sent.
	SendStatsIntervalSecs *int64 `protobuf:"varint,2,opt,name=send_stats_interval_secs,json=sendStatsIntervalSecs,def=60" json:"send_stats_interval_secs,omitempty"`
	// Email addresses for sending stats.
	StatsEmailContactsList []string `protobuf:"bytes,3,rep,name=stats_email_contacts_list,json=statsEmailContactsList" json:"stats_email_contacts_list,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *ConfigurationProto_Aegis_NccConfig) Reset()         { *m = ConfigurationProto_Aegis_NccConfig{} }
func (m *ConfigurationProto_Aegis_NccConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Aegis_NccConfig) ProtoMessage()    {}
func (*ConfigurationProto_Aegis_NccConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 1}
}

func (m *ConfigurationProto_Aegis_NccConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Aegis_NccConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_Aegis_NccConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Aegis_NccConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Aegis_NccConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Aegis_NccConfig.Merge(m, src)
}
func (m *ConfigurationProto_Aegis_NccConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Aegis_NccConfig.Size(m)
}
func (m *ConfigurationProto_Aegis_NccConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Aegis_NccConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Aegis_NccConfig proto.InternalMessageInfo

const Default_ConfigurationProto_Aegis_NccConfig_SendStatsEnabled bool = false
const Default_ConfigurationProto_Aegis_NccConfig_SendStatsIntervalSecs int64 = 60

func (m *ConfigurationProto_Aegis_NccConfig) GetSendStatsEnabled() bool {
	if m != nil && m.SendStatsEnabled != nil {
		return *m.SendStatsEnabled
	}
	return Default_ConfigurationProto_Aegis_NccConfig_SendStatsEnabled
}

func (m *ConfigurationProto_Aegis_NccConfig) GetSendStatsIntervalSecs() int64 {
	if m != nil && m.SendStatsIntervalSecs != nil {
		return *m.SendStatsIntervalSecs
	}
	return Default_ConfigurationProto_Aegis_NccConfig_SendStatsIntervalSecs
}

func (m *ConfigurationProto_Aegis_NccConfig) GetStatsEmailContactsList() []string {
	if m != nil {
		return m.StatsEmailContactsList
	}
	return nil
}

type ConfigurationProto_Aegis_AutoSupportConfig struct {
	// Turn on/off all emails sent for asups.
	// For AutoSupport:
	// a) If this field does not exist, we assume it is disabled.
	// b) until_time_usecs is not currently set or used.
	EmailAsups *ConfigurationProto_Aegis_TimedBool `protobuf:"bytes,1,opt,name=email_asups,json=emailAsups" json:"email_asups,omitempty"`
	// Customer configurable email contact list.
	DefaultEmailAsupContactList []string `protobuf:"bytes,2,rep,name=default_email_asup_contact_list,json=defaultEmailAsupContactList" json:"default_email_asup_contact_list,omitempty"`
	// Knob to control sending AutoSupport emails to nutanix.
	// The external recepient list is a constant defined in
	// support-info script.
	SendEmailAsupsExternally *bool `protobuf:"varint,3,opt,name=send_email_asups_externally,json=sendEmailAsupsExternally,def=0" json:"send_email_asups_externally,omitempty"`
	// Cluster's AOS version on which pulse screen (prompting user to choose
	// an action) was shown to user during UI login workflow. Empty value
	// means this screen was never shown.
	AosVersion *string `protobuf:"bytes,4,opt,name=aos_version,json=aosVersion,def=" json:"aos_version,omitempty"`
	// Unix epoch time in milliseconds at which the pulse screen was last
	// shown during UI login workflow. This field will be updated when user
	// enables/disables/skips pulse during UI login workflow.
	LastLoginWorkflowTimeMsecs *int64 `protobuf:"varint,5,opt,name=last_login_workflow_time_msecs,json=lastLoginWorkflowTimeMsecs" json:"last_login_workflow_time_msecs,omitempty"`
	// This field indicates if user chose "remind later" option when pulse
	// screen is shown during UI workflow. The current reminder period is set
	// to 15 days.
	RemindLater          *bool                                                         `protobuf:"varint,6,opt,name=remind_later,json=remindLater" json:"remind_later,omitempty"`
	PiiScrubbingLevel    *ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel `protobuf:"varint,7,opt,name=pii_scrubbing_level,json=piiScrubbingLevel,enum=nutanix.zeus.ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel,def=3" json:"pii_scrubbing_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                      `json:"-"`
	XXX_unrecognized     []byte                                                        `json:"-"`
	XXX_sizecache        int32                                                         `json:"-"`
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) Reset() {
	*m = ConfigurationProto_Aegis_AutoSupportConfig{}
}
func (m *ConfigurationProto_Aegis_AutoSupportConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Aegis_AutoSupportConfig) ProtoMessage() {}
func (*ConfigurationProto_Aegis_AutoSupportConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 2}
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Aegis_AutoSupportConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_Aegis_AutoSupportConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Aegis_AutoSupportConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Aegis_AutoSupportConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Aegis_AutoSupportConfig.Merge(m, src)
}
func (m *ConfigurationProto_Aegis_AutoSupportConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Aegis_AutoSupportConfig.Size(m)
}
func (m *ConfigurationProto_Aegis_AutoSupportConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Aegis_AutoSupportConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Aegis_AutoSupportConfig proto.InternalMessageInfo

const Default_ConfigurationProto_Aegis_AutoSupportConfig_SendEmailAsupsExternally bool = false
const Default_ConfigurationProto_Aegis_AutoSupportConfig_PiiScrubbingLevel ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel = ConfigurationProto_Aegis_AutoSupportConfig_kAuto

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetEmailAsups() *ConfigurationProto_Aegis_TimedBool {
	if m != nil {
		return m.EmailAsups
	}
	return nil
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetDefaultEmailAsupContactList() []string {
	if m != nil {
		return m.DefaultEmailAsupContactList
	}
	return nil
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetSendEmailAsupsExternally() bool {
	if m != nil && m.SendEmailAsupsExternally != nil {
		return *m.SendEmailAsupsExternally
	}
	return Default_ConfigurationProto_Aegis_AutoSupportConfig_SendEmailAsupsExternally
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetAosVersion() string {
	if m != nil && m.AosVersion != nil {
		return *m.AosVersion
	}
	return ""
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetLastLoginWorkflowTimeMsecs() int64 {
	if m != nil && m.LastLoginWorkflowTimeMsecs != nil {
		return *m.LastLoginWorkflowTimeMsecs
	}
	return 0
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetRemindLater() bool {
	if m != nil && m.RemindLater != nil {
		return *m.RemindLater
	}
	return false
}

func (m *ConfigurationProto_Aegis_AutoSupportConfig) GetPiiScrubbingLevel() ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel {
	if m != nil && m.PiiScrubbingLevel != nil {
		return *m.PiiScrubbingLevel
	}
	return Default_ConfigurationProto_Aegis_AutoSupportConfig_PiiScrubbingLevel
}

// Optionally we can accept Http Proxy Whitelist. When an outgoing URI
// matches with an entry in whitelist, we dot not apply proxy settings
// to the URI.
type ConfigurationProto_Aegis_HttpProxyWhitelist struct {
	TargetType           *ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType `protobuf:"varint,1,opt,name=target_type,json=targetType,enum=nutanix.zeus.ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType" json:"target_type,omitempty"`
	Target               *string                                                 `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                `json:"-"`
	XXX_unrecognized     []byte                                                  `json:"-"`
	XXX_sizecache        int32                                                   `json:"-"`
}

func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) Reset() {
	*m = ConfigurationProto_Aegis_HttpProxyWhitelist{}
}
func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_Aegis_HttpProxyWhitelist) ProtoMessage() {}
func (*ConfigurationProto_Aegis_HttpProxyWhitelist) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 12, 3}
}

func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Aegis_HttpProxyWhitelist.Unmarshal(m, b)
}
func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Aegis_HttpProxyWhitelist.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Aegis_HttpProxyWhitelist.Merge(m, src)
}
func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Aegis_HttpProxyWhitelist.Size(m)
}
func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Aegis_HttpProxyWhitelist.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Aegis_HttpProxyWhitelist proto.InternalMessageInfo

func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) GetTargetType() ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType {
	if m != nil && m.TargetType != nil {
		return *m.TargetType
	}
	return ConfigurationProto_Aegis_HttpProxyWhitelist_kIpv4Address
}

func (m *ConfigurationProto_Aegis_HttpProxyWhitelist) GetTarget() string {
	if m != nil && m.Target != nil {
		return *m.Target
	}
	return ""
}

// The chassis (or block) that the nodes reside in.
type ConfigurationProto_RackableUnit struct {
	// Globally unique id (within this cluster) for the rackable unit.
	RackableUnitId *int64 `protobuf:"varint,1,req,name=rackable_unit_id,json=rackableUnitId" json:"rackable_unit_id,omitempty"`
	// Nutanix serial number of the rackable unit.
	RackableUnitSerial *string                                `protobuf:"bytes,2,opt,name=rackable_unit_serial,json=rackableUnitSerial" json:"rackable_unit_serial,omitempty"`
	RackableUnitModel  *ConfigurationProto_RackableUnit_Model `protobuf:"varint,3,opt,name=rackable_unit_model,json=rackableUnitModel,enum=nutanix.zeus.ConfigurationProto_RackableUnit_Model" json:"rackable_unit_model,omitempty"`
	// Human-readable string that describes the rackable unit location.
	RackableUnitLocation *string `protobuf:"bytes,4,opt,name=rackable_unit_location,json=rackableUnitLocation" json:"rackable_unit_location,omitempty"`
	// Model name for the systems using the hardware config layout.
	RackableUnitModelName *string `protobuf:"bytes,5,opt,name=rackable_unit_model_name,json=rackableUnitModelName" json:"rackable_unit_model_name,omitempty"`
	// UUID of the rackable unit.
	RackableUnitUuid *string `protobuf:"bytes,6,opt,name=rackable_unit_uuid,json=rackableUnitUuid" json:"rackable_unit_uuid,omitempty"`
	// Unique id of the rack which contains this rackable unit.
	RackId *int64 `protobuf:"varint,7,opt,name=rack_id,json=rackId" json:"rack_id,omitempty"`
	// UUID of the rack which contains this rackable unit.
	RackUuid             *string  `protobuf:"bytes,8,opt,name=rack_uuid,json=rackUuid" json:"rack_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RackableUnit) Reset()         { *m = ConfigurationProto_RackableUnit{} }
func (m *ConfigurationProto_RackableUnit) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_RackableUnit) ProtoMessage()    {}
func (*ConfigurationProto_RackableUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 13}
}

func (m *ConfigurationProto_RackableUnit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RackableUnit.Unmarshal(m, b)
}
func (m *ConfigurationProto_RackableUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RackableUnit.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RackableUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RackableUnit.Merge(m, src)
}
func (m *ConfigurationProto_RackableUnit) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RackableUnit.Size(m)
}
func (m *ConfigurationProto_RackableUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RackableUnit.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RackableUnit proto.InternalMessageInfo

func (m *ConfigurationProto_RackableUnit) GetRackableUnitId() int64 {
	if m != nil && m.RackableUnitId != nil {
		return *m.RackableUnitId
	}
	return 0
}

func (m *ConfigurationProto_RackableUnit) GetRackableUnitSerial() string {
	if m != nil && m.RackableUnitSerial != nil {
		return *m.RackableUnitSerial
	}
	return ""
}

func (m *ConfigurationProto_RackableUnit) GetRackableUnitModel() ConfigurationProto_RackableUnit_Model {
	if m != nil && m.RackableUnitModel != nil {
		return *m.RackableUnitModel
	}
	return ConfigurationProto_RackableUnit_kDesktop
}

func (m *ConfigurationProto_RackableUnit) GetRackableUnitLocation() string {
	if m != nil && m.RackableUnitLocation != nil {
		return *m.RackableUnitLocation
	}
	return ""
}

func (m *ConfigurationProto_RackableUnit) GetRackableUnitModelName() string {
	if m != nil && m.RackableUnitModelName != nil {
		return *m.RackableUnitModelName
	}
	return ""
}

func (m *ConfigurationProto_RackableUnit) GetRackableUnitUuid() string {
	if m != nil && m.RackableUnitUuid != nil {
		return *m.RackableUnitUuid
	}
	return ""
}

func (m *ConfigurationProto_RackableUnit) GetRackId() int64 {
	if m != nil && m.RackId != nil {
		return *m.RackId
	}
	return 0
}

func (m *ConfigurationProto_RackableUnit) GetRackUuid() string {
	if m != nil && m.RackUuid != nil {
		return *m.RackUuid
	}
	return ""
}

// Information about the progress of a dynamic ring change
// operation.
type ConfigurationProto_DynamicRingChangeProgress struct {
	// Current phase in the ring change operation.
	RingChangePhase *string `protobuf:"bytes,1,opt,name=ring_change_phase,json=ringChangePhase" json:"ring_change_phase,omitempty"`
	// Current percent completion of the ring change operation.
	RingChangePercentComplete *float64 `protobuf:"fixed64,2,opt,name=ring_change_percent_complete,json=ringChangePercentComplete" json:"ring_change_percent_complete,omitempty"`
	// Last update time.
	LastUpdateTime       *int64   `protobuf:"varint,3,opt,name=last_update_time,json=lastUpdateTime" json:"last_update_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_DynamicRingChangeProgress) Reset() {
	*m = ConfigurationProto_DynamicRingChangeProgress{}
}
func (m *ConfigurationProto_DynamicRingChangeProgress) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_DynamicRingChangeProgress) ProtoMessage() {}
func (*ConfigurationProto_DynamicRingChangeProgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 14}
}

func (m *ConfigurationProto_DynamicRingChangeProgress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_DynamicRingChangeProgress.Unmarshal(m, b)
}
func (m *ConfigurationProto_DynamicRingChangeProgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_DynamicRingChangeProgress.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_DynamicRingChangeProgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_DynamicRingChangeProgress.Merge(m, src)
}
func (m *ConfigurationProto_DynamicRingChangeProgress) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_DynamicRingChangeProgress.Size(m)
}
func (m *ConfigurationProto_DynamicRingChangeProgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_DynamicRingChangeProgress.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_DynamicRingChangeProgress proto.InternalMessageInfo

func (m *ConfigurationProto_DynamicRingChangeProgress) GetRingChangePhase() string {
	if m != nil && m.RingChangePhase != nil {
		return *m.RingChangePhase
	}
	return ""
}

func (m *ConfigurationProto_DynamicRingChangeProgress) GetRingChangePercentComplete() float64 {
	if m != nil && m.RingChangePercentComplete != nil {
		return *m.RingChangePercentComplete
	}
	return 0
}

func (m *ConfigurationProto_DynamicRingChangeProgress) GetLastUpdateTime() int64 {
	if m != nil && m.LastUpdateTime != nil {
		return *m.LastUpdateTime
	}
	return 0
}

// Information about the addition/removal of nodes in the cluster.
// At a time, dynamic ring change can happen only for one node (being added
// or removed or for which PCIe disk is getting replaced). Only one out of
// 'service_vm_id_being_removed', 'service_vm_id_being_added',
// 'service_vm_id_disk_being_replaced', 'service_vm_id_doing_rf_migration',
// 'service_vm_id_being_repaired' or 'service_vm_id_doing_metadata_sharding'
// will be set.
type ConfigurationProto_DynamicRingChangeInfo struct {
	ServiceVmIdBeingRemoved      *int64 `protobuf:"varint,1,opt,name=service_vm_id_being_removed,json=serviceVmIdBeingRemoved,def=-1" json:"service_vm_id_being_removed,omitempty"`
	ServiceVmIdDoingRingChange   *int64 `protobuf:"varint,2,opt,name=service_vm_id_doing_ring_change,json=serviceVmIdDoingRingChange,def=-1" json:"service_vm_id_doing_ring_change,omitempty"`
	ServiceVmIdBeingAdded        *int64 `protobuf:"varint,3,opt,name=service_vm_id_being_added,json=serviceVmIdBeingAdded,def=-1" json:"service_vm_id_being_added,omitempty"`
	ServiceVmIdDiskBeingReplaced *int64 `protobuf:"varint,4,opt,name=service_vm_id_disk_being_replaced,json=serviceVmIdDiskBeingReplaced,def=-1" json:"service_vm_id_disk_being_replaced,omitempty"`
	// Disk Id of the disk being replaced.
	DiskBeingReplaced *int64 `protobuf:"varint,5,opt,name=disk_being_replaced,json=diskBeingReplaced,def=-1" json:"disk_being_replaced,omitempty"`
	// Set to true once ring change is done.
	RingChangeScanDone *bool `protobuf:"varint,6,opt,name=ring_change_scan_done,json=ringChangeScanDone" json:"ring_change_scan_done,omitempty"`
	// Set to true if ring change scan was aborted.
	RingChangeScanAborted *bool `protobuf:"varint,7,opt,name=ring_change_scan_aborted,json=ringChangeScanAborted,def=0" json:"ring_change_scan_aborted,omitempty"`
	// Service VM id that is doing the RF migration.
	ServiceVmIdDoingRfMigration *int64 `protobuf:"varint,8,opt,name=service_vm_id_doing_rf_migration,json=serviceVmIdDoingRfMigration,def=-1" json:"service_vm_id_doing_rf_migration,omitempty"`
	// Contains list of all nodes (SVM IDs) that didn't acknowledge the current
	// cassandra ring change in progress. This field was deprecated after we
	// moved to heartbeat for Cassandra.
	NodesYetToAckRingChange []int64 `protobuf:"varint,9,rep,name=nodes_yet_to_ack_ring_change,json=nodesYetToAckRingChange" json:"nodes_yet_to_ack_ring_change,omitempty"` // Deprecated: Do not use.
	// Start time for the ring change operation.
	RingChangeStartTime *int64 `protobuf:"varint,10,opt,name=ring_change_start_time,json=ringChangeStartTime" json:"ring_change_start_time,omitempty"`
	// Progress of the current operation.
	RingChangeProgress       *ConfigurationProto_DynamicRingChangeProgress `protobuf:"bytes,11,opt,name=ring_change_progress,json=ringChangeProgress" json:"ring_change_progress,omitempty"`
	ServiceVmIdBeingRepaired *int64                                        `protobuf:"varint,12,opt,name=service_vm_id_being_repaired,json=serviceVmIdBeingRepaired,def=-1" json:"service_vm_id_being_repaired,omitempty"`
	// Current replication factor of the Cassandra keyspaces during RF
	// migration.
	CurrentReplicationFactor *int32 `protobuf:"varint,13,opt,name=current_replication_factor,json=currentReplicationFactor,def=-1" json:"current_replication_factor,omitempty"`
	// Cassandra schema timestamp expected on all Cassandra nodes after a
	// schema update during RF migration.
	ExpectedSchemaTimestamp *int64 `protobuf:"varint,14,opt,name=expected_schema_timestamp,json=expectedSchemaTimestamp,def=-1" json:"expected_schema_timestamp,omitempty"`
	// Service VM id that is doing the metadata sharding.
	ServiceVmIdDoingMetadataSharding *int64 `protobuf:"varint,15,opt,name=service_vm_id_doing_metadata_sharding,json=serviceVmIdDoingMetadataSharding,def=-1" json:"service_vm_id_doing_metadata_sharding,omitempty"`
	// List of disk ids of the disks being added. This is set only if
	// service_vm_id_doing_metadata_sharding is set and contains the list of
	// disks being added as metadata disks to the node.
	DiskBeingAddedList []int64 `protobuf:"varint,16,rep,name=disk_being_added_list,json=diskBeingAddedList" json:"disk_being_added_list,omitempty"`
	// Unique id for the ring change op.
	RingChangeOpId *int64 `protobuf:"varint,17,opt,name=ring_change_op_id,json=ringChangeOpId,def=-1" json:"ring_change_op_id,omitempty"`
	// The field is valid for node removal/detach only. Indicates the node
	// being removed/detached was healthy or not when the node removal/detach
	// process started. The field will never be modified after initialized.
	RemoveOrDetachHealthyNode *bool `protobuf:"varint,18,opt,name=remove_or_detach_healthy_node,json=removeOrDetachHealthyNode" json:"remove_or_detach_healthy_node,omitempty"`
	// The field is valid for node removal/detach only. Indicates whether the
	// sstable loading in the replacement replicas have started. The field
	// will never be modified after populated.
	LoadingSstablesInReplacementReplicas *bool `protobuf:"varint,19,opt,name=loading_sstables_in_replacement_replicas,json=loadingSstablesInReplacementReplicas" json:"loading_sstables_in_replacement_replicas,omitempty"`
	// Indicates whether the current ring change operation involves
	// removal of internal replication. This flag is valid only for metadata
	// sharding operation.
	RemoveInternalReplication *bool    `protobuf:"varint,20,opt,name=remove_internal_replication,json=removeInternalReplication" json:"remove_internal_replication,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *ConfigurationProto_DynamicRingChangeInfo) Reset() {
	*m = ConfigurationProto_DynamicRingChangeInfo{}
}
func (m *ConfigurationProto_DynamicRingChangeInfo) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_DynamicRingChangeInfo) ProtoMessage()    {}
func (*ConfigurationProto_DynamicRingChangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 15}
}

func (m *ConfigurationProto_DynamicRingChangeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_DynamicRingChangeInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_DynamicRingChangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_DynamicRingChangeInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_DynamicRingChangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_DynamicRingChangeInfo.Merge(m, src)
}
func (m *ConfigurationProto_DynamicRingChangeInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_DynamicRingChangeInfo.Size(m)
}
func (m *ConfigurationProto_DynamicRingChangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_DynamicRingChangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_DynamicRingChangeInfo proto.InternalMessageInfo

const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdBeingRemoved int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDoingRingChange int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdBeingAdded int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDiskBeingReplaced int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_DiskBeingReplaced int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_RingChangeScanAborted bool = false
const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDoingRfMigration int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdBeingRepaired int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_CurrentReplicationFactor int32 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_ExpectedSchemaTimestamp int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDoingMetadataSharding int64 = -1
const Default_ConfigurationProto_DynamicRingChangeInfo_RingChangeOpId int64 = -1

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdBeingRemoved() int64 {
	if m != nil && m.ServiceVmIdBeingRemoved != nil {
		return *m.ServiceVmIdBeingRemoved
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdBeingRemoved
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdDoingRingChange() int64 {
	if m != nil && m.ServiceVmIdDoingRingChange != nil {
		return *m.ServiceVmIdDoingRingChange
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDoingRingChange
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdBeingAdded() int64 {
	if m != nil && m.ServiceVmIdBeingAdded != nil {
		return *m.ServiceVmIdBeingAdded
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdBeingAdded
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdDiskBeingReplaced() int64 {
	if m != nil && m.ServiceVmIdDiskBeingReplaced != nil {
		return *m.ServiceVmIdDiskBeingReplaced
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDiskBeingReplaced
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetDiskBeingReplaced() int64 {
	if m != nil && m.DiskBeingReplaced != nil {
		return *m.DiskBeingReplaced
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_DiskBeingReplaced
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRingChangeScanDone() bool {
	if m != nil && m.RingChangeScanDone != nil {
		return *m.RingChangeScanDone
	}
	return false
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRingChangeScanAborted() bool {
	if m != nil && m.RingChangeScanAborted != nil {
		return *m.RingChangeScanAborted
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_RingChangeScanAborted
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdDoingRfMigration() int64 {
	if m != nil && m.ServiceVmIdDoingRfMigration != nil {
		return *m.ServiceVmIdDoingRfMigration
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDoingRfMigration
}

// Deprecated: Do not use.
func (m *ConfigurationProto_DynamicRingChangeInfo) GetNodesYetToAckRingChange() []int64 {
	if m != nil {
		return m.NodesYetToAckRingChange
	}
	return nil
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRingChangeStartTime() int64 {
	if m != nil && m.RingChangeStartTime != nil {
		return *m.RingChangeStartTime
	}
	return 0
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRingChangeProgress() *ConfigurationProto_DynamicRingChangeProgress {
	if m != nil {
		return m.RingChangeProgress
	}
	return nil
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdBeingRepaired() int64 {
	if m != nil && m.ServiceVmIdBeingRepaired != nil {
		return *m.ServiceVmIdBeingRepaired
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdBeingRepaired
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetCurrentReplicationFactor() int32 {
	if m != nil && m.CurrentReplicationFactor != nil {
		return *m.CurrentReplicationFactor
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_CurrentReplicationFactor
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetExpectedSchemaTimestamp() int64 {
	if m != nil && m.ExpectedSchemaTimestamp != nil {
		return *m.ExpectedSchemaTimestamp
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ExpectedSchemaTimestamp
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetServiceVmIdDoingMetadataSharding() int64 {
	if m != nil && m.ServiceVmIdDoingMetadataSharding != nil {
		return *m.ServiceVmIdDoingMetadataSharding
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_ServiceVmIdDoingMetadataSharding
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetDiskBeingAddedList() []int64 {
	if m != nil {
		return m.DiskBeingAddedList
	}
	return nil
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRingChangeOpId() int64 {
	if m != nil && m.RingChangeOpId != nil {
		return *m.RingChangeOpId
	}
	return Default_ConfigurationProto_DynamicRingChangeInfo_RingChangeOpId
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRemoveOrDetachHealthyNode() bool {
	if m != nil && m.RemoveOrDetachHealthyNode != nil {
		return *m.RemoveOrDetachHealthyNode
	}
	return false
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetLoadingSstablesInReplacementReplicas() bool {
	if m != nil && m.LoadingSstablesInReplacementReplicas != nil {
		return *m.LoadingSstablesInReplacementReplicas
	}
	return false
}

func (m *ConfigurationProto_DynamicRingChangeInfo) GetRemoveInternalReplication() bool {
	if m != nil && m.RemoveInternalReplication != nil {
		return *m.RemoveInternalReplication
	}
	return false
}

// SnmpInfo message encapsulates all the information required by snmp agent
// and snmp traps. On a configuration change, all svms will synchronize the
// 3rd party configuration files as per the SnmpInfo details.
type ConfigurationProto_SnmpInfo struct {
	// State of the SNMP service.
	Enabled *bool `protobuf:"varint,1,req,name=enabled,def=1" json:"enabled,omitempty"`
	// The users in this user list will be used to populate the snmpd.conf
	// file.
	UserList []*ConfigurationProto_SnmpInfo_User `protobuf:"bytes,2,rep,name=user_list,json=userList" json:"user_list,omitempty"`
	// The list of transport specifiers will define the list of protocol:port
	// pairs on which the agent will be listening on.
	TransportList []*ConfigurationProto_SnmpInfo_Transport `protobuf:"bytes,3,rep,name=transport_list,json=transportList" json:"transport_list,omitempty"`
	// The list of trap sinks defines the destinations for nutanix generated
	// traps and informs.
	TrapSinkList         []*ConfigurationProto_SnmpInfo_TrapSink `protobuf:"bytes,4,rep,name=trap_sink_list,json=trapSinkList" json:"trap_sink_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *ConfigurationProto_SnmpInfo) Reset()         { *m = ConfigurationProto_SnmpInfo{} }
func (m *ConfigurationProto_SnmpInfo) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_SnmpInfo) ProtoMessage()    {}
func (*ConfigurationProto_SnmpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16}
}

func (m *ConfigurationProto_SnmpInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_SnmpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SnmpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SnmpInfo.Merge(m, src)
}
func (m *ConfigurationProto_SnmpInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo.Size(m)
}
func (m *ConfigurationProto_SnmpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SnmpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SnmpInfo proto.InternalMessageInfo

const Default_ConfigurationProto_SnmpInfo_Enabled bool = true

func (m *ConfigurationProto_SnmpInfo) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return Default_ConfigurationProto_SnmpInfo_Enabled
}

func (m *ConfigurationProto_SnmpInfo) GetUserList() []*ConfigurationProto_SnmpInfo_User {
	if m != nil {
		return m.UserList
	}
	return nil
}

func (m *ConfigurationProto_SnmpInfo) GetTransportList() []*ConfigurationProto_SnmpInfo_Transport {
	if m != nil {
		return m.TransportList
	}
	return nil
}

func (m *ConfigurationProto_SnmpInfo) GetTrapSinkList() []*ConfigurationProto_SnmpInfo_TrapSink {
	if m != nil {
		return m.TrapSinkList
	}
	return nil
}

// This message encapsulates the snmp user properties.
type ConfigurationProto_SnmpInfo_User struct {
	// Snmp user name.
	Username *string                                    `protobuf:"bytes,1,req,name=username" json:"username,omitempty"`
	AuthType *ConfigurationProto_SnmpInfo_User_AuthType `protobuf:"varint,2,opt,name=auth_type,json=authType,enum=nutanix.zeus.ConfigurationProto_SnmpInfo_User_AuthType" json:"auth_type,omitempty"`
	// Authentication key for the user. This is the user's password.
	AuthKey  *string                                    `protobuf:"bytes,3,opt,name=auth_key,json=authKey" json:"auth_key,omitempty"`
	PrivType *ConfigurationProto_SnmpInfo_User_PrivType `protobuf:"varint,4,opt,name=priv_type,json=privType,enum=nutanix.zeus.ConfigurationProto_SnmpInfo_User_PrivType" json:"priv_type,omitempty"`
	// Encryption key for the user.
	PrivKey              *string  `protobuf:"bytes,5,opt,name=priv_key,json=privKey" json:"priv_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_SnmpInfo_User) Reset()         { *m = ConfigurationProto_SnmpInfo_User{} }
func (m *ConfigurationProto_SnmpInfo_User) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_SnmpInfo_User) ProtoMessage()    {}
func (*ConfigurationProto_SnmpInfo_User) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 0}
}

func (m *ConfigurationProto_SnmpInfo_User) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_User.Unmarshal(m, b)
}
func (m *ConfigurationProto_SnmpInfo_User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_User.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SnmpInfo_User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SnmpInfo_User.Merge(m, src)
}
func (m *ConfigurationProto_SnmpInfo_User) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_User.Size(m)
}
func (m *ConfigurationProto_SnmpInfo_User) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SnmpInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SnmpInfo_User proto.InternalMessageInfo

func (m *ConfigurationProto_SnmpInfo_User) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *ConfigurationProto_SnmpInfo_User) GetAuthType() ConfigurationProto_SnmpInfo_User_AuthType {
	if m != nil && m.AuthType != nil {
		return *m.AuthType
	}
	return ConfigurationProto_SnmpInfo_User_kMD5
}

func (m *ConfigurationProto_SnmpInfo_User) GetAuthKey() string {
	if m != nil && m.AuthKey != nil {
		return *m.AuthKey
	}
	return ""
}

func (m *ConfigurationProto_SnmpInfo_User) GetPrivType() ConfigurationProto_SnmpInfo_User_PrivType {
	if m != nil && m.PrivType != nil {
		return *m.PrivType
	}
	return ConfigurationProto_SnmpInfo_User_kDES
}

func (m *ConfigurationProto_SnmpInfo_User) GetPrivKey() string {
	if m != nil && m.PrivKey != nil {
		return *m.PrivKey
	}
	return ""
}

// The Transport message sepecifies the protocol to be used to serve
// an snmp request and the port on which the snmp agent will listen
// for requests.
type ConfigurationProto_SnmpInfo_Transport struct {
	// Protocol used by the snmp agent to serve the snmp request. If
	// unset the snmp agent defaults to use UDP.
	Protocol *ConfigurationProto_SnmpInfo_Protocol `protobuf:"varint,1,opt,name=protocol,enum=nutanix.zeus.ConfigurationProto_SnmpInfo_Protocol" json:"protocol,omitempty"`
	// This is the port on which the snmp agent listens for requests. If
	// unset the snmp agent defaults to port 161.
	Port                 *int32   `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_SnmpInfo_Transport) Reset()         { *m = ConfigurationProto_SnmpInfo_Transport{} }
func (m *ConfigurationProto_SnmpInfo_Transport) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_SnmpInfo_Transport) ProtoMessage()    {}
func (*ConfigurationProto_SnmpInfo_Transport) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 1}
}

func (m *ConfigurationProto_SnmpInfo_Transport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_Transport.Unmarshal(m, b)
}
func (m *ConfigurationProto_SnmpInfo_Transport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_Transport.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SnmpInfo_Transport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SnmpInfo_Transport.Merge(m, src)
}
func (m *ConfigurationProto_SnmpInfo_Transport) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_Transport.Size(m)
}
func (m *ConfigurationProto_SnmpInfo_Transport) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SnmpInfo_Transport.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SnmpInfo_Transport proto.InternalMessageInfo

func (m *ConfigurationProto_SnmpInfo_Transport) GetProtocol() ConfigurationProto_SnmpInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ConfigurationProto_SnmpInfo_kUDP
}

func (m *ConfigurationProto_SnmpInfo_Transport) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

type ConfigurationProto_SnmpInfo_TrapSink struct {
	// The trap sink must use the defined protocol to listen for snmp
	// traps. If unset the protocol defaults to udp in the snmp agent
	// implementation.
	Protocol *ConfigurationProto_SnmpInfo_Protocol `protobuf:"varint,1,opt,name=protocol,enum=nutanix.zeus.ConfigurationProto_SnmpInfo_Protocol" json:"protocol,omitempty"`
	// IPv4 address or DNS resolvable host name of the snmp trap sink where
	// traps are delivered. Only the IPv4 address and port fields may be
	// used. The username and password fields of the network entity are not
	// used for the trap sink.
	TrapAddress *ConfigurationProto_NetworkEntity `protobuf:"bytes,2,opt,name=trap_address,json=trapAddress" json:"trap_address,omitempty"`
	// The user name defines the user which can send traps. The trap user
	// must be present in the SNMP user list. It inherits the authentication
	// and encryption parameters from the corresponding SNMP user.
	TrapUsername *string `protobuf:"bytes,3,opt,name=trap_username,json=trapUsername" json:"trap_username,omitempty"`
	// The snmp v3 engine id is used to identify the application sending
	// the traps. This should be the same as the engine id used by the
	// receiver.
	TrapEngineId *string `protobuf:"bytes,4,opt,name=trap_engine_id,json=trapEngineId" json:"trap_engine_id,omitempty"`
	// Send this trap as an inform. Setting this would cause the trap sender
	// to wait for acknowledgment after sending the trap.
	IsInform *bool `protobuf:"varint,5,opt,name=is_inform,json=isInform" json:"is_inform,omitempty"`
	// Snmp supported version.
	Version *ConfigurationProto_SnmpInfo_SnmpVersion `protobuf:"varint,6,opt,name=version,enum=nutanix.zeus.ConfigurationProto_SnmpInfo_SnmpVersion,def=2" json:"version,omitempty"`
	// Plaintext community string for snmp version 2.
	CommunityString *string `protobuf:"bytes,7,opt,name=community_string,json=communityString" json:"community_string,omitempty"`
	// Receiver name.
	ReceiverName         *string  `protobuf:"bytes,8,opt,name=receiver_name,json=receiverName" json:"receiver_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) Reset()         { *m = ConfigurationProto_SnmpInfo_TrapSink{} }
func (m *ConfigurationProto_SnmpInfo_TrapSink) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_SnmpInfo_TrapSink) ProtoMessage()    {}
func (*ConfigurationProto_SnmpInfo_TrapSink) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 16, 2}
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_TrapSink.Unmarshal(m, b)
}
func (m *ConfigurationProto_SnmpInfo_TrapSink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_TrapSink.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SnmpInfo_TrapSink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SnmpInfo_TrapSink.Merge(m, src)
}
func (m *ConfigurationProto_SnmpInfo_TrapSink) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SnmpInfo_TrapSink.Size(m)
}
func (m *ConfigurationProto_SnmpInfo_TrapSink) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SnmpInfo_TrapSink.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SnmpInfo_TrapSink proto.InternalMessageInfo

const Default_ConfigurationProto_SnmpInfo_TrapSink_Version ConfigurationProto_SnmpInfo_SnmpVersion = ConfigurationProto_SnmpInfo_kV3

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetProtocol() ConfigurationProto_SnmpInfo_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return ConfigurationProto_SnmpInfo_kUDP
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetTrapAddress() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.TrapAddress
	}
	return nil
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetTrapUsername() string {
	if m != nil && m.TrapUsername != nil {
		return *m.TrapUsername
	}
	return ""
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetTrapEngineId() string {
	if m != nil && m.TrapEngineId != nil {
		return *m.TrapEngineId
	}
	return ""
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetIsInform() bool {
	if m != nil && m.IsInform != nil {
		return *m.IsInform
	}
	return false
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetVersion() ConfigurationProto_SnmpInfo_SnmpVersion {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_ConfigurationProto_SnmpInfo_TrapSink_Version
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetCommunityString() string {
	if m != nil && m.CommunityString != nil {
		return *m.CommunityString
	}
	return ""
}

func (m *ConfigurationProto_SnmpInfo_TrapSink) GetReceiverName() string {
	if m != nil && m.ReceiverName != nil {
		return *m.ReceiverName
	}
	return ""
}

// Configuration for all authentication mechanisms used to authenticate
// a user.
type ConfigurationProto_AuthConfig struct {
	AuthTypeList []ConfigurationProto_AuthConfig_AuthSourceType `protobuf:"varint,1,rep,name=auth_type_list,json=authTypeList,enum=nutanix.zeus.ConfigurationProto_AuthConfig_AuthSourceType" json:"auth_type_list,omitempty"`
	// List of directory services. Will be more than one in forest scenario.
	DirectoryList        []*ConfigurationProto_AuthConfig_DirectoryConfig `protobuf:"bytes,2,rep,name=directory_list,json=directoryList" json:"directory_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *ConfigurationProto_AuthConfig) Reset()         { *m = ConfigurationProto_AuthConfig{} }
func (m *ConfigurationProto_AuthConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_AuthConfig) ProtoMessage()    {}
func (*ConfigurationProto_AuthConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17}
}

func (m *ConfigurationProto_AuthConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AuthConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_AuthConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AuthConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AuthConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AuthConfig.Merge(m, src)
}
func (m *ConfigurationProto_AuthConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AuthConfig.Size(m)
}
func (m *ConfigurationProto_AuthConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AuthConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AuthConfig proto.InternalMessageInfo

func (m *ConfigurationProto_AuthConfig) GetAuthTypeList() []ConfigurationProto_AuthConfig_AuthSourceType {
	if m != nil {
		return m.AuthTypeList
	}
	return nil
}

func (m *ConfigurationProto_AuthConfig) GetDirectoryList() []*ConfigurationProto_AuthConfig_DirectoryConfig {
	if m != nil {
		return m.DirectoryList
	}
	return nil
}

// Encapsulates configuration information needed for directory services.
type ConfigurationProto_AuthConfig_DirectoryConfig struct {
	DirectoryType  *ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType  `protobuf:"varint,1,opt,name=directory_type,json=directoryType,enum=nutanix.zeus.ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType,def=0" json:"directory_type,omitempty"`
	ConnectionType *ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType `protobuf:"varint,2,opt,name=connection_type,json=connectionType,enum=nutanix.zeus.ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType,def=0" json:"connection_type,omitempty"`
	// The url to connect to for the directory service.
	DirectoryUrl *ConfigurationProto_NetworkEntity `protobuf:"bytes,3,opt,name=directory_url,json=directoryUrl" json:"directory_url,omitempty"`
	// The domain that Active Directory needs to fully qualify a user.
	// May need to use a different format for other directory services.
	Domain          *string                                                        `protobuf:"bytes,4,opt,name=domain" json:"domain,omitempty"`
	GroupSearchType *ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType `protobuf:"varint,5,opt,name=group_search_type,json=groupSearchType,enum=nutanix.zeus.ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType,def=0" json:"group_search_type,omitempty"`
	// Uuid for the directory config
	Uuid *string `protobuf:"bytes,6,opt,name=uuid" json:"uuid,omitempty"`
	// True if this directory service is configured to use in self
	// service portal also.
	EnabledInSsp *bool `protobuf:"varint,7,opt,name=enabled_in_ssp,json=enabledInSsp,def=0" json:"enabled_in_ssp,omitempty"`
	// service account that can be used to connect to the directory service.
	ServiceAccount *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount `protobuf:"bytes,8,opt,name=service_account,json=serviceAccount" json:"service_account,omitempty"`
	// OpenLDAP configuration.
	OpenLdapConfig *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig `protobuf:"bytes,9,opt,name=open_ldap_config,json=openLdapConfig" json:"open_ldap_config,omitempty"`
	// The domain(non_display name)
	DomainNonDisplay     *string  `protobuf:"bytes,10,opt,name=domain_non_display,json=domainNonDisplay" json:"domain_non_display,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) Reset() {
	*m = ConfigurationProto_AuthConfig_DirectoryConfig{}
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_AuthConfig_DirectoryConfig) ProtoMessage() {}
func (*ConfigurationProto_AuthConfig_DirectoryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0}
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig.Merge(m, src)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig.Size(m)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig proto.InternalMessageInfo

const Default_ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType = ConfigurationProto_AuthConfig_DirectoryConfig_kACTIVE_DIRECTORY
const Default_ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType = ConfigurationProto_AuthConfig_DirectoryConfig_kLDAP
const Default_ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType = ConfigurationProto_AuthConfig_DirectoryConfig_kRECURSIVE
const Default_ConfigurationProto_AuthConfig_DirectoryConfig_EnabledInSsp bool = false

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetDirectoryType() ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType {
	if m != nil && m.DirectoryType != nil {
		return *m.DirectoryType
	}
	return Default_ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetConnectionType() ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType {
	if m != nil && m.ConnectionType != nil {
		return *m.ConnectionType
	}
	return Default_ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetDirectoryUrl() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.DirectoryUrl
	}
	return nil
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetGroupSearchType() ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType {
	if m != nil && m.GroupSearchType != nil {
		return *m.GroupSearchType
	}
	return Default_ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetEnabledInSsp() bool {
	if m != nil && m.EnabledInSsp != nil {
		return *m.EnabledInSsp
	}
	return Default_ConfigurationProto_AuthConfig_DirectoryConfig_EnabledInSsp
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetServiceAccount() *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetOpenLdapConfig() *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig {
	if m != nil {
		return m.OpenLdapConfig
	}
	return nil
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig) GetDomainNonDisplay() string {
	if m != nil && m.DomainNonDisplay != nil {
		return *m.DomainNonDisplay
	}
	return ""
}

type ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount struct {
	// Required. Username to be used to login to the directory service.
	Username *string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// Required. Password to be used to login to the directory service.
	EncryptedPassword    *string  `protobuf:"bytes,2,opt,name=encrypted_password,json=encryptedPassword" json:"encrypted_password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) Reset() {
	*m = ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount{}
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) ProtoMessage() {}
func (*ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0, 0}
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount.Unmarshal(m, b)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount.Merge(m, src)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount.Size(m)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount proto.InternalMessageInfo

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount) GetEncryptedPassword() string {
	if m != nil && m.EncryptedPassword != nil {
		return *m.EncryptedPassword
	}
	return ""
}

// Open LDAP configuration.
type ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig struct {
	// Unique identifier for object type user.
	UserObjectClass *string `protobuf:"bytes,1,opt,name=user_object_class,json=userObjectClass" json:"user_object_class,omitempty"`
	// Base DN to search for user.
	UserSearchBase *string `protobuf:"bytes,2,opt,name=user_search_base,json=userSearchBase" json:"user_search_base,omitempty"`
	// User attribute that can  be used for authentication.
	UsernameAttribute *string `protobuf:"bytes,3,opt,name=username_attribute,json=usernameAttribute" json:"username_attribute,omitempty"`
	// Unique identifier for object type group.
	GroupObjectClass *string `protobuf:"bytes,4,opt,name=group_object_class,json=groupObjectClass" json:"group_object_class,omitempty"`
	// Base DN to search for groups.
	GroupSearchBase *string `protobuf:"bytes,5,opt,name=group_search_base,json=groupSearchBase" json:"group_search_base,omitempty"`
	// Unique identifier in a group that associates user to a group.
	GroupMemberAttribute *string `protobuf:"bytes,6,opt,name=group_member_attribute,json=groupMemberAttribute" json:"group_member_attribute,omitempty"`
	// User attribute that will be used in group to associate a user
	// to the group.
	GroupMemberAttributeValue *string  `protobuf:"bytes,7,opt,name=group_member_attribute_value,json=groupMemberAttributeValue" json:"group_member_attribute_value,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) Reset() {
	*m = ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig{}
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) ProtoMessage() {}
func (*ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 17, 0, 1}
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig.Merge(m, src)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig.Size(m)
}
func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig proto.InternalMessageInfo

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetUserObjectClass() string {
	if m != nil && m.UserObjectClass != nil {
		return *m.UserObjectClass
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetUserSearchBase() string {
	if m != nil && m.UserSearchBase != nil {
		return *m.UserSearchBase
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetUsernameAttribute() string {
	if m != nil && m.UsernameAttribute != nil {
		return *m.UsernameAttribute
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetGroupObjectClass() string {
	if m != nil && m.GroupObjectClass != nil {
		return *m.GroupObjectClass
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetGroupSearchBase() string {
	if m != nil && m.GroupSearchBase != nil {
		return *m.GroupSearchBase
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetGroupMemberAttribute() string {
	if m != nil && m.GroupMemberAttribute != nil {
		return *m.GroupMemberAttribute
	}
	return ""
}

func (m *ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig) GetGroupMemberAttributeValue() string {
	if m != nil && m.GroupMemberAttributeValue != nil {
		return *m.GroupMemberAttributeValue
	}
	return ""
}

// A vstore.
type ConfigurationProto_VStore struct {
	// Currently stargate needs vstore id to be same as container id.
	// Once stargate is fixed, a unique id can be generated and used for vstore.
	VstoreId *int64 `protobuf:"varint,1,req,name=vstore_id,json=vstoreId" json:"vstore_id,omitempty"`
	// Name assigned to a vstore (by the admin/UI). This is always set
	// for a valid and current vstore and is unique across all vstores.
	// It is unset when a vstore is marked for deletion.
	VstoreName *string `protobuf:"bytes,2,opt,name=vstore_name,json=vstoreName" json:"vstore_name,omitempty"`
	// Container id that this vstore is associated with. For the time being,
	// there can be only one vstore per container.
	ContainerId *int64 `protobuf:"varint,3,req,name=container_id,json=containerId" json:"container_id,omitempty"`
	// If true, the vstore is marked for deletion, and the vstore_name field
	// is cleared.
	ToRemove *bool `protobuf:"varint,4,opt,name=to_remove,json=toRemove" json:"to_remove,omitempty"`
	// Component IDs that specify how the vstore is protected by Cerebro. The
	// actual protection of a vstore can be implemented in a number of
	// different ways.
	ProtectActionComponentIds []int64 `protobuf:"varint,5,rep,name=protect_action_component_ids,json=protectActionComponentIds" json:"protect_action_component_ids,omitempty"`
	// Uuid for vstore.
	VstoreUuid *string `protobuf:"bytes,6,opt,name=vstore_uuid,json=vstoreUuid" json:"vstore_uuid,omitempty"`
	// Container uuid that this vstore is associated with.
	ContainerUuid        *string  `protobuf:"bytes,7,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_VStore) Reset()         { *m = ConfigurationProto_VStore{} }
func (m *ConfigurationProto_VStore) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_VStore) ProtoMessage()    {}
func (*ConfigurationProto_VStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 18}
}

func (m *ConfigurationProto_VStore) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_VStore.Unmarshal(m, b)
}
func (m *ConfigurationProto_VStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_VStore.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_VStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_VStore.Merge(m, src)
}
func (m *ConfigurationProto_VStore) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_VStore.Size(m)
}
func (m *ConfigurationProto_VStore) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_VStore.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_VStore proto.InternalMessageInfo

func (m *ConfigurationProto_VStore) GetVstoreId() int64 {
	if m != nil && m.VstoreId != nil {
		return *m.VstoreId
	}
	return 0
}

func (m *ConfigurationProto_VStore) GetVstoreName() string {
	if m != nil && m.VstoreName != nil {
		return *m.VstoreName
	}
	return ""
}

func (m *ConfigurationProto_VStore) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *ConfigurationProto_VStore) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return false
}

func (m *ConfigurationProto_VStore) GetProtectActionComponentIds() []int64 {
	if m != nil {
		return m.ProtectActionComponentIds
	}
	return nil
}

func (m *ConfigurationProto_VStore) GetVstoreUuid() string {
	if m != nil && m.VstoreUuid != nil {
		return *m.VstoreUuid
	}
	return ""
}

func (m *ConfigurationProto_VStore) GetContainerUuid() string {
	if m != nil && m.ContainerUuid != nil {
		return *m.ContainerUuid
	}
	return ""
}

// Virtual node aware storage tiers. This is maintained in the Zeus
// configuration for the benefit of Prism and other non-C++ components which
// would like to see the set of virtual tiers computed by Zeus. Note that
// this could be a bit stale, as this is lazily updated.
type ConfigurationProto_VirtualStorageTier struct {
	// Name of the storage tier.
	VirtualStorageTierName *string `protobuf:"bytes,1,opt,name=virtual_storage_tier_name,json=virtualStorageTierName" json:"virtual_storage_tier_name,omitempty"`
	// The iops range for this tier in a node. IOPS per virtual storage tier is
	// calculated per node, and the min and max is calculated over the whole
	// cluster. Two disks of the same IOPS in a node would be aggregated and
	// the aggregated IOPS would be considered for the min and max.
	MinIopsRating *int64 `protobuf:"varint,2,opt,name=min_iops_rating,json=minIopsRating" json:"min_iops_rating,omitempty"`
	MaxIopsRating *int64 `protobuf:"varint,3,opt,name=max_iops_rating,json=maxIopsRating" json:"max_iops_rating,omitempty"`
	// Set of disk ids that belong to this storage tier.
	DiskIdList           []int64  `protobuf:"varint,4,rep,name=disk_id_list,json=diskIdList" json:"disk_id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_VirtualStorageTier) Reset()         { *m = ConfigurationProto_VirtualStorageTier{} }
func (m *ConfigurationProto_VirtualStorageTier) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_VirtualStorageTier) ProtoMessage()    {}
func (*ConfigurationProto_VirtualStorageTier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 19}
}

func (m *ConfigurationProto_VirtualStorageTier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_VirtualStorageTier.Unmarshal(m, b)
}
func (m *ConfigurationProto_VirtualStorageTier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_VirtualStorageTier.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_VirtualStorageTier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_VirtualStorageTier.Merge(m, src)
}
func (m *ConfigurationProto_VirtualStorageTier) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_VirtualStorageTier.Size(m)
}
func (m *ConfigurationProto_VirtualStorageTier) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_VirtualStorageTier.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_VirtualStorageTier proto.InternalMessageInfo

func (m *ConfigurationProto_VirtualStorageTier) GetVirtualStorageTierName() string {
	if m != nil && m.VirtualStorageTierName != nil {
		return *m.VirtualStorageTierName
	}
	return ""
}

func (m *ConfigurationProto_VirtualStorageTier) GetMinIopsRating() int64 {
	if m != nil && m.MinIopsRating != nil {
		return *m.MinIopsRating
	}
	return 0
}

func (m *ConfigurationProto_VirtualStorageTier) GetMaxIopsRating() int64 {
	if m != nil && m.MaxIopsRating != nil {
		return *m.MaxIopsRating
	}
	return 0
}

func (m *ConfigurationProto_VirtualStorageTier) GetDiskIdList() []int64 {
	if m != nil {
		return m.DiskIdList
	}
	return nil
}

// Public ssh keys for cluster.
type ConfigurationProto_SSHKey struct {
	KeyId                *string                               `protobuf:"bytes,1,req,name=key_id,json=keyId" json:"key_id,omitempty"`
	PubKey               *string                               `protobuf:"bytes,2,req,name=pub_key,json=pubKey" json:"pub_key,omitempty"`
	KeyType              *ConfigurationProto_SSHKey_SshKeyType `protobuf:"varint,3,opt,name=key_type,json=keyType,enum=nutanix.zeus.ConfigurationProto_SSHKey_SshKeyType" json:"key_type,omitempty"`
	SslCert              *string                               `protobuf:"bytes,4,opt,name=ssl_cert,json=sslCert" json:"ssl_cert,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ConfigurationProto_SSHKey) Reset()         { *m = ConfigurationProto_SSHKey{} }
func (m *ConfigurationProto_SSHKey) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_SSHKey) ProtoMessage()    {}
func (*ConfigurationProto_SSHKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 20}
}

func (m *ConfigurationProto_SSHKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SSHKey.Unmarshal(m, b)
}
func (m *ConfigurationProto_SSHKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SSHKey.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SSHKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SSHKey.Merge(m, src)
}
func (m *ConfigurationProto_SSHKey) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SSHKey.Size(m)
}
func (m *ConfigurationProto_SSHKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SSHKey.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SSHKey proto.InternalMessageInfo

func (m *ConfigurationProto_SSHKey) GetKeyId() string {
	if m != nil && m.KeyId != nil {
		return *m.KeyId
	}
	return ""
}

func (m *ConfigurationProto_SSHKey) GetPubKey() string {
	if m != nil && m.PubKey != nil {
		return *m.PubKey
	}
	return ""
}

func (m *ConfigurationProto_SSHKey) GetKeyType() ConfigurationProto_SSHKey_SshKeyType {
	if m != nil && m.KeyType != nil {
		return *m.KeyType
	}
	return ConfigurationProto_SSHKey_kNodeKey
}

func (m *ConfigurationProto_SSHKey) GetSslCert() string {
	if m != nil && m.SslCert != nil {
		return *m.SslCert
	}
	return ""
}

// Fault tolerance state of the cluster.
type ConfigurationProto_FaultToleranceState struct {
	// Max fault tolerance that is supported currently.
	CurrentMaxFaultTolerance *int32 `protobuf:"varint,1,opt,name=current_max_fault_tolerance,json=currentMaxFaultTolerance,def=1" json:"current_max_fault_tolerance,omitempty"`
	// Desired max fault tolerance. If different from
	// 'current_max_fault_tolerance', it means that the cluster is preparing
	// to support the desired fault tolerance.
	DesiredMaxFaultTolerance *int32 `protobuf:"varint,2,opt,name=desired_max_fault_tolerance,json=desiredMaxFaultTolerance,def=1" json:"desired_max_fault_tolerance,omitempty"`
	PrepareFtAck             *int32 `protobuf:"varint,3,opt,name=prepare_ft_ack,json=prepareFtAck" json:"prepare_ft_ack,omitempty"`
	// Fault tolerance level that the modules should desire to achieve. Default
	// desired fault tolerance level is set to
	// 'zeus.DomainFaultToleranceState.Domain.kNode'.
	DesiredFaultToleranceLevel *zeus.DomainFaultToleranceState_Domain_DomainType `protobuf:"varint,4,opt,name=desired_fault_tolerance_level,json=desiredFaultToleranceLevel,enum=nutanix.zeus.DomainFaultToleranceState_Domain_DomainType,def=200" json:"desired_fault_tolerance_level,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                                          `json:"-"`
	XXX_unrecognized           []byte                                            `json:"-"`
	XXX_sizecache              int32                                             `json:"-"`
}

func (m *ConfigurationProto_FaultToleranceState) Reset() {
	*m = ConfigurationProto_FaultToleranceState{}
}
func (m *ConfigurationProto_FaultToleranceState) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_FaultToleranceState) ProtoMessage()    {}
func (*ConfigurationProto_FaultToleranceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 21}
}

func (m *ConfigurationProto_FaultToleranceState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_FaultToleranceState.Unmarshal(m, b)
}
func (m *ConfigurationProto_FaultToleranceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_FaultToleranceState.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_FaultToleranceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_FaultToleranceState.Merge(m, src)
}
func (m *ConfigurationProto_FaultToleranceState) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_FaultToleranceState.Size(m)
}
func (m *ConfigurationProto_FaultToleranceState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_FaultToleranceState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_FaultToleranceState proto.InternalMessageInfo

const Default_ConfigurationProto_FaultToleranceState_CurrentMaxFaultTolerance int32 = 1
const Default_ConfigurationProto_FaultToleranceState_DesiredMaxFaultTolerance int32 = 1
const Default_ConfigurationProto_FaultToleranceState_DesiredFaultToleranceLevel zeus.DomainFaultToleranceState_Domain_DomainType = zeus.DomainFaultToleranceState_Domain_kNode

func (m *ConfigurationProto_FaultToleranceState) GetCurrentMaxFaultTolerance() int32 {
	if m != nil && m.CurrentMaxFaultTolerance != nil {
		return *m.CurrentMaxFaultTolerance
	}
	return Default_ConfigurationProto_FaultToleranceState_CurrentMaxFaultTolerance
}

func (m *ConfigurationProto_FaultToleranceState) GetDesiredMaxFaultTolerance() int32 {
	if m != nil && m.DesiredMaxFaultTolerance != nil {
		return *m.DesiredMaxFaultTolerance
	}
	return Default_ConfigurationProto_FaultToleranceState_DesiredMaxFaultTolerance
}

func (m *ConfigurationProto_FaultToleranceState) GetPrepareFtAck() int32 {
	if m != nil && m.PrepareFtAck != nil {
		return *m.PrepareFtAck
	}
	return 0
}

func (m *ConfigurationProto_FaultToleranceState) GetDesiredFaultToleranceLevel() zeus.DomainFaultToleranceState_Domain_DomainType {
	if m != nil && m.DesiredFaultToleranceLevel != nil {
		return *m.DesiredFaultToleranceLevel
	}
	return Default_ConfigurationProto_FaultToleranceState_DesiredFaultToleranceLevel
}

// RSyslogConfig message encapsulates all information required for remote
// logging feature. On configuration change, all CVMs will synchronize
// the rsyslog configuration and apply the configuration appropriately.
// Every node can be configured with different syslog server for remote
// logging.
type ConfigurationProto_RSyslogConfig struct {
	// State of the Remote Syslog feature.
	Enabled              *bool                                               `protobuf:"varint,1,opt,name=enabled,def=1" json:"enabled,omitempty"`
	LogServerConfigList  []*ConfigurationProto_RSyslogConfig_LogServerConfig `protobuf:"bytes,2,rep,name=log_server_config_list,json=logServerConfigList" json:"log_server_config_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_unrecognized     []byte                                              `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *ConfigurationProto_RSyslogConfig) Reset()         { *m = ConfigurationProto_RSyslogConfig{} }
func (m *ConfigurationProto_RSyslogConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_RSyslogConfig) ProtoMessage()    {}
func (*ConfigurationProto_RSyslogConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 22}
}

func (m *ConfigurationProto_RSyslogConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_RSyslogConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RSyslogConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RSyslogConfig.Merge(m, src)
}
func (m *ConfigurationProto_RSyslogConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig.Size(m)
}
func (m *ConfigurationProto_RSyslogConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RSyslogConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RSyslogConfig proto.InternalMessageInfo

const Default_ConfigurationProto_RSyslogConfig_Enabled bool = true

func (m *ConfigurationProto_RSyslogConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return Default_ConfigurationProto_RSyslogConfig_Enabled
}

func (m *ConfigurationProto_RSyslogConfig) GetLogServerConfigList() []*ConfigurationProto_RSyslogConfig_LogServerConfig {
	if m != nil {
		return m.LogServerConfigList
	}
	return nil
}

// Remote Syslog server parameters.
type ConfigurationProto_RSyslogConfig_LogServerConfig struct {
	// Unique name to identify a log server.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// IP and port details of the syslog server.
	Server  *ConfigurationProto_NetworkEntity                          `protobuf:"bytes,2,opt,name=server" json:"server,omitempty"`
	Modules []*ConfigurationProto_RSyslogConfig_LogServerConfig_Module `protobuf:"bytes,3,rep,name=modules" json:"modules,omitempty"`
	// Option to use Reliable Event Logging Protocol for rsyslog. This
	// protocol uses TCP as the underlying data transfer protocol.
	RelpEnabled          *bool    `protobuf:"varint,4,opt,name=relp_enabled,json=relpEnabled,def=0" json:"relp_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) Reset() {
	*m = ConfigurationProto_RSyslogConfig_LogServerConfig{}
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_RSyslogConfig_LogServerConfig) ProtoMessage() {}
func (*ConfigurationProto_RSyslogConfig_LogServerConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 22, 0}
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig.Merge(m, src)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig.Size(m)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig proto.InternalMessageInfo

const Default_ConfigurationProto_RSyslogConfig_LogServerConfig_RelpEnabled bool = false

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) GetServer() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) GetModules() []*ConfigurationProto_RSyslogConfig_LogServerConfig_Module {
	if m != nil {
		return m.Modules
	}
	return nil
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig) GetRelpEnabled() bool {
	if m != nil && m.RelpEnabled != nil {
		return *m.RelpEnabled
	}
	return Default_ConfigurationProto_RSyslogConfig_LogServerConfig_RelpEnabled
}

// List of modules to be logged to remote syslog server.
type ConfigurationProto_RSyslogConfig_LogServerConfig_Module struct {
	// Module Name to start logging.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Module priority to start logging.
	Priority *ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority `protobuf:"varint,2,opt,name=priority,enum=nutanix.zeus.ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority" json:"priority,omitempty"`
	// Option to log monitor files for a module.
	Monitor              *bool    `protobuf:"varint,3,opt,name=monitor,def=1" json:"monitor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) Reset() {
	*m = ConfigurationProto_RSyslogConfig_LogServerConfig_Module{}
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_RSyslogConfig_LogServerConfig_Module) ProtoMessage() {}
func (*ConfigurationProto_RSyslogConfig_LogServerConfig_Module) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 22, 0, 0}
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig_Module.Unmarshal(m, b)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig_Module.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig_Module.Merge(m, src)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig_Module.Size(m)
}
func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig_Module.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RSyslogConfig_LogServerConfig_Module proto.InternalMessageInfo

const Default_ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Monitor bool = true

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) GetPriority() ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return ConfigurationProto_RSyslogConfig_LogServerConfig_Module_kDebug
}

func (m *ConfigurationProto_RSyslogConfig_LogServerConfig_Module) GetMonitor() bool {
	if m != nil && m.Monitor != nil {
		return *m.Monitor
	}
	return Default_ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Monitor
}

type ConfigurationProto_KeyManagementServer struct {
	// Unique id for the key management server. Key management server has to be
	// accessible across cluster create/destroy cycle (because users may force
	// destroy a cluster when encryption keys are still active), so component
	// id cannot be used.
	KeyManagementServerUuid *string `protobuf:"bytes,1,req,name=key_management_server_uuid,json=keyManagementServerUuid" json:"key_management_server_uuid,omitempty"`
	// An optional, human readable name for the key management server.
	KeyManagementServerName *string `protobuf:"bytes,2,opt,name=key_management_server_name,json=keyManagementServerName" json:"key_management_server_name,omitempty"`
	// Network entities for the key management server. Key management server
	// can be a cluster (with multiple nodes) of its own for fault-tolerance.
	KeyManagementDeviceList []*ConfigurationProto_NetworkEntity `protobuf:"bytes,3,rep,name=key_management_device_list,json=keyManagementDeviceList" json:"key_management_device_list,omitempty"`
	// Path to the zknode where digital certificate of the key management
	// server's certificate authority is stored.
	CaCertificateZkpath  *string  `protobuf:"bytes,4,opt,name=ca_certificate_zkpath,json=caCertificateZkpath" json:"ca_certificate_zkpath,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_KeyManagementServer) Reset() {
	*m = ConfigurationProto_KeyManagementServer{}
}
func (m *ConfigurationProto_KeyManagementServer) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_KeyManagementServer) ProtoMessage()    {}
func (*ConfigurationProto_KeyManagementServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 23}
}

func (m *ConfigurationProto_KeyManagementServer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_KeyManagementServer.Unmarshal(m, b)
}
func (m *ConfigurationProto_KeyManagementServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_KeyManagementServer.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_KeyManagementServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_KeyManagementServer.Merge(m, src)
}
func (m *ConfigurationProto_KeyManagementServer) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_KeyManagementServer.Size(m)
}
func (m *ConfigurationProto_KeyManagementServer) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_KeyManagementServer.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_KeyManagementServer proto.InternalMessageInfo

func (m *ConfigurationProto_KeyManagementServer) GetKeyManagementServerUuid() string {
	if m != nil && m.KeyManagementServerUuid != nil {
		return *m.KeyManagementServerUuid
	}
	return ""
}

func (m *ConfigurationProto_KeyManagementServer) GetKeyManagementServerName() string {
	if m != nil && m.KeyManagementServerName != nil {
		return *m.KeyManagementServerName
	}
	return ""
}

func (m *ConfigurationProto_KeyManagementServer) GetKeyManagementDeviceList() []*ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.KeyManagementDeviceList
	}
	return nil
}

func (m *ConfigurationProto_KeyManagementServer) GetCaCertificateZkpath() string {
	if m != nil && m.CaCertificateZkpath != nil {
		return *m.CaCertificateZkpath
	}
	return ""
}

type ConfigurationProto_CertificateAuthority struct {
	// List of paths to digital certificates stored in zookeeper.
	// Certificate authorities are identified by one or more self-signed or
	// peer-signed certificates.
	DigitalCertificateZkpathList []string `protobuf:"bytes,1,rep,name=digital_certificate_zkpath_list,json=digitalCertificateZkpathList" json:"digital_certificate_zkpath_list,omitempty"`
	// Human readable name for the certificate authority.
	CertificateAuthorityName *string  `protobuf:"bytes,2,opt,name=certificate_authority_name,json=certificateAuthorityName" json:"certificate_authority_name,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *ConfigurationProto_CertificateAuthority) Reset() {
	*m = ConfigurationProto_CertificateAuthority{}
}
func (m *ConfigurationProto_CertificateAuthority) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_CertificateAuthority) ProtoMessage()    {}
func (*ConfigurationProto_CertificateAuthority) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 24}
}

func (m *ConfigurationProto_CertificateAuthority) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_CertificateAuthority.Unmarshal(m, b)
}
func (m *ConfigurationProto_CertificateAuthority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_CertificateAuthority.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_CertificateAuthority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_CertificateAuthority.Merge(m, src)
}
func (m *ConfigurationProto_CertificateAuthority) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_CertificateAuthority.Size(m)
}
func (m *ConfigurationProto_CertificateAuthority) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_CertificateAuthority.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_CertificateAuthority proto.InternalMessageInfo

func (m *ConfigurationProto_CertificateAuthority) GetDigitalCertificateZkpathList() []string {
	if m != nil {
		return m.DigitalCertificateZkpathList
	}
	return nil
}

func (m *ConfigurationProto_CertificateAuthority) GetCertificateAuthorityName() string {
	if m != nil && m.CertificateAuthorityName != nil {
		return *m.CertificateAuthorityName
	}
	return ""
}

// Customer information used in Certificate Signing Request for
// creating digital certificates.
type ConfigurationProto_CertificationSigningInfo struct {
	// The name and two-letter ISO code for the country where
	// customer's organization is located.
	Country     *string `protobuf:"bytes,1,opt,name=country" json:"country,omitempty"`
	CountryCode *string `protobuf:"bytes,2,opt,name=country_code,json=countryCode" json:"country_code,omitempty"`
	// The Province, Region, County or State where customer business
	// is located e.g. Sussex, Normandy, New Jersey, etc.
	State *string `protobuf:"bytes,3,opt,name=state" json:"state,omitempty"`
	// The Town or City where customer's business is located
	// e.g. London, Waterford, Paris, New York, etc.
	City *string `protobuf:"bytes,4,opt,name=city" json:"city,omitempty"`
	// Name of the customer business; usually the legal incorporated
	// name of a company and should include any suffixes such as Ltd.,
	// Inc., or Corp.
	Organization *string `protobuf:"bytes,5,opt,name=organization" json:"organization,omitempty"`
	// An email address to contact the organization. Usually the email
	// address of the certificate administrator or IT department.
	EmailAddress *string `protobuf:"bytes,6,opt,name=email_address,json=emailAddress" json:"email_address,omitempty"`
	// A department name or subunit within an organization. Examples of such
	// are: HR, IT, Finance, etc.
	OrganizationalUnitList []string `protobuf:"bytes,7,rep,name=organizational_unit_list,json=organizationalUnitList" json:"organizational_unit_list,omitempty"`
	// Common name is by default <node_uuid>.nutanix.com, but if a customer
	// wants something instead of nutanix.com they can specify it here.
	CommonNameSuffix     *string  `protobuf:"bytes,8,opt,name=common_name_suffix,json=commonNameSuffix" json:"common_name_suffix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_CertificationSigningInfo) Reset() {
	*m = ConfigurationProto_CertificationSigningInfo{}
}
func (m *ConfigurationProto_CertificationSigningInfo) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_CertificationSigningInfo) ProtoMessage() {}
func (*ConfigurationProto_CertificationSigningInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 25}
}

func (m *ConfigurationProto_CertificationSigningInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_CertificationSigningInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_CertificationSigningInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_CertificationSigningInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_CertificationSigningInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_CertificationSigningInfo.Merge(m, src)
}
func (m *ConfigurationProto_CertificationSigningInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_CertificationSigningInfo.Size(m)
}
func (m *ConfigurationProto_CertificationSigningInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_CertificationSigningInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_CertificationSigningInfo proto.InternalMessageInfo

func (m *ConfigurationProto_CertificationSigningInfo) GetCountry() string {
	if m != nil && m.Country != nil {
		return *m.Country
	}
	return ""
}

func (m *ConfigurationProto_CertificationSigningInfo) GetCountryCode() string {
	if m != nil && m.CountryCode != nil {
		return *m.CountryCode
	}
	return ""
}

func (m *ConfigurationProto_CertificationSigningInfo) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

func (m *ConfigurationProto_CertificationSigningInfo) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *ConfigurationProto_CertificationSigningInfo) GetOrganization() string {
	if m != nil && m.Organization != nil {
		return *m.Organization
	}
	return ""
}

func (m *ConfigurationProto_CertificationSigningInfo) GetEmailAddress() string {
	if m != nil && m.EmailAddress != nil {
		return *m.EmailAddress
	}
	return ""
}

func (m *ConfigurationProto_CertificationSigningInfo) GetOrganizationalUnitList() []string {
	if m != nil {
		return m.OrganizationalUnitList
	}
	return nil
}

func (m *ConfigurationProto_CertificationSigningInfo) GetCommonNameSuffix() string {
	if m != nil && m.CommonNameSuffix != nil {
		return *m.CommonNameSuffix
	}
	return ""
}

// State information for cassandra automatic ring fix operation.
type ConfigurationProto_AutoRingFixState struct {
	// Denotes the state of ring fixer.
	OperationState *ConfigurationProto_AutoRingFixState_RingFixerOperationState `protobuf:"varint,1,opt,name=operation_state,json=operationState,enum=nutanix.zeus.ConfigurationProto_AutoRingFixState_RingFixerOperationState" json:"operation_state,omitempty"`
	// Denotes owner of ring fixer.
	RingFixerSource *ConfigurationProto_AutoRingFixState_RingFixerSource `protobuf:"varint,2,opt,name=ring_fixer_source,json=ringFixerSource,enum=nutanix.zeus.ConfigurationProto_AutoRingFixState_RingFixerSource" json:"ring_fixer_source,omitempty"`
	// Number of total operations completed.
	NumberOfOperations *uint32 `protobuf:"varint,3,opt,name=number_of_operations,json=numberOfOperations" json:"number_of_operations,omitempty"`
	// Svm id and token information of the nodes to be detached/added.
	SvmAndToken []*ConfigurationProto_AutoRingFixState_SvmAndToken `protobuf:"bytes,4,rep,name=svm_and_token,json=svmAndToken" json:"svm_and_token,omitempty"`
	// Ring change start time.
	RingChangeStartTime  *uint32  `protobuf:"varint,5,opt,name=ring_change_start_time,json=ringChangeStartTime" json:"ring_change_start_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_AutoRingFixState) Reset()         { *m = ConfigurationProto_AutoRingFixState{} }
func (m *ConfigurationProto_AutoRingFixState) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_AutoRingFixState) ProtoMessage()    {}
func (*ConfigurationProto_AutoRingFixState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 26}
}

func (m *ConfigurationProto_AutoRingFixState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AutoRingFixState.Unmarshal(m, b)
}
func (m *ConfigurationProto_AutoRingFixState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AutoRingFixState.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AutoRingFixState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AutoRingFixState.Merge(m, src)
}
func (m *ConfigurationProto_AutoRingFixState) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AutoRingFixState.Size(m)
}
func (m *ConfigurationProto_AutoRingFixState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AutoRingFixState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AutoRingFixState proto.InternalMessageInfo

func (m *ConfigurationProto_AutoRingFixState) GetOperationState() ConfigurationProto_AutoRingFixState_RingFixerOperationState {
	if m != nil && m.OperationState != nil {
		return *m.OperationState
	}
	return ConfigurationProto_AutoRingFixState_kRingFixerInitialized
}

func (m *ConfigurationProto_AutoRingFixState) GetRingFixerSource() ConfigurationProto_AutoRingFixState_RingFixerSource {
	if m != nil && m.RingFixerSource != nil {
		return *m.RingFixerSource
	}
	return ConfigurationProto_AutoRingFixState_kSkewFixer
}

func (m *ConfigurationProto_AutoRingFixState) GetNumberOfOperations() uint32 {
	if m != nil && m.NumberOfOperations != nil {
		return *m.NumberOfOperations
	}
	return 0
}

func (m *ConfigurationProto_AutoRingFixState) GetSvmAndToken() []*ConfigurationProto_AutoRingFixState_SvmAndToken {
	if m != nil {
		return m.SvmAndToken
	}
	return nil
}

func (m *ConfigurationProto_AutoRingFixState) GetRingChangeStartTime() uint32 {
	if m != nil && m.RingChangeStartTime != nil {
		return *m.RingChangeStartTime
	}
	return 0
}

// Svm id and new token of the node to detach/add.
type ConfigurationProto_AutoRingFixState_SvmAndToken struct {
	// The svm_id of the cassandra node which will be detached
	// and added back into the ring.
	SvmId *int64 `protobuf:"varint,1,opt,name=svm_id,json=svmId" json:"svm_id,omitempty"`
	// The new token to be assigned once it is added back to the ring.
	// This field is set only if is_detach is false.
	NewCassandraToken *string `protobuf:"bytes,2,opt,name=new_cassandra_token,json=newCassandraToken" json:"new_cassandra_token,omitempty"`
	// True if node is going to be detached.
	IsDetach             *bool    `protobuf:"varint,3,opt,name=is_detach,json=isDetach" json:"is_detach,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) Reset() {
	*m = ConfigurationProto_AutoRingFixState_SvmAndToken{}
}
func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_AutoRingFixState_SvmAndToken) ProtoMessage() {}
func (*ConfigurationProto_AutoRingFixState_SvmAndToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 26, 0}
}

func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AutoRingFixState_SvmAndToken.Unmarshal(m, b)
}
func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AutoRingFixState_SvmAndToken.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AutoRingFixState_SvmAndToken.Merge(m, src)
}
func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AutoRingFixState_SvmAndToken.Size(m)
}
func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AutoRingFixState_SvmAndToken.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AutoRingFixState_SvmAndToken proto.InternalMessageInfo

func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) GetSvmId() int64 {
	if m != nil && m.SvmId != nil {
		return *m.SvmId
	}
	return 0
}

func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) GetNewCassandraToken() string {
	if m != nil && m.NewCassandraToken != nil {
		return *m.NewCassandraToken
	}
	return ""
}

func (m *ConfigurationProto_AutoRingFixState_SvmAndToken) GetIsDetach() bool {
	if m != nil && m.IsDetach != nil {
		return *m.IsDetach
	}
	return false
}

type ConfigurationProto_BlockIscsiTargetIPs struct {
	// List of IPs whose connections to any iSCSI target port we should block.
	// Used by Acropolis host HA.
	BlockedIpSet []string `protobuf:"bytes,1,rep,name=blocked_ip_set,json=blockedIpSet" json:"blocked_ip_set,omitempty"`
	// Unique, monotonically increasing id used to serialize changes to the
	// set of blocked IPs.
	LogicalTimestamp     *int64   `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp,def=1" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_BlockIscsiTargetIPs) Reset() {
	*m = ConfigurationProto_BlockIscsiTargetIPs{}
}
func (m *ConfigurationProto_BlockIscsiTargetIPs) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_BlockIscsiTargetIPs) ProtoMessage()    {}
func (*ConfigurationProto_BlockIscsiTargetIPs) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 27}
}

func (m *ConfigurationProto_BlockIscsiTargetIPs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_BlockIscsiTargetIPs.Unmarshal(m, b)
}
func (m *ConfigurationProto_BlockIscsiTargetIPs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_BlockIscsiTargetIPs.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_BlockIscsiTargetIPs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_BlockIscsiTargetIPs.Merge(m, src)
}
func (m *ConfigurationProto_BlockIscsiTargetIPs) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_BlockIscsiTargetIPs.Size(m)
}
func (m *ConfigurationProto_BlockIscsiTargetIPs) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_BlockIscsiTargetIPs.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_BlockIscsiTargetIPs proto.InternalMessageInfo

const Default_ConfigurationProto_BlockIscsiTargetIPs_LogicalTimestamp int64 = 1

func (m *ConfigurationProto_BlockIscsiTargetIPs) GetBlockedIpSet() []string {
	if m != nil {
		return m.BlockedIpSet
	}
	return nil
}

func (m *ConfigurationProto_BlockIscsiTargetIPs) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_ConfigurationProto_BlockIscsiTargetIPs_LogicalTimestamp
}

type ConfigurationProto_CuratorScanInfo struct {
	// Execution id of the partial scan which Curator is about to start.
	PartialScanExecutionId *int64 `protobuf:"varint,1,opt,name=partial_scan_execution_id,json=partialScanExecutionId" json:"partial_scan_execution_id,omitempty"`
	// Execution id of the full scan which Curator is about to start.
	FullScanExecutionId *int64 `protobuf:"varint,2,opt,name=full_scan_execution_id,json=fullScanExecutionId" json:"full_scan_execution_id,omitempty"`
	// Execution id of the selective scan which Curator is about to start.
	SelectiveScanExecutionId *int64   `protobuf:"varint,3,opt,name=selective_scan_execution_id,json=selectiveScanExecutionId" json:"selective_scan_execution_id,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *ConfigurationProto_CuratorScanInfo) Reset()         { *m = ConfigurationProto_CuratorScanInfo{} }
func (m *ConfigurationProto_CuratorScanInfo) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_CuratorScanInfo) ProtoMessage()    {}
func (*ConfigurationProto_CuratorScanInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 28}
}

func (m *ConfigurationProto_CuratorScanInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_CuratorScanInfo.Unmarshal(m, b)
}
func (m *ConfigurationProto_CuratorScanInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_CuratorScanInfo.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_CuratorScanInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_CuratorScanInfo.Merge(m, src)
}
func (m *ConfigurationProto_CuratorScanInfo) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_CuratorScanInfo.Size(m)
}
func (m *ConfigurationProto_CuratorScanInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_CuratorScanInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_CuratorScanInfo proto.InternalMessageInfo

func (m *ConfigurationProto_CuratorScanInfo) GetPartialScanExecutionId() int64 {
	if m != nil && m.PartialScanExecutionId != nil {
		return *m.PartialScanExecutionId
	}
	return 0
}

func (m *ConfigurationProto_CuratorScanInfo) GetFullScanExecutionId() int64 {
	if m != nil && m.FullScanExecutionId != nil {
		return *m.FullScanExecutionId
	}
	return 0
}

func (m *ConfigurationProto_CuratorScanInfo) GetSelectiveScanExecutionId() int64 {
	if m != nil && m.SelectiveScanExecutionId != nil {
		return *m.SelectiveScanExecutionId
	}
	return 0
}

type ConfigurationProto_AcropolisHAConfig struct {
	// Whether HA should be invoked upon host failure.
	FailoverEnabled *bool `protobuf:"varint,1,opt,name=failover_enabled,json=failoverEnabled,def=1" json:"failover_enabled,omitempty"`
	// Number of hosts specifically reserved for failover.
	NumHostFailuresToTolerate *int64 `protobuf:"varint,2,opt,name=num_host_failures_to_tolerate,json=numHostFailuresToTolerate" json:"num_host_failures_to_tolerate,omitempty"`
	// Unique, monotonically increasing id used to serialize changes to the
	// Acropolis HA configuration.
	LogicalTimestamp        *int64                                                           `protobuf:"varint,3,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	HaState                 *ConfigurationProto_AcropolisHAConfig_AcropolisHAState           `protobuf:"varint,5,opt,name=ha_state,json=haState,enum=nutanix.zeus.ConfigurationProto_AcropolisHAConfig_AcropolisHAState,def=4" json:"ha_state,omitempty"`
	ReservationType         *ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType `protobuf:"varint,6,opt,name=reservation_type,json=reservationType,enum=nutanix.zeus.ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType,def=3" json:"reservation_type,omitempty"`
	ReservationTypeOverride *bool                                                            `protobuf:"varint,7,opt,name=reservation_type_override,json=reservationTypeOverride,def=0" json:"reservation_type_override,omitempty"`
	// Whether the acropolis VMs had their locality fields cleared of
	// removed nodes.  This happens on upgrade to 4.5+
	RemovedNodeLocalityCleared *bool `protobuf:"varint,8,opt,name=removed_node_locality_cleared,json=removedNodeLocalityCleared" json:"removed_node_locality_cleared,omitempty"`
	// The number of host failures that can be tolerated at the given instant
	// based on the current state of the cluster.
	NumRemainingHostFailuresToTolerate *int64   `protobuf:"varint,9,opt,name=num_remaining_host_failures_to_tolerate,json=numRemainingHostFailuresToTolerate" json:"num_remaining_host_failures_to_tolerate,omitempty"`
	XXX_NoUnkeyedLiteral               struct{} `json:"-"`
	XXX_unrecognized                   []byte   `json:"-"`
	XXX_sizecache                      int32    `json:"-"`
}

func (m *ConfigurationProto_AcropolisHAConfig) Reset()         { *m = ConfigurationProto_AcropolisHAConfig{} }
func (m *ConfigurationProto_AcropolisHAConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_AcropolisHAConfig) ProtoMessage()    {}
func (*ConfigurationProto_AcropolisHAConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 29}
}

func (m *ConfigurationProto_AcropolisHAConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AcropolisHAConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_AcropolisHAConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AcropolisHAConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AcropolisHAConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AcropolisHAConfig.Merge(m, src)
}
func (m *ConfigurationProto_AcropolisHAConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AcropolisHAConfig.Size(m)
}
func (m *ConfigurationProto_AcropolisHAConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AcropolisHAConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AcropolisHAConfig proto.InternalMessageInfo

const Default_ConfigurationProto_AcropolisHAConfig_FailoverEnabled bool = true
const Default_ConfigurationProto_AcropolisHAConfig_HaState ConfigurationProto_AcropolisHAConfig_AcropolisHAState = ConfigurationProto_AcropolisHAConfig_kAcropolisHABestEffort
const Default_ConfigurationProto_AcropolisHAConfig_ReservationType ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType = ConfigurationProto_AcropolisHAConfig_kAcropolisHANoReservations
const Default_ConfigurationProto_AcropolisHAConfig_ReservationTypeOverride bool = false

func (m *ConfigurationProto_AcropolisHAConfig) GetFailoverEnabled() bool {
	if m != nil && m.FailoverEnabled != nil {
		return *m.FailoverEnabled
	}
	return Default_ConfigurationProto_AcropolisHAConfig_FailoverEnabled
}

func (m *ConfigurationProto_AcropolisHAConfig) GetNumHostFailuresToTolerate() int64 {
	if m != nil && m.NumHostFailuresToTolerate != nil {
		return *m.NumHostFailuresToTolerate
	}
	return 0
}

func (m *ConfigurationProto_AcropolisHAConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *ConfigurationProto_AcropolisHAConfig) GetHaState() ConfigurationProto_AcropolisHAConfig_AcropolisHAState {
	if m != nil && m.HaState != nil {
		return *m.HaState
	}
	return Default_ConfigurationProto_AcropolisHAConfig_HaState
}

func (m *ConfigurationProto_AcropolisHAConfig) GetReservationType() ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType {
	if m != nil && m.ReservationType != nil {
		return *m.ReservationType
	}
	return Default_ConfigurationProto_AcropolisHAConfig_ReservationType
}

func (m *ConfigurationProto_AcropolisHAConfig) GetReservationTypeOverride() bool {
	if m != nil && m.ReservationTypeOverride != nil {
		return *m.ReservationTypeOverride
	}
	return Default_ConfigurationProto_AcropolisHAConfig_ReservationTypeOverride
}

func (m *ConfigurationProto_AcropolisHAConfig) GetRemovedNodeLocalityCleared() bool {
	if m != nil && m.RemovedNodeLocalityCleared != nil {
		return *m.RemovedNodeLocalityCleared
	}
	return false
}

func (m *ConfigurationProto_AcropolisHAConfig) GetNumRemainingHostFailuresToTolerate() int64 {
	if m != nil && m.NumRemainingHostFailuresToTolerate != nil {
		return *m.NumRemainingHostFailuresToTolerate
	}
	return 0
}

type ConfigurationProto_ClickstreamConfig struct {
	// Flag to enable/disable click-stream logging
	LoggingEnabled       *bool    `protobuf:"varint,1,opt,name=logging_enabled,json=loggingEnabled,def=1" json:"logging_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_ClickstreamConfig) Reset()         { *m = ConfigurationProto_ClickstreamConfig{} }
func (m *ConfigurationProto_ClickstreamConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_ClickstreamConfig) ProtoMessage()    {}
func (*ConfigurationProto_ClickstreamConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 30}
}

func (m *ConfigurationProto_ClickstreamConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ClickstreamConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_ClickstreamConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ClickstreamConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ClickstreamConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ClickstreamConfig.Merge(m, src)
}
func (m *ConfigurationProto_ClickstreamConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ClickstreamConfig.Size(m)
}
func (m *ConfigurationProto_ClickstreamConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ClickstreamConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ClickstreamConfig proto.InternalMessageInfo

const Default_ConfigurationProto_ClickstreamConfig_LoggingEnabled bool = true

func (m *ConfigurationProto_ClickstreamConfig) GetLoggingEnabled() bool {
	if m != nil && m.LoggingEnabled != nil {
		return *m.LoggingEnabled
	}
	return Default_ConfigurationProto_ClickstreamConfig_LoggingEnabled
}

type ConfigurationProto_SecurityComplianceConfig struct {
	// Executes /srv/salt/statechange cron (hourly|daily|weekly|monthly)
	// command which adds the cronjob to run salt in the appropriate
	// cron directory.
	Schedule *ConfigurationProto_SaltstackSchedule `protobuf:"varint,1,opt,name=schedule,enum=nutanix.zeus.ConfigurationProto_SaltstackSchedule,def=1" json:"schedule,omitempty"`
	// Executes /srv/salt/statechange aide (on|off) command
	// which addresses the intrusion detection service.
	Aide *bool `protobuf:"varint,2,opt,name=aide,def=0" json:"aide,omitempty"`
	// Executes /srv/salt/statechange core (on|off) command
	// which addresses kernel core dumps (hardware/software).
	Core *bool `protobuf:"varint,3,opt,name=core,def=0" json:"core,omitempty"`
	// Executes /srv/salt/statechange passwordhs (on|off) command
	// which addresses setting the minimun length for password to 14
	// and remember to 24 in PAM.
	HighStrengthPassword *bool `protobuf:"varint,4,opt,name=high_strength_password,json=highStrengthPassword,def=0" json:"high_strength_password,omitempty"`
	// Executes /srv/salt/statechange banner (on|off) command which addresses
	// the DoD knowledge of consent banner for SSH and console logins.
	Banner *bool `protobuf:"varint,5,opt,name=banner,def=0" json:"banner,omitempty"`
	// Set the CVM host to either ignore or explicitly restrict v1 and v2 snmp
	// based connections.
	SnmpV3Only *bool `protobuf:"varint,6,opt,name=snmp_v3_only,json=snmpV3Only,def=0" json:"snmp_v3_only,omitempty"`
	// For compliance minimum password length must be configurable.
	CustomMinPasswordLength *int32 `protobuf:"varint,7,opt,name=custom_min_password_length,json=customMinPasswordLength" json:"custom_min_password_length,omitempty"`
	// For compliance the max login attempts must be configurable.
	MaxLoginAttempts *int32 `protobuf:"varint,8,opt,name=max_login_attempts,json=maxLoginAttempts" json:"max_login_attempts,omitempty"`
	// Number of seconds to be locked out if max_login_attempts is hit.
	LockoutSecs          *int32   `protobuf:"varint,9,opt,name=lockout_secs,json=lockoutSecs" json:"lockout_secs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_SecurityComplianceConfig) Reset() {
	*m = ConfigurationProto_SecurityComplianceConfig{}
}
func (m *ConfigurationProto_SecurityComplianceConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_SecurityComplianceConfig) ProtoMessage() {}
func (*ConfigurationProto_SecurityComplianceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 31}
}

func (m *ConfigurationProto_SecurityComplianceConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_SecurityComplianceConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_SecurityComplianceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_SecurityComplianceConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_SecurityComplianceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_SecurityComplianceConfig.Merge(m, src)
}
func (m *ConfigurationProto_SecurityComplianceConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_SecurityComplianceConfig.Size(m)
}
func (m *ConfigurationProto_SecurityComplianceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_SecurityComplianceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_SecurityComplianceConfig proto.InternalMessageInfo

const Default_ConfigurationProto_SecurityComplianceConfig_Schedule ConfigurationProto_SaltstackSchedule = ConfigurationProto_kDaily
const Default_ConfigurationProto_SecurityComplianceConfig_Aide bool = false
const Default_ConfigurationProto_SecurityComplianceConfig_Core bool = false
const Default_ConfigurationProto_SecurityComplianceConfig_HighStrengthPassword bool = false
const Default_ConfigurationProto_SecurityComplianceConfig_Banner bool = false
const Default_ConfigurationProto_SecurityComplianceConfig_SnmpV3Only bool = false

func (m *ConfigurationProto_SecurityComplianceConfig) GetSchedule() ConfigurationProto_SaltstackSchedule {
	if m != nil && m.Schedule != nil {
		return *m.Schedule
	}
	return Default_ConfigurationProto_SecurityComplianceConfig_Schedule
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetAide() bool {
	if m != nil && m.Aide != nil {
		return *m.Aide
	}
	return Default_ConfigurationProto_SecurityComplianceConfig_Aide
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetCore() bool {
	if m != nil && m.Core != nil {
		return *m.Core
	}
	return Default_ConfigurationProto_SecurityComplianceConfig_Core
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetHighStrengthPassword() bool {
	if m != nil && m.HighStrengthPassword != nil {
		return *m.HighStrengthPassword
	}
	return Default_ConfigurationProto_SecurityComplianceConfig_HighStrengthPassword
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetBanner() bool {
	if m != nil && m.Banner != nil {
		return *m.Banner
	}
	return Default_ConfigurationProto_SecurityComplianceConfig_Banner
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetSnmpV3Only() bool {
	if m != nil && m.SnmpV3Only != nil {
		return *m.SnmpV3Only
	}
	return Default_ConfigurationProto_SecurityComplianceConfig_SnmpV3Only
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetCustomMinPasswordLength() int32 {
	if m != nil && m.CustomMinPasswordLength != nil {
		return *m.CustomMinPasswordLength
	}
	return 0
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetMaxLoginAttempts() int32 {
	if m != nil && m.MaxLoginAttempts != nil {
		return *m.MaxLoginAttempts
	}
	return 0
}

func (m *ConfigurationProto_SecurityComplianceConfig) GetLockoutSecs() int32 {
	if m != nil && m.LockoutSecs != nil {
		return *m.LockoutSecs
	}
	return 0
}

type ConfigurationProto_HypervisorSecurityComplianceConfig struct {
	// Executes /srv/salt/statechange cron (hourly|daily|weekly|monthly)
	// command which adds the cronjob to run salt in the appropriate
	// cron directory.
	Schedule *ConfigurationProto_SaltstackSchedule `protobuf:"varint,1,opt,name=schedule,enum=nutanix.zeus.ConfigurationProto_SaltstackSchedule,def=1" json:"schedule,omitempty"`
	// Executes /srv/salt/statechange aide (on|off) command
	// which addresses the intrusion detection service.
	Aide *bool `protobuf:"varint,2,opt,name=aide,def=0" json:"aide,omitempty"`
	// Executes /srv/salt/statechange core (on|off) command
	// which addresses kernel core dumps (hardware/software).
	Core *bool `protobuf:"varint,3,opt,name=core,def=0" json:"core,omitempty"`
	// Executes /srv/salt/statechange passwordhs (on|off) command
	// which addresses setting the minimun length for password to 14
	// and remember to 24 in PAM.
	HighStrengthPassword *bool `protobuf:"varint,4,opt,name=high_strength_password,json=highStrengthPassword,def=0" json:"high_strength_password,omitempty"`
	// Executes /srv/salt/statechange banner (on|off) command which addresses
	// the DoD knowledge of consent banner for SSH and console logins.
	Banner               *bool    `protobuf:"varint,5,opt,name=banner,def=0" json:"banner,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) Reset() {
	*m = ConfigurationProto_HypervisorSecurityComplianceConfig{}
}
func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_HypervisorSecurityComplianceConfig) ProtoMessage() {}
func (*ConfigurationProto_HypervisorSecurityComplianceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 32}
}

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_HypervisorSecurityComplianceConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_HypervisorSecurityComplianceConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_HypervisorSecurityComplianceConfig.Merge(m, src)
}
func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_HypervisorSecurityComplianceConfig.Size(m)
}
func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_HypervisorSecurityComplianceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_HypervisorSecurityComplianceConfig proto.InternalMessageInfo

const Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Schedule ConfigurationProto_SaltstackSchedule = ConfigurationProto_kDaily
const Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Aide bool = false
const Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Core bool = false
const Default_ConfigurationProto_HypervisorSecurityComplianceConfig_HighStrengthPassword bool = false
const Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Banner bool = false

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) GetSchedule() ConfigurationProto_SaltstackSchedule {
	if m != nil && m.Schedule != nil {
		return *m.Schedule
	}
	return Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Schedule
}

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) GetAide() bool {
	if m != nil && m.Aide != nil {
		return *m.Aide
	}
	return Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Aide
}

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) GetCore() bool {
	if m != nil && m.Core != nil {
		return *m.Core
	}
	return Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Core
}

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) GetHighStrengthPassword() bool {
	if m != nil && m.HighStrengthPassword != nil {
		return *m.HighStrengthPassword
	}
	return Default_ConfigurationProto_HypervisorSecurityComplianceConfig_HighStrengthPassword
}

func (m *ConfigurationProto_HypervisorSecurityComplianceConfig) GetBanner() bool {
	if m != nil && m.Banner != nil {
		return *m.Banner
	}
	return Default_ConfigurationProto_HypervisorSecurityComplianceConfig_Banner
}

// Network configuration.
type ConfigurationProto_NetworkConfig struct {
	// Vlan id.
	VlanId *int32 `protobuf:"varint,1,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// Subnet in the format subnet/netmask.
	Subnet *string `protobuf:"bytes,2,opt,name=subnet" json:"subnet,omitempty"`
	// Priority Flow Control value for RDMA NICs.
	Pfc                  *int32                                               `protobuf:"varint,3,opt,name=pfc" json:"pfc,omitempty"`
	HostPhysicalEntity   *ConfigurationProto_NetworkConfig_HostPhysicalEntity `protobuf:"bytes,4,opt,name=host_physical_entity,json=hostPhysicalEntity" json:"host_physical_entity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                             `json:"-"`
	XXX_unrecognized     []byte                                               `json:"-"`
	XXX_sizecache        int32                                                `json:"-"`
}

func (m *ConfigurationProto_NetworkConfig) Reset()         { *m = ConfigurationProto_NetworkConfig{} }
func (m *ConfigurationProto_NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_NetworkConfig) ProtoMessage()    {}
func (*ConfigurationProto_NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 33}
}

func (m *ConfigurationProto_NetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_NetworkConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_NetworkConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_NetworkConfig.Merge(m, src)
}
func (m *ConfigurationProto_NetworkConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_NetworkConfig.Size(m)
}
func (m *ConfigurationProto_NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_NetworkConfig proto.InternalMessageInfo

func (m *ConfigurationProto_NetworkConfig) GetVlanId() int32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *ConfigurationProto_NetworkConfig) GetSubnet() string {
	if m != nil && m.Subnet != nil {
		return *m.Subnet
	}
	return ""
}

func (m *ConfigurationProto_NetworkConfig) GetPfc() int32 {
	if m != nil && m.Pfc != nil {
		return *m.Pfc
	}
	return 0
}

func (m *ConfigurationProto_NetworkConfig) GetHostPhysicalEntity() *ConfigurationProto_NetworkConfig_HostPhysicalEntity {
	if m != nil {
		return m.HostPhysicalEntity
	}
	return nil
}

// Backing Physical Entity on the host for Physical segmentation
// of Backplane traffic.
type ConfigurationProto_NetworkConfig_HostPhysicalEntity struct {
	// Physical entity to which host backplane interface is attached to.
	// Can be portgroup name on ESXi or bridge name on AHV.
	HostPhysicalNetwork *string `protobuf:"bytes,1,opt,name=host_physical_network,json=hostPhysicalNetwork" json:"host_physical_network,omitempty"`
	// Physical entity to which cvm backplane interface is attached to.
	// Can be portgroup name on ESXi or bridge name on AHV.
	CvmPhysicalNetwork *string `protobuf:"bytes,2,opt,name=cvm_physical_network,json=cvmPhysicalNetwork" json:"cvm_physical_network,omitempty"`
	//Virtual switch to which host backplane interface is attached to
	//This option applies to AHV cluster only
	HostVirtualSwitch    *string  `protobuf:"bytes,3,opt,name=host_virtual_switch,json=hostVirtualSwitch" json:"host_virtual_switch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) Reset() {
	*m = ConfigurationProto_NetworkConfig_HostPhysicalEntity{}
}
func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_NetworkConfig_HostPhysicalEntity) ProtoMessage() {}
func (*ConfigurationProto_NetworkConfig_HostPhysicalEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 33, 0}
}

func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_NetworkConfig_HostPhysicalEntity.Unmarshal(m, b)
}
func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_NetworkConfig_HostPhysicalEntity.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_NetworkConfig_HostPhysicalEntity.Merge(m, src)
}
func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_NetworkConfig_HostPhysicalEntity.Size(m)
}
func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_NetworkConfig_HostPhysicalEntity.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_NetworkConfig_HostPhysicalEntity proto.InternalMessageInfo

func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) GetHostPhysicalNetwork() string {
	if m != nil && m.HostPhysicalNetwork != nil {
		return *m.HostPhysicalNetwork
	}
	return ""
}

func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) GetCvmPhysicalNetwork() string {
	if m != nil && m.CvmPhysicalNetwork != nil {
		return *m.CvmPhysicalNetwork
	}
	return ""
}

func (m *ConfigurationProto_NetworkConfig_HostPhysicalEntity) GetHostVirtualSwitch() string {
	if m != nil && m.HostVirtualSwitch != nil {
		return *m.HostVirtualSwitch
	}
	return ""
}

// Iscsi configuration.
type ConfigurationProto_IscsiConfig struct {
	// Whether external iscsi clients are enabled or not.
	ExternalClientsEnabled *bool `protobuf:"varint,1,opt,name=external_clients_enabled,json=externalClientsEnabled" json:"external_clients_enabled,omitempty"`
	// Whether Curator has successfully completed the scan of Pithos
	// IscsiClientParams and added UUID to the entries that didn't have it.
	IscsiClientUuidFixDone *bool                                             `protobuf:"varint,2,opt,name=iscsi_client_uuid_fix_done,json=iscsiClientUuidFixDone" json:"iscsi_client_uuid_fix_done,omitempty"`
	ScsiPrEndianState      *ConfigurationProto_IscsiConfig_ScsiPREndianState `protobuf:"varint,3,opt,name=scsi_pr_endian_state,json=scsiPrEndianState,enum=nutanix.zeus.ConfigurationProto_IscsiConfig_ScsiPREndianState,def=0" json:"scsi_pr_endian_state,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                                          `json:"-"`
	XXX_unrecognized       []byte                                            `json:"-"`
	XXX_sizecache          int32                                             `json:"-"`
}

func (m *ConfigurationProto_IscsiConfig) Reset()         { *m = ConfigurationProto_IscsiConfig{} }
func (m *ConfigurationProto_IscsiConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_IscsiConfig) ProtoMessage()    {}
func (*ConfigurationProto_IscsiConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 34}
}

func (m *ConfigurationProto_IscsiConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_IscsiConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_IscsiConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_IscsiConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_IscsiConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_IscsiConfig.Merge(m, src)
}
func (m *ConfigurationProto_IscsiConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_IscsiConfig.Size(m)
}
func (m *ConfigurationProto_IscsiConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_IscsiConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_IscsiConfig proto.InternalMessageInfo

const Default_ConfigurationProto_IscsiConfig_ScsiPrEndianState ConfigurationProto_IscsiConfig_ScsiPREndianState = ConfigurationProto_IscsiConfig_kUnknownEndian

func (m *ConfigurationProto_IscsiConfig) GetExternalClientsEnabled() bool {
	if m != nil && m.ExternalClientsEnabled != nil {
		return *m.ExternalClientsEnabled
	}
	return false
}

func (m *ConfigurationProto_IscsiConfig) GetIscsiClientUuidFixDone() bool {
	if m != nil && m.IscsiClientUuidFixDone != nil {
		return *m.IscsiClientUuidFixDone
	}
	return false
}

func (m *ConfigurationProto_IscsiConfig) GetScsiPrEndianState() ConfigurationProto_IscsiConfig_ScsiPREndianState {
	if m != nil && m.ScsiPrEndianState != nil {
		return *m.ScsiPrEndianState
	}
	return Default_ConfigurationProto_IscsiConfig_ScsiPrEndianState
}

// Configuration which encapsulates details of protocol between Curator and
// Stargate. This config is used to synchronize behavior of Curator and
// Stargate.
type ConfigurationProto_CuratorStargateProtocolConfig struct {
	// The logical version of this config. Every time protocol config is
	// updated this version is incremented by 1. All Curator background tasks
	// which are dependent on this protocol config, must carry this version in
	// their task proto.
	CurrentVersion *int32 `protobuf:"varint,1,opt,name=current_version,json=currentVersion" json:"current_version,omitempty"`
	// Desired version of this config. If desired_version is greater than
	// current_version, then it indicates that this config is being updated.
	// Once the state transition is completed and we are ready to update this
	// config, then current_version will be set to this value. Stargate will
	// discard all the background tasks whose version does not match with
	// desired_version.
	DesiredVersion *int32 `protobuf:"varint,2,opt,name=desired_version,json=desiredVersion" json:"desired_version,omitempty"`
	// If true, Curator and Stargate will execute two phase deletion protocol
	// while updating refcount of dedup extents.
	//
	// Curator sets this field to true if all the following conditions are met:
	// 1. This field is not initialized before.
	// 2. Current StargateVersion is equal to or greater than
	//    kDedupExtentTwoPhaseDeletion.
	// 3. None of the Stargates have any background update refcount task
	//    running.
	EnableDedupExtentsTwoPhaseDeletion *bool    `protobuf:"varint,3,opt,name=enable_dedup_extents_two_phase_deletion,json=enableDedupExtentsTwoPhaseDeletion" json:"enable_dedup_extents_two_phase_deletion,omitempty"`
	XXX_NoUnkeyedLiteral               struct{} `json:"-"`
	XXX_unrecognized                   []byte   `json:"-"`
	XXX_sizecache                      int32    `json:"-"`
}

func (m *ConfigurationProto_CuratorStargateProtocolConfig) Reset() {
	*m = ConfigurationProto_CuratorStargateProtocolConfig{}
}
func (m *ConfigurationProto_CuratorStargateProtocolConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_CuratorStargateProtocolConfig) ProtoMessage() {}
func (*ConfigurationProto_CuratorStargateProtocolConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 35}
}

func (m *ConfigurationProto_CuratorStargateProtocolConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_CuratorStargateProtocolConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_CuratorStargateProtocolConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_CuratorStargateProtocolConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_CuratorStargateProtocolConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_CuratorStargateProtocolConfig.Merge(m, src)
}
func (m *ConfigurationProto_CuratorStargateProtocolConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_CuratorStargateProtocolConfig.Size(m)
}
func (m *ConfigurationProto_CuratorStargateProtocolConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_CuratorStargateProtocolConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_CuratorStargateProtocolConfig proto.InternalMessageInfo

func (m *ConfigurationProto_CuratorStargateProtocolConfig) GetCurrentVersion() int32 {
	if m != nil && m.CurrentVersion != nil {
		return *m.CurrentVersion
	}
	return 0
}

func (m *ConfigurationProto_CuratorStargateProtocolConfig) GetDesiredVersion() int32 {
	if m != nil && m.DesiredVersion != nil {
		return *m.DesiredVersion
	}
	return 0
}

func (m *ConfigurationProto_CuratorStargateProtocolConfig) GetEnableDedupExtentsTwoPhaseDeletion() bool {
	if m != nil && m.EnableDedupExtentsTwoPhaseDeletion != nil {
		return *m.EnableDedupExtentsTwoPhaseDeletion
	}
	return false
}

// Configuration specific to the Acropolis Dynamic Scheduler (ADS).
type ConfigurationProto_AdsConfig struct {
	// Whether ADS is enabled to automatically fix hotspots on the cluster.
	Enabled *bool `protobuf:"varint,1,opt,name=enabled,def=1" json:"enabled,omitempty"`
	// Unique, monotonically increasing id used to serialize changes to the ADS
	// configuration.
	LogicalTimestamp     *int64   `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_AdsConfig) Reset()         { *m = ConfigurationProto_AdsConfig{} }
func (m *ConfigurationProto_AdsConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_AdsConfig) ProtoMessage()    {}
func (*ConfigurationProto_AdsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 36}
}

func (m *ConfigurationProto_AdsConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_AdsConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_AdsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_AdsConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_AdsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_AdsConfig.Merge(m, src)
}
func (m *ConfigurationProto_AdsConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_AdsConfig.Size(m)
}
func (m *ConfigurationProto_AdsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_AdsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_AdsConfig proto.InternalMessageInfo

const Default_ConfigurationProto_AdsConfig_Enabled bool = true

func (m *ConfigurationProto_AdsConfig) GetEnabled() bool {
	if m != nil && m.Enabled != nil {
		return *m.Enabled
	}
	return Default_ConfigurationProto_AdsConfig_Enabled
}

func (m *ConfigurationProto_AdsConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

// Cluster wide LWS store related configuration.
type ConfigurationProto_LWSStoreConfig struct {
	State *ConfigurationProto_LWSStoreConfig_State `protobuf:"varint,1,opt,name=state,enum=nutanix.zeus.ConfigurationProto_LWSStoreConfig_State" json:"state,omitempty"`
	// The size of the LWS store, globally (cluster wide).
	Size                 *int64   `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_LWSStoreConfig) Reset()         { *m = ConfigurationProto_LWSStoreConfig{} }
func (m *ConfigurationProto_LWSStoreConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_LWSStoreConfig) ProtoMessage()    {}
func (*ConfigurationProto_LWSStoreConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 37}
}

func (m *ConfigurationProto_LWSStoreConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_LWSStoreConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_LWSStoreConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_LWSStoreConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_LWSStoreConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_LWSStoreConfig.Merge(m, src)
}
func (m *ConfigurationProto_LWSStoreConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_LWSStoreConfig.Size(m)
}
func (m *ConfigurationProto_LWSStoreConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_LWSStoreConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_LWSStoreConfig proto.InternalMessageInfo

func (m *ConfigurationProto_LWSStoreConfig) GetState() ConfigurationProto_LWSStoreConfig_State {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ConfigurationProto_LWSStoreConfig_kAbsent
}

func (m *ConfigurationProto_LWSStoreConfig) GetSize() int64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

// The following fields are used for two node clusters.
type ConfigurationProto_WitnessState struct {
	// This field will be set by Genesis to indicate which node won
	// the leadership election.
	LeaderSvmId             *int64 `protobuf:"varint,1,opt,name=leader_svm_id,json=leaderSvmId,def=-1" json:"leader_svm_id,omitempty"`
	ClusterTransitionStatus *int32 `protobuf:"varint,2,opt,name=cluster_transition_status,json=clusterTransitionStatus" json:"cluster_transition_status,omitempty"`
	// History of Witness State transitions. The latest state
	// change information is added at the end of the list.
	WitnessStateHistory []*ConfigurationProto_WitnessState_WitnessStateHistory `protobuf:"bytes,3,rep,name=witness_state_history,json=witnessStateHistory" json:"witness_state_history,omitempty"`
	// Logical clock updated for any change in leader, used as entity_version
	// in requests to witness, always to be in sync with witness entity_version.
	LogicalTimestamp *int64 `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// The witness object uuid.
	WitnessObjectUuid *string `protobuf:"bytes,5,opt,name=witness_object_uuid,json=witnessObjectUuid" json:"witness_object_uuid,omitempty"`
	// Logical timestamp updated whenever 'cluster_operation_mode' changes.
	ClusterOperationModeLogicalTimestamp *int64 `protobuf:"varint,6,opt,name=cluster_operation_mode_logical_timestamp,json=clusterOperationModeLogicalTimestamp,def=0" json:"cluster_operation_mode_logical_timestamp,omitempty"`
	// Whether the cluster was stopped during the last transition to
	// kStandAlone for upgrade. Cleared when cluster is started.
	ClusterStoppedSinceKStandAloneForUpgrade *bool `protobuf:"varint,7,opt,name=cluster_stopped_since_kStandAlone_for_upgrade,json=clusterStoppedSinceKStandAloneForUpgrade,def=0" json:"cluster_stopped_since_kStandAlone_for_upgrade,omitempty"`
	// State of the two node cluster which can take the values
	// start, stop and none
	TwoNodeClusterState  *string  `protobuf:"bytes,8,opt,name=two_node_cluster_state,json=twoNodeClusterState,def=none" json:"two_node_cluster_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_WitnessState) Reset()         { *m = ConfigurationProto_WitnessState{} }
func (m *ConfigurationProto_WitnessState) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_WitnessState) ProtoMessage()    {}
func (*ConfigurationProto_WitnessState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 38}
}

func (m *ConfigurationProto_WitnessState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_WitnessState.Unmarshal(m, b)
}
func (m *ConfigurationProto_WitnessState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_WitnessState.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_WitnessState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_WitnessState.Merge(m, src)
}
func (m *ConfigurationProto_WitnessState) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_WitnessState.Size(m)
}
func (m *ConfigurationProto_WitnessState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_WitnessState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_WitnessState proto.InternalMessageInfo

const Default_ConfigurationProto_WitnessState_LeaderSvmId int64 = -1
const Default_ConfigurationProto_WitnessState_ClusterOperationModeLogicalTimestamp int64 = 0
const Default_ConfigurationProto_WitnessState_ClusterStoppedSinceKStandAloneForUpgrade bool = false
const Default_ConfigurationProto_WitnessState_TwoNodeClusterState string = "none"

func (m *ConfigurationProto_WitnessState) GetLeaderSvmId() int64 {
	if m != nil && m.LeaderSvmId != nil {
		return *m.LeaderSvmId
	}
	return Default_ConfigurationProto_WitnessState_LeaderSvmId
}

func (m *ConfigurationProto_WitnessState) GetClusterTransitionStatus() int32 {
	if m != nil && m.ClusterTransitionStatus != nil {
		return *m.ClusterTransitionStatus
	}
	return 0
}

func (m *ConfigurationProto_WitnessState) GetWitnessStateHistory() []*ConfigurationProto_WitnessState_WitnessStateHistory {
	if m != nil {
		return m.WitnessStateHistory
	}
	return nil
}

func (m *ConfigurationProto_WitnessState) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *ConfigurationProto_WitnessState) GetWitnessObjectUuid() string {
	if m != nil && m.WitnessObjectUuid != nil {
		return *m.WitnessObjectUuid
	}
	return ""
}

func (m *ConfigurationProto_WitnessState) GetClusterOperationModeLogicalTimestamp() int64 {
	if m != nil && m.ClusterOperationModeLogicalTimestamp != nil {
		return *m.ClusterOperationModeLogicalTimestamp
	}
	return Default_ConfigurationProto_WitnessState_ClusterOperationModeLogicalTimestamp
}

func (m *ConfigurationProto_WitnessState) GetClusterStoppedSinceKStandAloneForUpgrade() bool {
	if m != nil && m.ClusterStoppedSinceKStandAloneForUpgrade != nil {
		return *m.ClusterStoppedSinceKStandAloneForUpgrade
	}
	return Default_ConfigurationProto_WitnessState_ClusterStoppedSinceKStandAloneForUpgrade
}

func (m *ConfigurationProto_WitnessState) GetTwoNodeClusterState() string {
	if m != nil && m.TwoNodeClusterState != nil {
		return *m.TwoNodeClusterState
	}
	return Default_ConfigurationProto_WitnessState_TwoNodeClusterState
}

type ConfigurationProto_WitnessState_WitnessStateHistory struct {
	// The cluster_transition_status in the past.
	ClusterStatus *int32 `protobuf:"varint,1,opt,name=cluster_status,json=clusterStatus" json:"cluster_status,omitempty"`
	// Reason for cluster transition.
	TransitionReason *ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason `protobuf:"varint,2,opt,name=transition_reason,json=transitionReason,enum=nutanix.zeus.ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason" json:"transition_reason,omitempty"`
	// Time at which this transition was initiated.
	LastTransitionTimestamp *int64 `protobuf:"varint,3,opt,name=last_transition_timestamp,json=lastTransitionTimestamp" json:"last_transition_timestamp,omitempty"`
	// Leader node which initiated this transition.
	LeaderSvmId *int64 `protobuf:"varint,4,opt,name=leader_svm_id,json=leaderSvmId" json:"leader_svm_id,omitempty"`
	// Cluster operation mode at the time this transition was initiated.
	ClusterOperationMode *ConfigurationProto_OperationMode `protobuf:"varint,5,opt,name=cluster_operation_mode,json=clusterOperationMode,enum=nutanix.zeus.ConfigurationProto_OperationMode" json:"cluster_operation_mode,omitempty"`
	// Flag that indicates if the cluster has been in a stopped state
	// since going to kStandAlone for upgrade.
	ClusterStoppedSinceKStandAloneForUpgrade *bool    `protobuf:"varint,6,opt,name=cluster_stopped_since_kStandAlone_for_upgrade,json=clusterStoppedSinceKStandAloneForUpgrade" json:"cluster_stopped_since_kStandAlone_for_upgrade,omitempty"`
	XXX_NoUnkeyedLiteral                     struct{} `json:"-"`
	XXX_unrecognized                         []byte   `json:"-"`
	XXX_sizecache                            int32    `json:"-"`
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) Reset() {
	*m = ConfigurationProto_WitnessState_WitnessStateHistory{}
}
func (m *ConfigurationProto_WitnessState_WitnessStateHistory) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_WitnessState_WitnessStateHistory) ProtoMessage() {}
func (*ConfigurationProto_WitnessState_WitnessStateHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 38, 0}
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_WitnessState_WitnessStateHistory.Unmarshal(m, b)
}
func (m *ConfigurationProto_WitnessState_WitnessStateHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_WitnessState_WitnessStateHistory.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_WitnessState_WitnessStateHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_WitnessState_WitnessStateHistory.Merge(m, src)
}
func (m *ConfigurationProto_WitnessState_WitnessStateHistory) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_WitnessState_WitnessStateHistory.Size(m)
}
func (m *ConfigurationProto_WitnessState_WitnessStateHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_WitnessState_WitnessStateHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_WitnessState_WitnessStateHistory proto.InternalMessageInfo

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) GetClusterStatus() int32 {
	if m != nil && m.ClusterStatus != nil {
		return *m.ClusterStatus
	}
	return 0
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) GetTransitionReason() ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason {
	if m != nil && m.TransitionReason != nil {
		return *m.TransitionReason
	}
	return ConfigurationProto_WitnessState_WitnessStateHistory_kManual
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) GetLastTransitionTimestamp() int64 {
	if m != nil && m.LastTransitionTimestamp != nil {
		return *m.LastTransitionTimestamp
	}
	return 0
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) GetLeaderSvmId() int64 {
	if m != nil && m.LeaderSvmId != nil {
		return *m.LeaderSvmId
	}
	return 0
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) GetClusterOperationMode() ConfigurationProto_OperationMode {
	if m != nil && m.ClusterOperationMode != nil {
		return *m.ClusterOperationMode
	}
	return ConfigurationProto_kNormal
}

func (m *ConfigurationProto_WitnessState_WitnessStateHistory) GetClusterStoppedSinceKStandAloneForUpgrade() bool {
	if m != nil && m.ClusterStoppedSinceKStandAloneForUpgrade != nil {
		return *m.ClusterStoppedSinceKStandAloneForUpgrade
	}
	return false
}

// Describes a single Rack which contains one or more blocks/rackable units.
type ConfigurationProto_Rack struct {
	// Globally unique id (within this cluster) for the rack generated by the
	// system.
	RackId *int64 `protobuf:"varint,1,opt,name=rack_id,json=rackId" json:"rack_id,omitempty"`
	// Unique name given to the rack by the customer.
	RackName *string `protobuf:"bytes,2,opt,name=rack_name,json=rackName" json:"rack_name,omitempty"`
	// Globally unique identifier that identifies this rack across
	// all clusters.
	RackUuid             *string  `protobuf:"bytes,3,opt,name=rack_uuid,json=rackUuid" json:"rack_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_Rack) Reset()         { *m = ConfigurationProto_Rack{} }
func (m *ConfigurationProto_Rack) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_Rack) ProtoMessage()    {}
func (*ConfigurationProto_Rack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 39}
}

func (m *ConfigurationProto_Rack) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_Rack.Unmarshal(m, b)
}
func (m *ConfigurationProto_Rack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_Rack.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_Rack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_Rack.Merge(m, src)
}
func (m *ConfigurationProto_Rack) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_Rack.Size(m)
}
func (m *ConfigurationProto_Rack) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_Rack.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_Rack proto.InternalMessageInfo

func (m *ConfigurationProto_Rack) GetRackId() int64 {
	if m != nil && m.RackId != nil {
		return *m.RackId
	}
	return 0
}

func (m *ConfigurationProto_Rack) GetRackName() string {
	if m != nil && m.RackName != nil {
		return *m.RackName
	}
	return ""
}

func (m *ConfigurationProto_Rack) GetRackUuid() string {
	if m != nil && m.RackUuid != nil {
		return *m.RackUuid
	}
	return ""
}

type ConfigurationProto_ClusterConversionStatus struct {
	// Target hypervisor for the cluster conversion operation.
	TargetHypervisor *ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,1,opt,name=target_hypervisor,json=targetHypervisor,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType" json:"target_hypervisor,omitempty"`
	// Indicates that cluster conversion (Dial) operation is in progress. All
	// Create/Update/Delete APIs will be blocked by Prism during this period.
	// This field is to convey this information to Prism. WAL is still
	// maintained in zookeeper nodes and IDF.
	ConversionInProgress *bool    `protobuf:"varint,2,opt,name=conversion_in_progress,json=conversionInProgress,def=0" json:"conversion_in_progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_ClusterConversionStatus) Reset() {
	*m = ConfigurationProto_ClusterConversionStatus{}
}
func (m *ConfigurationProto_ClusterConversionStatus) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_ClusterConversionStatus) ProtoMessage() {}
func (*ConfigurationProto_ClusterConversionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 40}
}

func (m *ConfigurationProto_ClusterConversionStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ClusterConversionStatus.Unmarshal(m, b)
}
func (m *ConfigurationProto_ClusterConversionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ClusterConversionStatus.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ClusterConversionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ClusterConversionStatus.Merge(m, src)
}
func (m *ConfigurationProto_ClusterConversionStatus) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ClusterConversionStatus.Size(m)
}
func (m *ConfigurationProto_ClusterConversionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ClusterConversionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ClusterConversionStatus proto.InternalMessageInfo

const Default_ConfigurationProto_ClusterConversionStatus_ConversionInProgress bool = false

func (m *ConfigurationProto_ClusterConversionStatus) GetTargetHypervisor() ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.TargetHypervisor != nil {
		return *m.TargetHypervisor
	}
	return ConfigurationProto_ManagementServer_kVMware
}

func (m *ConfigurationProto_ClusterConversionStatus) GetConversionInProgress() bool {
	if m != nil && m.ConversionInProgress != nil {
		return *m.ConversionInProgress
	}
	return Default_ConfigurationProto_ClusterConversionStatus_ConversionInProgress
}

type ConfigurationProto_MemoryReservationsPerComponent struct {
	// Name of the component requesting adding or removing memory reservations
	// per host.
	ComponentName *string `protobuf:"bytes,1,opt,name=component_name,json=componentName" json:"component_name,omitempty"`
	// Amount of user space memory overhead reserved per host in megabytes for
	// this component.
	UserMemoryMb *uint64 `protobuf:"varint,2,opt,name=user_memory_mb,json=userMemoryMb" json:"user_memory_mb,omitempty"`
	// Amount of kernel space memory overhead reserved per host in megabytes
	// for this comonent.
	KernelMemoryMb       *uint64  `protobuf:"varint,3,opt,name=kernel_memory_mb,json=kernelMemoryMb" json:"kernel_memory_mb,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_MemoryReservationsPerComponent) Reset() {
	*m = ConfigurationProto_MemoryReservationsPerComponent{}
}
func (m *ConfigurationProto_MemoryReservationsPerComponent) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_MemoryReservationsPerComponent) ProtoMessage() {}
func (*ConfigurationProto_MemoryReservationsPerComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 41}
}

func (m *ConfigurationProto_MemoryReservationsPerComponent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_MemoryReservationsPerComponent.Unmarshal(m, b)
}
func (m *ConfigurationProto_MemoryReservationsPerComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_MemoryReservationsPerComponent.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_MemoryReservationsPerComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_MemoryReservationsPerComponent.Merge(m, src)
}
func (m *ConfigurationProto_MemoryReservationsPerComponent) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_MemoryReservationsPerComponent.Size(m)
}
func (m *ConfigurationProto_MemoryReservationsPerComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_MemoryReservationsPerComponent.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_MemoryReservationsPerComponent proto.InternalMessageInfo

func (m *ConfigurationProto_MemoryReservationsPerComponent) GetComponentName() string {
	if m != nil && m.ComponentName != nil {
		return *m.ComponentName
	}
	return ""
}

func (m *ConfigurationProto_MemoryReservationsPerComponent) GetUserMemoryMb() uint64 {
	if m != nil && m.UserMemoryMb != nil {
		return *m.UserMemoryMb
	}
	return 0
}

func (m *ConfigurationProto_MemoryReservationsPerComponent) GetKernelMemoryMb() uint64 {
	if m != nil && m.KernelMemoryMb != nil {
		return *m.KernelMemoryMb
	}
	return 0
}

type ConfigurationProto_HypervisorLldpConfig struct {
	// Executes /srv/salt/statechange lldpd (txon|txoff) command which addresses
	// enabling LLDP TX on or disabling it. LLDP RX is always enabled.
	LldpdTx              *bool    `protobuf:"varint,1,opt,name=lldpd_tx,json=lldpdTx,def=1" json:"lldpd_tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_HypervisorLldpConfig) Reset() {
	*m = ConfigurationProto_HypervisorLldpConfig{}
}
func (m *ConfigurationProto_HypervisorLldpConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_HypervisorLldpConfig) ProtoMessage()    {}
func (*ConfigurationProto_HypervisorLldpConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 42}
}

func (m *ConfigurationProto_HypervisorLldpConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_HypervisorLldpConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_HypervisorLldpConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_HypervisorLldpConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_HypervisorLldpConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_HypervisorLldpConfig.Merge(m, src)
}
func (m *ConfigurationProto_HypervisorLldpConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_HypervisorLldpConfig.Size(m)
}
func (m *ConfigurationProto_HypervisorLldpConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_HypervisorLldpConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_HypervisorLldpConfig proto.InternalMessageInfo

const Default_ConfigurationProto_HypervisorLldpConfig_LldpdTx bool = true

func (m *ConfigurationProto_HypervisorLldpConfig) GetLldpdTx() bool {
	if m != nil && m.LldpdTx != nil {
		return *m.LldpdTx
	}
	return Default_ConfigurationProto_HypervisorLldpConfig_LldpdTx
}

// Properties configured in individual instances of this type enable an
// AOS cluster to authenticate and access resources such as the virtual
// disks stored in these external repositories.
type ConfigurationProto_ExternalRepository struct {
	// Unique integer ID generated by the Nutanix software for the external
	// repository.
	ExternalRepositoryId *int64 `protobuf:"varint,1,opt,name=external_repository_id,json=externalRepositoryId" json:"external_repository_id,omitempty"`
	// Administrator-provided name of the ExternalRepository instance.
	ExternalRepositoryName *string `protobuf:"bytes,2,opt,name=external_repository_name,json=externalRepositoryName" json:"external_repository_name,omitempty"`
	// System-generated UUID of the ExternalRepository instance.
	ExternalRepositoryUuid *string `protobuf:"bytes,3,opt,name=external_repository_uuid,json=externalRepositoryUuid" json:"external_repository_uuid,omitempty"`
	// If true, this is an intent to remove the ExternalRepository instance.
	ToRemove *bool `protobuf:"varint,4,opt,name=to_remove,json=toRemove,def=0" json:"to_remove,omitempty"`
	// Properties of network_entity encapsulate details about the server
	// viz.,FQDN, IP address, port etc.
	Server *ConfigurationProto_NetworkEntity `protobuf:"bytes,5,opt,name=server" json:"server,omitempty"`
	// Protocol using which the storage identified by the ExternalRepository
	// instance can be accessed by an AOS cluster.
	Protocol *ConfigurationProto_ExternalRepository_Protocol `protobuf:"varint,6,opt,name=protocol,enum=nutanix.zeus.ConfigurationProto_ExternalRepository_Protocol,def=0" json:"protocol,omitempty"`
	// If protocol is kNfs, then the following property must be set.
	NfsExport            *ConfigurationProto_ExternalRepository_NfsExport `protobuf:"bytes,7,opt,name=nfs_export,json=nfsExport" json:"nfs_export,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *ConfigurationProto_ExternalRepository) Reset()         { *m = ConfigurationProto_ExternalRepository{} }
func (m *ConfigurationProto_ExternalRepository) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_ExternalRepository) ProtoMessage()    {}
func (*ConfigurationProto_ExternalRepository) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 43}
}

func (m *ConfigurationProto_ExternalRepository) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ExternalRepository.Unmarshal(m, b)
}
func (m *ConfigurationProto_ExternalRepository) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ExternalRepository.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ExternalRepository) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ExternalRepository.Merge(m, src)
}
func (m *ConfigurationProto_ExternalRepository) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ExternalRepository.Size(m)
}
func (m *ConfigurationProto_ExternalRepository) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ExternalRepository.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ExternalRepository proto.InternalMessageInfo

const Default_ConfigurationProto_ExternalRepository_ToRemove bool = false
const Default_ConfigurationProto_ExternalRepository_Protocol ConfigurationProto_ExternalRepository_Protocol = ConfigurationProto_ExternalRepository_kNfs

func (m *ConfigurationProto_ExternalRepository) GetExternalRepositoryId() int64 {
	if m != nil && m.ExternalRepositoryId != nil {
		return *m.ExternalRepositoryId
	}
	return 0
}

func (m *ConfigurationProto_ExternalRepository) GetExternalRepositoryName() string {
	if m != nil && m.ExternalRepositoryName != nil {
		return *m.ExternalRepositoryName
	}
	return ""
}

func (m *ConfigurationProto_ExternalRepository) GetExternalRepositoryUuid() string {
	if m != nil && m.ExternalRepositoryUuid != nil {
		return *m.ExternalRepositoryUuid
	}
	return ""
}

func (m *ConfigurationProto_ExternalRepository) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return Default_ConfigurationProto_ExternalRepository_ToRemove
}

func (m *ConfigurationProto_ExternalRepository) GetServer() *ConfigurationProto_NetworkEntity {
	if m != nil {
		return m.Server
	}
	return nil
}

func (m *ConfigurationProto_ExternalRepository) GetProtocol() ConfigurationProto_ExternalRepository_Protocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Default_ConfigurationProto_ExternalRepository_Protocol
}

func (m *ConfigurationProto_ExternalRepository) GetNfsExport() *ConfigurationProto_ExternalRepository_NfsExport {
	if m != nil {
		return m.NfsExport
	}
	return nil
}

type ConfigurationProto_ExternalRepository_NfsExport struct {
	// Name of the exported directory.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The kind of access permitted by the storage repository when using NFS.
	AccessMode           *ConfigurationProto_ExternalRepository_NfsExport_AccessMode `protobuf:"varint,2,opt,name=access_mode,json=accessMode,enum=nutanix.zeus.ConfigurationProto_ExternalRepository_NfsExport_AccessMode,def=0" json:"access_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                    `json:"-"`
	XXX_unrecognized     []byte                                                      `json:"-"`
	XXX_sizecache        int32                                                       `json:"-"`
}

func (m *ConfigurationProto_ExternalRepository_NfsExport) Reset() {
	*m = ConfigurationProto_ExternalRepository_NfsExport{}
}
func (m *ConfigurationProto_ExternalRepository_NfsExport) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_ExternalRepository_NfsExport) ProtoMessage() {}
func (*ConfigurationProto_ExternalRepository_NfsExport) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 43, 0}
}

func (m *ConfigurationProto_ExternalRepository_NfsExport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ExternalRepository_NfsExport.Unmarshal(m, b)
}
func (m *ConfigurationProto_ExternalRepository_NfsExport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ExternalRepository_NfsExport.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ExternalRepository_NfsExport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ExternalRepository_NfsExport.Merge(m, src)
}
func (m *ConfigurationProto_ExternalRepository_NfsExport) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ExternalRepository_NfsExport.Size(m)
}
func (m *ConfigurationProto_ExternalRepository_NfsExport) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ExternalRepository_NfsExport.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ExternalRepository_NfsExport proto.InternalMessageInfo

const Default_ConfigurationProto_ExternalRepository_NfsExport_AccessMode ConfigurationProto_ExternalRepository_NfsExport_AccessMode = ConfigurationProto_ExternalRepository_NfsExport_kReadOnly

func (m *ConfigurationProto_ExternalRepository_NfsExport) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ConfigurationProto_ExternalRepository_NfsExport) GetAccessMode() ConfigurationProto_ExternalRepository_NfsExport_AccessMode {
	if m != nil && m.AccessMode != nil {
		return *m.AccessMode
	}
	return Default_ConfigurationProto_ExternalRepository_NfsExport_AccessMode
}

// 'ClusterCapabilities' message can be used by services to communicate their
// capabilities to other services on the same cluster, or to servcies on a
// remote cluster in case of PC-PE through Zeus config sync.
type ConfigurationProto_ClusterCapabilities struct {
	// Capabilities of Mercury service.
	MercuryCapabilities *ConfigurationProto_ClusterCapabilities_MercuryCapabilities `protobuf:"bytes,1,opt,name=mercury_capabilities,json=mercuryCapabilities" json:"mercury_capabilities,omitempty"`
	// Capabilities of Catalog service.
	CatalogCapabilities  *ConfigurationProto_ClusterCapabilities_CatalogCapabilities `protobuf:"bytes,2,opt,name=catalog_capabilities,json=catalogCapabilities" json:"catalog_capabilities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                    `json:"-"`
	XXX_unrecognized     []byte                                                      `json:"-"`
	XXX_sizecache        int32                                                       `json:"-"`
}

func (m *ConfigurationProto_ClusterCapabilities) Reset() {
	*m = ConfigurationProto_ClusterCapabilities{}
}
func (m *ConfigurationProto_ClusterCapabilities) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_ClusterCapabilities) ProtoMessage()    {}
func (*ConfigurationProto_ClusterCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 44}
}

func (m *ConfigurationProto_ClusterCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities.Unmarshal(m, b)
}
func (m *ConfigurationProto_ClusterCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ClusterCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ClusterCapabilities.Merge(m, src)
}
func (m *ConfigurationProto_ClusterCapabilities) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities.Size(m)
}
func (m *ConfigurationProto_ClusterCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ClusterCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ClusterCapabilities proto.InternalMessageInfo

func (m *ConfigurationProto_ClusterCapabilities) GetMercuryCapabilities() *ConfigurationProto_ClusterCapabilities_MercuryCapabilities {
	if m != nil {
		return m.MercuryCapabilities
	}
	return nil
}

func (m *ConfigurationProto_ClusterCapabilities) GetCatalogCapabilities() *ConfigurationProto_ClusterCapabilities_CatalogCapabilities {
	if m != nil {
		return m.CatalogCapabilities
	}
	return nil
}

// 'MercuryCapabilities' describes the capabilities of Mercury service on
// this cluster.
type ConfigurationProto_ClusterCapabilities_MercuryCapabilities struct {
	// This field indicates whether Mercury on this cluster is capable of
	// receiving gRPC requests.
	GrpcServerEnabled    *bool    `protobuf:"varint,1,opt,name=grpc_server_enabled,json=grpcServerEnabled,def=0" json:"grpc_server_enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) Reset() {
	*m = ConfigurationProto_ClusterCapabilities_MercuryCapabilities{}
}
func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_ClusterCapabilities_MercuryCapabilities) ProtoMessage() {}
func (*ConfigurationProto_ClusterCapabilities_MercuryCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 44, 0}
}

func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities_MercuryCapabilities.Unmarshal(m, b)
}
func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities_MercuryCapabilities.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ClusterCapabilities_MercuryCapabilities.Merge(m, src)
}
func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities_MercuryCapabilities.Size(m)
}
func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ClusterCapabilities_MercuryCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ClusterCapabilities_MercuryCapabilities proto.InternalMessageInfo

const Default_ConfigurationProto_ClusterCapabilities_MercuryCapabilities_GrpcServerEnabled bool = false

func (m *ConfigurationProto_ClusterCapabilities_MercuryCapabilities) GetGrpcServerEnabled() bool {
	if m != nil && m.GrpcServerEnabled != nil {
		return *m.GrpcServerEnabled
	}
	return Default_ConfigurationProto_ClusterCapabilities_MercuryCapabilities_GrpcServerEnabled
}

type ConfigurationProto_ClusterCapabilities_CatalogCapabilities struct {
	// Indicates if the cluster supports rate limits on image operations.
	RateLimitSupported   *bool    `protobuf:"varint,1,opt,name=rate_limit_supported,json=rateLimitSupported,def=0" json:"rate_limit_supported,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) Reset() {
	*m = ConfigurationProto_ClusterCapabilities_CatalogCapabilities{}
}
func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigurationProto_ClusterCapabilities_CatalogCapabilities) ProtoMessage() {}
func (*ConfigurationProto_ClusterCapabilities_CatalogCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 44, 1}
}

func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities_CatalogCapabilities.Unmarshal(m, b)
}
func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities_CatalogCapabilities.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ClusterCapabilities_CatalogCapabilities.Merge(m, src)
}
func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ClusterCapabilities_CatalogCapabilities.Size(m)
}
func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ClusterCapabilities_CatalogCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ClusterCapabilities_CatalogCapabilities proto.InternalMessageInfo

const Default_ConfigurationProto_ClusterCapabilities_CatalogCapabilities_RateLimitSupported bool = false

func (m *ConfigurationProto_ClusterCapabilities_CatalogCapabilities) GetRateLimitSupported() bool {
	if m != nil && m.RateLimitSupported != nil {
		return *m.RateLimitSupported
	}
	return Default_ConfigurationProto_ClusterCapabilities_CatalogCapabilities_RateLimitSupported
}

// 'DnsConfig' message would be used to save the relevant configurations
// inside /etc/resolv.conf for the purpose of DNS resolution.
type ConfigurationProto_DnsConfig struct {
	// The list of search suffix strings in /etc/resolv.conf.
	// CMSP would be leveraging them during its deployment on PC.
	// Genesis learns this value and applies locally on each SVM.
	DnsSearchSuffixString []string `protobuf:"bytes,1,rep,name=dns_search_suffix_string,json=dnsSearchSuffixString" json:"dns_search_suffix_string,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ConfigurationProto_DnsConfig) Reset()         { *m = ConfigurationProto_DnsConfig{} }
func (m *ConfigurationProto_DnsConfig) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_DnsConfig) ProtoMessage()    {}
func (*ConfigurationProto_DnsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 45}
}

func (m *ConfigurationProto_DnsConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_DnsConfig.Unmarshal(m, b)
}
func (m *ConfigurationProto_DnsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_DnsConfig.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_DnsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_DnsConfig.Merge(m, src)
}
func (m *ConfigurationProto_DnsConfig) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_DnsConfig.Size(m)
}
func (m *ConfigurationProto_DnsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_DnsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_DnsConfig proto.InternalMessageInfo

func (m *ConfigurationProto_DnsConfig) GetDnsSearchSuffixString() []string {
	if m != nil {
		return m.DnsSearchSuffixString
	}
	return nil
}

// The following fields are used for clusters hibernate and restore
// operations.
type ConfigurationProto_ClusterHibernateState struct {
	HibernateMode        *int32   `protobuf:"varint,1,opt,name=hibernate_mode,json=hibernateMode,def=0" json:"hibernate_mode,omitempty"`
	HibernateTaskStatus  *int32   `protobuf:"varint,2,opt,name=hibernate_task_status,json=hibernateTaskStatus,def=0" json:"hibernate_task_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_ClusterHibernateState) Reset() {
	*m = ConfigurationProto_ClusterHibernateState{}
}
func (m *ConfigurationProto_ClusterHibernateState) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_ClusterHibernateState) ProtoMessage()    {}
func (*ConfigurationProto_ClusterHibernateState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 46}
}

func (m *ConfigurationProto_ClusterHibernateState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_ClusterHibernateState.Unmarshal(m, b)
}
func (m *ConfigurationProto_ClusterHibernateState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_ClusterHibernateState.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_ClusterHibernateState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_ClusterHibernateState.Merge(m, src)
}
func (m *ConfigurationProto_ClusterHibernateState) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_ClusterHibernateState.Size(m)
}
func (m *ConfigurationProto_ClusterHibernateState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_ClusterHibernateState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_ClusterHibernateState proto.InternalMessageInfo

const Default_ConfigurationProto_ClusterHibernateState_HibernateMode int32 = 0
const Default_ConfigurationProto_ClusterHibernateState_HibernateTaskStatus int32 = 0

func (m *ConfigurationProto_ClusterHibernateState) GetHibernateMode() int32 {
	if m != nil && m.HibernateMode != nil {
		return *m.HibernateMode
	}
	return Default_ConfigurationProto_ClusterHibernateState_HibernateMode
}

func (m *ConfigurationProto_ClusterHibernateState) GetHibernateTaskStatus() int32 {
	if m != nil && m.HibernateTaskStatus != nil {
		return *m.HibernateTaskStatus
	}
	return Default_ConfigurationProto_ClusterHibernateState_HibernateTaskStatus
}

// Message describing the state of the recycle bin.
type ConfigurationProto_RecycleBinState struct {
	RecycleBinStatus *int32 `protobuf:"varint,1,opt,name=recycle_bin_status,json=recycleBinStatus,def=0" json:"recycle_bin_status,omitempty"`
	// The unix epoch time at which this state was last updated.
	TimestampSecs        *int64   `protobuf:"varint,3,opt,name=timestamp_secs,json=timestampSecs" json:"timestamp_secs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigurationProto_RecycleBinState) Reset()         { *m = ConfigurationProto_RecycleBinState{} }
func (m *ConfigurationProto_RecycleBinState) String() string { return proto.CompactTextString(m) }
func (*ConfigurationProto_RecycleBinState) ProtoMessage()    {}
func (*ConfigurationProto_RecycleBinState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f1d65eee945286d7, []int{0, 47}
}

func (m *ConfigurationProto_RecycleBinState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigurationProto_RecycleBinState.Unmarshal(m, b)
}
func (m *ConfigurationProto_RecycleBinState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigurationProto_RecycleBinState.Marshal(b, m, deterministic)
}
func (m *ConfigurationProto_RecycleBinState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigurationProto_RecycleBinState.Merge(m, src)
}
func (m *ConfigurationProto_RecycleBinState) XXX_Size() int {
	return xxx_messageInfo_ConfigurationProto_RecycleBinState.Size(m)
}
func (m *ConfigurationProto_RecycleBinState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigurationProto_RecycleBinState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigurationProto_RecycleBinState proto.InternalMessageInfo

const Default_ConfigurationProto_RecycleBinState_RecycleBinStatus int32 = 0

func (m *ConfigurationProto_RecycleBinState) GetRecycleBinStatus() int32 {
	if m != nil && m.RecycleBinStatus != nil {
		return *m.RecycleBinStatus
	}
	return Default_ConfigurationProto_RecycleBinState_RecycleBinStatus
}

func (m *ConfigurationProto_RecycleBinState) GetTimestampSecs() int64 {
	if m != nil && m.TimestampSecs != nil {
		return *m.TimestampSecs
	}
	return 0
}

func init() {
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RowCASUpgradeStatus", ConfigurationProto_RowCASUpgradeStatus_name, ConfigurationProto_RowCASUpgradeStatus_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_StargateVersion", ConfigurationProto_StargateVersion_name, ConfigurationProto_StargateVersion_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ClusterFunctions", ConfigurationProto_ClusterFunctions_name, ConfigurationProto_ClusterFunctions_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_SaltstackSchedule", ConfigurationProto_SaltstackSchedule_name, ConfigurationProto_SaltstackSchedule_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_OperationMode", ConfigurationProto_OperationMode_name, ConfigurationProto_OperationMode_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ClusterArch", ConfigurationProto_ClusterArch_name, ConfigurationProto_ClusterArch_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_KMSType", ConfigurationProto_KMSType_name, ConfigurationProto_KMSType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_MantleVersion", ConfigurationProto_MantleVersion_name, ConfigurationProto_MantleVersion_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_StorageTier_StorageType", ConfigurationProto_StorageTier_StorageType_name, ConfigurationProto_StorageTier_StorageType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Disk_DataMigrationStatus", ConfigurationProto_Disk_DataMigrationStatus_name, ConfigurationProto_Disk_DataMigrationStatus_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_NetworkEntity_ProtocolType", ConfigurationProto_NetworkEntity_ProtocolType_name, ConfigurationProto_NetworkEntity_ProtocolType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_NetworkEntity_ProxyType", ConfigurationProto_NetworkEntity_ProxyType_name, ConfigurationProto_NetworkEntity_ProxyType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_Status", ConfigurationProto_Node_Status_name, ConfigurationProto_Node_Status_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_NodeRemovalAck", ConfigurationProto_Node_NodeRemovalAck_name, ConfigurationProto_Node_NodeRemovalAck_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_CassandraStatus", ConfigurationProto_Node_CassandraStatus_name, ConfigurationProto_Node_CassandraStatus_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_CassandraStateChangeSource", ConfigurationProto_Node_CassandraStateChangeSource_name, ConfigurationProto_Node_CassandraStateChangeSource_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_NodeType", ConfigurationProto_Node_NodeType_name, ConfigurationProto_Node_NodeType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState", ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState_name, ConfigurationProto_Node_AcropolisStatus_AcropolisNodeState_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState", ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState_name, ConfigurationProto_Node_AcropolisStatus_AcropolisConnectionState_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_EncryptionParams_EncryptionScope", ConfigurationProto_EncryptionParams_EncryptionScope_name, ConfigurationProto_EncryptionParams_EncryptionScope_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_EncryptionParams_EncryptionComponents", ConfigurationProto_EncryptionParams_EncryptionComponents_name, ConfigurationProto_EncryptionParams_EncryptionComponents_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ContainerParams_EncryptionType", ConfigurationProto_ContainerParams_EncryptionType_name, ConfigurationProto_ContainerParams_EncryptionType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ContainerParams_CompressionType", ConfigurationProto_ContainerParams_CompressionType_name, ConfigurationProto_ContainerParams_CompressionType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType", ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType_name, ConfigurationProto_ContainerParams_ReaddirPlusResponseAttributesType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType", ConfigurationProto_ManagementServer_HypervisorType_name, ConfigurationProto_ManagementServer_HypervisorType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RemoteSite_CompressionAlgorithm", ConfigurationProto_RemoteSite_CompressionAlgorithm_name, ConfigurationProto_RemoteSite_CompressionAlgorithm_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RemoteSite_RemoteSiteType", ConfigurationProto_RemoteSite_RemoteSiteType_name, ConfigurationProto_RemoteSite_RemoteSiteType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RemoteSite_Capabilities_ClusterProperties", ConfigurationProto_RemoteSite_Capabilities_ClusterProperties_name, ConfigurationProto_RemoteSite_Capabilities_ClusterProperties_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Aegis_SmtpServerType", ConfigurationProto_Aegis_SmtpServerType_name, ConfigurationProto_Aegis_SmtpServerType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Aegis_SupportInformationVerbosityLevel", ConfigurationProto_Aegis_SupportInformationVerbosityLevel_name, ConfigurationProto_Aegis_SupportInformationVerbosityLevel_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel", ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel_name, ConfigurationProto_Aegis_AutoSupportConfig_PIIScrubbingLevel_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType", ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType_name, ConfigurationProto_Aegis_HttpProxyWhitelist_TargetType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RackableUnit_Model", ConfigurationProto_RackableUnit_Model_name, ConfigurationProto_RackableUnit_Model_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_SnmpInfo_Protocol", ConfigurationProto_SnmpInfo_Protocol_name, ConfigurationProto_SnmpInfo_Protocol_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_SnmpInfo_SnmpVersion", ConfigurationProto_SnmpInfo_SnmpVersion_name, ConfigurationProto_SnmpInfo_SnmpVersion_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_SnmpInfo_User_AuthType", ConfigurationProto_SnmpInfo_User_AuthType_name, ConfigurationProto_SnmpInfo_User_AuthType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_SnmpInfo_User_PrivType", ConfigurationProto_SnmpInfo_User_PrivType_name, ConfigurationProto_SnmpInfo_User_PrivType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AuthConfig_AuthSourceType", ConfigurationProto_AuthConfig_AuthSourceType_name, ConfigurationProto_AuthConfig_AuthSourceType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType", ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType_name, ConfigurationProto_AuthConfig_DirectoryConfig_DirectoryType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType", ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType_name, ConfigurationProto_AuthConfig_DirectoryConfig_ConnectionType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType", ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType_name, ConfigurationProto_AuthConfig_DirectoryConfig_GroupSearchType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_SSHKey_SshKeyType", ConfigurationProto_SSHKey_SshKeyType_name, ConfigurationProto_SSHKey_SshKeyType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck", ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck_name, ConfigurationProto_FaultToleranceState_PrepareForDesiredFTAck_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority", ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority_name, ConfigurationProto_RSyslogConfig_LogServerConfig_Module_Priority_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AutoRingFixState_RingFixerSource", ConfigurationProto_AutoRingFixState_RingFixerSource_name, ConfigurationProto_AutoRingFixState_RingFixerSource_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AutoRingFixState_RingFixerOperationState", ConfigurationProto_AutoRingFixState_RingFixerOperationState_name, ConfigurationProto_AutoRingFixState_RingFixerOperationState_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AcropolisHAConfig_AcropolisHAState", ConfigurationProto_AcropolisHAConfig_AcropolisHAState_name, ConfigurationProto_AcropolisHAConfig_AcropolisHAState_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType", ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType_name, ConfigurationProto_AcropolisHAConfig_AcropolisHAReservationType_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_IscsiConfig_ScsiPREndianState", ConfigurationProto_IscsiConfig_ScsiPREndianState_name, ConfigurationProto_IscsiConfig_ScsiPREndianState_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_LWSStoreConfig_State", ConfigurationProto_LWSStoreConfig_State_name, ConfigurationProto_LWSStoreConfig_State_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_WitnessState_ClusterTransitionStatus", ConfigurationProto_WitnessState_ClusterTransitionStatus_name, ConfigurationProto_WitnessState_ClusterTransitionStatus_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason", ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason_name, ConfigurationProto_WitnessState_WitnessStateHistory_TransitionReason_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ExternalRepository_Protocol", ConfigurationProto_ExternalRepository_Protocol_name, ConfigurationProto_ExternalRepository_Protocol_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ExternalRepository_NfsExport_AccessMode", ConfigurationProto_ExternalRepository_NfsExport_AccessMode_name, ConfigurationProto_ExternalRepository_NfsExport_AccessMode_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ClusterHibernateState_HibernateMode", ConfigurationProto_ClusterHibernateState_HibernateMode_name, ConfigurationProto_ClusterHibernateState_HibernateMode_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_ClusterHibernateState_HibernateTaskStatus", ConfigurationProto_ClusterHibernateState_HibernateTaskStatus_name, ConfigurationProto_ClusterHibernateState_HibernateTaskStatus_value)
	proto.RegisterEnum("nutanix.zeus.ConfigurationProto_RecycleBinState_Status", ConfigurationProto_RecycleBinState_Status_name, ConfigurationProto_RecycleBinState_Status_value)
	proto.RegisterType((*ConfigurationProto)(nil), "nutanix.zeus.ConfigurationProto")
	proto.RegisterType((*ConfigurationProto_SymbolicLink)(nil), "nutanix.zeus.ConfigurationProto.SymbolicLink")
	proto.RegisterType((*ConfigurationProto_StorageTier)(nil), "nutanix.zeus.ConfigurationProto.StorageTier")
	proto.RegisterType((*ConfigurationProto_Disk)(nil), "nutanix.zeus.ConfigurationProto.Disk")
	proto.RegisterType((*ConfigurationProto_Disk_SelfEncryptingDrive)(nil), "nutanix.zeus.ConfigurationProto.Disk.SelfEncryptingDrive")
	proto.RegisterType((*ConfigurationProto_Disk_SelfEncryptingDrive_PasswordConfig)(nil), "nutanix.zeus.ConfigurationProto.Disk.SelfEncryptingDrive.PasswordConfig")
	proto.RegisterType((*ConfigurationProto_Disk_BlockStoreDeviceInfo)(nil), "nutanix.zeus.ConfigurationProto.Disk.BlockStoreDeviceInfo")
	proto.RegisterType((*ConfigurationProto_NetworkEntity)(nil), "nutanix.zeus.ConfigurationProto.NetworkEntity")
	proto.RegisterType((*ConfigurationProto_NetworkEntity_ClientOauthToken)(nil), "nutanix.zeus.ConfigurationProto.NetworkEntity.ClientOauthToken")
	proto.RegisterType((*ConfigurationProto_Node)(nil), "nutanix.zeus.ConfigurationProto.Node")
	proto.RegisterType((*ConfigurationProto_Node_CassandraStatusHistory)(nil), "nutanix.zeus.ConfigurationProto.Node.CassandraStatusHistory")
	proto.RegisterType((*ConfigurationProto_Node_AcropolisStatus)(nil), "nutanix.zeus.ConfigurationProto.Node.AcropolisStatus")
	proto.RegisterType((*ConfigurationProto_Node_DigitalCertificateMap)(nil), "nutanix.zeus.ConfigurationProto.Node.DigitalCertificateMap")
	proto.RegisterType((*ConfigurationProto_Node_CvmResourceState)(nil), "nutanix.zeus.ConfigurationProto.Node.CvmResourceState")
	proto.RegisterType((*ConfigurationProto_Node_FoundationInfo)(nil), "nutanix.zeus.ConfigurationProto.Node.FoundationInfo")
	proto.RegisterType((*ConfigurationProto_Node_PlannedOutage)(nil), "nutanix.zeus.ConfigurationProto.Node.PlannedOutage")
	proto.RegisterType((*ConfigurationProto_StoragePool)(nil), "nutanix.zeus.ConfigurationProto.StoragePool")
	proto.RegisterType((*ConfigurationProto_EncryptionParams)(nil), "nutanix.zeus.ConfigurationProto.EncryptionParams")
	proto.RegisterType((*ConfigurationProto_ContainerParams)(nil), "nutanix.zeus.ConfigurationProto.ContainerParams")
	proto.RegisterType((*ConfigurationProto_Container)(nil), "nutanix.zeus.ConfigurationProto.Container")
	proto.RegisterType((*ConfigurationProto_ManagementServer)(nil), "nutanix.zeus.ConfigurationProto.ManagementServer")
	proto.RegisterType((*ConfigurationProto_VZone)(nil), "nutanix.zeus.ConfigurationProto.VZone")
	proto.RegisterType((*ConfigurationProto_RemoteSite)(nil), "nutanix.zeus.ConfigurationProto.RemoteSite")
	proto.RegisterType((*ConfigurationProto_RemoteSite_MaxVirtualHardwareVersion)(nil), "nutanix.zeus.ConfigurationProto.RemoteSite.MaxVirtualHardwareVersion")
	proto.RegisterType((*ConfigurationProto_RemoteSite_Capabilities)(nil), "nutanix.zeus.ConfigurationProto.RemoteSite.Capabilities")
	proto.RegisterType((*ConfigurationProto_RemoteSite_FileServerCapabilities)(nil), "nutanix.zeus.ConfigurationProto.RemoteSite.FileServerCapabilities")
	proto.RegisterType((*ConfigurationProto_RemoteSite_ContainerInfo)(nil), "nutanix.zeus.ConfigurationProto.RemoteSite.ContainerInfo")
	proto.RegisterType((*ConfigurationProto_RemoteSite_NodeInfo)(nil), "nutanix.zeus.ConfigurationProto.RemoteSite.NodeInfo")
	proto.RegisterType((*ConfigurationProto_Aegis)(nil), "nutanix.zeus.ConfigurationProto.Aegis")
	proto.RegisterType((*ConfigurationProto_Aegis_TimedBool)(nil), "nutanix.zeus.ConfigurationProto.Aegis.TimedBool")
	proto.RegisterType((*ConfigurationProto_Aegis_NccConfig)(nil), "nutanix.zeus.ConfigurationProto.Aegis.NccConfig")
	proto.RegisterType((*ConfigurationProto_Aegis_AutoSupportConfig)(nil), "nutanix.zeus.ConfigurationProto.Aegis.AutoSupportConfig")
	proto.RegisterType((*ConfigurationProto_Aegis_HttpProxyWhitelist)(nil), "nutanix.zeus.ConfigurationProto.Aegis.HttpProxyWhitelist")
	proto.RegisterType((*ConfigurationProto_RackableUnit)(nil), "nutanix.zeus.ConfigurationProto.RackableUnit")
	proto.RegisterType((*ConfigurationProto_DynamicRingChangeProgress)(nil), "nutanix.zeus.ConfigurationProto.DynamicRingChangeProgress")
	proto.RegisterType((*ConfigurationProto_DynamicRingChangeInfo)(nil), "nutanix.zeus.ConfigurationProto.DynamicRingChangeInfo")
	proto.RegisterType((*ConfigurationProto_SnmpInfo)(nil), "nutanix.zeus.ConfigurationProto.SnmpInfo")
	proto.RegisterType((*ConfigurationProto_SnmpInfo_User)(nil), "nutanix.zeus.ConfigurationProto.SnmpInfo.User")
	proto.RegisterType((*ConfigurationProto_SnmpInfo_Transport)(nil), "nutanix.zeus.ConfigurationProto.SnmpInfo.Transport")
	proto.RegisterType((*ConfigurationProto_SnmpInfo_TrapSink)(nil), "nutanix.zeus.ConfigurationProto.SnmpInfo.TrapSink")
	proto.RegisterType((*ConfigurationProto_AuthConfig)(nil), "nutanix.zeus.ConfigurationProto.AuthConfig")
	proto.RegisterType((*ConfigurationProto_AuthConfig_DirectoryConfig)(nil), "nutanix.zeus.ConfigurationProto.AuthConfig.DirectoryConfig")
	proto.RegisterType((*ConfigurationProto_AuthConfig_DirectoryConfig_ServiceAccount)(nil), "nutanix.zeus.ConfigurationProto.AuthConfig.DirectoryConfig.ServiceAccount")
	proto.RegisterType((*ConfigurationProto_AuthConfig_DirectoryConfig_OpenLdapConfig)(nil), "nutanix.zeus.ConfigurationProto.AuthConfig.DirectoryConfig.OpenLdapConfig")
	proto.RegisterType((*ConfigurationProto_VStore)(nil), "nutanix.zeus.ConfigurationProto.VStore")
	proto.RegisterType((*ConfigurationProto_VirtualStorageTier)(nil), "nutanix.zeus.ConfigurationProto.VirtualStorageTier")
	proto.RegisterType((*ConfigurationProto_SSHKey)(nil), "nutanix.zeus.ConfigurationProto.SSHKey")
	proto.RegisterType((*ConfigurationProto_FaultToleranceState)(nil), "nutanix.zeus.ConfigurationProto.FaultToleranceState")
	proto.RegisterType((*ConfigurationProto_RSyslogConfig)(nil), "nutanix.zeus.ConfigurationProto.RSyslogConfig")
	proto.RegisterType((*ConfigurationProto_RSyslogConfig_LogServerConfig)(nil), "nutanix.zeus.ConfigurationProto.RSyslogConfig.LogServerConfig")
	proto.RegisterType((*ConfigurationProto_RSyslogConfig_LogServerConfig_Module)(nil), "nutanix.zeus.ConfigurationProto.RSyslogConfig.LogServerConfig.Module")
	proto.RegisterType((*ConfigurationProto_KeyManagementServer)(nil), "nutanix.zeus.ConfigurationProto.KeyManagementServer")
	proto.RegisterType((*ConfigurationProto_CertificateAuthority)(nil), "nutanix.zeus.ConfigurationProto.CertificateAuthority")
	proto.RegisterType((*ConfigurationProto_CertificationSigningInfo)(nil), "nutanix.zeus.ConfigurationProto.CertificationSigningInfo")
	proto.RegisterType((*ConfigurationProto_AutoRingFixState)(nil), "nutanix.zeus.ConfigurationProto.AutoRingFixState")
	proto.RegisterType((*ConfigurationProto_AutoRingFixState_SvmAndToken)(nil), "nutanix.zeus.ConfigurationProto.AutoRingFixState.SvmAndToken")
	proto.RegisterType((*ConfigurationProto_BlockIscsiTargetIPs)(nil), "nutanix.zeus.ConfigurationProto.BlockIscsiTargetIPs")
	proto.RegisterType((*ConfigurationProto_CuratorScanInfo)(nil), "nutanix.zeus.ConfigurationProto.CuratorScanInfo")
	proto.RegisterType((*ConfigurationProto_AcropolisHAConfig)(nil), "nutanix.zeus.ConfigurationProto.AcropolisHAConfig")
	proto.RegisterType((*ConfigurationProto_ClickstreamConfig)(nil), "nutanix.zeus.ConfigurationProto.ClickstreamConfig")
	proto.RegisterType((*ConfigurationProto_SecurityComplianceConfig)(nil), "nutanix.zeus.ConfigurationProto.SecurityComplianceConfig")
	proto.RegisterType((*ConfigurationProto_HypervisorSecurityComplianceConfig)(nil), "nutanix.zeus.ConfigurationProto.HypervisorSecurityComplianceConfig")
	proto.RegisterType((*ConfigurationProto_NetworkConfig)(nil), "nutanix.zeus.ConfigurationProto.NetworkConfig")
	proto.RegisterType((*ConfigurationProto_NetworkConfig_HostPhysicalEntity)(nil), "nutanix.zeus.ConfigurationProto.NetworkConfig.HostPhysicalEntity")
	proto.RegisterType((*ConfigurationProto_IscsiConfig)(nil), "nutanix.zeus.ConfigurationProto.IscsiConfig")
	proto.RegisterType((*ConfigurationProto_CuratorStargateProtocolConfig)(nil), "nutanix.zeus.ConfigurationProto.CuratorStargateProtocolConfig")
	proto.RegisterType((*ConfigurationProto_AdsConfig)(nil), "nutanix.zeus.ConfigurationProto.AdsConfig")
	proto.RegisterType((*ConfigurationProto_LWSStoreConfig)(nil), "nutanix.zeus.ConfigurationProto.LWSStoreConfig")
	proto.RegisterType((*ConfigurationProto_WitnessState)(nil), "nutanix.zeus.ConfigurationProto.WitnessState")
	proto.RegisterType((*ConfigurationProto_WitnessState_WitnessStateHistory)(nil), "nutanix.zeus.ConfigurationProto.WitnessState.WitnessStateHistory")
	proto.RegisterType((*ConfigurationProto_Rack)(nil), "nutanix.zeus.ConfigurationProto.Rack")
	proto.RegisterType((*ConfigurationProto_ClusterConversionStatus)(nil), "nutanix.zeus.ConfigurationProto.ClusterConversionStatus")
	proto.RegisterType((*ConfigurationProto_MemoryReservationsPerComponent)(nil), "nutanix.zeus.ConfigurationProto.MemoryReservationsPerComponent")
	proto.RegisterType((*ConfigurationProto_HypervisorLldpConfig)(nil), "nutanix.zeus.ConfigurationProto.HypervisorLldpConfig")
	proto.RegisterType((*ConfigurationProto_ExternalRepository)(nil), "nutanix.zeus.ConfigurationProto.ExternalRepository")
	proto.RegisterType((*ConfigurationProto_ExternalRepository_NfsExport)(nil), "nutanix.zeus.ConfigurationProto.ExternalRepository.NfsExport")
	proto.RegisterType((*ConfigurationProto_ClusterCapabilities)(nil), "nutanix.zeus.ConfigurationProto.ClusterCapabilities")
	proto.RegisterType((*ConfigurationProto_ClusterCapabilities_MercuryCapabilities)(nil), "nutanix.zeus.ConfigurationProto.ClusterCapabilities.MercuryCapabilities")
	proto.RegisterType((*ConfigurationProto_ClusterCapabilities_CatalogCapabilities)(nil), "nutanix.zeus.ConfigurationProto.ClusterCapabilities.CatalogCapabilities")
	proto.RegisterType((*ConfigurationProto_DnsConfig)(nil), "nutanix.zeus.ConfigurationProto.DnsConfig")
	proto.RegisterType((*ConfigurationProto_ClusterHibernateState)(nil), "nutanix.zeus.ConfigurationProto.ClusterHibernateState")
	proto.RegisterType((*ConfigurationProto_RecycleBinState)(nil), "nutanix.zeus.ConfigurationProto.RecycleBinState")
}

func init() { proto.RegisterFile("zeus/configuration.proto", fileDescriptor_f1d65eee945286d7) }

var fileDescriptor_f1d65eee945286d7 = []byte{
	// 18916 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xfd, 0x69, 0x8c, 0x64, 0xc9,
	0x76, 0x18, 0x06, 0x4f, 0x66, 0xd6, 0x7a, 0xaa, 0x2a, 0xeb, 0x56, 0xd4, 0xd2, 0x59, 0xd9, 0x5b,
	0x75, 0xf6, 0xcc, 0x74, 0xcd, 0x56, 0x5d, 0xbd, 0xf7, 0xf4, 0xdb, 0x26, 0x6b, 0x9b, 0xae, 0xd7,
	0xb5, 0xcd, 0xcd, 0xea, 0xee, 0xf7, 0x86, 0x7c, 0xef, 0xf2, 0xd6, 0xbd, 0x91, 0x95, 0x97, 0x79,
	0xb7, 0xb9, 0x71, 0xb3, 0xaa, 0x72, 0x48, 0x89, 0x43, 0x8a, 0xa2, 0x96, 0x4f, 0xe2, 0x7b, 0xe4,
	0x47, 0xd0, 0x8b, 0x2c, 0xd3, 0x20, 0x64, 0x18, 0x20, 0x6c, 0x6d, 0x14, 0x0c, 0x59, 0x02, 0x68,
	0x51, 0x92, 0x0d, 0xc3, 0x16, 0x0c, 0xc3, 0x16, 0xbc, 0x08, 0x82, 0xb7, 0x1f, 0x04, 0x2d, 0xf8,
	0x87, 0x25, 0x0b, 0x36, 0x4c, 0xd8, 0xa2, 0x11, 0x27, 0x22, 0xee, 0x92, 0x99, 0x35, 0x5d, 0x3d,
	0x43, 0xfd, 0xf3, 0x03, 0xe6, 0x75, 0x65, 0xc4, 0x39, 0x27, 0xe2, 0x46, 0x9c, 0x38, 0x71, 0xce,
	0x89, 0x13, 0x27, 0xa0, 0xf2, 0x39, 0xed, 0xb0, 0xdb, 0x56, 0xe0, 0x37, 0x9d, 0xe3, 0x4e, 0x64,
	0xc6, 0x4e, 0xe0, 0xaf, 0x84, 0x51, 0x10, 0x07, 0x64, 0xd2, 0xef, 0xc4, 0xa6, 0xef, 0x9c, 0xad,
	0x70, 0x88, 0xea, 0x6c, 0xe8, 0xc4, 0xad, 0x80, 0xdd, 0x16, 0xff, 0x08, 0x90, 0xea, 0x6a, 0x27,
	0x76, 0xdc, 0xdb, 0xcc, 0x35, 0x8e, 0x3a, 0x4d, 0x76, 0xfb, 0xc8, 0x64, 0xf4, 0xb6, 0x6d, 0xc6,
	0xa6, 0x11, 0x47, 0xa6, 0xcf, 0x9a, 0x41, 0xe4, 0x21, 0x3d, 0x23, 0xee, 0x86, 0x54, 0x62, 0x54,
	0x73, 0x18, 0x9f, 0x05, 0xf8, 0x9f, 0xac, 0xbb, 0x82, 0x5d, 0x31, 0x4f, 0x4c, 0xc7, 0x35, 0x8f,
	0x1c, 0xd7, 0x89, 0xbb, 0xc6, 0xe7, 0x81, 0xaf, 0x30, 0x2f, 0x8b, 0x8e, 0xba, 0x41, 0xc7, 0x36,
	0x58, 0x1c, 0x44, 0xd4, 0x70, 0xfc, 0x66, 0x20, 0x2b, 0x6f, 0x61, 0xa5, 0x1d, 0x78, 0xa6, 0xe3,
	0x1b, 0x4d, 0xb3, 0xe3, 0xc6, 0x46, 0x1c, 0xb8, 0x34, 0x32, 0x7d, 0x8b, 0x1a, 0x2c, 0x36, 0x63,
	0x45, 0xa5, 0x8c, 0x80, 0x6e, 0x60, 0xe5, 0xda, 0x0c, 0x69, 0xe4, 0x04, 0xb6, 0x63, 0x19, 0xcc,
	0x6a, 0x51, 0xbb, 0xe3, 0x4a, 0xe8, 0xda, 0x5f, 0xf8, 0x8d, 0x12, 0x90, 0xf5, 0xec, 0xd8, 0x1c,
	0xe0, 0xd0, 0x34, 0x60, 0x8a, 0x75, 0xbd, 0xa3, 0xc0, 0x75, 0x2c, 0xc3, 0x75, 0xfc, 0x76, 0xe5,
	0xf7, 0x47, 0x97, 0x0a, 0xcb, 0x13, 0x77, 0x3f, 0x58, 0xc9, 0x8e, 0xd9, 0x4a, 0x3f, 0xe6, 0x4a,
	0x43, 0xa2, 0xed, 0x38, 0x7e, 0x5b, 0x9f, 0x64, 0x99, 0x5f, 0xe4, 0x3d, 0x98, 0x71, 0x83, 0x63,
	0xc7, 0x32, 0x5d, 0x23, 0x76, 0x3c, 0xca, 0x62, 0xd3, 0x0b, 0x2b, 0x85, 0xa5, 0xe2, 0x72, 0x49,
	0xd7, 0x64, 0xc5, 0xa1, 0x2a, 0x27, 0x6b, 0x30, 0xed, 0xf8, 0x31, 0x8d, 0x7c, 0xd3, 0x35, 0x58,
	0xe7, 0xc8, 0xa7, 0x71, 0xa5, 0xb8, 0x54, 0x58, 0x1e, 0x7f, 0xb2, 0x78, 0xe7, 0xc3, 0xbb, 0x2b,
	0x77, 0x1e, 0x3e, 0x5e, 0x79, 0xb0, 0xb2, 0x7a, 0xfb, 0xee, 0x83, 0x07, 0x2b, 0xea, 0xbf, 0x55,
	0xbd, 0xac, 0x30, 0x1a, 0x88, 0x40, 0xbe, 0x03, 0xd3, 0xf4, 0x2c, 0x4f, 0xa3, 0x84, 0x34, 0x16,
	0xee, 0x3c, 0xe2, 0x34, 0x56, 0x56, 0x15, 0x89, 0xfb, 0xab, 0xfc, 0x6f, 0xbd, 0xac, 0xc0, 0x25,
	0x81, 0xef, 0xc1, 0x0c, 0x9f, 0x09, 0xf3, 0x98, 0x1a, 0xb1, 0x43, 0x23, 0xc3, 0x75, 0x58, 0x5c,
	0x19, 0x5a, 0x2a, 0x2d, 0x4f, 0xdc, 0x7d, 0xff, 0xd5, 0x23, 0x21, 0x30, 0x0f, 0x1d, 0x1a, 0xe9,
	0xd3, 0x2c, 0xfd, 0xb1, 0xe3, 0xb0, 0x98, 0x6c, 0x42, 0xf9, 0xb3, 0x80, 0x19, 0x61, 0xe4, 0xf8,
	0x96, 0x13, 0x9a, 0x2e, 0xab, 0x0c, 0x23, 0xd9, 0x6b, 0x09, 0x59, 0xce, 0x36, 0x9f, 0x04, 0xec,
	0x40, 0x41, 0x20, 0x51, 0x7d, 0xea, 0xb3, 0x4c, 0x11, 0x23, 0xdf, 0x82, 0xcb, 0x9c, 0x8c, 0x65,
	0xc6, 0x56, 0xcb, 0x74, 0xdd, 0x94, 0x9e, 0xe1, 0x9b, 0x1e, 0xad, 0x8c, 0xf0, 0xaf, 0xd5, 0x2b,
	0x9f, 0x05, 0x6c, 0x5d, 0x42, 0x24, 0xb8, 0x7b, 0xa6, 0x47, 0xc9, 0x87, 0xb0, 0xc8, 0xd1, 0x59,
	0x97, 0xc5, 0xd4, 0xeb, 0x45, 0x1e, 0x45, 0xe4, 0x85, 0xcf, 0x02, 0xd6, 0xc0, 0xfa, 0x3c, 0xea,
	0x1a, 0x8c, 0xdb, 0x0e, 0x6b, 0x8b, 0x21, 0x19, 0xc3, 0xbe, 0xbf, 0xf5, 0xca, 0x21, 0xd9, 0x70,
	0x58, 0x5b, 0x1f, 0xe3, 0x78, 0x38, 0x08, 0x6b, 0x30, 0xee, 0x07, 0x36, 0x15, 0x34, 0xc6, 0x2f,
	0x48, 0x63, 0x2f, 0xb0, 0xa9, 0x3e, 0xc6, 0xf1, 0x90, 0x46, 0x66, 0x8a, 0xc2, 0x20, 0x70, 0x05,
	0x2d, 0x78, 0xbd, 0x29, 0x3a, 0x08, 0x02, 0x37, 0x99, 0x22, 0xfe, 0x03, 0x29, 0x7f, 0x02, 0x65,
	0x2b, 0xf0, 0x63, 0xd3, 0xf1, 0xd5, 0xcc, 0x4f, 0x20, 0xd9, 0x77, 0x5f, 0x49, 0x76, 0x5d, 0xa1,
	0xe9, 0x53, 0x09, 0x05, 0x24, 0xb9, 0x0f, 0xf3, 0x36, 0x0d, 0x23, 0x6a, 0x99, 0x31, 0xb5, 0x8d,
	0x93, 0x74, 0x00, 0x27, 0x91, 0xf2, 0xe5, 0x84, 0xb2, 0x14, 0x42, 0x2f, 0xf8, 0x80, 0x89, 0x06,
	0xf4, 0xd9, 0x14, 0xf3, 0x45, 0x32, 0x82, 0xc7, 0xb0, 0xe0, 0x99, 0xbe, 0x79, 0x4c, 0x3d, 0xea,
	0xc7, 0x06, 0xa3, 0xd1, 0x89, 0xea, 0xeb, 0x14, 0x52, 0xbc, 0xf3, 0xca, 0xbe, 0xee, 0x26, 0xe8,
	0x0d, 0xc4, 0xd6, 0xe7, 0xbc, 0x9e, 0x12, 0xc9, 0xaf, 0x70, 0xc2, 0x65, 0x95, 0x20, 0x5e, 0x46,
	0xe2, 0x6f, 0xbf, 0x92, 0xf8, 0x8b, 0x4f, 0x03, 0x9f, 0xea, 0xe3, 0x88, 0x89, 0x64, 0x9e, 0x83,
	0x16, 0x51, 0x2f, 0x88, 0xa9, 0xc1, 0x9c, 0x58, 0x12, 0x9b, 0x46, 0x62, 0xef, 0xbd, 0x92, 0x98,
	0x8e, 0x88, 0x0d, 0x27, 0xa6, 0x7a, 0x39, 0x4a, 0xfe, 0x46, 0xb2, 0xf7, 0x61, 0xc1, 0x72, 0x3b,
	0x2c, 0xa6, 0x91, 0xe1, 0xf8, 0x96, 0x19, 0xf9, 0x42, 0x2c, 0x3b, 0x76, 0x45, 0x5b, 0x2a, 0x2c,
	0x97, 0xf4, 0x39, 0x59, 0xbb, 0x9d, 0x56, 0x6e, 0xdb, 0xe4, 0x2a, 0x40, 0x82, 0x65, 0x57, 0x08,
	0x42, 0x8e, 0x2b, 0x48, 0x9b, 0xbc, 0x0b, 0x93, 0xaa, 0x1a, 0xd7, 0xc3, 0x2c, 0x8a, 0x8e, 0xd1,
	0xe7, 0x3e, 0xff, 0x65, 0xeb, 0x13, 0xb2, 0x12, 0x57, 0xc3, 0x2a, 0xcc, 0xf9, 0x4d, 0x26, 0x85,
	0x8c, 0x71, 0xda, 0x72, 0x62, 0x8a, 0xdf, 0x36, 0x87, 0x6b, 0x88, 0xf8, 0x4d, 0x26, 0x24, 0xca,
	0x4b, 0x55, 0x43, 0xbe, 0x09, 0xc3, 0x26, 0x3d, 0x76, 0x58, 0x65, 0x11, 0x05, 0xeb, 0xab, 0xc7,
	0xb2, 0xce, 0xa1, 0x75, 0x81, 0x44, 0x6e, 0xc3, 0x5c, 0xca, 0x3d, 0x86, 0xe3, 0x1b, 0x82, 0x61,
	0x2a, 0xd5, 0xa5, 0xc2, 0xf2, 0x98, 0x3e, 0x73, 0xa2, 0x18, 0x64, 0xdb, 0x3f, 0xc0, 0x0a, 0xf2,
	0x3e, 0x10, 0x9b, 0x8a, 0x7d, 0xe3, 0xd8, 0x8c, 0xe9, 0xa9, 0xd9, 0x35, 0x9c, 0xb0, 0x72, 0x19,
	0xbb, 0xa7, 0xc9, 0x9a, 0x8f, 0x45, 0xc5, 0x76, 0x48, 0xde, 0x86, 0x69, 0x3f, 0x0e, 0x73, 0xfc,
	0x74, 0x65, 0xa9, 0xb4, 0x3c, 0xae, 0x4f, 0xf9, 0x71, 0x98, 0xe1, 0x8a, 0x0f, 0x60, 0x96, 0x0f,
	0x86, 0x02, 0x74, 0x42, 0x01, 0x7b, 0x15, 0x61, 0x35, 0x5e, 0x25, 0x80, 0xb7, 0x43, 0x04, 0xff,
	0x09, 0x20, 0x91, 0x69, 0xb5, 0xcd, 0x23, 0x97, 0x1a, 0x1d, 0xdf, 0x89, 0x05, 0xf4, 0x35, 0x9c,
	0xff, 0x57, 0xef, 0x2c, 0xba, 0x44, 0x7d, 0xee, 0x3b, 0xb1, 0xae, 0x45, 0x99, 0x5f, 0x72, 0x29,
	0xcc, 0xd9, 0x5d, 0xdf, 0x88, 0x1c, 0xff, 0xd8, 0xb0, 0x5a, 0xa6, 0x7f, 0x2c, 0xf6, 0xcf, 0xca,
	0x75, 0x1c, 0xdf, 0x87, 0xaf, 0x96, 0x4d, 0x5d, 0xdf, 0xf4, 0x1c, 0x4b, 0x77, 0xfc, 0xe3, 0x75,
	0x44, 0xdf, 0xf6, 0x9b, 0x81, 0x3e, 0x63, 0x77, 0xfd, 0x7c, 0x11, 0xd9, 0x82, 0x71, 0xe6, 0x7b,
	0xa1, 0xa0, 0xbe, 0x84, 0xd4, 0xdf, 0x79, 0xb5, 0xa4, 0xf1, 0xbd, 0x10, 0x09, 0x8e, 0x31, 0xf9,
	0x17, 0x09, 0x61, 0x21, 0x0a, 0x4e, 0x0d, 0xcb, 0x64, 0x46, 0x27, 0x3c, 0x8e, 0x4c, 0x5b, 0x6c,
	0xe4, 0x1d, 0x56, 0xb9, 0xb1, 0x54, 0x58, 0x2e, 0xdf, 0xbd, 0xff, 0xea, 0x11, 0x09, 0x4e, 0xd7,
	0xeb, 0x8d, 0xe7, 0x02, 0xb9, 0x81, 0xb8, 0x4f, 0x86, 0xdb, 0x7b, 0x7c, 0xcd, 0xcd, 0x46, 0xc1,
	0xe9, 0xba, 0xc9, 0x72, 0x75, 0x5c, 0xdc, 0xf7, 0xb6, 0x98, 0x6e, 0xc4, 0x35, 0xe4, 0xff, 0x85,
	0x1c, 0x5e, 0xba, 0x1d, 0x3f, 0x86, 0x8a, 0x65, 0x32, 0x66, 0xfa, 0x76, 0x64, 0xa2, 0x12, 0xe1,
	0x99, 0xc6, 0x09, 0x8d, 0x98, 0x13, 0xf8, 0x95, 0x9b, 0x62, 0xa3, 0x48, 0xea, 0x1b, 0x58, 0xfd,
	0x42, 0xd4, 0x92, 0x1d, 0x98, 0x30, 0x3b, 0x71, 0xcb, 0x10, 0x1a, 0x58, 0xe5, 0x4d, 0x1c, 0xb0,
	0x57, 0xaf, 0xf6, 0x7a, 0x27, 0x6e, 0x49, 0xc9, 0x07, 0x66, 0xf2, 0x37, 0x79, 0x0a, 0x13, 0x27,
	0x42, 0x39, 0x42, 0xde, 0x79, 0x0b, 0x79, 0xe7, 0xd6, 0xab, 0x05, 0x11, 0x97, 0xf4, 0x54, 0x07,
	0x81, 0x8b, 0xfc, 0xe2, 0xc3, 0xe2, 0x89, 0x13, 0xc5, 0x1d, 0xae, 0x1b, 0xf4, 0xed, 0xf1, 0x6f,
	0x23, 0xdd, 0x7b, 0xaf, 0xa6, 0x2b, 0x28, 0x64, 0xb7, 0xfa, 0x85, 0x93, 0xbe, 0x32, 0x6c, 0xef,
	0x01, 0xcc, 0xca, 0x9e, 0xab, 0xb1, 0xb7, 0x03, 0x9f, 0x56, 0x6e, 0xf1, 0x15, 0xfb, 0x64, 0xb8,
	0x69, 0xba, 0x8c, 0xea, 0x33, 0x02, 0x42, 0x8e, 0xfe, 0x46, 0xe0, 0x53, 0x72, 0x0b, 0xa6, 0x23,
	0xea, 0x52, 0x93, 0xd1, 0x64, 0xbc, 0x97, 0x71, 0xbc, 0xcb, 0xb2, 0x58, 0x8d, 0xf3, 0x36, 0x4c,
	0x32, 0xd6, 0x32, 0xda, 0xb4, 0x2b, 0x3e, 0xe1, 0x9d, 0x0b, 0x0e, 0x4d, 0xa3, 0xf1, 0xf4, 0x19,
	0xed, 0xea, 0xc0, 0x58, 0xeb, 0x19, 0xed, 0x4a, 0x29, 0xfd, 0x96, 0x92, 0x7c, 0x7c, 0xff, 0xe2,
	0x5b, 0x8b, 0x65, 0x5a, 0x2d, 0x6a, 0x34, 0x1d, 0xff, 0x98, 0x46, 0x5c, 0x4f, 0x88, 0x8d, 0xd0,
	0x8a, 0x2b, 0xef, 0x2e, 0x15, 0x96, 0x87, 0x9f, 0x94, 0xee, 0xac, 0xae, 0xea, 0x37, 0x24, 0xc6,
	0xba, 0x40, 0x58, 0xe7, 0xf0, 0x5b, 0x29, 0xf8, 0x81, 0xc5, 0x47, 0x60, 0xc1, 0x76, 0x18, 0xae,
	0xfe, 0x0c, 0x21, 0xc7, 0x3f, 0xae, 0xbc, 0x87, 0x62, 0x6b, 0x5e, 0xd6, 0x6e, 0xe5, 0x2a, 0xc9,
	0x0a, 0xcc, 0xa2, 0xa8, 0x8b, 0x03, 0xef, 0x88, 0xc5, 0xc9, 0x1e, 0xf4, 0x3e, 0x0a, 0x99, 0x19,
	0x5e, 0x75, 0xa8, 0x6a, 0xb0, 0xf7, 0x2b, 0x30, 0xab, 0x7a, 0x9f, 0x68, 0x7f, 0x4e, 0x58, 0xf9,
	0x00, 0x47, 0x6d, 0x46, 0x56, 0x6d, 0xca, 0x9a, 0xed, 0x90, 0x9c, 0xc2, 0x55, 0x05, 0x3f, 0x50,
	0xb1, 0xae, 0xac, 0x20, 0xcb, 0xbe, 0x7a, 0x39, 0x6e, 0x71, 0xec, 0x43, 0x85, 0xcc, 0xd7, 0x1c,
	0xd5, 0xab, 0x92, 0xf4, 0x80, 0x3a, 0xd2, 0x82, 0x2b, 0x5f, 0xa6, 0xd0, 0x57, 0x6e, 0x63, 0xbb,
	0x3d, 0x33, 0xb8, 0x81, 0x18, 0x83, 0x9a, 0x5a, 0xb4, 0xcf, 0xab, 0x22, 0xcf, 0xa1, 0x1c, 0xb1,
	0x2e, 0x73, 0x83, 0x63, 0xb5, 0x0c, 0x57, 0x91, 0xf6, 0xca, 0xab, 0x45, 0x4c, 0x03, 0xd1, 0xe4,
	0x4a, 0x9c, 0x92, 0x54, 0xe4, 0x62, 0x7c, 0x0c, 0xf3, 0xac, 0x65, 0xda, 0x5c, 0xa4, 0xb8, 0x81,
	0x4f, 0x99, 0x41, 0x7d, 0x3e, 0x7f, 0x76, 0xe5, 0x0e, 0x32, 0xf5, 0x50, 0x1c, 0x75, 0xa8, 0x3e,
	0x2b, 0x40, 0xd6, 0x11, 0x62, 0x53, 0x00, 0x90, 0x8f, 0xe1, 0x6a, 0x68, 0x32, 0x76, 0x1a, 0x44,
	0xb6, 0x21, 0x15, 0x02, 0x6e, 0x01, 0xf8, 0x09, 0x85, 0xbb, 0x19, 0x0a, 0x55, 0x05, 0x2a, 0x34,
	0x80, 0x1d, 0x0e, 0xa8, 0x08, 0xed, 0xc2, 0x4d, 0x8f, 0xc6, 0x26, 0x1a, 0x65, 0xcc, 0x37, 0x43,
	0xd6, 0x0a, 0x62, 0xa3, 0xdf, 0xca, 0xb8, 0x87, 0xc2, 0x6d, 0x49, 0x81, 0x36, 0x24, 0xe4, 0x4e,
	0xaf, 0xd5, 0xb1, 0x02, 0x1a, 0x8b, 0xcd, 0x88, 0x6f, 0x91, 0xc9, 0x72, 0xbb, 0x2f, 0x99, 0xfc,
	0xce, 0x2a, 0xd7, 0x11, 0x45, 0xa5, 0x5a, 0x74, 0x2b, 0x30, 0x93, 0xf0, 0x4e, 0xc7, 0xb7, 0xf8,
	0xb8, 0xb1, 0xca, 0x83, 0xa5, 0xc2, 0xf2, 0xe8, 0x93, 0xc2, 0x1d, 0x5d, 0x53, 0x93, 0xaf, 0xaa,
	0xc8, 0x8d, 0x54, 0xa7, 0xe8, 0x74, 0x1c, 0xbb, 0xf2, 0x10, 0x99, 0x52, 0xa9, 0x12, 0xcf, 0x3b,
	0x8e, 0x4d, 0xbe, 0x09, 0xd5, 0xbe, 0x2f, 0x4a, 0x47, 0xf6, 0x11, 0xae, 0x94, 0x4a, 0xef, 0x87,
	0x24, 0x03, 0x5b, 0x85, 0x31, 0xfe, 0xd5, 0x5c, 0xe1, 0xaa, 0x3c, 0x46, 0xe2, 0xc9, 0x6f, 0x72,
	0x07, 0xd4, 0x0a, 0x33, 0x02, 0xdf, 0xc0, 0x35, 0x65, 0x53, 0xbb, 0x13, 0x56, 0x3e, 0x44, 0xa2,
	0x44, 0x56, 0xee, 0xfb, 0x5c, 0xeb, 0xdc, 0xe0, 0x35, 0xe4, 0x33, 0xa8, 0x72, 0x81, 0x72, 0x8e,
	0x8e, 0xf9, 0x04, 0x45, 0xcc, 0xab, 0x17, 0xc6, 0x33, 0xda, 0xed, 0x53, 0x33, 0x2f, 0xb5, 0xfb,
	0x0b, 0x71, 0xf9, 0xfe, 0x42, 0x01, 0x6a, 0x71, 0xc4, 0xc7, 0xc3, 0x36, 0x2c, 0x1a, 0xc5, 0x4e,
	0xd3, 0xe1, 0x4a, 0xaf, 0xc1, 0x37, 0x81, 0x20, 0xe2, 0x36, 0x33, 0xb6, 0xfd, 0x0d, 0x6c, 0xfb,
	0xc1, 0xab, 0x75, 0xf1, 0x94, 0x44, 0x5d, 0x51, 0xd0, 0xaf, 0xcb, 0x06, 0x06, 0x55, 0x62, 0x27,
	0xbe, 0x03, 0x57, 0xb8, 0xec, 0xf0, 0x6d, 0x6a, 0x1b, 0x5c, 0xb1, 0x6b, 0xb6, 0x4c, 0xdf, 0x76,
	0x69, 0x32, 0x0d, 0xdf, 0xc4, 0x11, 0x5b, 0x54, 0x30, 0x7b, 0x4d, 0xb6, 0x25, 0x20, 0xd4, 0x3c,
	0xac, 0xc3, 0xb4, 0xb4, 0xe4, 0xb9, 0x9e, 0x8b, 0xaa, 0xc2, 0xb7, 0x70, 0xc9, 0x5d, 0xee, 0xe9,
	0x31, 0x07, 0xe2, 0x7a, 0x2c, 0x2a, 0x07, 0x53, 0x56, 0xf6, 0x27, 0x39, 0x85, 0x6a, 0x3a, 0x02,
	0x5c, 0xa1, 0x65, 0xce, 0xb1, 0xcf, 0xf5, 0x1b, 0xa4, 0xf7, 0x6d, 0xa4, 0xf7, 0xe1, 0x6b, 0x8c,
	0x80, 0x13, 0xf8, 0x0d, 0x41, 0x01, 0x5b, 0xab, 0x58, 0xe7, 0xd4, 0x90, 0x97, 0x50, 0x46, 0x3d,
	0xaa, 0xe9, 0x9c, 0x49, 0x59, 0xf4, 0x1d, 0x6c, 0xec, 0xce, 0x45, 0xb6, 0xed, 0x80, 0xeb, 0x4b,
	0x5b, 0xce, 0x99, 0x90, 0x4a, 0x93, 0x51, 0xe6, 0x17, 0xb9, 0x8d, 0xb2, 0x1c, 0x59, 0xd0, 0x0a,
	0xbc, 0x30, 0xa2, 0x0c, 0x97, 0xd8, 0x47, 0x39, 0x06, 0x5c, 0x4f, 0x6b, 0x88, 0x03, 0x0b, 0x47,
	0x6e, 0x60, 0xb5, 0x0d, 0x87, 0x59, 0xcc, 0x31, 0xf8, 0xf2, 0xa3, 0xb1, 0xe1, 0x84, 0xac, 0x52,
	0xbf, 0xa0, 0x54, 0x5e, 0xe3, 0xe8, 0xdb, 0x1c, 0xfb, 0x10, 0x91, 0xb7, 0x0f, 0x98, 0x3e, 0x7b,
	0xd4, 0x5b, 0x18, 0x32, 0xf2, 0x93, 0x30, 0x63, 0x71, 0xcc, 0x20, 0x32, 0x98, 0x65, 0xfa, 0x62,
	0x90, 0xd7, 0xb0, 0x95, 0xd5, 0x57, 0x0f, 0xb2, 0xc0, 0x6c, 0x58, 0xa6, 0x8f, 0x63, 0x3b, 0x6d,
	0xe5, 0x0b, 0xc8, 0x11, 0xcc, 0x9a, 0x56, 0x14, 0x84, 0x81, 0xeb, 0x30, 0xa3, 0x65, 0x2a, 0x39,
	0xbc, 0x8e, 0xf4, 0xef, 0xbe, 0x7a, 0x5c, 0x15, 0xee, 0xd3, 0xba, 0x94, 0xc5, 0x33, 0x09, 0xb9,
	0xa7, 0xa6, 0x94, 0xc7, 0x47, 0xf0, 0x7e, 0x87, 0x71, 0x49, 0x7a, 0x4a, 0x23, 0xa1, 0xcc, 0xc4,
	0x81, 0x41, 0xfd, 0x66, 0x10, 0x59, 0xd4, 0x88, 0x3a, 0x86, 0x79, 0x6a, 0x46, 0xd4, 0x08, 0x5d,
	0xd3, 0xc2, 0x45, 0x57, 0xd9, 0xc8, 0xea, 0x1e, 0x6f, 0x75, 0x18, 0xdd, 0xe1, 0x98, 0x5c, 0x63,
	0x39, 0x0c, 0x36, 0x05, 0x9a, 0xde, 0xa9, 0x73, 0xa4, 0x03, 0x85, 0x43, 0x4c, 0x20, 0x96, 0xeb,
	0x58, 0x6d, 0x16, 0x47, 0xd4, 0xf4, 0xd4, 0x67, 0x6c, 0x5e, 0xf0, 0x33, 0xd6, 0x53, 0x54, 0xf5,
	0x19, 0x56, 0x6f, 0x11, 0xb9, 0x09, 0x13, 0xbe, 0x65, 0x25, 0xf2, 0x77, 0x8b, 0x8b, 0xb1, 0xb5,
	0x62, 0xa5, 0xa0, 0x83, 0x6f, 0x59, 0x4a, 0xf2, 0xfe, 0x71, 0xb8, 0x66, 0x9d, 0x78, 0x06, 0xa3,
	0x56, 0x07, 0x85, 0x02, 0x67, 0x27, 0xd7, 0xc1, 0xdd, 0x53, 0xf6, 0xe9, 0xe3, 0x0b, 0xae, 0x8f,
	0x86, 0x24, 0xb1, 0x9e, 0x50, 0x90, 0x5d, 0xbb, 0x6c, 0x9d, 0x78, 0xe7, 0x55, 0x92, 0x36, 0x5c,
	0x57, 0xdc, 0xc2, 0x77, 0xdd, 0x98, 0xfa, 0xd8, 0xb6, 0x17, 0xd8, 0x49, 0x07, 0x9e, 0x62, 0x07,
	0xde, 0xcc, 0x77, 0xe0, 0x40, 0x7a, 0xe2, 0x1a, 0xd2, 0x11, 0x27, 0xdb, 0xba, 0x22, 0x89, 0xed,
	0xa6, 0xb4, 0x76, 0x03, 0x5b, 0x35, 0xf6, 0xeb, 0x05, 0x78, 0xab, 0xd5, 0x0d, 0x69, 0x74, 0xe2,
	0x30, 0xce, 0x9e, 0xe7, 0x7f, 0xf4, 0x36, 0xb6, 0xb9, 0xfe, 0xca, 0x8f, 0x7e, 0x9a, 0x50, 0x3b,
	0xf7, 0xf3, 0x6b, 0xad, 0x57, 0xc2, 0x90, 0xa7, 0x70, 0xa3, 0x4f, 0xd7, 0x12, 0x3b, 0x17, 0xc7,
	0xb4, 0x28, 0xe3, 0x9a, 0xd7, 0x77, 0x71, 0x1f, 0xba, 0xda, 0xa3, 0x79, 0x6d, 0xf0, 0xed, 0x4b,
	0x42, 0x6d, 0x87, 0xa4, 0x05, 0x95, 0x23, 0xd3, 0x6a, 0x87, 0xae, 0xe9, 0x53, 0xc3, 0xa7, 0xf1,
	0x69, 0x10, 0xb5, 0xd5, 0x47, 0x3d, 0xbb, 0xa0, 0xb2, 0xb2, 0x27, 0xd0, 0x64, 0xff, 0x17, 0x12,
	0x7a, 0xb9, 0x72, 0xf2, 0x43, 0x98, 0x8d, 0x6c, 0xcf, 0xec, 0x6d, 0xe4, 0x87, 0x5f, 0xa9, 0x91,
	0x19, 0x4e, 0x2a, 0x4f, 0x7f, 0x0f, 0x96, 0x94, 0x8c, 0xb3, 0x29, 0x2a, 0xf2, 0xb6, 0x81, 0x6e,
	0x2e, 0x2f, 0xf0, 0x9d, 0x38, 0xe0, 0xf2, 0xb0, 0xb2, 0x93, 0x5d, 0x79, 0x57, 0x25, 0xf8, 0x86,
	0x84, 0xde, 0x0b, 0x6c, 0xba, 0x9b, 0xc0, 0x12, 0x2f, 0x75, 0x6e, 0x04, 0x21, 0x15, 0x5d, 0x41,
	0x3e, 0xab, 0xec, 0xa2, 0x9d, 0xf8, 0xea, 0x2e, 0xef, 0x2b, 0x34, 0xce, 0x52, 0x4f, 0x46, 0xdb,
	0x7b, 0x41, 0xe4, 0x99, 0x6e, 0xe2, 0x15, 0xc9, 0x55, 0x93, 0x47, 0x30, 0x67, 0x05, 0x9e, 0x17,
	0xf8, 0x86, 0x15, 0x39, 0x31, 0x8d, 0x1c, 0x53, 0x34, 0xb6, 0x97, 0xed, 0x32, 0x11, 0x20, 0xeb,
	0x12, 0x02, 0x11, 0xf7, 0x61, 0x52, 0x08, 0x69, 0x39, 0xa0, 0xfb, 0x38, 0xa0, 0xaf, 0x76, 0xc2,
	0xa1, 0x18, 0x96, 0xc3, 0x39, 0xe1, 0xa4, 0x3f, 0xc8, 0x9f, 0x2a, 0xc0, 0x52, 0x22, 0x91, 0x95,
	0x56, 0x86, 0x7e, 0x6b, 0x2b, 0x70, 0x55, 0x2b, 0x07, 0xd8, 0xca, 0xb7, 0x2f, 0x2c, 0xa0, 0x25,
	0x9d, 0x03, 0x49, 0x46, 0xb6, 0x7b, 0xd5, 0xfa, 0xb2, 0x6a, 0xf2, 0x03, 0x78, 0xdf, 0xf1, 0x9d,
	0xd8, 0x31, 0x5d, 0xe7, 0x73, 0x6a, 0x0b, 0xad, 0x09, 0x19, 0xde, 0x8f, 0x99, 0x11, 0x9f, 0x06,
	0x46, 0xd8, 0xe2, 0x06, 0x9a, 0x4d, 0x5d, 0xca, 0x5b, 0xac, 0x7c, 0x82, 0xfb, 0xd9, 0xad, 0x0c,
	0x0e, 0xaa, 0x53, 0x9b, 0x02, 0xe3, 0xf0, 0x34, 0x38, 0xe0, 0xf0, 0x1b, 0x12, 0x9c, 0xd4, 0xe1,
	0x6a, 0x56, 0xc3, 0x6a, 0x71, 0x29, 0x9d, 0xba, 0x1e, 0x1d, 0xbb, 0xa2, 0xa3, 0xfa, 0x5a, 0xcd,
	0x78, 0xe6, 0x38, 0x4c, 0xe2, 0x66, 0xdc, 0xb6, 0xc9, 0x23, 0xa8, 0x28, 0xff, 0x0e, 0x63, 0x61,
	0x1e, 0xbb, 0x81, 0xd8, 0xf3, 0xb2, 0xbe, 0xc1, 0xc2, 0x2c, 0xe2, 0x36, 0x80, 0x69, 0x33, 0x35,
	0x9a, 0x87, 0x38, 0x9a, 0xaf, 0xf6, 0x70, 0xd6, 0x6d, 0x26, 0x47, 0x6e, 0xdc, 0x54, 0x7f, 0x92,
	0x87, 0x70, 0x49, 0x31, 0xaa, 0x67, 0xb2, 0xcf, 0x3a, 0x34, 0x32, 0x6d, 0xd4, 0x56, 0xc2, 0xca,
	0x73, 0x14, 0x01, 0xf3, 0xb2, 0x7a, 0x37, 0x53, 0xbb, 0x1d, 0x92, 0x27, 0xb0, 0x38, 0x10, 0x2f,
	0x0c, 0xa2, 0xb8, 0xf2, 0x82, 0x6b, 0xdf, 0xfa, 0xa5, 0x01, 0x98, 0x07, 0x41, 0x14, 0x93, 0x0d,
	0xb8, 0x1e, 0x9a, 0x7c, 0xd3, 0xa3, 0x96, 0x41, 0x7d, 0x4b, 0x4a, 0x5f, 0xf1, 0x75, 0x4c, 0x68,
	0x8a, 0x2f, 0x97, 0x4a, 0xcb, 0x25, 0xfd, 0x32, 0x82, 0x6d, 0x5a, 0x9b, 0x08, 0x94, 0x8c, 0x00,
	0x43, 0x75, 0xef, 0x43, 0x58, 0xa4, 0x7e, 0x8c, 0x12, 0x95, 0xfa, 0x71, 0xe4, 0x58, 0x86, 0x1d,
	0x25, 0xba, 0xde, 0xf7, 0x70, 0x32, 0x17, 0x04, 0xc0, 0xba, 0xa8, 0xdf, 0x88, 0x94, 0xa2, 0xf7,
	0x7d, 0xd0, 0xdc, 0x53, 0x26, 0x0f, 0x6c, 0xe4, 0x28, 0x7e, 0x1f, 0x47, 0xf1, 0xf6, 0x2b, 0x47,
	0x71, 0xe7, 0x65, 0x03, 0xfd, 0x12, 0x72, 0x28, 0xcb, 0xee, 0x29, 0xcb, 0xfc, 0x26, 0xcb, 0xa0,
	0xc9, 0xb9, 0x6c, 0x3a, 0xc7, 0x46, 0x70, 0xea, 0xd3, 0xa8, 0xf2, 0x29, 0x76, 0xa6, 0xcc, 0x70,
	0x12, 0x9b, 0xce, 0xf1, 0x3e, 0x2f, 0x25, 0xf7, 0x80, 0x34, 0x63, 0x83, 0x75, 0x42, 0x3e, 0x64,
	0x49, 0xc7, 0x7f, 0x22, 0xbb, 0x62, 0xb5, 0x66, 0xdc, 0x10, 0xf5, 0xaa, 0xe7, 0x16, 0xbc, 0x97,
	0x11, 0x81, 0x3e, 0xb5, 0x84, 0x8a, 0x19, 0x9b, 0x31, 0x67, 0x07, 0xd7, 0x95, 0x05, 0x8a, 0xda,
	0x4f, 0x66, 0xa9, 0xdd, 0xf2, 0x13, 0x91, 0x27, 0x11, 0xb9, 0x7e, 0xc7, 0xd6, 0x13, 0x34, 0xd5,
	0x88, 0x0e, 0x53, 0xa7, 0x4e, 0xec, 0x53, 0xc6, 0xa4, 0x22, 0xf9, 0x83, 0x0b, 0x9e, 0x23, 0xbd,
	0x14, 0x58, 0x52, 0x89, 0x3c, 0xcd, 0xfc, 0x22, 0x5e, 0xca, 0x2f, 0xd4, 0xb7, 0xa2, 0x6e, 0x88,
	0xfd, 0x0c, 0xcd, 0xc8, 0xf4, 0x58, 0xc5, 0xb8, 0xa0, 0xa2, 0xba, 0x99, 0x60, 0x1e, 0x20, 0x62,
	0xc2, 0x62, 0xbd, 0x15, 0x5c, 0xae, 0xa9, 0xe6, 0xcc, 0xc8, 0x6a, 0x55, 0x7e, 0x0a, 0xa5, 0xee,
	0xfb, 0x17, 0xd0, 0x75, 0x10, 0xa9, 0x1e, 0x59, 0xad, 0xc4, 0xc2, 0xe3, 0x3f, 0xc8, 0x1a, 0x8c,
	0x47, 0xa6, 0x25, 0x3d, 0xff, 0xe6, 0x05, 0x8f, 0x3d, 0x74, 0xd3, 0x6a, 0xeb, 0x63, 0x1c, 0x0f,
	0x39, 0xf6, 0x63, 0x58, 0x72, 0x3c, 0xf3, 0x18, 0x59, 0x4e, 0x2a, 0x4a, 0x42, 0x1b, 0xa0, 0x31,
	0x35, 0x82, 0x23, 0xea, 0x3a, 0x67, 0x95, 0x23, 0xe4, 0x95, 0xab, 0x08, 0xb7, 0x9e, 0x80, 0xad,
	0x4b, 0xa8, 0x7d, 0x04, 0x22, 0xbb, 0xb0, 0x64, 0x99, 0xb1, 0x89, 0xae, 0x01, 0xe1, 0x35, 0x45,
	0x46, 0x43, 0x9f, 0x72, 0x14, 0x1c, 0x73, 0x3d, 0xbc, 0x62, 0x65, 0xa7, 0xfe, 0x8a, 0x04, 0x17,
	0x1e, 0x51, 0xe4, 0xbf, 0x6d, 0xde, 0x47, 0x04, 0x25, 0x77, 0x61, 0x5e, 0x91, 0x0b, 0xa9, 0x11,
	0xd1, 0x63, 0x87, 0x7f, 0x36, 0xb5, 0x2b, 0x36, 0x76, 0x66, 0x56, 0x56, 0x1e, 0x50, 0x3d, 0xa9,
	0xe2, 0xdf, 0x92, 0xaa, 0xc6, 0xea, 0x80, 0x32, 0x32, 0x2c, 0x97, 0x9a, 0x7e, 0x27, 0x14, 0x6e,
	0x32, 0x2a, 0xbe, 0x25, 0x81, 0x53, 0xea, 0x53, 0xb4, 0x2e, 0xa0, 0xd0, 0x57, 0x16, 0xa7, 0x8c,
	0x91, 0x19, 0x16, 0xe9, 0x54, 0x6d, 0x22, 0x63, 0x3c, 0xbe, 0xe8, 0xb4, 0xa5, 0x03, 0x26, 0x9c,
	0xa7, 0x09, 0x7f, 0xf4, 0x56, 0x90, 0x4f, 0x60, 0x86, 0x8f, 0x7c, 0x27, 0xa6, 0x46, 0x7a, 0x9a,
	0x75, 0xfc, 0x3a, 0xa7, 0x59, 0xd3, 0x12, 0x7f, 0x4f, 0x1d, 0x6a, 0x2d, 0xc3, 0x24, 0x8b, 0x9d,
	0xe3, 0x64, 0xed, 0xb5, 0xb2, 0x13, 0x30, 0xc1, 0xab, 0x52, 0xf1, 0xf3, 0x56, 0x3a, 0x76, 0x47,
	0x26, 0xa3, 0xae, 0xe3, 0x53, 0xa3, 0xc3, 0xb8, 0x2c, 0xa5, 0x5e, 0x10, 0x75, 0x0d, 0xef, 0xc8,
	0x38, 0x7b, 0xfc, 0xb0, 0xe2, 0x2c, 0x15, 0x96, 0x87, 0x9e, 0x0c, 0xdd, 0x79, 0x70, 0xef, 0x21,
	0xea, 0xd2, 0xe9, 0x90, 0xaf, 0x49, 0xac, 0xe7, 0x8c, 0x46, 0xbb, 0x88, 0xb3, 0x7b, 0xf4, 0xbd,
	0xc7, 0x0f, 0xc9, 0x0f, 0xe0, 0xd6, 0x00, 0xd2, 0x6d, 0x1a, 0xf9, 0xd4, 0xed, 0x21, 0xfe, 0xd3,
	0x92, 0xf8, 0xea, 0xdd, 0xfb, 0x48, 0xbc, 0xd6, 0x47, 0xfc, 0x19, 0xa2, 0x65, 0xc9, 0xff, 0xff,
	0x0b, 0xf0, 0xb6, 0xa4, 0x12, 0x51, 0xae, 0x2e, 0xe2, 0xa8, 0x30, 0x23, 0xc4, 0xd9, 0xf3, 0xc2,
	0xc0, 0xe7, 0x9b, 0x21, 0x0e, 0x66, 0x1b, 0x07, 0xf3, 0x3b, 0xaf, 0x3e, 0xcb, 0x42, 0x72, 0x7a,
	0x86, 0xda, 0x01, 0x9f, 0x2f, 0x49, 0x4b, 0xaf, 0x79, 0x5f, 0x5a, 0x8f, 0x23, 0xdf, 0x86, 0x85,
	0x8c, 0xa2, 0xed, 0xba, 0xb6, 0x92, 0xbf, 0x15, 0x17, 0xf9, 0xe7, 0xc1, 0x6b, 0x68, 0xd6, 0x3b,
	0xae, 0x2d, 0xa5, 0xb4, 0x3e, 0xd7, 0x1a, 0x50, 0x4a, 0x28, 0xdc, 0xa1, 0x8e, 0x6d, 0x78, 0x66,
	0x68, 0xe0, 0xb6, 0x42, 0xc5, 0xd7, 0x23, 0x17, 0x09, 0x1d, 0x23, 0x6e, 0x45, 0x94, 0xb5, 0x02,
	0xd7, 0x36, 0xe8, 0x99, 0x45, 0xa9, 0x4d, 0xed, 0x8a, 0x87, 0x2b, 0xe1, 0x5d, 0xea, 0xd8, 0xbb,
	0x66, 0xb8, 0x29, 0xd0, 0x0e, 0x68, 0xc4, 0x79, 0x07, 0x95, 0x8c, 0x43, 0x85, 0xb2, 0x29, 0x31,
	0xc8, 0x9b, 0x50, 0xb6, 0xa8, 0xeb, 0x1a, 0xcd, 0xcf, 0x6c, 0x5f, 0x0c, 0xa8, 0x8f, 0xbe, 0xd3,
	0x49, 0x5e, 0xba, 0xf5, 0x99, 0xed, 0xe3, 0x97, 0xf3, 0xdd, 0x9b, 0x46, 0xf4, 0x28, 0x0a, 0x8c,
	0x26, 0x35, 0xe3, 0x4e, 0x44, 0x99, 0x71, 0xe4, 0xc4, 0x9e, 0x19, 0x56, 0x02, 0x3e, 0xbd, 0xfa,
	0xbc, 0xac, 0xde, 0x92, 0xb5, 0x6b, 0x58, 0x49, 0xb6, 0x61, 0xac, 0xed, 0x31, 0x0c, 0x81, 0xa8,
	0x84, 0x28, 0x1a, 0x97, 0x5f, 0xed, 0x10, 0xda, 0x6d, 0x1c, 0x76, 0x43, 0xfa, 0x64, 0xa8, 0xbd,
	0xf9, 0x6c, 0x57, 0x1f, 0x6d, 0x7b, 0x8c, 0xff, 0xe4, 0x82, 0x40, 0x09, 0x0f, 0xd6, 0x39, 0x62,
	0x34, 0x36, 0x3c, 0xe7, 0x58, 0x2a, 0xbc, 0x6a, 0x29, 0x7c, 0x26, 0x04, 0x81, 0x84, 0x6b, 0x20,
	0xd8, 0xae, 0x82, 0x52, 0xab, 0xe2, 0x39, 0x2c, 0x0f, 0x92, 0x28, 0xad, 0x20, 0x36, 0x4c, 0xdb,
	0xce, 0x4b, 0x96, 0x08, 0x09, 0xde, 0xec, 0x97, 0x2c, 0x4f, 0x83, 0xb8, 0x6e, 0xdb, 0x59, 0xf9,
	0xf2, 0x5d, 0xa8, 0xe5, 0x6c, 0xf8, 0x30, 0x72, 0x84, 0x47, 0x2a, 0x47, 0x90, 0x21, 0xc1, 0x6b,
	0x19, 0xf3, 0xfc, 0x40, 0xc2, 0x65, 0x69, 0xcd, 0xc3, 0x88, 0xc3, 0x0c, 0x37, 0x66, 0x95, 0x18,
	0xe1, 0x87, 0x1d, 0xb6, 0x13, 0x33, 0x72, 0x08, 0xb7, 0x4c, 0xca, 0xd4, 0x56, 0x4e, 0x6d, 0x65,
	0x05, 0x0f, 0xf0, 0x69, 0x76, 0x50, 0xad, 0xbb, 0x69, 0x52, 0xd6, 0x50, 0xd0, 0xd2, 0x38, 0xee,
	0x73, 0x6b, 0x3e, 0x82, 0x0a, 0xd7, 0x91, 0xac, 0x16, 0xb5, 0xda, 0xac, 0xe3, 0xe1, 0x6a, 0x96,
	0x6a, 0x6c, 0xe5, 0x44, 0xf8, 0xde, 0x3b, 0x8c, 0xae, 0xcb, 0x6a, 0xbe, 0x66, 0x85, 0xc2, 0x4a,
	0x76, 0xe0, 0x66, 0xea, 0xdf, 0x74, 0xdd, 0xae, 0xf1, 0x59, 0xc7, 0x74, 0x9d, 0xa6, 0xc3, 0xb1,
	0x85, 0xeb, 0x1a, 0x8f, 0x46, 0x4f, 0x51, 0xbd, 0xbb, 0x9e, 0xb8, 0x3b, 0x5d, 0xb7, 0xfb, 0x89,
	0x02, 0x14, 0x0e, 0x6b, 0x3c, 0x25, 0xfd, 0x0e, 0x5c, 0x11, 0xd3, 0x68, 0xd0, 0x66, 0xd3, 0xb1,
	0x1c, 0xbe, 0xc0, 0x3d, 0x8a, 0xfa, 0x16, 0xeb, 0xfa, 0x56, 0xe5, 0x4c, 0x7a, 0xd5, 0x10, 0x66,
	0x53, 0x81, 0xec, 0x22, 0x44, 0xa3, 0xeb, 0x5b, 0xe4, 0x26, 0x4c, 0xf1, 0xef, 0x48, 0x66, 0xb4,
	0xd2, 0x45, 0x8c, 0xc9, 0x0e, 0xa3, 0xc9, 0xb4, 0x11, 0x0f, 0x2a, 0x89, 0x2d, 0x1a, 0xd1, 0x30,
	0x60, 0xdc, 0x90, 0x92, 0x5e, 0xc3, 0xcf, 0x2f, 0x78, 0xae, 0xa3, 0x8c, 0x54, 0x3d, 0xc1, 0xd7,
	0x17, 0x68, 0x5f, 0x19, 0xae, 0x9b, 0x67, 0x50, 0x4b, 0x8c, 0x13, 0x75, 0xb2, 0xd3, 0x3f, 0x59,
	0x3f, 0x83, 0x93, 0x75, 0x5d, 0x41, 0xca, 0x13, 0x9e, 0xbe, 0x89, 0xfa, 0x09, 0x78, 0x27, 0xf1,
	0x0f, 0x33, 0xbe, 0xbd, 0x9f, 0x9a, 0x11, 0x7a, 0xfc, 0x4c, 0x97, 0x46, 0x71, 0x46, 0x1c, 0x84,
	0x56, 0x5c, 0xf9, 0x59, 0x74, 0x4c, 0x17, 0x1f, 0x3d, 0xd0, 0xdf, 0x54, 0x0e, 0x64, 0x8e, 0xf3,
	0x52, 0xa0, 0xd4, 0x39, 0x46, 0x22, 0x0c, 0x0e, 0xac, 0x98, 0xfc, 0x00, 0xde, 0xcd, 0x13, 0xe7,
	0x06, 0x1e, 0xf6, 0x73, 0x10, 0xf5, 0x3f, 0x26, 0xa8, 0x7f, 0xb8, 0xaa, 0xbf, 0x95, 0xa5, 0xbe,
	0x2e, 0x71, 0xfa, 0xc9, 0x1f, 0xc0, 0x0d, 0x21, 0xb4, 0x12, 0x36, 0xe3, 0x5a, 0xa4, 0x83, 0xdc,
	0x9b, 0x48, 0xaf, 0x3f, 0x9e, 0xdd, 0xc9, 0xae, 0x21, 0xbc, 0x62, 0xbb, 0x75, 0x05, 0x9d, 0x08,
	0x2e, 0xae, 0x4c, 0xf4, 0x9f, 0xe4, 0x9c, 0x3c, 0xac, 0xfc, 0x1c, 0xf2, 0xdb, 0x6c, 0xdf, 0x59,
	0xce, 0xc9, 0x43, 0xd2, 0x82, 0xb9, 0x44, 0x07, 0x30, 0x43, 0x11, 0x66, 0xe5, 0x50, 0x56, 0xf9,
	0x85, 0xc2, 0x05, 0xfd, 0x85, 0x6a, 0xff, 0xcf, 0x20, 0x27, 0x2d, 0x65, 0x0b, 0xc9, 0x47, 0x70,
	0x25, 0x8c, 0xe8, 0x89, 0x13, 0x74, 0x98, 0x31, 0xe8, 0xc0, 0xe9, 0x4f, 0x14, 0xb0, 0x97, 0x8b,
	0x0a, 0x68, 0xbd, 0xef, 0xe4, 0x69, 0x03, 0xae, 0x7d, 0x19, 0x85, 0x93, 0x87, 0x95, 0x5f, 0x14,
	0x34, 0x2e, 0x9f, 0x4b, 0xe3, 0xe4, 0x21, 0x59, 0x87, 0xaa, 0xd7, 0x71, 0x63, 0xc7, 0x68, 0x3a,
	0x2e, 0xed, 0x33, 0x02, 0xfe, 0x64, 0x21, 0x3b, 0xe2, 0x97, 0x10, 0x72, 0xcb, 0x71, 0x69, 0x8f,
	0x31, 0xf0, 0x08, 0xe6, 0x22, 0x6a, 0x75, 0x2d, 0x97, 0x1a, 0x47, 0x8e, 0x6f, 0xc4, 0xb1, 0x6b,
	0x30, 0x6a, 0xb1, 0xca, 0x2f, 0x15, 0x90, 0x0d, 0x86, 0x1f, 0x3f, 0xbc, 0xbf, 0xba, 0xaa, 0xcf,
	0x48, 0x98, 0x35, 0xc7, 0x3f, 0x8c, 0xdd, 0x06, 0xb5, 0x18, 0x67, 0xff, 0x54, 0x26, 0x9a, 0xc7,
	0x7c, 0x49, 0x9f, 0x78, 0x59, 0xf5, 0x0b, 0x65, 0xe2, 0x9f, 0x2a, 0xf4, 0x08, 0xc5, 0x3a, 0x87,
	0x7c, 0xe1, 0xa5, 0xca, 0x14, 0x0a, 0xc5, 0x03, 0x78, 0xb3, 0x97, 0x15, 0x93, 0xe0, 0x9e, 0x28,
	0x38, 0x41, 0xee, 0x70, 0xfc, 0xe3, 0xca, 0x9f, 0xe6, 0xe4, 0x0a, 0xfa, 0x0d, 0x33, 0xc7, 0x84,
	0x2a, 0x9a, 0x27, 0x03, 0x49, 0x3e, 0x84, 0x8a, 0xb4, 0xc2, 0x8d, 0xbe, 0x83, 0x9d, 0x3f, 0x83,
	0xdf, 0xa6, 0x2f, 0x48, 0x80, 0x46, 0xcf, 0xd9, 0xce, 0xf7, 0x41, 0x86, 0x04, 0x26, 0x32, 0x18,
	0x3d, 0xc2, 0x7f, 0x56, 0x30, 0xd2, 0x72, 0x6f, 0xac, 0x8e, 0x08, 0xb4, 0x90, 0xc8, 0xdb, 0x7e,
	0x12, 0x1c, 0xa8, 0xcf, 0x84, 0xbd, 0x35, 0xe4, 0x36, 0x08, 0x0f, 0xb4, 0x34, 0x1b, 0xd5, 0x5c,
	0xfd, 0xff, 0xc4, 0x28, 0xcd, 0x60, 0x1d, 0x5a, 0x82, 0x6a, 0x7a, 0x3e, 0x00, 0x92, 0x30, 0xc6,
	0xc9, 0x43, 0x15, 0xcc, 0xf6, 0xe7, 0x04, 0x77, 0x68, 0xaa, 0xea, 0xc5, 0x43, 0x19, 0xb7, 0xf6,
	0x5d, 0x00, 0xdb, 0x4f, 0x8c, 0xfa, 0x3f, 0x5f, 0xb8, 0xa0, 0x55, 0xbf, 0xe1, 0x27, 0x56, 0xbd,
	0xad, 0xfe, 0x24, 0xef, 0x80, 0x26, 0x18, 0x4b, 0x1c, 0xfc, 0xe0, 0xb1, 0xd5, 0x2f, 0x8b, 0x86,
	0xcb, 0xbc, 0x42, 0x1c, 0xdd, 0xe0, 0xd1, 0xd5, 0x3b, 0x50, 0xf6, 0x4c, 0x3f, 0x76, 0xd3, 0x21,
	0xfe, 0x91, 0x60, 0x9f, 0xc2, 0xaa, 0x3e, 0x25, 0x6a, 0xd4, 0xe0, 0x3e, 0x86, 0x8a, 0xd9, 0x3a,
	0x49, 0xd4, 0xc8, 0xc0, 0xa6, 0x6e, 0x82, 0xf4, 0x63, 0x31, 0x2f, 0xf3, 0x66, 0xeb, 0x44, 0x2a,
	0x8c, 0xbc, 0x5a, 0x61, 0xde, 0x83, 0xf9, 0xa8, 0x79, 0x27, 0xe3, 0xe1, 0x50, 0xa3, 0xf7, 0x2b,
	0x62, 0xf4, 0x66, 0xa3, 0xe6, 0x9d, 0xc4, 0xbc, 0x57, 0xe3, 0xf7, 0x53, 0x30, 0xdd, 0x72, 0x8e,
	0xf8, 0x20, 0xc5, 0xea, 0x74, 0xf5, 0x57, 0x0b, 0x17, 0x0c, 0x0c, 0x91, 0x6b, 0xee, 0xa9, 0xc2,
	0x17, 0x26, 0x69, 0xb9, 0x95, 0xfb, 0x4d, 0x7e, 0x00, 0x33, 0xd9, 0x05, 0x24, 0xda, 0xf8, 0xb5,
	0xc2, 0x05, 0x8f, 0x0f, 0xf4, 0x64, 0x5d, 0x09, 0xea, 0xd3, 0x51, 0xbe, 0xa0, 0xda, 0x86, 0xc9,
	0x6c, 0x64, 0x25, 0x59, 0x82, 0x49, 0xab, 0xd5, 0xf1, 0xdb, 0x06, 0xd7, 0x92, 0x1c, 0x5b, 0x86,
	0x51, 0x02, 0x96, 0x35, 0x68, 0xbc, 0x8d, 0x27, 0x81, 0x4a, 0x10, 0x57, 0x8a, 0x4b, 0xc5, 0xe5,
	0x29, 0x3d, 0xf9, 0x4d, 0xae, 0x02, 0xf8, 0x5c, 0x3e, 0x73, 0x68, 0x56, 0x29, 0x2d, 0x15, 0x97,
	0x87, 0xf5, 0x71, 0xbf, 0xe3, 0xad, 0x63, 0x41, 0xf5, 0x7f, 0x2f, 0xc1, 0x44, 0x26, 0x7c, 0x81,
	0xbc, 0xdb, 0x13, 0x06, 0x89, 0x7b, 0x3e, 0x6f, 0x71, 0x3c, 0x17, 0xd8, 0x88, 0x7b, 0xfc, 0xfb,
	0x40, 0x22, 0xd3, 0xb7, 0x03, 0xcf, 0x70, 0x82, 0x44, 0x41, 0xc2, 0x0e, 0x0c, 0xeb, 0x9a, 0xa8,
	0xd9, 0x0e, 0x94, 0x42, 0x44, 0xee, 0xc3, 0x02, 0xa3, 0x9f, 0x75, 0xa8, 0x8f, 0x2b, 0x34, 0x8b,
	0x21, 0x3a, 0x35, 0x97, 0xd6, 0x66, 0xb0, 0x7e, 0x82, 0x9b, 0x47, 0xb2, 0x3f, 0x5c, 0xed, 0x1c,
	0x42, 0xb5, 0xf3, 0xf1, 0xeb, 0x44, 0x64, 0x26, 0x7f, 0x77, 0x43, 0xb4, 0xa8, 0x92, 0x1f, 0xa4,
	0x02, 0xa3, 0xe8, 0xc7, 0xa3, 0x76, 0x65, 0x18, 0x19, 0x4a, 0xfd, 0x24, 0x1b, 0x70, 0xd5, 0x33,
	0xcf, 0x0c, 0xd3, 0x75, 0x83, 0x53, 0x6a, 0x1b, 0xa1, 0xe3, 0xfb, 0xd4, 0x56, 0xee, 0x19, 0xbe,
	0x65, 0x8e, 0x88, 0x2d, 0xf3, 0xee, 0x03, 0x7d, 0xd1, 0x33, 0xcf, 0xea, 0x02, 0xee, 0x00, 0xc1,
	0x44, 0x6f, 0xf8, 0x36, 0xb9, 0x06, 0x57, 0x06, 0x50, 0x11, 0x1b, 0x32, 0x27, 0x32, 0x2a, 0x88,
	0x3c, 0x58, 0xd5, 0x2b, 0xbd, 0x44, 0x70, 0x03, 0x3e, 0xb0, 0xe2, 0x5a, 0x23, 0x9d, 0x1f, 0xde,
	0xe5, 0x49, 0x18, 0x6b, 0x1f, 0x58, 0x0e, 0x6d, 0x34, 0x36, 0xb4, 0x37, 0xf0, 0x57, 0xc3, 0x8c,
	0x4d, 0xfe, 0xab, 0x40, 0xc6, 0x60, 0xa8, 0xfd, 0x74, 0x63, 0x43, 0x2b, 0xe2, 0x5f, 0x8d, 0xfa,
	0x9e, 0x56, 0xc2, 0xbf, 0xf6, 0xea, 0x0d, 0x6d, 0x88, 0x00, 0x8c, 0xb4, 0xf1, 0x08, 0x52, 0x1b,
	0xae, 0xfe, 0x67, 0xb3, 0x30, 0xb4, 0xe1, 0xb0, 0x36, 0xb9, 0x04, 0xa3, 0x78, 0x38, 0x9c, 0xb0,
	0xd5, 0x08, 0xff, 0xb9, 0x6d, 0x93, 0x1a, 0x4c, 0x49, 0xbf, 0x3e, 0x97, 0xf1, 0x8e, 0x8d, 0x11,
	0xb9, 0x25, 0x7d, 0x42, 0x16, 0xbe, 0xf0, 0xb6, 0x6d, 0xf2, 0x1e, 0x10, 0xd7, 0x64, 0xb1, 0x91,
	0x07, 0x2c, 0x21, 0xe0, 0x34, 0xaf, 0x69, 0x64, 0x80, 0xaf, 0x02, 0x78, 0x41, 0xc7, 0x8f, 0x8d,
	0xd0, 0x8c, 0x5b, 0x95, 0x21, 0xe4, 0xa8, 0x71, 0x2c, 0x39, 0x30, 0xe3, 0x16, 0xb9, 0x2c, 0x63,
	0x4c, 0x99, 0xf3, 0x39, 0xad, 0x0c, 0x63, 0x57, 0x30, 0x78, 0xb4, 0xe1, 0x7c, 0x4e, 0xd1, 0x3b,
	0x16, 0x9b, 0x71, 0x93, 0x19, 0x29, 0xcc, 0x08, 0x36, 0x53, 0x16, 0xe5, 0x1b, 0x0a, 0xf2, 0x46,
	0x86, 0x5d, 0x1c, 0x1a, 0x55, 0x46, 0xb1, 0x9d, 0x89, 0x0c, 0xe7, 0x62, 0x78, 0x9c, 0x19, 0x9b,
	0x86, 0xed, 0x44, 0x5c, 0xb8, 0xba, 0xf4, 0x84, 0xba, 0xac, 0x32, 0x86, 0x72, 0x48, 0xe3, 0x35,
	0x1b, 0x4e, 0xd4, 0x50, 0xe5, 0xe4, 0x1e, 0x2c, 0xf4, 0x41, 0xf3, 0x1f, 0xac, 0x32, 0x8e, 0x18,
	0xb3, 0x3d, 0x18, 0x1b, 0x4e, 0xc4, 0xf8, 0xc7, 0xc4, 0x01, 0x06, 0x3b, 0x9c, 0xd0, 0x0a, 0x20,
	0x67, 0x8d, 0xc5, 0x81, 0x8e, 0xbf, 0xb9, 0xa6, 0x83, 0x14, 0x53, 0x7b, 0x47, 0x7a, 0x2d, 0x26,
	0x52, 0x82, 0x89, 0x95, 0x23, 0xfd, 0x0e, 0x37, 0x61, 0x4a, 0x84, 0x00, 0x06, 0xe2, 0x00, 0xb7,
	0x32, 0x89, 0xb0, 0x93, 0x18, 0xfb, 0x27, 0xcb, 0xc8, 0x7b, 0x30, 0x23, 0x25, 0x25, 0x33, 0x54,
	0xd0, 0x40, 0xa5, 0x8c, 0xad, 0x6b, 0xaa, 0x62, 0x57, 0x96, 0x93, 0xb7, 0x61, 0x3a, 0x08, 0xb9,
	0xf5, 0x95, 0x8e, 0xe8, 0x34, 0x8e, 0xe8, 0x14, 0x16, 0x27, 0x03, 0x7a, 0x1d, 0x26, 0x9c, 0x20,
	0x64, 0x06, 0xef, 0x8e, 0x7f, 0x8c, 0x31, 0x96, 0xc3, 0x3a, 0xf0, 0x22, 0x1d, 0x4b, 0x48, 0x1d,
	0xae, 0x31, 0x3c, 0x05, 0x62, 0xb6, 0x54, 0x05, 0xb8, 0x29, 0x13, 0x07, 0x46, 0x68, 0x39, 0x94,
	0x97, 0x56, 0x66, 0x84, 0xaa, 0xcf, 0xa1, 0x1a, 0xcc, 0x5e, 0x57, 0x30, 0x87, 0x01, 0xf2, 0x31,
	0x43, 0x3e, 0xf2, 0x4c, 0xd4, 0x88, 0x4e, 0x4d, 0xd7, 0x50, 0xfc, 0x28, 0x82, 0x34, 0xa7, 0x45,
	0xcd, 0x4b, 0xd3, 0xdd, 0x10, 0x8c, 0xf9, 0x1e, 0x10, 0x19, 0x88, 0x92, 0x05, 0x9e, 0x15, 0xc0,
	0xa2, 0x26, 0x05, 0x5e, 0x06, 0xcd, 0x12, 0xe1, 0x4c, 0xe9, 0x67, 0xce, 0x09, 0xc6, 0x11, 0xe5,
	0xc9, 0x77, 0xbe, 0x09, 0x65, 0x01, 0x42, 0x23, 0x14, 0x4f, 0x76, 0x65, 0x1e, 0xf7, 0x3d, 0x1c,
	0xe2, 0x06, 0x16, 0x6e, 0xdb, 0x64, 0x0b, 0xb4, 0xde, 0xa0, 0xfd, 0xca, 0x02, 0xca, 0xfd, 0x2b,
	0x83, 0xce, 0xfa, 0x39, 0x10, 0x1e, 0x11, 0x97, 0xad, 0xdc, 0x6f, 0xe2, 0xc1, 0x3c, 0xa3, 0x6e,
	0x33, 0xf1, 0x69, 0xfa, 0xc7, 0x86, 0x1d, 0x39, 0x27, 0xb4, 0x72, 0xe9, 0x82, 0x07, 0x99, 0xbc,
	0xdf, 0x2b, 0x0d, 0xea, 0x36, 0x37, 0x13, 0x0a, 0x1b, 0x9c, 0x80, 0x3e, 0xcb, 0xfa, 0x0b, 0xd1,
	0xde, 0x4f, 0x38, 0xc3, 0x0c, 0x23, 0x6a, 0x77, 0x2c, 0x8a, 0x87, 0x77, 0x95, 0x8a, 0x30, 0x09,
	0x13, 0xfe, 0x50, 0xb5, 0x1b, 0x9c, 0x49, 0xd4, 0xa2, 0x44, 0x45, 0x60, 0x51, 0x84, 0x98, 0xf0,
	0x02, 0xd4, 0x00, 0xd6, 0xe1, 0x9a, 0x3a, 0xb1, 0x41, 0xa0, 0x8c, 0x67, 0xc7, 0x38, 0xea, 0xc6,
	0x94, 0x55, 0xae, 0xe0, 0x48, 0x5f, 0x96, 0x50, 0x18, 0x10, 0x9e, 0xc2, 0xac, 0x71, 0x10, 0xbe,
	0x18, 0x1d, 0x66, 0x28, 0x3a, 0x61, 0xe4, 0x78, 0x66, 0xd4, 0xad, 0x5c, 0x15, 0x4c, 0xeb, 0x30,
	0x79, 0x92, 0x73, 0x20, 0xca, 0x79, 0x7f, 0xd0, 0x61, 0x82, 0xfd, 0xb9, 0x26, 0xfa, 0xc3, 0x0b,
	0xb0, 0x3f, 0x6f, 0x42, 0x19, 0xa5, 0x51, 0x0a, 0x71, 0x5d, 0xcc, 0x20, 0x2f, 0xdd, 0x53, 0x50,
	0x1f, 0xc0, 0xb4, 0x54, 0x9b, 0x85, 0x97, 0xba, 0xc9, 0x30, 0xae, 0x53, 0xc5, 0x1f, 0x95, 0x55,
	0x65, 0x03, 0xeb, 0xc8, 0x07, 0x30, 0x9b, 0xba, 0xfc, 0x53, 0x1e, 0xba, 0x81, 0x5f, 0xa6, 0x29,
	0x27, 0x7e, 0xc2, 0x45, 0x0f, 0x60, 0xd6, 0x6a, 0x05, 0x8c, 0xfa, 0x46, 0x33, 0x88, 0xd2, 0x45,
	0x58, 0xcb, 0x05, 0xfe, 0x09, 0x88, 0xad, 0x20, 0x4a, 0x16, 0xe3, 0x26, 0x5c, 0x4f, 0xe2, 0x80,
	0xce, 0x19, 0xcb, 0x9b, 0xd8, 0xe2, 0x15, 0x05, 0x36, 0x70, 0x30, 0x3f, 0x83, 0x4b, 0x59, 0x55,
	0xd3, 0xa6, 0x28, 0x95, 0x91, 0x49, 0x97, 0x91, 0xaf, 0x9e, 0x5c, 0x8c, 0xaf, 0xd6, 0x12, 0x9d,
	0x74, 0x03, 0x49, 0x20, 0x0b, 0xcf, 0x1d, 0x0d, 0x28, 0xe5, 0xea, 0x82, 0x68, 0x52, 0x36, 0x86,
	0xc2, 0xfd, 0x1d, 0x1c, 0xf7, 0x69, 0xac, 0x10, 0xb0, 0x28, 0xe2, 0x97, 0xa1, 0xcc, 0x35, 0x91,
	0xd0, 0x8c, 0x62, 0x47, 0x44, 0x4f, 0x89, 0x98, 0xc2, 0xc2, 0x1d, 0x7d, 0xca, 0xef, 0x78, 0x07,
	0x49, 0x39, 0x97, 0xe2, 0x28, 0x3d, 0x4c, 0xdb, 0x46, 0xa7, 0xf4, 0x7b, 0x22, 0x74, 0x8a, 0x97,
	0xd5, 0x45, 0x11, 0xea, 0x29, 0x7c, 0x05, 0x89, 0x73, 0x32, 0xdb, 0xf0, 0x4f, 0x3c, 0x5a, 0x79,
	0x1f, 0xf9, 0x66, 0x9a, 0x57, 0x88, 0x78, 0x23, 0x7b, 0xef, 0xc4, 0xa3, 0xd5, 0x5f, 0x2c, 0xc1,
	0xec, 0x80, 0xb5, 0x42, 0x7e, 0x16, 0xe6, 0xad, 0x4e, 0x14, 0x51, 0xdc, 0x94, 0x64, 0x84, 0x1a,
	0xba, 0x0e, 0x0a, 0xe8, 0x3a, 0x78, 0xfa, 0x95, 0x57, 0xe1, 0xca, 0x81, 0x24, 0xa7, 0xe2, 0xf9,
	0x65, 0x33, 0xaa, 0x18, 0x9d, 0x09, 0x5f, 0x14, 0xe0, 0x52, 0x4c, 0xfd, 0xd8, 0x8c, 0x9d, 0x13,
	0xda, 0xd3, 0x81, 0xe2, 0x1f, 0x71, 0x07, 0xe6, 0x93, 0x86, 0xb2, 0x5d, 0xa8, 0xba, 0x50, 0xce,
	0x03, 0xf2, 0x5d, 0x9a, 0x51, 0x2b, 0xa2, 0xb1, 0xd1, 0x41, 0x95, 0x80, 0x8f, 0xfb, 0xb8, 0x28,
	0x79, 0xee, 0xd8, 0xe4, 0x1b, 0xe7, 0xc5, 0x88, 0xe1, 0x7a, 0xc3, 0x4b, 0x3b, 0x03, 0xa3, 0xbd,
	0xf8, 0xd2, 0xab, 0xfe, 0x66, 0x01, 0xe6, 0xd6, 0x06, 0x33, 0xd1, 0x94, 0x30, 0xa1, 0x0c, 0x5f,
	0x78, 0x0e, 0x72, 0x76, 0xec, 0xa4, 0xa8, 0xdb, 0x13, 0x7e, 0x82, 0x55, 0x20, 0xdc, 0xb8, 0x8b,
	0x8d, 0xa0, 0xd9, 0xe4, 0xfa, 0xb0, 0x58, 0x1d, 0xa8, 0x9c, 0x3c, 0x29, 0x7e, 0x70, 0x47, 0xc7,
	0x98, 0xbe, 0x78, 0x1f, 0x2b, 0x95, 0x88, 0xd1, 0xa8, 0x6f, 0xe7, 0xe1, 0x4b, 0x09, 0x7c, 0x99,
	0xfa, 0x76, 0x06, 0xba, 0xf6, 0xd7, 0x0a, 0x30, 0xbb, 0x31, 0x60, 0x07, 0x9e, 0x03, 0xad, 0xcd,
	0xcb, 0xf7, 0x02, 0xe9, 0x82, 0xa4, 0xb6, 0xf6, 0x06, 0xb9, 0x04, 0xb3, 0xed, 0x4d, 0x5c, 0x6d,
	0x29, 0x0e, 0xb5, 0xb5, 0x02, 0x99, 0x87, 0x99, 0xf6, 0x3e, 0x6e, 0xa4, 0x7c, 0xb1, 0x46, 0xdc,
	0x40, 0xb1, 0x35, 0x8d, 0x5c, 0x85, 0x4a, 0x7b, 0x5d, 0xc5, 0x4e, 0xf3, 0x2a, 0x9d, 0x86, 0x2e,
	0xc6, 0xa4, 0xd9, 0xda, 0x17, 0x45, 0x72, 0x0d, 0x16, 0xdb, 0x7b, 0xd4, 0x8c, 0x1a, 0x5d, 0xdf,
	0x4a, 0xb0, 0x37, 0xcf, 0x42, 0x27, 0xe2, 0xf5, 0x4b, 0x64, 0x1e, 0xb4, 0x76, 0xdd, 0x75, 0x73,
	0x6d, 0xfd, 0x4a, 0xad, 0xfa, 0xe3, 0x51, 0x98, 0x92, 0x71, 0x09, 0x9b, 0x78, 0x72, 0x89, 0x1e,
	0x47, 0xbe, 0x49, 0x45, 0x72, 0x0a, 0x87, 0x1d, 0xbb, 0x11, 0x47, 0xb2, 0xd8, 0xf1, 0x63, 0xa9,
	0xcd, 0x0d, 0x3b, 0xf6, 0xb6, 0x1f, 0x13, 0x02, 0x43, 0xa8, 0x5b, 0x97, 0x70, 0x73, 0xc7, 0xbf,
	0xf9, 0x12, 0x94, 0xab, 0x2f, 0xbd, 0x09, 0x35, 0xae, 0x4f, 0xc8, 0x32, 0x64, 0x60, 0x02, 0x43,
	0x78, 0x6c, 0x3b, 0x2c, 0xd0, 0xf8, 0xdf, 0xdc, 0x12, 0xe9, 0x30, 0x6e, 0x2b, 0x25, 0x37, 0x92,
	0x92, 0xdf, 0xbc, 0x4e, 0x71, 0xb9, 0xbc, 0x70, 0x94, 0xfc, 0xe6, 0x7c, 0x67, 0x5a, 0x16, 0x6f,
	0xad, 0x13, 0xb9, 0xa8, 0x8c, 0x8d, 0xeb, 0xe3, 0xa2, 0xe4, 0x79, 0xe4, 0x92, 0x97, 0x30, 0xa6,
	0x82, 0x01, 0x50, 0xef, 0x2a, 0xdf, 0xfd, 0xc6, 0x45, 0x83, 0x37, 0xc4, 0x88, 0xac, 0xa8, 0x53,
	0x7e, 0x34, 0x02, 0x12, 0x62, 0x5c, 0xf2, 0xda, 0xce, 0xb1, 0x13, 0x9b, 0x6e, 0x2e, 0x00, 0xf1,
	0xf3, 0x36, 0x17, 0x64, 0xe9, 0x05, 0xa3, 0x71, 0xfd, 0x8a, 0x04, 0xcb, 0x84, 0x11, 0x7e, 0x8a,
	0x40, 0x38, 0x14, 0x2f, 0x01, 0xc2, 0x28, 0x38, 0xeb, 0x0a, 0x1b, 0x65, 0x62, 0xa9, 0x74, 0x21,
	0x1b, 0xa5, 0xaf, 0x87, 0x67, 0x5d, 0xec, 0xde, 0x78, 0xa8, 0xfe, 0x24, 0x1e, 0x86, 0x60, 0xf1,
	0x85, 0x16, 0x60, 0x64, 0x7d, 0x1c, 0xb4, 0xa9, 0xd0, 0xfe, 0x2e, 0x72, 0x48, 0x92, 0x6f, 0x60,
	0x1d, 0x09, 0xed, 0x73, 0x3a, 0x87, 0x9c, 0x8c, 0xae, 0x59, 0x3d, 0x25, 0xd5, 0x7f, 0x56, 0x00,
	0xad, 0x17, 0x8c, 0xcf, 0x0d, 0x36, 0x2b, 0x3e, 0x4e, 0xca, 0x04, 0x2c, 0x39, 0x54, 0x9c, 0x22,
	0xa6, 0x4e, 0x74, 0x4e, 0x48, 0x81, 0x09, 0x51, 0x26, 0x28, 0xdc, 0x84, 0xa9, 0x88, 0x36, 0x23,
	0xca, 0xd4, 0x07, 0x94, 0xc4, 0xce, 0x2c, 0x0b, 0x93, 0x66, 0x28, 0xb2, 0x3a, 0x33, 0x1c, 0x1f,
	0xed, 0xbc, 0x21, 0x7d, 0x5c, 0x96, 0x6c, 0xfb, 0x64, 0x01, 0x46, 0x98, 0x15, 0x84, 0x54, 0xdc,
	0x9e, 0x1b, 0xd7, 0xe5, 0x2f, 0xae, 0x13, 0xc8, 0x11, 0x72, 0x6c, 0xc5, 0x72, 0xa2, 0x60, 0xdb,
	0xe6, 0x0d, 0xcb, 0x4a, 0x21, 0xc3, 0x24, 0xdf, 0x4d, 0x8a, 0xc2, 0x06, 0x96, 0xd5, 0x6a, 0x30,
	0x99, 0xe5, 0x0e, 0x34, 0x99, 0x0e, 0xad, 0x50, 0x7b, 0x03, 0xff, 0x7a, 0x6e, 0x87, 0x5a, 0xa1,
	0xb6, 0x02, 0xe3, 0xc9, 0xfc, 0x90, 0x71, 0x18, 0x6e, 0x3f, 0x8d, 0x63, 0x0e, 0xc1, 0x8d, 0x2a,
	0xfe, 0x27, 0xd3, 0x0a, 0xf8, 0x77, 0x23, 0xb0, 0xda, 0x4c, 0x2b, 0x56, 0xff, 0xc6, 0x5d, 0x18,
	0xe2, 0x3a, 0x47, 0xbf, 0x1d, 0x25, 0xcc, 0xac, 0x9c, 0x1d, 0x75, 0x8f, 0x5b, 0xc6, 0x09, 0x4c,
	0xd6, 0xaf, 0x28, 0xc6, 0x72, 0x36, 0x01, 0xce, 0x38, 0x14, 0x5f, 0xc0, 0x04, 0x6a, 0x3a, 0xd2,
	0x78, 0x28, 0x5d, 0xf0, 0xa4, 0x9a, 0x77, 0x6a, 0x45, 0xde, 0x1f, 0x49, 0xa2, 0x83, 0x80, 0x53,
	0x92, 0x82, 0x6e, 0x19, 0x34, 0xa4, 0x8b, 0xd6, 0x8b, 0xe9, 0x1a, 0xa6, 0xd5, 0xc6, 0xc9, 0x18,
	0xd6, 0xcb, 0xbc, 0x5c, 0x17, 0xc5, 0x75, 0xab, 0xcd, 0x27, 0x4c, 0xdc, 0x13, 0xc3, 0xd5, 0x3e,
	0x2c, 0xf8, 0x02, 0x4b, 0xd0, 0x3b, 0xf0, 0x08, 0x2a, 0x41, 0xb3, 0x89, 0x07, 0x89, 0xa8, 0xd3,
	0xa4, 0xd6, 0x1f, 0xab, 0x8c, 0xe0, 0x14, 0xce, 0xcb, 0x7a, 0xbe, 0x8b, 0xed, 0x2a, 0x4b, 0x90,
	0x91, 0xb7, 0xa0, 0x9c, 0x39, 0x97, 0x6b, 0xd3, 0xae, 0x9c, 0xb5, 0xa9, 0xb4, 0xf4, 0x19, 0x45,
	0x7f, 0x42, 0xff, 0x3e, 0x84, 0x5d, 0x11, 0xe2, 0xa3, 0xef, 0x72, 0x1b, 0xf6, 0xea, 0x16, 0x4c,
	0x9b, 0x16, 0xdf, 0x08, 0xbd, 0xcf, 0x8c, 0xa3, 0x28, 0x68, 0xd3, 0x08, 0x05, 0xca, 0x98, 0x5e,
	0x56, 0xc5, 0x6b, 0x58, 0xca, 0x35, 0xd3, 0xf4, 0x16, 0x8c, 0xe0, 0x7f, 0xc7, 0x46, 0x63, 0x6e,
	0x5c, 0xd7, 0x92, 0x1a, 0x64, 0xdd, 0x6d, 0x7b, 0x90, 0x39, 0x35, 0x31, 0xc8, 0x9c, 0xba, 0x07,
	0x0b, 0x02, 0xae, 0xcf, 0x9e, 0x9d, 0x44, 0xf0, 0x59, 0xac, 0x6d, 0xe4, 0x8d, 0xda, 0x3d, 0x80,
	0xf4, 0xd3, 0x2b, 0x53, 0xaf, 0x17, 0xbc, 0x26, 0x16, 0xbf, 0x9e, 0xa1, 0x40, 0xd6, 0x60, 0xc8,
	0x09, 0x3d, 0x07, 0x6d, 0xc3, 0xd7, 0xa7, 0x84, 0xb8, 0xe4, 0x36, 0x68, 0x7c, 0xb3, 0x66, 0xd9,
	0x48, 0xb7, 0xe9, 0x8c, 0x22, 0x3d, 0x8d, 0xb5, 0x99, 0xd0, 0xb6, 0xb7, 0xa0, 0xfc, 0x79, 0x10,
	0xb4, 0x29, 0x0d, 0x69, 0x64, 0x78, 0x5d, 0x79, 0x5f, 0x6f, 0x58, 0x9f, 0x4a, 0x4a, 0x77, 0xbb,
	0x8e, 0xcd, 0x37, 0x15, 0xd4, 0x25, 0x66, 0x70, 0xa0, 0xf1, 0x6f, 0xce, 0x92, 0xf9, 0xbb, 0x64,
	0x89, 0x75, 0x58, 0xce, 0x5e, 0x0d, 0x13, 0xeb, 0x1d, 0x99, 0x17, 0x4f, 0x6d, 0xb8, 0x9d, 0x3c,
	0x2b, 0xec, 0x64, 0x5e, 0x78, 0x20, 0xcb, 0xc8, 0x3b, 0xa0, 0xf5, 0x86, 0x71, 0xa2, 0x51, 0x38,
	0xc6, 0x8d, 0xcd, 0x5c, 0x48, 0x26, 0xd9, 0x82, 0xa5, 0x88, 0x9a, 0x2c, 0x90, 0xfa, 0x7c, 0x6f,
	0xf0, 0x27, 0xee, 0x0f, 0xf3, 0x62, 0x7f, 0x10, 0x70, 0x5b, 0x7d, 0x61, 0x9d, 0xb8, 0x3f, 0x78,
	0xa0, 0x65, 0xae, 0x54, 0x89, 0x15, 0xbb, 0x80, 0x2b, 0xf6, 0xc1, 0xc5, 0x56, 0x6c, 0xa2, 0x34,
	0xc8, 0xa5, 0x3b, 0x21, 0x97, 0xee, 0xae, 0x88, 0x29, 0xc8, 0xd7, 0xa2, 0xbd, 0xd7, 0xd3, 0x9c,
	0x21, 0xfa, 0x57, 0xb9, 0x24, 0x56, 0x5e, 0x0f, 0x86, 0x8e, 0x95, 0x7c, 0x64, 0x58, 0xd0, 0x8c,
	0x31, 0x74, 0x58, 0x79, 0x68, 0x2b, 0x42, 0x99, 0x57, 0xe5, 0xca, 0x35, 0x7b, 0x5d, 0x89, 0x1f,
	0x34, 0x8d, 0xa5, 0x71, 0x28, 0xe4, 0x08, 0x96, 0xf0, 0x85, 0xd6, 0x32, 0x23, 0xfb, 0xd4, 0x4c,
	0x63, 0xa5, 0xaa, 0xc2, 0x93, 0xac, 0x8a, 0xa5, 0xca, 0xf9, 0x00, 0x54, 0xb8, 0x9a, 0x91, 0x59,
	0x42, 0x8e, 0x8d, 0x37, 0x16, 0x4b, 0x18, 0x63, 0xa0, 0xee, 0x33, 0xee, 0xab, 0xb5, 0xb4, 0xcd,
	0x15, 0xc1, 0xb9, 0xfe, 0xe5, 0xef, 0xd8, 0xd2, 0xe8, 0x24, 0xbd, 0x8b, 0x7f, 0xdb, 0x26, 0xfb,
	0x70, 0x23, 0x1d, 0x15, 0xcf, 0x61, 0x8c, 0xda, 0xd9, 0x2b, 0x84, 0xcc, 0xb0, 0xe2, 0x08, 0x4d,
	0xcf, 0xd2, 0x93, 0xc2, 0x2a, 0xb6, 0x7b, 0x35, 0x81, 0xdf, 0x45, 0xf0, 0xf4, 0x76, 0x20, 0x5b,
	0x8f, 0x23, 0x72, 0x92, 0xbb, 0x28, 0x27, 0x86, 0xb9, 0xe5, 0x70, 0x75, 0xb0, 0x2b, 0x6f, 0x3a,
	0x7e, 0xf3, 0x2b, 0xcd, 0xee, 0x53, 0x41, 0x23, 0x7b, 0xcd, 0x2e, 0x5b, 0x4e, 0x36, 0xe0, 0x72,
	0xda, 0xae, 0xd9, 0x89, 0x03, 0x3c, 0xe9, 0x96, 0x91, 0xa5, 0xc2, 0xec, 0x4d, 0xb4, 0xe7, 0xb4,
	0x87, 0xf5, 0x4e, 0x1c, 0xd4, 0x6d, 0x7b, 0x43, 0x82, 0x91, 0xef, 0xc2, 0xb5, 0x1e, 0x2a, 0x36,
	0x8d, 0x4d, 0xab, 0x95, 0x12, 0x5a, 0xca, 0x12, 0xba, 0x9c, 0x23, 0xb4, 0x81, 0xa0, 0x09, 0xad,
	0x0b, 0xa8, 0x51, 0x37, 0x2e, 0xa0, 0x46, 0xe9, 0xf0, 0x36, 0x3b, 0xf1, 0x72, 0x24, 0xd4, 0x35,
	0x88, 0x88, 0x7e, 0xd6, 0xa1, 0x2c, 0x96, 0x24, 0xd1, 0xa2, 0x1e, 0xd7, 0x6b, 0xec, 0xc4, 0xcb,
	0x50, 0x92, 0xd7, 0x1a, 0x74, 0x01, 0x2a, 0xe8, 0x92, 0x9f, 0x02, 0x2d, 0x13, 0x1f, 0x20, 0x96,
	0xde, 0xcd, 0x0b, 0xc6, 0x77, 0xe0, 0xe4, 0x24, 0xe1, 0xf8, 0x72, 0xa9, 0x4c, 0x9b, 0xf9, 0x02,
	0xf2, 0xb3, 0x70, 0x65, 0xd0, 0xc7, 0x7b, 0xa6, 0xbc, 0x22, 0xfb, 0x26, 0xb2, 0xc2, 0x37, 0x2e,
	0xd6, 0xda, 0x46, 0xdf, 0xf8, 0xec, 0x9a, 0xa1, 0xbe, 0x68, 0x0f, 0x2a, 0xc6, 0x31, 0xdb, 0x80,
	0xcb, 0xe8, 0xf6, 0x68, 0xfb, 0xc1, 0xa9, 0x6f, 0xe4, 0xdd, 0x08, 0x8e, 0x5d, 0x79, 0x4b, 0x59,
	0x3a, 0xc8, 0xd0, 0x97, 0x38, 0xe8, 0x33, 0x0e, 0xb9, 0x9b, 0x71, 0x24, 0x6c, 0xdb, 0xe4, 0x63,
	0xb8, 0x92, 0x32, 0x83, 0x15, 0x78, 0xa1, 0x29, 0x22, 0x02, 0x43, 0xea, 0xdb, 0x5c, 0xb4, 0xbf,
	0x9d, 0x65, 0x85, 0x6a, 0x02, 0xba, 0x9e, 0x40, 0x1e, 0x08, 0xc0, 0xbe, 0x5b, 0x4f, 0xcb, 0xfd,
	0xb7, 0x9e, 0xde, 0xef, 0xbd, 0x1a, 0x8c, 0x80, 0xc2, 0x69, 0x90, 0xbb, 0xeb, 0x8b, 0xd0, 0x03,
	0xb7, 0x79, 0xc4, 0x78, 0x77, 0xf0, 0x36, 0x8f, 0x58, 0x37, 0x61, 0xca, 0x75, 0x2c, 0xea, 0x33,
	0x6a, 0x58, 0xae, 0x99, 0xb8, 0x10, 0x26, 0x65, 0xe1, 0x3a, 0x2f, 0x23, 0x1f, 0x41, 0xb5, 0xef,
	0xa2, 0x6b, 0x7a, 0x8c, 0xff, 0x7e, 0x62, 0x23, 0x56, 0x7a, 0xae, 0xbb, 0xa6, 0x67, 0xf8, 0xd7,
	0x61, 0xc2, 0x61, 0x49, 0xe8, 0x37, 0xde, 0x3b, 0x1c, 0xd3, 0xc1, 0x61, 0x2a, 0xbc, 0x9b, 0x1b,
	0xcc, 0x56, 0xe0, 0xc7, 0x51, 0xe0, 0xba, 0x34, 0xe2, 0xda, 0x5d, 0x1a, 0xf8, 0xee, 0x84, 0x78,
	0xdb, 0x70, 0x5c, 0xbf, 0x94, 0x42, 0xbc, 0xf0, 0xd6, 0x54, 0xfd, 0x36, 0x52, 0xa7, 0x67, 0x96,
	0xdb, 0xb1, 0xa9, 0x61, 0x1e, 0x31, 0xbc, 0x23, 0x38, 0xa6, 0x83, 0x2c, 0xaa, 0x1f, 0x31, 0x62,
	0x03, 0xb1, 0x4e, 0x3c, 0x23, 0xa2, 0x2c, 0xe8, 0x44, 0xc9, 0x5d, 0xc2, 0xd5, 0x0b, 0x1e, 0x76,
	0x09, 0xd1, 0x73, 0xe2, 0xe9, 0x12, 0x5d, 0x1c, 0x47, 0x69, 0x56, 0x4f, 0x09, 0xce, 0x97, 0xed,
	0x99, 0xb9, 0xae, 0xb3, 0xca, 0x1d, 0x71, 0xf1, 0x9b, 0xd7, 0x64, 0xfa, 0xcc, 0xc8, 0x9b, 0x50,
	0xee, 0xb4, 0x3a, 0x91, 0x69, 0x74, 0x4e, 0x3c, 0x31, 0x4f, 0x77, 0xc5, 0xd0, 0x63, 0xe9, 0xf3,
	0x13, 0x4f, 0x1e, 0x1f, 0xce, 0x64, 0x54, 0x5e, 0xdf, 0x8c, 0xf9, 0x70, 0xdc, 0x13, 0xfb, 0x43,
	0xa2, 0xed, 0xee, 0x99, 0xf1, 0x76, 0x48, 0x3e, 0x80, 0xd9, 0x1e, 0x50, 0xb4, 0x3a, 0xef, 0x0b,
	0x87, 0x7d, 0x16, 0x18, 0xa3, 0x84, 0x9f, 0x4b, 0x1f, 0x21, 0x1a, 0x2b, 0x0f, 0x2e, 0x18, 0x35,
	0x8f, 0x43, 0xc1, 0xff, 0x0f, 0x43, 0x95, 0xc6, 0xda, 0x3a, 0x3d, 0xee, 0xb8, 0x66, 0x24, 0xbc,
	0x8b, 0xa8, 0xf3, 0xff, 0x00, 0xa6, 0x9b, 0x41, 0xc7, 0xb7, 0x65, 0xb6, 0x01, 0xbf, 0x19, 0xe0,
	0x85, 0xbe, 0x8b, 0x44, 0x19, 0x20, 0xf1, 0xad, 0x04, 0x59, 0x38, 0x84, 0x9b, 0xb9, 0xdf, 0xe4,
	0x05, 0x2c, 0xf7, 0x69, 0x17, 0x72, 0x47, 0x91, 0xa1, 0x9a, 0x29, 0x63, 0x3e, 0xc2, 0x1d, 0xee,
	0xcd, 0x1e, 0x5d, 0x45, 0x08, 0x23, 0xb1, 0x3b, 0xa5, 0x0c, 0x7a, 0x1b, 0x34, 0x2e, 0xf6, 0xa8,
	0xd5, 0x89, 0xa8, 0x71, 0x14, 0x04, 0x31, 0xb5, 0xf1, 0xae, 0x60, 0xb2, 0x96, 0xcb, 0x0e, 0xc3,
	0x1b, 0x1f, 0x74, 0x0d, 0x2b, 0x89, 0x03, 0x0b, 0x7c, 0x2a, 0x7d, 0x6a, 0x1b, 0x41, 0x27, 0x36,
	0x8f, 0x69, 0xb2, 0xa3, 0x7d, 0x78, 0xc1, 0x78, 0x1a, 0xfc, 0xdc, 0x03, 0x41, 0x63, 0x1f, 0x49,
	0xe8, 0x73, 0x61, 0xf6, 0xa7, 0xda, 0xc6, 0x6e, 0xc3, 0x1c, 0xcb, 0xdb, 0x3b, 0xe9, 0x55, 0xc3,
	0x71, 0x7d, 0x86, 0x9d, 0x64, 0xcc, 0x1d, 0x14, 0x75, 0x77, 0x60, 0xbe, 0x15, 0xb0, 0xb8, 0x1f,
	0xe3, 0x1b, 0x88, 0x41, 0x78, 0x65, 0x0f, 0xca, 0x2a, 0xcc, 0xf9, 0xe9, 0x35, 0x9d, 0x4e, 0x44,
	0x6d, 0x1c, 0x48, 0xbc, 0xd4, 0x57, 0xd2, 0x89, 0x9f, 0xdc, 0xbb, 0xe1, 0x55, 0x7c, 0xd8, 0xaa,
	0xbf, 0x53, 0x82, 0x85, 0xc1, 0xfb, 0x31, 0xdf, 0x4a, 0xfa, 0xb4, 0xb8, 0xc2, 0xd7, 0xd0, 0xe2,
	0xfa, 0x15, 0xb7, 0x3f, 0x59, 0x80, 0x59, 0x5c, 0xc4, 0x6a, 0xd6, 0xc5, 0x3a, 0x44, 0x3b, 0xb0,
	0x7c, 0xf7, 0xa3, 0xaf, 0xd0, 0x0a, 0x15, 0x1c, 0xd1, 0x40, 0x3a, 0x4f, 0x66, 0xdb, 0x7d, 0xa9,
	0x0f, 0x22, 0x7d, 0x86, 0xf5, 0xc2, 0xe1, 0xa1, 0x0e, 0x9a, 0xab, 0xb2, 0x03, 0x46, 0xd0, 0xcc,
	0xb3, 0xa3, 0x3c, 0xe5, 0x5b, 0x64, 0x27, 0xde, 0xb6, 0x2d, 0x90, 0xf6, 0x9b, 0x59, 0x16, 0x24,
	0xdb, 0x59, 0x6d, 0xeb, 0x3c, 0x56, 0x1e, 0x42, 0x2a, 0xd7, 0x7a, 0x86, 0xa1, 0x97, 0x89, 0x07,
	0x9b, 0x62, 0xc3, 0x83, 0x4d, 0xb1, 0xea, 0x3f, 0x1a, 0x85, 0xe9, 0x9e, 0x3d, 0x9b, 0x74, 0x01,
	0x12, 0x63, 0x99, 0xca, 0x39, 0x7b, 0xfa, 0x95, 0xb6, 0xff, 0xf4, 0xf7, 0x9e, 0x5c, 0x74, 0xf4,
	0x89, 0xd6, 0xce, 0x14, 0xa2, 0x41, 0x3d, 0xae, 0x0c, 0x6a, 0x4a, 0x56, 0x06, 0x65, 0x42, 0x12,
	0xfe, 0xca, 0xc2, 0x9d, 0x01, 0xc9, 0x90, 0x3e, 0x84, 0xc5, 0xa6, 0xe9, 0xb8, 0x01, 0xdf, 0xe6,
	0xe4, 0xe0, 0x23, 0xd3, 0xa3, 0x28, 0x15, 0x7e, 0x93, 0x05, 0x05, 0x20, 0x06, 0xfe, 0x69, 0xc0,
	0xc4, 0x56, 0x79, 0x06, 0xb3, 0x49, 0x8c, 0x51, 0xe6, 0x73, 0x87, 0xfe, 0x68, 0x3f, 0x57, 0x9f,
	0x51, 0x8d, 0x24, 0x45, 0xc4, 0x03, 0xb0, 0x02, 0x5f, 0x85, 0x42, 0x0c, 0x63, 0x83, 0x7b, 0x5f,
	0xb3, 0xc1, 0xfc, 0x7d, 0x03, 0xaa, 0x8f, 0xf3, 0x16, 0x44, 0x73, 0x77, 0xf8, 0x98, 0x5a, 0x26,
	0x66, 0xd5, 0x8a, 0x28, 0xfa, 0x5f, 0x85, 0xef, 0x47, 0x59, 0x9f, 0x9a, 0xaa, 0xd6, 0x65, 0x2d,
	0x37, 0x89, 0x30, 0x90, 0x53, 0x5a, 0x24, 0x32, 0x71, 0x83, 0xf3, 0x39, 0x15, 0xbe, 0xc8, 0x31,
	0x7d, 0xde, 0x61, 0x4f, 0x65, 0xed, 0x8b, 0xb4, 0x92, 0x9b, 0x31, 0x7c, 0x8b, 0xcd, 0x08, 0x5b,
	0x74, 0x2f, 0x8c, 0xe9, 0x65, 0xeb, 0xc4, 0xcb, 0x98, 0x7a, 0xb5, 0xbf, 0x54, 0x04, 0xd2, 0x3f,
	0x58, 0xe8, 0x37, 0xee, 0xe1, 0x0e, 0xad, 0x40, 0xae, 0x40, 0x85, 0x9b, 0xd3, 0x94, 0x9b, 0x1f,
	0x3d, 0xf6, 0xa2, 0x56, 0x24, 0x97, 0xe1, 0x92, 0xa8, 0xa5, 0x76, 0x6f, 0x65, 0x89, 0x54, 0x61,
	0x41, 0x9e, 0xfc, 0x50, 0x7b, 0x2b, 0x88, 0x9e, 0xd6, 0xb7, 0x24, 0x33, 0x68, 0x43, 0xe4, 0x5d,
	0x78, 0xfb, 0x3c, 0xb2, 0x5b, 0x51, 0xe0, 0x65, 0x60, 0x87, 0xb1, 0x11, 0x41, 0xc7, 0xf1, 0x8f,
	0xf3, 0x84, 0x46, 0xd0, 0x7d, 0x9d, 0x16, 0x08, 0x36, 0xd3, 0x46, 0x7b, 0x8a, 0xc5, 0x75, 0x5a,
	0x6d, 0x0c, 0xbf, 0xf1, 0x69, 0xfd, 0x29, 0x35, 0x5d, 0xc7, 0x3f, 0x96, 0xc0, 0xe3, 0xf9, 0x52,
	0x09, 0x0b, 0xb5, 0x6f, 0x41, 0xe5, 0xbc, 0x19, 0x26, 0x33, 0x30, 0xd5, 0xde, 0x70, 0x98, 0xbc,
	0xa1, 0x82, 0x7e, 0xf4, 0x32, 0x80, 0xba, 0x78, 0x42, 0x6d, 0xad, 0x58, 0xfd, 0xd5, 0x02, 0xcc,
	0x0f, 0x54, 0x91, 0xc9, 0x37, 0xa1, 0x7a, 0xbe, 0x09, 0x22, 0x23, 0x58, 0x2a, 0xe7, 0x59, 0x1f,
	0x5f, 0xef, 0x60, 0xe3, 0x36, 0x68, 0xbd, 0x6a, 0x14, 0xb9, 0x0c, 0xe3, 0x49, 0xdc, 0x3c, 0x0a,
	0x9c, 0x21, 0x7d, 0xcc, 0x93, 0x21, 0xf1, 0xd5, 0xff, 0xaa, 0x00, 0xe5, 0xbc, 0x42, 0x40, 0x9e,
	0x41, 0xcd, 0xf1, 0x59, 0x6c, 0xba, 0x2e, 0x46, 0x88, 0xe0, 0x8d, 0xec, 0x54, 0xdf, 0x50, 0xc6,
	0xb8, 0x70, 0xbe, 0x5e, 0x4f, 0x20, 0x9f, 0x33, 0x9c, 0x3c, 0x05, 0xa7, 0x8c, 0xf3, 0x4d, 0xb8,
	0xde, 0x4b, 0x2c, 0x6c, 0x05, 0xd4, 0x77, 0xce, 0x12, 0x4a, 0xe2, 0x93, 0xae, 0xe4, 0x29, 0x1d,
	0x08, 0x20, 0x45, 0xe6, 0x03, 0x20, 0x03, 0xfa, 0x20, 0x64, 0xd0, 0x4c, 0xb3, 0xb7, 0xd5, 0xaa,
	0x09, 0x53, 0xb9, 0x6d, 0x1f, 0x0f, 0x93, 0xf0, 0xac, 0x06, 0xb7, 0xdc, 0x82, 0x48, 0xba, 0x84,
	0x25, 0x5c, 0xdc, 0x91, 0x45, 0x18, 0xa3, 0xbe, 0xdc, 0x8f, 0xc5, 0x79, 0xc4, 0x28, 0xf5, 0x71,
	0x13, 0x26, 0x0b, 0x30, 0x22, 0xfd, 0x15, 0xa2, 0x35, 0xf9, 0xab, 0xb6, 0x0d, 0x23, 0x52, 0xa2,
	0x4f, 0x80, 0xf2, 0x5e, 0x6a, 0x6f, 0x10, 0x0d, 0x26, 0xdb, 0x87, 0xc1, 0x9a, 0x70, 0x4e, 0x22,
	0xdf, 0x10, 0x28, 0xb7, 0xf7, 0x73, 0x65, 0x45, 0x0c, 0x96, 0xd9, 0xa3, 0xa7, 0x7b, 0xb8, 0x8e,
	0x6a, 0xbf, 0x5b, 0x80, 0xf2, 0x5e, 0xde, 0xa1, 0xb9, 0x00, 0xa4, 0x2d, 0x4f, 0x9c, 0x39, 0xae,
	0xc0, 0xd4, 0x0a, 0xa4, 0x02, 0x73, 0xe9, 0xa9, 0x4d, 0xa6, 0x46, 0x23, 0x8b, 0x30, 0xd7, 0xfe,
	0x54, 0xf9, 0xaf, 0x32, 0x35, 0x5f, 0x14, 0xb1, 0x2a, 0xe1, 0xf4, 0x6c, 0xd5, 0x12, 0xb9, 0x04,
	0x33, 0xed, 0x5d, 0x0c, 0x91, 0xcb, 0x96, 0x7f, 0x31, 0x44, 0x2a, 0x40, 0xda, 0x1f, 0x53, 0x9f,
	0xb2, 0x3c, 0xc6, 0x17, 0x1f, 0x91, 0x39, 0x28, 0xb7, 0xeb, 0xae, 0x9b, 0x29, 0xfd, 0x95, 0xdf,
	0xdc, 0xa8, 0xfd, 0x95, 0x22, 0x4c, 0xf7, 0xe8, 0x14, 0x64, 0x1a, 0xb2, 0xbe, 0x21, 0xed, 0x0d,
	0x32, 0x0b, 0xd3, 0xed, 0xad, 0x20, 0x3a, 0x35, 0x23, 0x6e, 0xa0, 0x61, 0x61, 0x81, 0x2c, 0xc2,
	0x3c, 0x8e, 0x8e, 0xb0, 0xe3, 0xa9, 0xcd, 0xc5, 0x03, 0xd7, 0x09, 0xb4, 0x22, 0x0a, 0x98, 0x35,
	0xea, 0xf8, 0xc7, 0x7d, 0x75, 0x25, 0x14, 0x00, 0x7d, 0xc5, 0x43, 0xe4, 0x2a, 0x2c, 0xe2, 0xe1,
	0xd8, 0x86, 0x88, 0x9e, 0xda, 0x0b, 0x4e, 0xb7, 0xfd, 0x83, 0x88, 0xee, 0x38, 0xde, 0x51, 0xa0,
	0x0d, 0xa3, 0x24, 0xe0, 0x8d, 0xd5, 0x6d, 0x9b, 0xda, 0x87, 0x98, 0x33, 0x40, 0x1b, 0x21, 0xd7,
	0xa0, 0x8a, 0xa5, 0x5b, 0x41, 0x64, 0xf5, 0xf7, 0x63, 0x14, 0xcf, 0xd6, 0x94, 0x95, 0xaa, 0xd3,
	0xd0, 0x74, 0xa2, 0x8d, 0xc0, 0xa7, 0xda, 0x18, 0x4a, 0xae, 0x7c, 0x05, 0xb7, 0xf8, 0xf1, 0x8c,
	0x6c, 0x1c, 0xbb, 0xa2, 0x2a, 0x1b, 0x2d, 0xf1, 0xcd, 0x49, 0x35, 0xd4, 0x7e, 0xbf, 0x08, 0xd5,
	0xf3, 0xf5, 0x23, 0x6c, 0xb3, 0x5f, 0x43, 0xd2, 0xde, 0xc0, 0x0f, 0x4f, 0xf0, 0xa4, 0x57, 0x53,
	0x2b, 0x20, 0xe3, 0x65, 0x98, 0x48, 0x2b, 0x92, 0x25, 0xb8, 0x22, 0x47, 0x68, 0xa3, 0x43, 0x0f,
	0x83, 0xad, 0x48, 0x04, 0xb5, 0xf1, 0x7d, 0xc8, 0x8c, 0x62, 0xa6, 0x95, 0xb0, 0xfb, 0x19, 0x08,
	0x19, 0x23, 0xb5, 0x11, 0x9c, 0xfa, 0xda, 0x10, 0x8a, 0x40, 0x1c, 0x10, 0x5b, 0x80, 0x68, 0xc3,
	0x72, 0xaf, 0xe0, 0x36, 0x71, 0xf2, 0x5d, 0x7c, 0x4b, 0xdb, 0xb3, 0x5c, 0x47, 0x1b, 0x41, 0xa6,
	0x96, 0x9e, 0x1d, 0x6d, 0x14, 0xfb, 0x23, 0x42, 0x03, 0xf0, 0xe6, 0xbf, 0x36, 0x86, 0xd8, 0x49,
	0xc7, 0xb9, 0x30, 0x8e, 0x5b, 0x32, 0x68, 0x9c, 0x69, 0xe3, 0x08, 0x9f, 0x49, 0xe3, 0xa0, 0x81,
	0x90, 0xc1, 0x99, 0xcb, 0xc9, 0xda, 0x04, 0xb2, 0x3f, 0xf6, 0x29, 0x3f, 0xe8, 0xda, 0x24, 0x36,
	0xfe, 0xdc, 0x47, 0xcf, 0x83, 0x36, 0x45, 0xa6, 0x60, 0x1c, 0x1b, 0xdf, 0xea, 0xb8, 0xae, 0x56,
	0xae, 0xdd, 0x85, 0x31, 0x65, 0x51, 0x21, 0xa0, 0xb4, 0xa9, 0xe4, 0x7a, 0xaa, 0xb7, 0x4e, 0xf6,
	0x28, 0xdf, 0x5b, 0x44, 0x2c, 0x3f, 0xff, 0x3c, 0xad, 0x58, 0xfd, 0xa7, 0xc5, 0x24, 0xda, 0xed,
	0x20, 0x08, 0xdc, 0x6c, 0x34, 0x22, 0x66, 0xfc, 0x1b, 0x10, 0x8d, 0xc8, 0xe1, 0xd0, 0xb3, 0xff,
	0x36, 0x4c, 0xe7, 0x60, 0x51, 0x6e, 0x17, 0x97, 0x4b, 0xfa, 0x54, 0x06, 0x72, 0xdb, 0xce, 0x86,
	0xbc, 0x95, 0xf0, 0xba, 0xa8, 0x0a, 0x79, 0xcb, 0x45, 0x6d, 0x0d, 0xf5, 0x44, 0x6d, 0x6d, 0xc1,
	0x35, 0xc7, 0xf5, 0x0c, 0x1b, 0x9d, 0x2c, 0xe2, 0xec, 0xd5, 0x08, 0xad, 0x4c, 0xf4, 0xb2, 0x38,
	0x06, 0xc5, 0x10, 0xfd, 0xaa, 0xe3, 0x7a, 0x7c, 0x3e, 0xe5, 0x19, 0xed, 0x81, 0x95, 0xc6, 0x2d,
	0x93, 0x8f, 0x61, 0x29, 0x0e, 0xf8, 0x26, 0xe5, 0x78, 0xa1, 0xeb, 0x58, 0x4e, 0x2c, 0x63, 0x3d,
	0xa8, 0x8d, 0x31, 0xec, 0x96, 0x13, 0x77, 0x65, 0x68, 0xdb, 0x55, 0x84, 0xdb, 0x96, 0x60, 0x6a,
	0xcb, 0x5f, 0x97, 0x40, 0x7d, 0x43, 0x83, 0x1b, 0xd5, 0xa8, 0x74, 0xd6, 0xa6, 0x1f, 0x8c, 0x8a,
	0x61, 0x2e, 0x8e, 0x67, 0x0c, 0x8d, 0xa5, 0x24, 0x8e, 0xa7, 0xfa, 0x3f, 0x0c, 0x81, 0xd6, 0x77,
	0x11, 0xd2, 0x80, 0xe9, 0xcc, 0x7d, 0xcb, 0xe4, 0xe0, 0xaf, 0x7c, 0x77, 0x29, 0xd1, 0xea, 0xf8,
	0x82, 0x3f, 0xcc, 0xe5, 0x46, 0x5d, 0x41, 0xeb, 0x79, 0xae, 0x9d, 0x52, 0xab, 0x6f, 0x36, 0xee,
	0x3e, 0x78, 0xb8, 0x7e, 0xa8, 0xeb, 0xe5, 0x94, 0x1c, 0x72, 0x84, 0x0b, 0x5a, 0xa6, 0x01, 0x3c,
	0xcb, 0x93, 0x56, 0x4e, 0xfd, 0xb5, 0xef, 0x73, 0x66, 0x0a, 0x1a, 0x9c, 0x90, 0x9e, 0xe9, 0x3b,
	0x16, 0x90, 0x1a, 0x4c, 0x59, 0x4e, 0xd8, 0xa2, 0x78, 0x9c, 0xa4, 0x82, 0x14, 0x27, 0xf5, 0x09,
	0x51, 0xf8, 0x8c, 0x76, 0xb7, 0x6d, 0xcc, 0x25, 0x95, 0xc2, 0x24, 0xf1, 0xb4, 0x9c, 0x11, 0xa6,
	0xf4, 0x99, 0x04, 0x52, 0x5d, 0x61, 0xe0, 0x0a, 0x87, 0x6c, 0x06, 0x23, 0x43, 0xd5, 0x2d, 0x36,
	0x79, 0x8f, 0x6a, 0x18, 0xd1, 0x2a, 0x09, 0x44, 0x72, 0xf5, 0x4c, 0x5e, 0xa5, 0xaa, 0xc1, 0x78,
	0x52, 0x97, 0x53, 0x5d, 0xd3, 0xe2, 0xda, 0x6d, 0x98, 0xee, 0xf9, 0x32, 0x5c, 0x48, 0x32, 0x48,
	0x59, 0x7b, 0x43, 0x69, 0x47, 0x22, 0xfe, 0x59, 0x2b, 0xd4, 0x7e, 0xad, 0x00, 0x73, 0x29, 0x46,
	0xd2, 0x24, 0xc3, 0x75, 0x2e, 0x6e, 0xa4, 0xa3, 0xec, 0x50, 0x92, 0x6b, 0xab, 0xa1, 0x96, 0xb4,
	0x56, 0xc4, 0xe3, 0x4b, 0x74, 0xb0, 0x4b, 0x31, 0xc4, 0x6b, 0x45, 0xec, 0x5d, 0x7d, 0x47, 0x1b,
	0xc3, 0x1d, 0x35, 0x17, 0x9b, 0xa0, 0x69, 0x08, 0x96, 0x4d, 0x02, 0xa6, 0x2d, 0x21, 0x58, 0xdd,
	0x75, 0xd3, 0xb6, 0xb5, 0xef, 0x54, 0xff, 0x9f, 0x19, 0x98, 0x4e, 0xba, 0x29, 0x19, 0x6c, 0x15,
	0x48, 0x24, 0x63, 0x1f, 0x38, 0x03, 0x34, 0x4d, 0x2b, 0x0e, 0x44, 0xb4, 0xc2, 0xf0, 0x93, 0xc2,
	0x5d, 0x7d, 0x26, 0x53, 0xb9, 0x85, 0x75, 0xe4, 0x06, 0x4c, 0xd2, 0xc8, 0x64, 0x1d, 0x3c, 0x4f,
	0xb0, 0xa9, 0x3a, 0x67, 0x96, 0x65, 0xeb, 0x81, 0x4d, 0xc9, 0x47, 0x70, 0x35, 0x8c, 0x68, 0x93,
	0x46, 0x46, 0xcb, 0x39, 0xe6, 0x33, 0x49, 0x2d, 0x99, 0x6f, 0x4b, 0xdc, 0x60, 0x92, 0x39, 0x13,
	0x17, 0x05, 0xd0, 0x53, 0x84, 0xd9, 0xb4, 0x30, 0x8b, 0x96, 0xb8, 0xba, 0x44, 0x5a, 0xfd, 0x7c,
	0x2f, 0x4e, 0x56, 0xbf, 0x73, 0xf1, 0x4c, 0xa0, 0x7d, 0x4c, 0x89, 0x87, 0xfa, 0xbd, 0x0b, 0xe0,
	0x87, 0x30, 0xd3, 0x7f, 0xa3, 0x79, 0xf1, 0xab, 0xde, 0x68, 0xce, 0x2c, 0x26, 0x39, 0xc0, 0x6d,
	0xd0, 0x32, 0x69, 0x77, 0xb2, 0xc1, 0xd3, 0x1f, 0xbd, 0xf6, 0xa7, 0x64, 0xb2, 0xf4, 0xe0, 0xb7,
	0x4c, 0x5b, 0xf9, 0x02, 0x6e, 0xa1, 0xe7, 0x52, 0xdc, 0x66, 0x8f, 0x84, 0xb5, 0x6c, 0x1a, 0x5b,
	0x95, 0x8a, 0x36, 0x8d, 0x1b, 0xc7, 0x28, 0x73, 0x31, 0x21, 0x94, 0x5b, 0x57, 0xe2, 0x68, 0x78,
	0x41, 0x85, 0x8f, 0x1f, 0x3a, 0x34, 0x3a, 0x48, 0x6a, 0x49, 0x1d, 0xae, 0xe6, 0x83, 0xc8, 0x7b,
	0xd1, 0x47, 0x11, 0xbd, 0x9a, 0x8d, 0x25, 0xef, 0x21, 0x91, 0x48, 0x60, 0x7a, 0x76, 0xae, 0x04,
	0x1e, 0xcb, 0x48, 0xe0, 0xcd, 0xb3, 0x73, 0x24, 0xf0, 0x0d, 0x98, 0xf4, 0xcc, 0xb3, 0x14, 0x69,
	0x5c, 0x44, 0x48, 0x7b, 0xe6, 0x59, 0x02, 0x72, 0x11, 0x69, 0x0f, 0x17, 0x91, 0xf6, 0x8f, 0x61,
	0x9e, 0xb7, 0x95, 0xcd, 0x46, 0x91, 0x9e, 0x32, 0x0f, 0x3f, 0x19, 0xbe, 0xb3, 0x7a, 0xf7, 0xfe,
	0xaa, 0x4e, 0x3c, 0xf3, 0x2c, 0x93, 0x7d, 0x02, 0x0f, 0x8f, 0x1f, 0xc1, 0xbc, 0xe7, 0xf8, 0x03,
	0x30, 0x31, 0x84, 0xf8, 0xc9, 0xd0, 0xfd, 0xd5, 0x0f, 0x1f, 0xea, 0xc4, 0x73, 0xfc, 0x5e, 0xc4,
	0x6f, 0xc0, 0x25, 0xc7, 0xa6, 0xa6, 0x3b, 0x00, 0x75, 0x4a, 0xa0, 0x3e, 0xbe, 0xf3, 0xe1, 0x5d,
	0x7d, 0x0e, 0x81, 0x7a, 0x91, 0x9f, 0x40, 0xb5, 0x6f, 0xbb, 0xe4, 0x8a, 0xbe, 0xb8, 0x69, 0x54,
	0x5e, 0x2a, 0xe1, 0x65, 0x9c, 0xdc, 0x36, 0xc9, 0x15, 0x7f, 0xbc, 0x66, 0xf4, 0x09, 0x4c, 0x8a,
	0x83, 0x40, 0xb9, 0x28, 0xa6, 0x7b, 0x8e, 0xa9, 0xfb, 0x13, 0xe6, 0xae, 0x48, 0x3e, 0x45, 0xb9,
	0x24, 0x57, 0xc4, 0x44, 0x90, 0xfe, 0x38, 0x37, 0x67, 0xab, 0x76, 0x6e, 0xce, 0xd6, 0x10, 0x2e,
	0xe1, 0x39, 0x0a, 0xfa, 0xe6, 0xd5, 0x61, 0x48, 0xe0, 0x3a, 0x56, 0x17, 0x8f, 0xa6, 0xb3, 0xb7,
	0xcb, 0xcf, 0xef, 0x0f, 0xdf, 0x22, 0xd7, 0x53, 0x02, 0x07, 0x88, 0xaf, 0x63, 0xf8, 0x77, 0x5f,
	0x31, 0x79, 0x06, 0xd7, 0xf3, 0xac, 0xcd, 0x27, 0x3c, 0x92, 0xaa, 0xab, 0xe1, 0x04, 0x21, 0xc3,
	0x43, 0xef, 0xe1, 0x27, 0xc3, 0xf7, 0x1e, 0xae, 0xae, 0xae, 0xea, 0x97, 0xb3, 0x3c, 0xbe, 0x6b,
	0x9e, 0x29, 0x2d, 0x77, 0x3b, 0x08, 0x19, 0x59, 0x87, 0xcb, 0xe9, 0x12, 0xeb, 0x27, 0x34, 0x9b,
	0x25, 0x74, 0x49, 0xad, 0xb5, 0x5e, 0x22, 0xab, 0x30, 0x97, 0xcd, 0x02, 0x19, 0xf8, 0xc6, 0x69,
	0xe4, 0xc4, 0xea, 0xb0, 0x9c, 0x64, 0xea, 0xf6, 0xfd, 0x97, 0xbc, 0x86, 0x3c, 0x81, 0x45, 0xd3,
	0x3e, 0xe1, 0xd6, 0x35, 0xcb, 0xb0, 0xb8, 0x0c, 0xba, 0x5b, 0x40, 0x46, 0xbf, 0x94, 0x02, 0x28,
	0xee, 0x16, 0x71, 0x7a, 0xb7, 0x60, 0x5a, 0x8e, 0xa8, 0x0a, 0xea, 0xc4, 0x68, 0xe8, 0x31, 0xbd,
	0x2c, 0x8b, 0x65, 0x48, 0x27, 0xf9, 0xad, 0x02, 0x2c, 0x45, 0x34, 0xee, 0x44, 0xbe, 0x61, 0xc6,
	0x71, 0xe4, 0x1c, 0x75, 0x62, 0xca, 0x78, 0xef, 0x22, 0x6a, 0xda, 0xb6, 0x13, 0x85, 0x6e, 0x87,
	0xe1, 0xb1, 0x75, 0xf9, 0xae, 0xfe, 0xda, 0xa2, 0x4e, 0x17, 0x34, 0x0e, 0xdc, 0x0e, 0xd3, 0x29,
	0x0b, 0x03, 0x9f, 0xd1, 0x7a, 0xd2, 0x08, 0xea, 0x37, 0x53, 0xed, 0xbd, 0x20, 0x2d, 0xd2, 0xaf,
	0x8a, 0xae, 0xa4, 0x25, 0xfb, 0xbe, 0x9e, 0xf6, 0x83, 0x5c, 0x87, 0x09, 0x33, 0x93, 0x2d, 0xf1,
	0xb2, 0x38, 0xc3, 0x31, 0xd3, 0xf4, 0x88, 0xef, 0xc2, 0x8c, 0xe3, 0x63, 0x94, 0x0c, 0xa6, 0x35,
	0x11, 0x60, 0x57, 0x44, 0x38, 0x82, 0xa8, 0xd8, 0xb4, 0x14, 0xec, 0x7d, 0x58, 0xf0, 0x68, 0x74,
	0x4c, 0x6d, 0xe3, 0x04, 0x83, 0x6b, 0x53, 0xba, 0x22, 0x62, 0x7a, 0x4e, 0xd4, 0xbe, 0x10, 0x95,
	0x0a, 0xeb, 0x5b, 0x70, 0x59, 0xee, 0xa6, 0x69, 0x3e, 0x30, 0xc9, 0xcb, 0x86, 0x8c, 0xa3, 0x2e,
	0xe9, 0x15, 0x09, 0x92, 0x64, 0xff, 0x12, 0x5c, 0xb9, 0x6d, 0xa3, 0xb4, 0x1e, 0x80, 0x2e, 0x34,
	0xec, 0xeb, 0x32, 0x93, 0x6c, 0x1f, 0x32, 0xaa, 0xda, 0xef, 0x80, 0xd6, 0xf1, 0x6d, 0x1a, 0x89,
	0x1c, 0xfa, 0x22, 0x22, 0x63, 0x49, 0x7c, 0x1a, 0x96, 0x1f, 0x26, 0xc5, 0xb5, 0x65, 0x28, 0xe7,
	0x37, 0x4c, 0x8c, 0xb2, 0x7a, 0x49, 0xcd, 0xb6, 0xf6, 0x06, 0x1a, 0xfb, 0x8d, 0x38, 0x0a, 0xfc,
	0x63, 0xad, 0x50, 0xfb, 0x98, 0x2b, 0x13, 0xf9, 0xed, 0x87, 0x80, 0x48, 0x85, 0xab, 0xfd, 0xa1,
	0xfa, 0x9f, 0xb8, 0x0c, 0xb3, 0x13, 0x9c, 0x4a, 0xec, 0x5d, 0x6a, 0x3b, 0x1d, 0x4f, 0x2b, 0x88,
	0xd8, 0x2d, 0xe7, 0xb8, 0xa5, 0x15, 0x6b, 0xc7, 0x70, 0xe3, 0x95, 0xb3, 0x2d, 0x34, 0xa1, 0xcc,
	0x7c, 0x6b, 0x6f, 0x28, 0x15, 0x27, 0x53, 0x56, 0x40, 0xa3, 0x6e, 0xdf, 0x77, 0xbb, 0xcf, 0xc3,
	0xc3, 0x60, 0xc3, 0x8c, 0x33, 0x54, 0xb4, 0x62, 0xf5, 0x0f, 0x4b, 0x30, 0x9e, 0xf0, 0x19, 0x79,
	0x2b, 0x9b, 0x6b, 0x3c, 0x63, 0xd0, 0xa4, 0xf9, 0xc3, 0x71, 0x93, 0xbc, 0x01, 0x93, 0xb9, 0xcc,
	0x3e, 0xc2, 0x96, 0x99, 0xb0, 0x32, 0xf9, 0x7c, 0xee, 0x80, 0x26, 0x32, 0x43, 0xcb, 0xa8, 0x6f,
	0x2e, 0x9a, 0x31, 0x86, 0xf3, 0xc9, 0xe8, 0x9d, 0xd5, 0xfb, 0x8f, 0x1f, 0x3c, 0x7a, 0xa8, 0x97,
	0x11, 0x40, 0x44, 0xdd, 0x72, 0xb9, 0xfc, 0x2e, 0x4c, 0xb2, 0x38, 0x72, 0x42, 0x6a, 0x9c, 0x3a,
	0x36, 0xde, 0xc3, 0xc9, 0x81, 0x4f, 0x88, 0xca, 0x97, 0xbc, 0x6e, 0x90, 0x41, 0x35, 0x8c, 0x06,
	0x53, 0x8f, 0x41, 0xf5, 0x14, 0x46, 0xa4, 0xa4, 0x1e, 0xb9, 0x68, 0x06, 0xbd, 0xfc, 0xa2, 0xd3,
	0x25, 0x7e, 0xde, 0x02, 0x1b, 0xed, 0xb1, 0xc0, 0x1e, 0xc1, 0x90, 0x1b, 0x58, 0x4c, 0x26, 0xa0,
	0xbf, 0x99, 0x6f, 0x44, 0xde, 0xae, 0x4e, 0xd2, 0x5b, 0xad, 0xf3, 0x2f, 0xd6, 0x11, 0x21, 0x3f,
	0xe0, 0x68, 0x02, 0x8d, 0x8b, 0x78, 0xb2, 0xa4, 0x14, 0x8d, 0xa4, 0x81, 0x06, 0x95, 0x08, 0xfe,
	0xec, 0x33, 0xa8, 0xe6, 0x61, 0xa8, 0xc9, 0x1c, 0x5b, 0xee, 0xbe, 0x85, 0x55, 0x1d, 0x7f, 0x92,
	0x4b, 0x30, 0x4c, 0xc3, 0xc0, 0x6a, 0xc9, 0xbd, 0xb5, 0xb0, 0xaa, 0x8b, 0xdf, 0xd5, 0xff, 0x66,
	0x18, 0xb4, 0x5e, 0xd7, 0xe1, 0x97, 0x04, 0xb0, 0x09, 0x86, 0x18, 0x1c, 0xc0, 0x96, 0x8f, 0x94,
	0x2d, 0xf6, 0x46, 0xca, 0x5e, 0x86, 0x71, 0xcc, 0x08, 0x82, 0x74, 0x4a, 0x69, 0x04, 0xee, 0x5e,
	0x6f, 0x04, 0xee, 0x50, 0x4f, 0x04, 0xee, 0x1f, 0x1b, 0xd4, 0x1b, 0xd4, 0x1a, 0x87, 0x2f, 0xa8,
	0x35, 0xf6, 0x7e, 0x60, 0x26, 0x3d, 0x06, 0x0a, 0xce, 0xe1, 0xf6, 0x5e, 0xc7, 0x75, 0xfb, 0x3f,
	0x0b, 0xd7, 0xd9, 0x79, 0xe1, 0x3c, 0x23, 0xe7, 0x86, 0xf3, 0x7c, 0x0b, 0x2e, 0x87, 0x26, 0x06,
	0xef, 0x0f, 0x44, 0x1c, 0x15, 0x62, 0x4d, 0x80, 0xec, 0xf6, 0xa3, 0x9f, 0x1f, 0x57, 0x30, 0xf6,
	0x25, 0x71, 0x05, 0x75, 0xb8, 0x7a, 0x6e, 0xa3, 0x19, 0xd6, 0xaa, 0x0e, 0x6e, 0x16, 0x49, 0x3c,
	0x81, 0xc5, 0x7e, 0x5c, 0xe5, 0x5c, 0x15, 0xf1, 0x85, 0x97, 0x7a, 0xdb, 0x96, 0x2e, 0xd6, 0xda,
	0x8f, 0x0a, 0x50, 0xce, 0x8f, 0x2a, 0x4a, 0xb7, 0x17, 0xbb, 0xa7, 0x66, 0x44, 0x65, 0xc0, 0xea,
	0xf7, 0xa8, 0xaf, 0x15, 0xb0, 0x58, 0x40, 0xca, 0xeb, 0x80, 0xcf, 0x4e, 0x3c, 0xad, 0x84, 0x2e,
	0xce, 0xba, 0x67, 0x7e, 0x1e, 0xf8, 0x2f, 0xe9, 0x91, 0x4a, 0xc9, 0xa7, 0xd9, 0x64, 0x0a, 0xc6,
	0xda, 0x2f, 0xd6, 0xa9, 0xcf, 0xed, 0xca, 0xdf, 0x1f, 0x25, 0xd3, 0x00, 0xa9, 0xf3, 0x52, 0xfb,
	0x5f, 0x46, 0xc9, 0x04, 0x8c, 0xb4, 0x1b, 0xeb, 0x2f, 0x76, 0x77, 0xb5, 0x7f, 0x32, 0x4a, 0x00,
	0xc4, 0x54, 0x6a, 0x3f, 0xda, 0xab, 0xbe, 0x0d, 0xc3, 0x98, 0xf9, 0xbf, 0x27, 0x1a, 0x54, 0x70,
	0x70, 0x1a, 0x0d, 0x5a, 0xfd, 0x5b, 0xef, 0x01, 0xa4, 0x59, 0xfd, 0xf9, 0xb6, 0x28, 0x73, 0x01,
	0x67, 0xc0, 0x41, 0x14, 0x21, 0xab, 0xde, 0x83, 0x05, 0x09, 0xa0, 0x32, 0x95, 0xa8, 0xc3, 0xde,
	0x22, 0x2e, 0xc9, 0x59, 0x51, 0xbb, 0x2e, 0x2a, 0xe5, 0x69, 0xef, 0x23, 0xa8, 0xf4, 0x20, 0xe1,
	0xfd, 0x78, 0x44, 0x2b, 0xa1, 0xce, 0x39, 0x9f, 0x43, 0x3b, 0x08, 0x22, 0x91, 0x0a, 0x86, 0xdb,
	0x96, 0x22, 0x5b, 0x05, 0x86, 0x5e, 0x4b, 0xef, 0xcf, 0x84, 0x28, 0xc3, 0xc0, 0x5f, 0x2e, 0x1e,
	0xf0, 0x50, 0xc9, 0x90, 0x99, 0xbd, 0xa5, 0x85, 0x83, 0xe2, 0x01, 0x2b, 0x5e, 0x60, 0x79, 0x72,
	0x31, 0x56, 0xf4, 0x23, 0x0b, 0x3c, 0x22, 0x23, 0x26, 0xb0, 0x26, 0x03, 0xfd, 0x0e, 0xcc, 0x70,
	0x0d, 0x0d, 0x95, 0x24, 0x4c, 0x0a, 0xc3, 0xa8, 0x25, 0xae, 0x86, 0xea, 0x65, 0xcf, 0x3c, 0x43,
	0xed, 0xe8, 0x80, 0x46, 0x0d, 0x6a, 0xf5, 0x3c, 0x63, 0x30, 0xd6, 0xfb, 0x8c, 0xc1, 0xf9, 0x6f,
	0x23, 0x8c, 0x7f, 0xc9, 0xdb, 0x08, 0xf7, 0x60, 0xc1, 0xa7, 0x5c, 0x5d, 0x4b, 0x28, 0x1b, 0x9d,
	0xd0, 0x36, 0x63, 0x75, 0x75, 0x71, 0x96, 0xd7, 0xae, 0xab, 0x46, 0x9e, 0x63, 0x55, 0x5e, 0x54,
	0x4f, 0xf4, 0x88, 0xea, 0x07, 0x78, 0xd8, 0x66, 0x77, 0xe4, 0xdd, 0x86, 0x0c, 0x65, 0x94, 0x8c,
	0x63, 0xfa, 0x9c, 0xc3, 0x36, 0x54, 0x6d, 0x42, 0x59, 0x24, 0xb6, 0x4b, 0x9e, 0xcc, 0xe0, 0xba,
	0x1d, 0x0e, 0x9c, 0x71, 0x42, 0x2d, 0x7c, 0xe3, 0x62, 0x5c, 0xcf, 0x3c, 0xa9, 0xc1, 0x77, 0x58,
	0x3e, 0x7c, 0x2f, 0xa8, 0xc5, 0x55, 0x94, 0x5e, 0xc4, 0x13, 0xd3, 0xed, 0x08, 0xcc, 0xb2, 0x30,
	0x28, 0xf3, 0x98, 0x2f, 0x78, 0x35, 0x47, 0xed, 0xc0, 0x7c, 0xd6, 0x4c, 0x36, 0xdd, 0xe3, 0x20,
	0x72, 0xe2, 0x96, 0x87, 0x56, 0xc7, 0x45, 0xa4, 0x5e, 0xca, 0xd4, 0x59, 0x33, 0xb9, 0xae, 0xe8,
	0xe8, 0x73, 0xd6, 0x80, 0xd2, 0x81, 0xd6, 0xb9, 0xf6, 0x2f, 0xcb, 0x3a, 0xbf, 0xd5, 0xff, 0x36,
	0x8e, 0x08, 0xaf, 0xed, 0x7d, 0x03, 0xe7, 0x27, 0x61, 0x32, 0x97, 0x48, 0x83, 0x5c, 0x30, 0x8f,
	0x56, 0x76, 0x0c, 0xb2, 0xb9, 0x34, 0x72, 0xd4, 0x30, 0x32, 0x88, 0x51, 0x83, 0xb1, 0x96, 0x11,
	0x77, 0x7c, 0x9f, 0xba, 0x68, 0x86, 0xc8, 0x94, 0x2e, 0xac, 0x75, 0x88, 0x65, 0x64, 0x57, 0x5d,
	0xa5, 0x90, 0x8f, 0x6a, 0x94, 0xbe, 0x42, 0x88, 0xb2, 0xb8, 0x40, 0x81, 0x2b, 0x7b, 0x40, 0x72,
	0xe6, 0xf9, 0xd7, 0x4e, 0xce, 0xbc, 0x0a, 0x73, 0x2c, 0x8e, 0x68, 0x6c, 0xb5, 0x0c, 0x87, 0x19,
	0x1d, 0xbf, 0x85, 0x7e, 0xf4, 0x2e, 0x5a, 0x34, 0x63, 0x3a, 0x91, 0x75, 0xdb, 0xec, 0xb9, 0xaa,
	0xc1, 0x90, 0xe5, 0xcc, 0xe3, 0x27, 0xb8, 0x35, 0x5c, 0x52, 0xb9, 0xfc, 0xd5, 0x60, 0xe1, 0x76,
	0xc0, 0x4d, 0x53, 0x99, 0x9a, 0xcf, 0x33, 0xc3, 0xd0, 0xf1, 0x8f, 0x05, 0x74, 0x05, 0x3d, 0x94,
	0x44, 0xd6, 0xed, 0x8a, 0x2a, 0x19, 0x3b, 0xd5, 0x9f, 0xb8, 0x7c, 0x11, 0xc5, 0x45, 0x5f, 0xce,
	0xf2, 0xbb, 0x30, 0x7f, 0x64, 0xfa, 0x36, 0xea, 0x7a, 0x4a, 0xe5, 0x47, 0xea, 0x55, 0xa4, 0x3e,
	0x9b, 0x54, 0x0a, 0x6d, 0x1f, 0xc9, 0x3f, 0x86, 0x4a, 0x1f, 0x4e, 0xde, 0x7c, 0x59, 0xe8, 0x41,
	0x53, 0x86, 0x06, 0xfa, 0x75, 0xb2, 0x81, 0x7d, 0x22, 0xd7, 0x03, 0x5f, 0xc3, 0x4c, 0x3e, 0x2a,
	0xb2, 0x90, 0x8d, 0xef, 0xc3, 0x5c, 0x0f, 0x7c, 0x0d, 0x33, 0xf2, 0x02, 0xde, 0x71, 0x98, 0xd1,
	0x3b, 0x10, 0x9c, 0x8b, 0xf9, 0x26, 0xd9, 0x0c, 0x22, 0x43, 0x08, 0x5f, 0x3e, 0x9a, 0xd2, 0xd8,
	0xb9, 0xe9, 0xb0, 0xbd, 0xdc, 0xe0, 0x1c, 0x08, 0xe8, 0xad, 0x20, 0xda, 0xe1, 0xb0, 0xb8, 0xcf,
	0x5c, 0x28, 0x69, 0xed, 0xb5, 0x8b, 0x24, 0xad, 0xfd, 0x59, 0xa8, 0x64, 0x73, 0x63, 0xe4, 0xd6,
	0x89, 0x78, 0x77, 0x64, 0xed, 0x75, 0xd6, 0xc9, 0x56, 0x92, 0x4e, 0x23, 0xb7, 0x62, 0x16, 0x9a,
	0x03, 0xcb, 0xb9, 0x64, 0xef, 0x7b, 0x4b, 0x4c, 0xcc, 0xe4, 0x12, 0xce, 0xe4, 0x5c, 0xb6, 0x96,
	0xef, 0xc7, 0x38, 0x95, 0x74, 0x10, 0x16, 0xca, 0x1a, 0xf1, 0xec, 0x48, 0x4f, 0xda, 0xca, 0x7a,
	0x0f, 0x8d, 0x83, 0x56, 0x97, 0x61, 0x70, 0x4a, 0x37, 0xa4, 0xe8, 0xdb, 0xef, 0x6f, 0x06, 0xe5,
	0x8b, 0x91, 0xcd, 0x8b, 0x29, 0xe3, 0xa2, 0x6a, 0x17, 0x8c, 0x8b, 0xca, 0xe7, 0xc5, 0x5c, 0x91,
	0x09, 0x37, 0xd4, 0xc5, 0x5a, 0x79, 0xa6, 0xb9, 0x06, 0x57, 0x23, 0xca, 0x59, 0x9d, 0x66, 0xd3,
	0x57, 0x3a, 0x36, 0xf5, 0x63, 0xa7, 0xe9, 0xd0, 0x48, 0x3e, 0x4b, 0x72, 0x59, 0x02, 0xa5, 0x71,
	0x05, 0xdb, 0x09, 0x08, 0x97, 0x3e, 0x67, 0x8e, 0x81, 0x11, 0x11, 0x32, 0x98, 0xe6, 0x4d, 0x11,
	0x97, 0x78, 0xe6, 0x1c, 0x62, 0x21, 0x8e, 0xd8, 0xc7, 0xb0, 0x24, 0xd7, 0x6d, 0xff, 0xc0, 0xa9,
	0xdb, 0xa8, 0x6f, 0x09, 0x76, 0x11, 0x70, 0xbd, 0x63, 0xa6, 0xee, 0xa7, 0x6e, 0xc2, 0x75, 0xc1,
	0xb1, 0xe7, 0xd3, 0x79, 0x5b, 0x1c, 0xc1, 0x23, 0xd8, 0x79, 0x64, 0xbc, 0xbc, 0x1c, 0xc1, 0xb9,
	0xbb, 0x85, 0x43, 0xfb, 0xe4, 0x75, 0xb8, 0x2d, 0xfd, 0x13, 0x35, 0xf1, 0xd1, 0xf6, 0x0e, 0x3d,
	0x36, 0xad, 0x6e, 0x56, 0x18, 0x49, 0xa7, 0x74, 0x6a, 0x14, 0xe1, 0xe6, 0xb9, 0x8c, 0xf2, 0xf7,
	0xc3, 0xd7, 0xdb, 0x05, 0x95, 0x85, 0xca, 0x25, 0x69, 0x6a, 0xc4, 0xf2, 0xdd, 0xf6, 0x21, 0x5c,
	0xe2, 0x5b, 0x80, 0xba, 0x59, 0x88, 0x6e, 0x01, 0x57, 0x64, 0x34, 0x78, 0x27, 0xc9, 0x4d, 0x26,
	0xbf, 0xfd, 0x30, 0xad, 0x24, 0xdf, 0x85, 0x9a, 0xc3, 0x32, 0x29, 0x26, 0x8d, 0x38, 0xe8, 0x57,
	0xc0, 0x31, 0x20, 0x78, 0x4c, 0xbf, 0xe6, 0xb0, 0x34, 0xe1, 0xe4, 0x61, 0xd0, 0x67, 0x76, 0xdd,
	0x80, 0xc9, 0x9c, 0x10, 0x17, 0x0f, 0x92, 0x4c, 0x38, 0x19, 0xe9, 0xfd, 0x29, 0xe0, 0x5d, 0x27,
	0xdc, 0x2e, 0xd2, 0x17, 0x48, 0x2e, 0x12, 0xeb, 0x99, 0x19, 0x87, 0xbd, 0xc0, 0x16, 0x9b, 0x09,
	0xde, 0x3e, 0xe1, 0x7f, 0xa9, 0xf7, 0xab, 0xfa, 0x59, 0x02, 0xf5, 0x43, 0xf1, 0x6a, 0x49, 0xdf,
	0x12, 0x53, 0xe9, 0xd4, 0xce, 0x63, 0x27, 0xe4, 0xe5, 0x15, 0x94, 0x02, 0x8b, 0x03, 0x79, 0x09,
	0x19, 0xfb, 0x4b, 0x08, 0x60, 0xe3, 0xb7, 0x45, 0x02, 0xab, 0x81, 0x04, 0xb0, 0x07, 0x77, 0x60,
	0xde, 0x45, 0xa6, 0x51, 0x8f, 0x78, 0x9c, 0x99, 0x31, 0x5e, 0xce, 0x5a, 0x15, 0x3e, 0x54, 0x51,
	0x29, 0xbe, 0xff, 0x7b, 0x66, 0xfc, 0x8c, 0x76, 0xc9, 0x27, 0x50, 0x6b, 0x99, 0x4c, 0x64, 0xa8,
	0x64, 0x21, 0xb5, 0x44, 0x32, 0xb9, 0x5e, 0x55, 0xe4, 0x4e, 0x2e, 0x4d, 0x58, 0xcb, 0x64, 0xcf,
	0x19, 0x8d, 0x1a, 0x0a, 0x7c, 0x33, 0xaf, 0xa1, 0xac, 0xc0, 0xac, 0xd2, 0xf0, 0xb3, 0xef, 0x75,
	0x89, 0x10, 0xe3, 0x19, 0xa9, 0xdc, 0x67, 0x1e, 0xeb, 0xfa, 0x0e, 0x5c, 0xc9, 0x1e, 0x33, 0xa9,
	0x37, 0x05, 0xf8, 0xbc, 0xe2, 0xb8, 0x89, 0x90, 0xe3, 0xc5, 0x0c, 0x8c, 0x7c, 0x24, 0xc0, 0x6f,
	0x06, 0x78, 0x3a, 0xfa, 0xf3, 0x45, 0x58, 0xdc, 0x35, 0xcf, 0x64, 0x48, 0x58, 0x12, 0x21, 0x26,
	0xf7, 0xd7, 0x3d, 0x78, 0xf3, 0x84, 0x85, 0x2d, 0x1a, 0x51, 0x74, 0xb2, 0xaa, 0x47, 0x86, 0xd2,
	0x30, 0xb3, 0x4c, 0xdc, 0xce, 0xb0, 0xbe, 0x24, 0x61, 0xcf, 0xa7, 0xb7, 0x03, 0x37, 0xc5, 0x3d,
	0xad, 0x2f, 0x27, 0x57, 0x44, 0x72, 0xd7, 0x05, 0xe8, 0xf9, 0xd4, 0xb6, 0x60, 0xa9, 0x8d, 0xb1,
	0x6b, 0x5f, 0x42, 0x4a, 0xdc, 0xf9, 0xbd, 0xd2, 0x3e, 0xf1, 0xce, 0xa5, 0x53, 0xfd, 0xef, 0x26,
	0x61, 0x32, 0xb7, 0x1b, 0x5d, 0x81, 0x91, 0x23, 0xd3, 0x6a, 0x77, 0x42, 0x79, 0x53, 0x5b, 0x9c,
	0x5c, 0xca, 0x32, 0x72, 0x07, 0x66, 0x6c, 0x87, 0x89, 0x84, 0x1e, 0x11, 0xb5, 0x82, 0x13, 0x1a,
	0x75, 0xb1, 0xcb, 0x49, 0x74, 0x9e, 0xaa, 0xd6, 0x65, 0x2d, 0xd7, 0x39, 0x92, 0xac, 0x0c, 0x78,
	0xdc, 0x20, 0xf9, 0xc4, 0x8f, 0xc5, 0xcd, 0xc6, 0x31, 0x7d, 0x41, 0xd5, 0x6f, 0x88, 0x6a, 0x99,
	0x5f, 0x1b, 0x95, 0x21, 0x85, 0x29, 0x87, 0x57, 0x5a, 0x6f, 0x49, 0x9e, 0x87, 0x17, 0xa2, 0x98,
	0xab, 0xc1, 0x09, 0xa8, 0x18, 0x3a, 0x99, 0xf5, 0x27, 0x49, 0xfa, 0x20, 0x0c, 0x66, 0x4c, 0x22,
	0xa3, 0x00, 0xdb, 0x27, 0x9e, 0x38, 0x9e, 0xd5, 0x27, 0x54, 0xd9, 0xb3, 0x13, 0x3c, 0xfc, 0xcd,
	0x34, 0x2b, 0x37, 0x3e, 0xd4, 0x02, 0x1d, 0xff, 0x58, 0xba, 0xae, 0x2a, 0x69, 0x07, 0xc4, 0x5e,
	0xa6, 0xea, 0xc9, 0x06, 0x5c, 0x4f, 0xb0, 0x03, 0xdf, 0x38, 0x75, 0x38, 0x7a, 0x68, 0xf2, 0xfd,
	0x4d, 0x7d, 0xb5, 0x08, 0x32, 0xbc, 0xac, 0xc0, 0xf6, 0xfd, 0x97, 0x4e, 0x44, 0x1b, 0x08, 0xa3,
	0x3e, 0xfd, 0x97, 0x0a, 0x22, 0xbd, 0xd0, 0xb9, 0x73, 0x3b, 0x8e, 0x6a, 0xc9, 0xe6, 0xeb, 0x08,
	0xad, 0x73, 0x99, 0x00, 0xd3, 0x1c, 0x9d, 0xc3, 0x67, 0x03, 0x06, 0x23, 0xa2, 0x2c, 0x70, 0x3b,
	0xb1, 0x72, 0x69, 0xf4, 0x0d, 0x86, 0x9e, 0xd4, 0x73, 0x1d, 0x35, 0x9d, 0x7b, 0xa7, 0xd9, 0x54,
	0xbe, 0x6d, 0x69, 0x55, 0xce, 0x26, 0x13, 0xef, 0x34, 0x9b, 0xd2, 0xb3, 0x4d, 0x0e, 0xe1, 0x96,
	0x15, 0x05, 0x4c, 0xcd, 0x23, 0x5e, 0x14, 0xb5, 0xf3, 0x4a, 0x99, 0x3a, 0x88, 0x9f, 0xc4, 0xd8,
	0xbb, 0x9b, 0x08, 0x9e, 0xba, 0x4e, 0x36, 0x72, 0xea, 0x95, 0x3c, 0x93, 0xff, 0x92, 0xb4, 0xa8,
	0x53, 0x5f, 0x96, 0x16, 0x55, 0x87, 0xb7, 0x51, 0x35, 0x14, 0xc9, 0x81, 0x64, 0x40, 0xea, 0xc0,
	0xce, 0x94, 0x91, 0x4c, 0x8d, 0x43, 0xef, 0x70, 0x60, 0x19, 0x9e, 0x3a, 0xa0, 0x2f, 0xe7, 0xbf,
	0x04, 0x30, 0xfd, 0x2f, 0xe3, 0x25, 0x80, 0x1d, 0xb8, 0xa1, 0x3e, 0x3d, 0xa2, 0x16, 0x75, 0x4e,
	0xa8, 0x11, 0x85, 0x16, 0x1e, 0xd9, 0x05, 0x9d, 0xd8, 0xf0, 0xf0, 0xd8, 0x4e, 0x13, 0x11, 0x2e,
	0x1f, 0xdc, 0xd1, 0xaf, 0x4a, 0x60, 0x5d, 0xc0, 0xea, 0xa1, 0x75, 0x28, 0x20, 0x77, 0x39, 0x20,
	0xf9, 0x56, 0x9a, 0x9c, 0x39, 0x8c, 0x78, 0xf7, 0xb3, 0x63, 0xc0, 0x4d, 0xcf, 0xa9, 0x27, 0x85,
	0xd5, 0x24, 0xcb, 0xf2, 0x41, 0x02, 0x22, 0xbf, 0x7d, 0x07, 0x96, 0x3c, 0xc7, 0x77, 0xbc, 0x8e,
	0x97, 0x49, 0x8e, 0x6a, 0xb2, 0xae, 0x6f, 0x19, 0x51, 0x18, 0x88, 0x23, 0x44, 0x22, 0xd2, 0x10,
	0xdf, 0x7b, 0xb8, 0xba, 0xaa, 0x5f, 0x91, 0xd0, 0x49, 0x6e, 0xd4, 0x3a, 0x87, 0xd5, 0xc3, 0x00,
	0x8f, 0x13, 0x0f, 0xe0, 0x66, 0x3f, 0x35, 0x9f, 0x9a, 0x51, 0x9e, 0xe0, 0x6c, 0x72, 0xdd, 0xe7,
	0x7a, 0x2f, 0xb9, 0x3d, 0x09, 0xac, 0x28, 0xf6, 0x66, 0x09, 0x9f, 0xfb, 0xba, 0x59, 0xc2, 0xef,
	0xc2, 0xbc, 0x47, 0x59, 0xc0, 0xfa, 0xd8, 0x6e, 0x1e, 0xf9, 0x65, 0x16, 0x2b, 0x7b, 0x98, 0xee,
	0x07, 0xf0, 0xee, 0x97, 0x7c, 0x96, 0x5a, 0x86, 0xea, 0xeb, 0x16, 0x92, 0xaf, 0x7b, 0xeb, 0xbc,
	0xaf, 0x93, 0x0b, 0x53, 0x7c, 0x63, 0xad, 0x09, 0x33, 0xeb, 0xbd, 0xd3, 0x83, 0x51, 0x83, 0xfb,
	0x3e, 0xe6, 0xae, 0x5e, 0x43, 0x59, 0xaf, 0x42, 0x51, 0x44, 0x4c, 0xd7, 0x8e, 0x73, 0xdc, 0x8a,
	0xd7, 0x45, 0x7e, 0x6b, 0x55, 0x53, 0xc4, 0x08, 0x34, 0x89, 0xb4, 0xa1, 0x23, 0xa7, 0xbb, 0x49,
	0xed, 0x50, 0xf5, 0x1e, 0x2c, 0x0c, 0x36, 0x85, 0xc8, 0x22, 0x8c, 0xc8, 0x51, 0xc0, 0xf0, 0x59,
	0xce, 0x31, 0xb2, 0xa0, 0xfa, 0xa3, 0x02, 0x4c, 0xe5, 0xd4, 0xcc, 0x81, 0x87, 0x2a, 0x85, 0xfe,
	0x43, 0x95, 0xfe, 0xa3, 0x80, 0x22, 0x2a, 0x4e, 0x3d, 0x47, 0x01, 0xab, 0x30, 0x87, 0xd7, 0xba,
	0x44, 0xec, 0x48, 0x52, 0x27, 0xb7, 0x22, 0xe2, 0xb0, 0x0d, 0x51, 0x95, 0xf4, 0xa1, 0xfa, 0x52,
	0x04, 0xbb, 0x61, 0x5f, 0x06, 0x5c, 0xf9, 0xef, 0x4b, 0x9d, 0xc6, 0xf7, 0x22, 0x65, 0xc3, 0x8b,
	0xd7, 0xa4, 0xa4, 0x2b, 0xbf, 0xac, 0x8a, 0x9f, 0x62, 0x69, 0xed, 0x00, 0xe6, 0x06, 0xb9, 0x95,
	0xc4, 0x91, 0x98, 0x6f, 0x86, 0x61, 0x57, 0x1e, 0x6a, 0x7d, 0xea, 0x3a, 0x47, 0x32, 0x8a, 0x67,
	0xed, 0x73, 0x27, 0xbc, 0xab, 0x0d, 0x89, 0x23, 0xb0, 0x4f, 0xef, 0x6b, 0x63, 0x58, 0xba, 0xf3,
	0xe9, 0xfd, 0xa7, 0xeb, 0x9a, 0x56, 0xbb, 0x03, 0xe5, 0xbc, 0x39, 0x80, 0xb4, 0x84, 0x41, 0x20,
	0x23, 0x67, 0x37, 0xb3, 0xef, 0x1f, 0x68, 0xc5, 0xea, 0x6f, 0xcf, 0xc3, 0x30, 0xbe, 0x49, 0x4a,
	0x7e, 0x98, 0x5e, 0xc6, 0xb2, 0xd0, 0x5b, 0x9c, 0x4d, 0x98, 0xf3, 0xba, 0x6e, 0x1a, 0x75, 0x05,
	0x4c, 0xf8, 0x9d, 0x51, 0x3b, 0x7e, 0x01, 0xd3, 0xad, 0x38, 0x0e, 0x8d, 0x8c, 0x0b, 0xa8, 0xf8,
	0x95, 0x68, 0x4f, 0x71, 0x32, 0x07, 0x89, 0x1b, 0xe8, 0x25, 0x94, 0x95, 0x1d, 0x25, 0xf8, 0x1e,
	0xe7, 0xf2, 0x22, 0x67, 0x55, 0xf8, 0xdd, 0x2b, 0x5c, 0xbc, 0xd9, 0x6b, 0x41, 0xe0, 0xea, 0x53,
	0xd2, 0x64, 0x12, 0x64, 0x48, 0x03, 0x26, 0xa9, 0x67, 0x3a, 0x32, 0xaf, 0x2e, 0x43, 0xdd, 0xe3,
	0xab, 0x90, 0x9d, 0x40, 0x2a, 0x98, 0x69, 0x97, 0x71, 0xc5, 0x4d, 0x31, 0x5f, 0x86, 0xb8, 0x60,
	0x44, 0x4b, 0xfa, 0xb3, 0x87, 0xe5, 0x7d, 0x5a, 0x01, 0xb7, 0x99, 0x60, 0xaf, 0x0b, 0x20, 0xf9,
	0x06, 0xf1, 0x04, 0xf3, 0x92, 0xc7, 0x5d, 0xe5, 0xf1, 0xdc, 0x6b, 0x67, 0x0e, 0xe0, 0x24, 0xa4,
	0xed, 0x74, 0x0c, 0x5a, 0x86, 0xa0, 0x30, 0x47, 0x47, 0x2f, 0x68, 0xe9, 0x8b, 0x2f, 0x6e, 0x24,
	0xc4, 0xd0, 0x12, 0x1d, 0x69, 0x1f, 0xb8, 0xa6, 0xe3, 0xeb, 0x65, 0x96, 0x2b, 0x27, 0x5d, 0x18,
	0x3f, 0xa1, 0xd1, 0x51, 0xc0, 0x54, 0x34, 0x4e, 0xf9, 0xee, 0xc7, 0x17, 0x6d, 0x41, 0xcc, 0x4c,
	0x26, 0x2d, 0xeb, 0x0b, 0x45, 0x09, 0xf7, 0xdc, 0x27, 0xa4, 0xbd, 0x66, 0x32, 0xc7, 0x3a, 0x70,
	0x3b, 0x6c, 0x3d, 0x88, 0xe8, 0x46, 0xc7, 0x0b, 0xf5, 0xb4, 0x35, 0xb2, 0x0f, 0xe0, 0x5b, 0x96,
	0xba, 0xb3, 0x3e, 0xfe, 0x5a, 0xf3, 0xb9, 0x67, 0x59, 0x2a, 0xab, 0xaa, 0xaf, 0xfe, 0x24, 0x2d,
	0x98, 0xc5, 0xeb, 0xd5, 0x2a, 0x5d, 0xaf, 0xa4, 0x0c, 0x17, 0x74, 0xae, 0x0a, 0xca, 0xf5, 0x4e,
	0x1c, 0xc8, 0x2f, 0x4b, 0x1e, 0x05, 0xeb, 0x2d, 0x22, 0x0f, 0x61, 0xb2, 0x19, 0x05, 0x5e, 0xe2,
	0x61, 0x98, 0xc0, 0x67, 0x8c, 0x55, 0x46, 0xe3, 0x8f, 0x54, 0x4b, 0x56, 0xe0, 0xe9, 0x13, 0x1c,
	0x50, 0x79, 0x19, 0xb6, 0xe0, 0x0a, 0xa3, 0xbe, 0x9d, 0x65, 0x36, 0x96, 0xd8, 0x69, 0x6e, 0x57,
	0x38, 0xed, 0x95, 0x89, 0xb6, 0xc8, 0x41, 0x53, 0x7e, 0x63, 0x9b, 0x09, 0x1c, 0xf9, 0x06, 0x5c,
	0x42, 0x3a, 0x82, 0x5d, 0x05, 0x35, 0xdb, 0x39, 0xa6, 0xf8, 0x46, 0x75, 0xaa, 0xff, 0xcf, 0x71,
	0x20, 0x44, 0x46, 0x32, 0x1b, 0x08, 0xc1, 0xb5, 0x2f, 0xf5, 0x96, 0x92, 0x13, 0x7a, 0x4e, 0x36,
	0xb1, 0x44, 0x39, 0xf7, 0x66, 0xe8, 0x76, 0xe8, 0x39, 0x99, 0xc4, 0x12, 0xdf, 0x80, 0x6a, 0x76,
	0x91, 0xb0, 0xce, 0xd1, 0x4f, 0x53, 0x2b, 0xc6, 0x98, 0x30, 0xe7, 0x0c, 0xb5, 0xa5, 0x71, 0xfd,
	0x52, 0xba, 0xba, 0x1a, 0xa2, 0xfe, 0x00, 0xab, 0xc9, 0x03, 0xb8, 0x94, 0x45, 0x3e, 0x0a, 0xec,
	0xae, 0xc1, 0x3a, 0x4d, 0x8e, 0x29, 0x62, 0x83, 0xe6, 0x52, 0xcc, 0xb5, 0xc0, 0xee, 0x36, 0xb0,
	0x8e, 0xb4, 0x61, 0x2e, 0x23, 0xa6, 0xd2, 0x78, 0xa2, 0x99, 0x0b, 0xba, 0x4b, 0xc4, 0x9c, 0x3e,
	0x55, 0x22, 0x2a, 0x09, 0x3b, 0xd2, 0x49, 0xab, 0xaf, 0x8c, 0x6c, 0xc1, 0x55, 0xd6, 0x76, 0x42,
	0x83, 0x7a, 0x61, 0xdc, 0x1d, 0x34, 0xb6, 0x24, 0x33, 0xb6, 0x8b, 0x1c, 0x74, 0x93, 0x43, 0xf6,
	0x0e, 0x70, 0x55, 0x87, 0xf1, 0x44, 0xde, 0x90, 0xcb, 0x30, 0x8c, 0x47, 0x24, 0xf9, 0x5c, 0x5b,
	0xa2, 0x8c, 0x2c, 0x83, 0xd6, 0xf1, 0x63, 0x47, 0xdc, 0x58, 0xe3, 0xf6, 0xbb, 0x25, 0x53, 0x6c,
	0xe9, 0x65, 0x2c, 0xe7, 0x64, 0x9e, 0xf3, 0xd2, 0xea, 0xdf, 0x2c, 0xc0, 0x78, 0xc2, 0xf4, 0xe4,
	0x1e, 0x10, 0x9c, 0x7f, 0xf1, 0xb0, 0x8c, 0x72, 0x1a, 0xe7, 0x5a, 0xd0, 0x38, 0x00, 0x3e, 0x20,
	0xa3, 0xbc, 0xc6, 0xdf, 0x80, 0x4a, 0x06, 0x09, 0x9f, 0xf5, 0x3f, 0x31, 0x65, 0x4a, 0x6a, 0x99,
	0xd7, 0xeb, 0xe1, 0xaa, 0x3e, 0x9f, 0xe0, 0x6d, 0x4b, 0x08, 0x54, 0xc5, 0x3e, 0x84, 0x45, 0xd9,
	0x18, 0x0e, 0x88, 0x94, 0x90, 0x2c, 0x3d, 0xf2, 0x1b, 0xd7, 0x17, 0x10, 0x00, 0x07, 0x42, 0xca,
	0x46, 0x4c, 0x5f, 0x55, 0xfd, 0x7b, 0x43, 0x30, 0xd3, 0xb7, 0xaa, 0xc8, 0x27, 0x30, 0x21, 0x19,
	0x82, 0x75, 0x42, 0x71, 0xbd, 0xf3, 0xab, 0x88, 0x73, 0x10, 0x6c, 0xc3, 0x69, 0x70, 0x6b, 0xaf,
	0x47, 0x9a, 0xb3, 0x4e, 0x98, 0x17, 0xe6, 0xe2, 0x4c, 0xf3, 0x72, 0x4e, 0x98, 0xb3, 0x4e, 0x98,
	0x95, 0xe5, 0x1b, 0x70, 0x39, 0xbb, 0x46, 0x39, 0xe5, 0xec, 0x12, 0x2d, 0xe5, 0x92, 0x3e, 0xa4,
	0x4b, 0x94, 0xc3, 0x65, 0x56, 0xe8, 0x0d, 0x98, 0x30, 0xd3, 0x2c, 0xd7, 0x22, 0x08, 0xe0, 0xc9,
	0x1b, 0x3a, 0x98, 0x49, 0xd2, 0x6a, 0xb2, 0x06, 0xd7, 0x30, 0xa1, 0x80, 0x78, 0xa4, 0x95, 0x6f,
	0x04, 0x4d, 0x37, 0x38, 0x15, 0xac, 0x20, 0xec, 0x80, 0x61, 0xf1, 0x44, 0x15, 0x87, 0xc2, 0x07,
	0x5a, 0x5f, 0x4a, 0x18, 0xfe, 0xf9, 0xc2, 0x00, 0xb8, 0x01, 0x93, 0x11, 0xf5, 0x1c, 0xdf, 0x36,
	0x5c, 0x33, 0x96, 0x3b, 0xcf, 0x98, 0x3e, 0x21, 0xca, 0x76, 0x78, 0x11, 0xf9, 0xf9, 0x02, 0xcc,
	0x86, 0x8e, 0x63, 0x30, 0x2b, 0xea, 0x1c, 0x1d, 0x39, 0xfe, 0xb1, 0x30, 0x9f, 0xe4, 0x76, 0xf2,
	0xdd, 0xaf, 0x2a, 0x16, 0x57, 0x0e, 0xb6, 0xb7, 0x1b, 0x8a, 0xa4, 0x90, 0xf7, 0xc3, 0xe2, 0x8a,
	0xc3, 0x4c, 0xe8, 0x38, 0xf9, 0x9a, 0x5a, 0x1d, 0x66, 0xfa, 0xc0, 0x51, 0x6b, 0xaa, 0xbb, 0xae,
	0xcc, 0xae, 0x8b, 0x59, 0x09, 0xf1, 0xce, 0xde, 0xb8, 0x0a, 0x32, 0x2a, 0xe2, 0x9f, 0x9c, 0xa6,
	0x56, 0xaa, 0xfe, 0x7c, 0x11, 0x48, 0xff, 0x3a, 0x26, 0x14, 0x26, 0xa4, 0xaf, 0x29, 0x13, 0x3b,
	0xbf, 0xf1, 0x95, 0xe5, 0xc2, 0x8a, 0xf0, 0x4a, 0xa1, 0x0f, 0x1e, 0xe2, 0xe4, 0x6f, 0xb2, 0x00,
	0x23, 0xe2, 0x97, 0xd4, 0x1e, 0xe5, 0xaf, 0x9a, 0x0b, 0x90, 0x62, 0x60, 0xac, 0xf7, 0x76, 0x78,
	0x72, 0x5f, 0x8a, 0x7b, 0xad, 0x80, 0x37, 0x72, 0x78, 0x49, 0x72, 0x80, 0xc2, 0xda, 0x5a, 0x51,
	0xdc, 0xee, 0x49, 0x9e, 0x70, 0x10, 0xa2, 0x4e, 0x2b, 0xe1, 0xbd, 0x8e, 0xa7, 0x01, 0x8b, 0x79,
	0xa1, 0x36, 0xa4, 0xa8, 0x3d, 0x54, 0xd4, 0x86, 0x6b, 0x0f, 0xa0, 0x9c, 0xdf, 0xd6, 0x51, 0xdf,
	0xc4, 0x8d, 0x5d, 0x7b, 0x03, 0xd1, 0x1b, 0x78, 0xe9, 0x6b, 0xa7, 0x21, 0x93, 0x14, 0x37, 0x1a,
	0x3b, 0x5a, 0xb1, 0xf6, 0x43, 0x58, 0x7a, 0xd5, 0x5e, 0x2d, 0xee, 0x6c, 0x05, 0x71, 0xcb, 0xf1,
	0x8f, 0x65, 0xb6, 0x2d, 0xdc, 0xbb, 0xb5, 0x02, 0x46, 0x32, 0xf4, 0xed, 0xe3, 0x32, 0xd6, 0x81,
	0x4f, 0x5f, 0xa9, 0xfa, 0x87, 0x43, 0x30, 0x99, 0x7d, 0x48, 0x7e, 0x60, 0x1e, 0x21, 0x91, 0x8e,
	0xab, 0x37, 0x8f, 0xd0, 0x2a, 0xcc, 0xe5, 0x21, 0x65, 0x9a, 0x1b, 0x31, 0xca, 0x24, 0x0b, 0x2d,
	0xd3, 0xdd, 0x58, 0x30, 0x3b, 0xe0, 0xec, 0x4b, 0x06, 0x8f, 0xdf, 0x7b, 0xad, 0x07, 0xef, 0x57,
	0xf0, 0x5c, 0x4c, 0x9f, 0xe9, 0x3b, 0x2a, 0x23, 0xf7, 0x61, 0xa1, 0xe7, 0x51, 0x7d, 0x95, 0x0f,
	0x58, 0x44, 0xf3, 0xcc, 0xe5, 0x5e, 0xca, 0x57, 0x79, 0x81, 0x1f, 0x41, 0xe5, 0xbc, 0x63, 0x39,
	0x19, 0xa2, 0x3d, 0x3f, 0xf0, 0x54, 0xee, 0x9c, 0x44, 0x1d, 0x23, 0xe7, 0x24, 0xea, 0xb8, 0x04,
	0xa3, 0xf8, 0xd4, 0x55, 0x12, 0x7b, 0x33, 0xc2, 0x7f, 0x8a, 0x7b, 0x35, 0x58, 0x91, 0x09, 0xae,
	0xc1, 0xc7, 0xad, 0x38, 0x56, 0xed, 0x1f, 0x15, 0x60, 0x58, 0x7c, 0x1c, 0x9f, 0xea, 0x0d, 0xca,
	0xda, 0x71, 0x10, 0xca, 0xf8, 0x95, 0xbd, 0xef, 0xdd, 0x5d, 0x5d, 0x5d, 0xd5, 0x8a, 0xf2, 0xc7,
	0x3d, 0xfe, 0xa3, 0x94, 0xfc, 0x78, 0xb0, 0xaa, 0x0d, 0xc9, 0x1f, 0x0f, 0xf9, 0x8f, 0xe1, 0xe4,
	0xc7, 0xa3, 0x55, 0x6d, 0x44, 0xfe, 0xb8, 0xc3, 0x6b, 0x46, 0x13, 0x9c, 0x87, 0xab, 0xda, 0x58,
	0x02, 0xf6, 0x70, 0x55, 0x1b, 0x4f, 0x7e, 0x3c, 0x5e, 0xd5, 0x20, 0xf9, 0x71, 0x77, 0x55, 0x9b,
	0x90, 0x3f, 0x1e, 0xdd, 0xb9, 0xb3, 0xaa, 0x4d, 0x26, 0xd4, 0xee, 0xae, 0x6a, 0x53, 0xf2, 0xc7,
	0x87, 0xab, 0xf7, 0x57, 0xb5, 0x32, 0xde, 0xc1, 0x78, 0xce, 0xe8, 0x8e, 0xd9, 0x0d, 0x3a, 0xb1,
	0x66, 0xe7, 0x82, 0x63, 0xfe, 0x7a, 0x01, 0x16, 0xfb, 0xae, 0x93, 0x25, 0xef, 0x67, 0xbd, 0x0b,
	0x33, 0x99, 0xf4, 0x43, 0xe2, 0x5d, 0x41, 0x69, 0xb6, 0x4e, 0x47, 0x29, 0x38, 0x2f, 0x46, 0x3f,
	0x76, 0x16, 0x96, 0x46, 0x16, 0x3e, 0xd5, 0x2e, 0x1f, 0xf8, 0x42, 0xc6, 0x2c, 0xe8, 0x8b, 0x19,
	0x34, 0x01, 0xa1, 0x5e, 0x00, 0xe3, 0xbc, 0x8f, 0x52, 0x5d, 0x44, 0x76, 0x88, 0x4b, 0x97, 0xe2,
	0x0e, 0x3f, 0x66, 0xcd, 0x15, 0x51, 0x1d, 0x98, 0x00, 0xe1, 0x1f, 0x03, 0xcc, 0xf7, 0x75, 0x1a,
	0x0d, 0xdb, 0x8f, 0xf8, 0x16, 0x94, 0x31, 0x6c, 0x8d, 0x23, 0x2a, 0x52, 0xf3, 0xe0, 0x0d, 0x4b,
	0x61, 0xe6, 0xa2, 0x8f, 0xe1, 0x52, 0xc6, 0xd4, 0xc5, 0xab, 0x84, 0xf2, 0x12, 0x26, 0xf9, 0x18,
	0xae, 0xe7, 0x29, 0xd8, 0x01, 0x52, 0x48, 0x3f, 0x2d, 0x93, 0xca, 0xb3, 0x9a, 0xa1, 0xb2, 0xc1,
	0xe1, 0xd2, 0xee, 0x90, 0x6f, 0xc2, 0xe2, 0xa0, 0xae, 0x98, 0xb6, 0x4d, 0xed, 0x4c, 0x76, 0xcf,
	0xf9, 0xde, 0x8e, 0xe0, 0x15, 0x44, 0xf2, 0x0c, 0x6e, 0xf4, 0x74, 0x03, 0xa3, 0x28, 0xe5, 0xd7,
	0x60, 0x94, 0xab, 0x08, 0x90, 0x13, 0x54, 0xae, 0x64, 0x3b, 0xe2, 0xb0, 0xb6, 0xfc, 0x24, 0x01,
	0x47, 0xee, 0xca, 0x37, 0xeb, 0x7b, 0xd0, 0x87, 0x13, 0x74, 0x7c, 0xb7, 0x3e, 0x8f, 0x73, 0x07,
	0xe6, 0xb3, 0xd3, 0x89, 0x6f, 0x10, 0xe3, 0xe3, 0x19, 0x62, 0xa3, 0x24, 0xe9, 0x3c, 0x36, 0x2c,
	0x53, 0xbc, 0x97, 0xf1, 0x6d, 0xa8, 0xf4, 0xa1, 0x98, 0x47, 0xe8, 0xc1, 0x11, 0xfe, 0x66, 0xb5,
	0xf9, 0xcf, 0xe7, 0x91, 0xeb, 0x02, 0x86, 0x6c, 0xc3, 0xd2, 0xc0, 0xa1, 0x6f, 0xa6, 0x89, 0xc8,
	0x45, 0x40, 0x11, 0xf6, 0xf9, 0x72, 0xdf, 0xd8, 0x37, 0x93, 0x8c, 0xa8, 0xa4, 0x0e, 0x57, 0xfc,
	0xc0, 0xa6, 0xcc, 0xe8, 0xf2, 0xfd, 0x2d, 0x30, 0xf8, 0xe2, 0xce, 0x4e, 0xe1, 0xf8, 0x52, 0x49,
	0x26, 0xee, 0xba, 0x84, 0x70, 0xdf, 0xa7, 0xf1, 0x61, 0x50, 0xb7, 0xda, 0x99, 0xf9, 0xbb, 0x07,
	0x0b, 0xb9, 0xaf, 0x49, 0xaf, 0x09, 0x8b, 0xeb, 0x10, 0xb3, 0x99, 0x8f, 0x48, 0x2e, 0x0c, 0xbb,
	0x30, 0x97, 0x5b, 0x04, 0xea, 0xcd, 0xba, 0x89, 0x8b, 0x26, 0x37, 0x3e, 0x6f, 0x29, 0x66, 0x07,
	0x3c, 0x59, 0x9e, 0x6b, 0x70, 0x65, 0x30, 0xb7, 0x87, 0xa6, 0x13, 0x51, 0x11, 0xc9, 0x24, 0xf3,
	0x03, 0xf5, 0xb3, 0xbb, 0x80, 0xc1, 0x0c, 0x43, 0x32, 0xc3, 0xf0, 0x80, 0xdb, 0x4e, 0x53, 0x89,
	0x3f, 0xb5, 0x22, 0xa1, 0xf4, 0xbe, 0x5b, 0x4f, 0xdf, 0x86, 0x45, 0x7a, 0x16, 0xe2, 0xf5, 0xf7,
	0xfe, 0x14, 0x45, 0xe5, 0x74, 0xc5, 0x29, 0xa0, 0xde, 0x0c, 0x45, 0x0d, 0x78, 0x6b, 0xd0, 0xb4,
	0xa7, 0xcf, 0xce, 0xcb, 0x3b, 0xb2, 0x22, 0xfb, 0x3b, 0xd2, 0x5a, 0xea, 0x9d, 0xfb, 0xde, 0xfb,
	0xb4, 0xf2, 0x75, 0xf9, 0x76, 0x76, 0xd1, 0x19, 0xf2, 0x3e, 0x45, 0x69, 0xb9, 0x84, 0x8f, 0x7b,
	0xb7, 0xd3, 0xe5, 0x86, 0xea, 0xeb, 0x07, 0x79, 0x61, 0x17, 0x84, 0x86, 0x4c, 0xf2, 0x27, 0xd3,
	0xf0, 0xa6, 0x13, 0xb0, 0x1f, 0x6e, 0xf3, 0x81, 0xbb, 0x2a, 0xc4, 0x8a, 0x11, 0x44, 0x2a, 0x2f,
	0x99, 0x3c, 0x9d, 0xc5, 0xd4, 0x16, 0xc2, 0xe6, 0xd1, 0x17, 0x05, 0xd0, 0x7e, 0x24, 0x6e, 0xcb,
	0x8a, 0xfb, 0xad, 0x5d, 0x4c, 0xbc, 0xf9, 0x02, 0x96, 0xdd, 0x40, 0x3c, 0x2e, 0xca, 0x58, 0xcc,
	0x77, 0x2a, 0x6e, 0x5c, 0xa8, 0xf5, 0xe9, 0x65, 0xa6, 0x84, 0xc9, 0x38, 0xa4, 0x37, 0x25, 0x7c,
	0x43, 0x82, 0x6f, 0xfb, 0x7a, 0x0a, 0x2c, 0x67, 0x86, 0x91, 0x6f, 0xc3, 0x65, 0xd9, 0x33, 0x34,
	0x55, 0xe4, 0xcb, 0x53, 0x6a, 0xd6, 0xe4, 0xdd, 0x08, 0xd9, 0xaf, 0x6d, 0x3f, 0x79, 0x46, 0x4a,
	0x01, 0x54, 0xff, 0x60, 0x1c, 0xc6, 0x1a, 0xbe, 0x17, 0xa2, 0x44, 0xbd, 0x06, 0xa3, 0xa9, 0x95,
	0x54, 0x4c, 0x8c, 0x38, 0x55, 0x48, 0x9e, 0xc9, 0x68, 0xde, 0xd7, 0x72, 0x84, 0x29, 0xea, 0x2b,
	0xcf, 0x19, 0x8d, 0x44, 0xf4, 0x2f, 0x4e, 0xc1, 0xa7, 0x50, 0xc6, 0x03, 0xf7, 0x7c, 0x4c, 0xe4,
	0x45, 0x52, 0xfa, 0x24, 0x14, 0x0f, 0x15, 0xbe, 0x3e, 0x95, 0x90, 0x42, 0xda, 0xdf, 0x43, 0xda,
	0xa1, 0xc1, 0x1c, 0xbf, 0x9d, 0x26, 0x0c, 0xbe, 0xc8, 0x33, 0xe1, 0x59, 0xda, 0x61, 0xc3, 0xf1,
	0xdb, 0xfa, 0x64, 0x2c, 0xff, 0x42, 0x33, 0xed, 0xef, 0x17, 0x61, 0x88, 0x7f, 0x48, 0x2e, 0xb5,
	0xb0, 0x88, 0x17, 0x4d, 0x53, 0x0b, 0x1f, 0xc2, 0xb8, 0x48, 0x8f, 0xdb, 0x4d, 0xae, 0x91, 0x3e,
	0x7a, 0xbd, 0x71, 0xe2, 0x96, 0x44, 0x4b, 0x24, 0x07, 0x36, 0xe5, 0x5f, 0x64, 0x11, 0xf0, 0x6f,
	0x3c, 0xe5, 0x16, 0xa1, 0xd4, 0xa3, 0xfc, 0xf7, 0x33, 0xda, 0xe5, 0x0d, 0x86, 0x91, 0x73, 0x92,
	0xbd, 0x56, 0xf7, 0xba, 0x0d, 0x1e, 0x44, 0xce, 0x89, 0xca, 0x46, 0x2c, 0xfe, 0xe2, 0x0d, 0x22,
	0x55, 0xde, 0xa0, 0xd0, 0xcc, 0x46, 0xf9, 0xef, 0x67, 0xb4, 0x5b, 0xbb, 0x06, 0x63, 0xaa, 0x87,
	0xa8, 0xe2, 0xee, 0x6e, 0x3c, 0x50, 0xca, 0xf4, 0xd3, 0xba, 0x56, 0xe4, 0xf5, 0x8a, 0x20, 0x96,
	0x6e, 0x6c, 0x2a, 0x65, 0xbb, 0xbe, 0xd9, 0xd0, 0x8a, 0xd5, 0x00, 0xc6, 0x93, 0xc9, 0x23, 0x7b,
	0x99, 0x74, 0xca, 0xc2, 0x34, 0x79, 0x8d, 0x79, 0x52, 0xb9, 0x72, 0x33, 0x59, 0x94, 0x55, 0x26,
	0xe8, 0x62, 0x9a, 0x09, 0xba, 0xfa, 0xb7, 0x4b, 0x30, 0xa6, 0xa6, 0xf4, 0x8f, 0xbc, 0xc1, 0x4f,
	0x00, 0x99, 0x24, 0x71, 0x74, 0x15, 0xbf, 0x92, 0x67, 0x73, 0x82, 0xd3, 0x50, 0x3e, 0xb0, 0x9b,
	0x30, 0x85, 0x24, 0x13, 0x1e, 0x93, 0x39, 0x8a, 0x79, 0xe1, 0x73, 0xc5, 0x67, 0x6f, 0x4a, 0x36,
	0xa7, 0xfe, 0xb1, 0xe3, 0x53, 0x2e, 0xc2, 0x86, 0x52, 0xa8, 0x4d, 0x2c, 0x14, 0x0a, 0xaf, 0xc3,
	0x30, 0xc8, 0x20, 0xf2, 0xe4, 0x11, 0xf3, 0x98, 0xc3, 0x84, 0x91, 0x43, 0x0e, 0x61, 0x54, 0x59,
	0xdf, 0x23, 0x17, 0xf4, 0x9c, 0x26, 0x23, 0xc1, 0xff, 0x90, 0x66, 0xfa, 0x93, 0x52, 0xfb, 0xc5,
	0x3d, 0x5d, 0x91, 0x22, 0xef, 0x60, 0x3c, 0xa9, 0xc7, 0xb5, 0xf4, 0xae, 0xc1, 0xe2, 0x48, 0x9d,
	0x42, 0x8f, 0x63, 0x34, 0xa8, 0x28, 0x6f, 0x60, 0xb1, 0x48, 0xc6, 0x8c, 0xc7, 0x76, 0xb9, 0x74,
	0xb9, 0x93, 0xaa, 0x90, 0xab, 0xfe, 0xb5, 0xfb, 0x9c, 0x9d, 0xe4, 0x60, 0x63, 0x16, 0xe4, 0x8d,
	0x03, 0x69, 0x02, 0x3f, 0xdf, 0x38, 0x78, 0x28, 0xcd, 0xac, 0xc3, 0xf5, 0x03, 0xad, 0x84, 0x85,
	0x87, 0xeb, 0x07, 0x0f, 0xb5, 0xa1, 0xda, 0x75, 0x98, 0xc8, 0x74, 0x91, 0x8c, 0x42, 0xa9, 0xfd,
	0xe2, 0xae, 0x56, 0x10, 0x7f, 0xdc, 0xd3, 0x8a, 0xd5, 0x7f, 0x30, 0x05, 0xc0, 0xd9, 0x58, 0x3a,
	0x5b, 0x7e, 0x0a, 0xca, 0xc9, 0xb2, 0x4d, 0x0f, 0x12, 0x2e, 0x12, 0xdb, 0x94, 0x12, 0xc1, 0x3f,
	0x45, 0xfa, 0x06, 0x5c, 0x4d, 0x93, 0x6a, 0xf9, 0xa2, 0x5c, 0x3a, 0x82, 0xb2, 0xed, 0x44, 0xd4,
	0x4a, 0x9f, 0x05, 0x2c, 0x5e, 0x30, 0x1b, 0x63, 0xa6, 0x85, 0x0d, 0x45, 0x41, 0x7a, 0x5e, 0xa7,
	0x12, 0x92, 0x28, 0xa1, 0x7e, 0x77, 0x02, 0xa6, 0x7b, 0x40, 0xc8, 0x9f, 0x28, 0x64, 0x1b, 0xce,
	0xf8, 0x00, 0xb6, 0xbf, 0x46, 0xc3, 0xe9, 0x6f, 0xf4, 0x9d, 0xcf, 0xb4, 0xeb, 0xeb, 0x87, 0xdb,
	0x2f, 0x36, 0x8d, 0x8d, 0x6d, 0x7d, 0x73, 0xfd, 0x70, 0x5f, 0xff, 0x7e, 0xa6, 0x67, 0x28, 0x08,
	0x3e, 0x87, 0xe9, 0x4c, 0xbc, 0x5c, 0x46, 0x38, 0x7e, 0xf7, 0xeb, 0xf4, 0x22, 0x0d, 0xaf, 0x93,
	0xd7, 0x3a, 0x76, 0x36, 0xea, 0x07, 0x7a, 0xd9, 0xca, 0x15, 0x93, 0x06, 0xa4, 0x9d, 0xc1, 0xab,
	0x2a, 0xa5, 0xaf, 0xb4, 0x46, 0x27, 0x13, 0x22, 0xcf, 0x23, 0x97, 0x2c, 0xc0, 0x88, 0xbc, 0xc9,
	0x2d, 0xd6, 0x9d, 0xfc, 0xc5, 0x87, 0x7b, 0xe6, 0x38, 0x0a, 0x3a, 0xa1, 0xc1, 0xa8, 0x19, 0x59,
	0xad, 0xec, 0xc5, 0x95, 0x67, 0x5f, 0xe7, 0x5b, 0x3f, 0xe6, 0x44, 0x1b, 0x48, 0x13, 0x3f, 0x16,
	0xda, 0xfa, 0xe6, 0xfa, 0x73, 0xbd, 0xb1, 0xfd, 0x62, 0x53, 0x9f, 0x3e, 0xce, 0x57, 0x26, 0xb9,
	0x8b, 0x47, 0x32, 0xb9, 0x8b, 0xdf, 0x83, 0xb2, 0xdc, 0xcc, 0xb9, 0xf6, 0xc1, 0x58, 0x98, 0x57,
	0xd6, 0xe5, 0xb5, 0x03, 0x7b, 0xdb, 0x6f, 0xb0, 0x90, 0x30, 0x98, 0x56, 0xca, 0x9a, 0x69, 0x59,
	0x41, 0xc7, 0x8f, 0x71, 0x71, 0x4e, 0x7c, 0xbd, 0xf9, 0x92, 0x41, 0xac, 0x75, 0x41, 0x31, 0xc9,
	0xaf, 0x28, 0x7f, 0x93, 0x18, 0xb4, 0x20, 0xa4, 0xbe, 0xe1, 0xda, 0x66, 0x98, 0x3f, 0xf5, 0xf8,
	0x5a, 0xad, 0xee, 0x87, 0xd4, 0xdf, 0xb1, 0x4d, 0xf5, 0x2a, 0x6e, 0x39, 0xc8, 0xfd, 0xc6, 0x57,
	0x98, 0xe4, 0xab, 0xa2, 0x81, 0xcf, 0xed, 0xaf, 0xd0, 0x35, 0xbb, 0x2a, 0xbd, 0xb6, 0xa8, 0xd9,
	0x0b, 0xfc, 0x0d, 0x51, 0x5e, 0xfd, 0x09, 0x28, 0xe7, 0xbf, 0xa2, 0x47, 0x1b, 0xc8, 0x3f, 0x34,
	0xf0, 0x01, 0x90, 0x34, 0x33, 0x43, 0x72, 0xe1, 0x49, 0xf8, 0x6e, 0x66, 0x92, 0x1a, 0xf5, 0xf2,
	0x45, 0xf5, 0xf7, 0x8a, 0x50, 0xce, 0xf7, 0x96, 0x9b, 0xe6, 0xa8, 0x77, 0x05, 0xe2, 0x2c, 0x41,
	0xa4, 0x10, 0x95, 0xa6, 0x39, 0xaf, 0xd8, 0xc7, 0x72, 0x91, 0x45, 0x74, 0x19, 0x34, 0x11, 0xe1,
	0x26, 0x38, 0xef, 0x88, 0x5b, 0xf1, 0xf2, 0x2c, 0x97, 0x97, 0x0b, 0xfe, 0x58, 0xe3, 0x46, 0xfc,
	0x07, 0x40, 0x54, 0x1f, 0xd3, 0x9b, 0xab, 0x2a, 0x9f, 0x92, 0xaa, 0x49, 0x6e, 0x0e, 0xf2, 0x21,
	0x12, 0x3c, 0x9d, 0xeb, 0x85, 0x60, 0x7c, 0x0d, 0x6b, 0xb2, 0xdd, 0x78, 0xb7, 0x67, 0x05, 0x60,
	0x3f, 0x84, 0x12, 0x91, 0x65, 0x54, 0xec, 0xc8, 0x7d, 0x58, 0x10, 0xb0, 0x1e, 0xf5, 0x8e, 0x68,
	0x94, 0xe9, 0x8c, 0x60, 0xdd, 0x39, 0xac, 0xdd, 0xc5, 0xca, 0xb4, 0x3f, 0xdf, 0x81, 0x2b, 0x83,
	0xb1, 0xc4, 0x65, 0x0b, 0xb9, 0xdf, 0x2c, 0x0e, 0xc2, 0xc5, 0xeb, 0x16, 0xb5, 0x87, 0x30, 0x95,
	0x93, 0x60, 0xe8, 0x70, 0xec, 0x95, 0x61, 0x32, 0xad, 0xc5, 0xfe, 0xc1, 0xe6, 0x9e, 0xc1, 0x05,
	0x8b, 0x56, 0xa8, 0xbd, 0x0b, 0xe5, 0xbc, 0xcc, 0xc1, 0x3d, 0x07, 0x2b, 0x85, 0x7b, 0xf1, 0xd9,
	0xa6, 0xbe, 0xb6, 0xa9, 0xef, 0x37, 0xb4, 0x42, 0xed, 0x01, 0x4c, 0xf7, 0xac, 0x59, 0x24, 0x97,
	0xac, 0x5a, 0x79, 0x7f, 0x73, 0x6f, 0x7f, 0xcf, 0x48, 0xcb, 0x0a, 0xb5, 0xfb, 0x50, 0xce, 0xef,
	0x23, 0xe2, 0xc8, 0x7c, 0x7f, 0xbd, 0xbe, 0xa3, 0xbd, 0x81, 0xbe, 0xc6, 0xa4, 0x83, 0x46, 0x63,
	0x53, 0x7f, 0xb1, 0xbd, 0xbe, 0xa9, 0x15, 0xaa, 0x3f, 0x2a, 0xc2, 0xc8, 0x0b, 0x0c, 0x54, 0xe6,
	0x7b, 0xbe, 0x8c, 0xb9, 0x48, 0x9c, 0x8a, 0x63, 0xa2, 0x60, 0xdb, 0x26, 0xd7, 0x61, 0x22, 0x7b,
	0x11, 0x48, 0x70, 0x07, 0x9c, 0xa4, 0x57, 0x80, 0x7a, 0x2f, 0x7b, 0x96, 0xfa, 0x2f, 0x7b, 0x7e,
	0x69, 0x76, 0x9a, 0xef, 0xc0, 0x15, 0xae, 0x1b, 0x71, 0x2e, 0x91, 0x77, 0xd5, 0xd3, 0x84, 0x24,
	0x8e, 0xcd, 0xe4, 0xbd, 0xcd, 0x45, 0x09, 0x53, 0xb7, 0x72, 0xe9, 0x41, 0xb6, 0x6d, 0x96, 0xe9,
	0x61, 0x46, 0x82, 0xc9, 0x1e, 0xa2, 0x77, 0xaf, 0x3f, 0x72, 0x62, 0x74, 0xc0, 0x25, 0xca, 0xea,
	0xef, 0x16, 0x80, 0xc8, 0x28, 0xb1, 0xec, 0xab, 0x82, 0x1f, 0xc2, 0xa2, 0x8a, 0x52, 0x1b, 0xf4,
	0xba, 0x20, 0x26, 0x35, 0x3c, 0xe9, 0x43, 0x53, 0x69, 0x7d, 0x3c, 0xc7, 0x37, 0xb2, 0x8f, 0x90,
	0x89, 0xa3, 0xa8, 0x29, 0xcf, 0xf1, 0xb7, 0xd3, 0x77, 0xc8, 0x38, 0x9c, 0x79, 0x96, 0x83, 0x2b,
	0x49, 0x38, 0xf3, 0x2c, 0x03, 0xb7, 0x04, 0x93, 0x32, 0xfd, 0x4f, 0x6a, 0xa7, 0x94, 0x74, 0x10,
	0x39, 0x80, 0x70, 0x3f, 0xff, 0xbd, 0x02, 0x8c, 0x34, 0x1a, 0x4f, 0xb9, 0x9a, 0x3f, 0x0f, 0x23,
	0x32, 0x61, 0x8c, 0xb0, 0x38, 0x86, 0xdb, 0x98, 0x2a, 0xe6, 0x12, 0x8c, 0x86, 0x9d, 0x23, 0x54,
	0xd3, 0x8b, 0x58, 0x3e, 0x12, 0x76, 0x8e, 0x38, 0xfc, 0x2e, 0x8c, 0x71, 0xf8, 0x4c, 0xde, 0x90,
	0x0b, 0xe8, 0xb9, 0xd8, 0xd4, 0x4a, 0x83, 0x71, 0xc3, 0x02, 0x55, 0x98, 0xd1, 0xb6, 0xf8, 0x83,
	0xdb, 0x03, 0x8c, 0x89, 0x7c, 0x76, 0x72, 0xdd, 0x8f, 0x32, 0x86, 0xd9, 0xeb, 0x6a, 0x6b, 0x00,
	0x29, 0x86, 0x74, 0x93, 0xdb, 0xf4, 0x19, 0xed, 0xca, 0xdc, 0x2e, 0xea, 0xcc, 0x87, 0x97, 0x14,
	0xd1, 0xdf, 0x2f, 0x82, 0x3e, 0xc4, 0x2d, 0x1b, 0x5e, 0x5a, 0xaa, 0xfe, 0x56, 0x09, 0x66, 0x31,
	0xf9, 0xc9, 0x61, 0xe0, 0xd2, 0xc8, 0xf4, 0x55, 0xee, 0xba, 0x8f, 0xe0, 0xb2, 0xf2, 0x5a, 0xf0,
	0x21, 0x15, 0x47, 0x57, 0xb1, 0x82, 0x51, 0x49, 0x5a, 0x52, 0xaf, 0xc5, 0xae, 0x79, 0x96, 0x27,
	0xc3, 0x29, 0xd8, 0x94, 0x61, 0xbe, 0x81, 0x41, 0x14, 0x8a, 0x09, 0x05, 0x09, 0xd5, 0x4f, 0xe1,
	0x4d, 0x28, 0x87, 0x11, 0x0d, 0xcd, 0x88, 0x1a, 0xcd, 0x18, 0x1f, 0xa1, 0x10, 0x91, 0xaa, 0x93,
	0xb2, 0x74, 0x2b, 0xae, 0x5b, 0x6d, 0xbe, 0xef, 0x5f, 0x55, 0x0d, 0xf5, 0x34, 0x22, 0x8f, 0x93,
	0x84, 0x6d, 0xd6, 0x73, 0x22, 0x2b, 0x0e, 0x39, 0x06, 0x7c, 0xba, 0xac, 0x91, 0xff, 0xa8, 0x5b,
	0xab, 0x81, 0x4d, 0xf5, 0xaa, 0x6c, 0x26, 0x8f, 0x24, 0x8e, 0x91, 0x2c, 0x58, 0x38, 0x90, 0xbd,
	0x0a, 0xa2, 0x0d, 0x09, 0x77, 0xc8, 0xfb, 0xb7, 0x08, 0xf3, 0x69, 0x7e, 0x38, 0x09, 0x83, 0x59,
	0xcc, 0x44, 0x06, 0xb6, 0x24, 0x31, 0x57, 0xb6, 0x4a, 0xc3, 0x8c, 0x6d, 0x75, 0xd7, 0xcd, 0x16,
	0xce, 0x54, 0xff, 0xc3, 0x61, 0x98, 0xd2, 0x1b, 0x5d, 0xe6, 0x06, 0xc7, 0x72, 0x93, 0xca, 0x39,
	0x0f, 0x0a, 0xfd, 0xce, 0x03, 0x06, 0x0b, 0xf8, 0xd2, 0x84, 0xbc, 0xb0, 0x22, 0xde, 0xae, 0xcc,
	0xe8, 0xc0, 0xdf, 0x7e, 0xf5, 0xa9, 0x44, 0xb6, 0xbd, 0x95, 0x9d, 0xe0, 0x58, 0x86, 0x69, 0xc9,
	0x57, 0xad, 0xdc, 0x7c, 0x01, 0x2e, 0x9e, 0x7f, 0x75, 0x08, 0xa6, 0x7b, 0x00, 0xb9, 0x5e, 0x94,
	0x59, 0xe8, 0xf8, 0x37, 0xd9, 0x82, 0x11, 0x19, 0x95, 0xf2, 0xd5, 0x6c, 0x37, 0x89, 0x4d, 0x0c,
	0x18, 0xf5, 0x02, 0xbb, 0xe3, 0xe2, 0xa3, 0x4e, 0xa5, 0x8b, 0x85, 0xbb, 0x7e, 0xd9, 0x57, 0xad,
	0xec, 0x22, 0x35, 0x5d, 0x51, 0x25, 0xcb, 0x30, 0x19, 0x51, 0x37, 0x4c, 0x4e, 0xb3, 0x87, 0xb2,
	0xea, 0xdb, 0x04, 0xaf, 0x92, 0x07, 0xd9, 0xd5, 0xbf, 0x58, 0x84, 0x11, 0x81, 0x3d, 0xf0, 0x8b,
	0x7f, 0x1a, 0x8d, 0x7b, 0xf5, 0x46, 0xea, 0xc5, 0x32, 0xa4, 0x5e, 0xa4, 0xab, 0x2b, 0xea, 0xad,
	0x54, 0x3d, 0xa1, 0xcf, 0x59, 0x43, 0x86, 0x4f, 0xc8, 0x83, 0x61, 0xc9, 0x1a, 0xb2, 0xb0, 0xc6,
	0xd0, 0x5b, 0x20, 0x60, 0xf9, 0x46, 0xb7, 0x41, 0x8f, 0x3a, 0xc7, 0xda, 0x1b, 0xb8, 0xaf, 0x72,
	0x4b, 0x53, 0x1d, 0xc0, 0x04, 0xb1, 0x63, 0x51, 0x99, 0x3a, 0x51, 0xa6, 0x8d, 0xd3, 0x4a, 0x88,
	0xb1, 0x19, 0x45, 0x41, 0xa4, 0x0d, 0xe1, 0xf6, 0xab, 0xde, 0x09, 0xd7, 0x86, 0xb1, 0x0a, 0x03,
	0x0f, 0xb4, 0x11, 0xdc, 0x77, 0x37, 0x31, 0x23, 0x85, 0x6f, 0x75, 0xb5, 0xd1, 0xea, 0x5f, 0x2d,
	0xc2, 0xec, 0xb3, 0xfe, 0x14, 0x9a, 0xaf, 0xc8, 0xbd, 0x29, 0x04, 0xef, 0x79, 0xb9, 0x37, 0xcf,
	0x47, 0xce, 0xec, 0xb4, 0x83, 0x90, 0x71, 0x6f, 0x69, 0xf7, 0x21, 0xcb, 0x67, 0xec, 0x32, 0xde,
	0xb1, 0xd7, 0x65, 0xcc, 0x7c, 0x63, 0xe2, 0x95, 0x33, 0x34, 0x45, 0xef, 0xc2, 0xbc, 0x65, 0x0e,
	0xca, 0x4d, 0x3a, 0x24, 0x5f, 0x38, 0x37, 0xfb, 0xd2, 0x92, 0x56, 0xff, 0x42, 0x01, 0xe6, 0x32,
	0xa5, 0x5c, 0x45, 0x11, 0x93, 0x76, 0x81, 0x07, 0x17, 0x0a, 0x17, 0x78, 0x70, 0xe1, 0x9b, 0x50,
	0xcd, 0xa2, 0x9b, 0x8a, 0x7e, 0x76, 0xf4, 0x2a, 0xd6, 0x80, 0x0e, 0xe0, 0x9d, 0xee, 0xbf, 0x5e,
	0x84, 0x4a, 0x4a, 0xd7, 0x09, 0x7c, 0xf9, 0x00, 0x03, 0xba, 0x36, 0x2b, 0x30, 0x8a, 0x9a, 0x7a,
	0xd4, 0x95, 0xab, 0x40, 0xfd, 0x14, 0xca, 0x0e, 0xfe, 0x99, 0x4b, 0xe4, 0x25, 0xcb, 0x30, 0x91,
	0xd7, 0x1c, 0x0c, 0x8b, 0x54, 0xc2, 0x42, 0x39, 0x16, 0x3f, 0xf8, 0xaa, 0xc2, 0x8c, 0x49, 0x62,
	0xc0, 0xf0, 0x6f, 0x52, 0x83, 0xc9, 0x20, 0x3a, 0x36, 0x7d, 0xe7, 0x73, 0xe1, 0x7f, 0x15, 0x1a,
	0x6f, 0xae, 0x8c, 0xdc, 0x84, 0x29, 0x19, 0x35, 0x21, 0xdd, 0x45, 0x42, 0xbd, 0x11, 0x81, 0x7b,
	0xca, 0xff, 0xf3, 0x18, 0x2a, 0x59, 0x24, 0xd3, 0x95, 0x27, 0xac, 0x7c, 0x28, 0x45, 0x52, 0xa9,
	0x85, 0x7c, 0x3d, 0x9e, 0xb1, 0xf2, 0x41, 0x7c, 0x1f, 0x88, 0x15, 0x78, 0x5e, 0xe0, 0x8b, 0xdb,
	0xca, 0x32, 0x7c, 0x68, 0x4c, 0xa6, 0xa7, 0xc6, 0x9a, 0xf4, 0x3c, 0xbd, 0xfa, 0x4f, 0x87, 0x41,
	0xcb, 0xa4, 0x5c, 0x14, 0x3b, 0x6e, 0x04, 0xd3, 0x69, 0x94, 0x77, 0x36, 0x49, 0xf5, 0x85, 0xdc,
	0x05, 0x39, 0x5a, 0x2b, 0xf2, 0x47, 0x26, 0xc2, 0x5b, 0x5e, 0xaa, 0x0b, 0x72, 0xbf, 0x89, 0x27,
	0x3d, 0xf2, 0x4d, 0x0e, 0x9b, 0x4f, 0x34, 0x5e, 0xff, 0x1a, 0xad, 0x0a, 0x15, 0x5a, 0x9c, 0x60,
	0x66, 0x0a, 0xf0, 0x9e, 0x6b, 0x07, 0xed, 0x86, 0xa0, 0x99, 0x86, 0xb4, 0x8b, 0xeb, 0x1d, 0x53,
	0x3a, 0x11, 0x75, 0xfb, 0xcd, 0xa4, 0xd3, 0x8c, 0x98, 0x30, 0xc5, 0x4e, 0x3c, 0xc3, 0xf4, 0x6d,
	0xf9, 0x6a, 0x98, 0x70, 0x29, 0x7f, 0xeb, 0xf5, 0x3b, 0xd7, 0x38, 0xf1, 0xea, 0xbe, 0x2d, 0x1e,
	0x3d, 0x9b, 0x60, 0xe9, 0x8f, 0x2f, 0x39, 0x86, 0x12, 0xf9, 0xfb, 0x06, 0x1d, 0x43, 0x55, 0x3f,
	0x83, 0x89, 0x0c, 0x41, 0xae, 0x23, 0xb2, 0x6c, 0x9c, 0xef, 0x30, 0xe6, 0x44, 0x27, 0x2b, 0x30,
	0xeb, 0xd3, 0x53, 0xa3, 0x27, 0x71, 0xb9, 0xb2, 0x42, 0x7d, 0x7a, 0xba, 0x9e, 0x4b, 0x5c, 0x2e,
	0x9d, 0x86, 0xe2, 0xa8, 0x43, 0x06, 0x1a, 0x8f, 0x39, 0x4c, 0x9c, 0x6b, 0xd4, 0xbe, 0x09, 0xd3,
	0x3d, 0x03, 0x8c, 0xd2, 0xb5, 0xd1, 0xa6, 0xa7, 0x58, 0xa6, 0xbd, 0x81, 0xfa, 0x84, 0x50, 0x5b,
	0xea, 0xa7, 0x66, 0x44, 0x7d, 0xca, 0x98, 0xa8, 0x2a, 0xd4, 0x7e, 0x0e, 0x2e, 0x9d, 0xc3, 0x14,
	0x88, 0x95, 0xd4, 0x6d, 0x8b, 0xc7, 0xf1, 0x9d, 0xcf, 0xf1, 0x6d, 0x43, 0x6e, 0x9c, 0x25, 0x55,
	0xf2, 0x14, 0x51, 0xbe, 0x6c, 0x98, 0x14, 0xeb, 0x1d, 0xdf, 0x17, 0x59, 0x63, 0xd3, 0xac, 0xa6,
	0x75, 0x1b, 0x13, 0x87, 0xaa, 0x93, 0x67, 0x5b, 0x2b, 0x55, 0xdb, 0x30, 0x8b, 0x29, 0x68, 0xb6,
	0x99, 0xc5, 0x1c, 0x79, 0xc1, 0xea, 0x00, 0x2f, 0x84, 0xe3, 0x7d, 0x0e, 0x6a, 0x1b, 0x0e, 0xb7,
	0x5b, 0x95, 0xcc, 0x9a, 0x94, 0xa5, 0xdb, 0x61, 0x03, 0xaf, 0x7c, 0xbd, 0x56, 0x02, 0xf5, 0xea,
	0xdf, 0x29, 0xc0, 0xb4, 0xcc, 0xe2, 0xdb, 0xb0, 0x4c, 0x91, 0x5d, 0xf9, 0x43, 0x58, 0x0c, 0x45,
	0x20, 0x8f, 0x38, 0x38, 0xa5, 0x67, 0xd4, 0xea, 0xa8, 0xdc, 0x08, 0x62, 0xda, 0x16, 0x24, 0x00,
	0xc7, 0xd9, 0x54, 0xd5, 0x22, 0x3b, 0x42, 0xb3, 0xe3, 0x0e, 0xc2, 0x13, 0x66, 0xc8, 0x2c, 0xaf,
	0xed, 0x45, 0xfa, 0x16, 0x5c, 0x66, 0xd4, 0xa5, 0xf8, 0xa2, 0xd8, 0x00, 0x4c, 0x61, 0x98, 0x54,
	0x12, 0x90, 0x1e, 0xf4, 0xea, 0x6f, 0x8c, 0xc2, 0x4c, 0x92, 0x7e, 0xe3, 0x69, 0x5d, 0xaa, 0x51,
	0xb7, 0x41, 0x4b, 0x32, 0xc3, 0x0f, 0x52, 0xfc, 0xa6, 0x55, 0xad, 0x8a, 0xac, 0xfb, 0x08, 0xae,
	0xfa, 0x1d, 0x4f, 0xa4, 0x8f, 0xe7, 0x75, 0x78, 0xb3, 0x20, 0x0e, 0xa4, 0x8e, 0x1c, 0xab, 0xac,
	0xcb, 0x8b, 0x7e, 0xc7, 0x7b, 0x1a, 0xb0, 0x78, 0x4b, 0x82, 0x1c, 0x06, 0x87, 0x12, 0x80, 0xbc,
	0x37, 0x68, 0xec, 0x4b, 0xf2, 0xf1, 0xdb, 0xde, 0xcc, 0xf5, 0x27, 0x30, 0xd6, 0x32, 0x73, 0x29,
	0xe0, 0xd7, 0x5f, 0xbd, 0x54, 0x7b, 0xbf, 0x32, 0x5b, 0x22, 0xb2, 0xeb, 0x2f, 0xb4, 0x33, 0x45,
	0x6b, 0x94, 0xc5, 0x9b, 0xcd, 0x66, 0x10, 0xc5, 0xfa, 0x68, 0x4b, 0x24, 0xf0, 0x25, 0xbf, 0x56,
	0x00, 0x2d, 0xfb, 0x60, 0x2e, 0x5a, 0x5f, 0xc2, 0xb7, 0xbe, 0xfb, 0xf5, 0x3a, 0x90, 0x79, 0x61,
	0x17, 0x6d, 0x81, 0x6a, 0xb6, 0x2b, 0x7b, 0x41, 0xa6, 0x9a, 0xe9, 0xd3, 0x51, 0x1e, 0x98, 0xd4,
	0x61, 0xb1, 0xb7, 0x57, 0x06, 0x9f, 0x9d, 0xc8, 0xb1, 0x69, 0xde, 0x09, 0x78, 0xa9, 0x07, 0x75,
	0x5f, 0x42, 0x91, 0xba, 0x3a, 0x05, 0xb5, 0x45, 0x3e, 0xff, 0x24, 0xe9, 0xbd, 0xe5, 0x52, 0x33,
	0xa2, 0xb6, 0xbc, 0x25, 0x56, 0x95, 0x40, 0x7c, 0xd9, 0xed, 0x48, 0x90, 0x75, 0x01, 0x41, 0x1a,
	0x70, 0x8b, 0xf3, 0x40, 0xc4, 0xf7, 0x3a, 0x7c, 0x48, 0xe9, 0x7c, 0x6e, 0x10, 0x39, 0x42, 0x6a,
	0x7e, 0xc7, 0xd3, 0x15, 0xf4, 0x60, 0xb6, 0xa8, 0xfd, 0x42, 0x01, 0xb4, 0xde, 0x79, 0x22, 0xd7,
	0xe1, 0x72, 0x76, 0x78, 0x9e, 0x3a, 0xc7, 0x2d, 0xb7, 0x2b, 0xaf, 0x92, 0xba, 0xdc, 0xe2, 0xb9,
	0x04, 0xb3, 0x39, 0x00, 0x91, 0x19, 0x5e, 0xa6, 0xb4, 0x1f, 0x38, 0xc7, 0xda, 0x90, 0xc8, 0x15,
	0x9c, 0xd6, 0xa9, 0x17, 0xa7, 0xb4, 0xe1, 0xda, 0xcf, 0x40, 0xf5, 0xfc, 0xa9, 0xc2, 0x5b, 0x27,
	0x7d, 0xd5, 0xf8, 0x54, 0x02, 0xd3, 0x0a, 0xbd, 0x7d, 0x95, 0xb5, 0x0d, 0x7a, 0xec, 0x61, 0xca,
	0xd2, 0x22, 0x26, 0xa7, 0x3e, 0x77, 0xae, 0xb5, 0x52, 0x75, 0x0d, 0x66, 0xd6, 0x5d, 0xc7, 0x6a,
	0xb3, 0x38, 0xa2, 0xa6, 0x27, 0x17, 0xe8, 0x07, 0x30, 0xed, 0x06, 0xc7, 0xc7, 0x7c, 0x94, 0x07,
	0xad, 0xcf, 0xb2, 0xac, 0x54, 0xf6, 0xc2, 0xdf, 0x2e, 0x41, 0x05, 0xdf, 0x5e, 0xe1, 0xd3, 0xc5,
	0xa5, 0xa5, 0xc3, 0x4d, 0x4a, 0x49, 0xeb, 0x05, 0x8c, 0x31, 0x91, 0x1a, 0x99, 0x5e, 0xfc, 0xc4,
	0xcc, 0x74, 0x63, 0x16, 0x9b, 0x56, 0x5b, 0x26, 0x55, 0xa6, 0x4f, 0x46, 0xda, 0x1b, 0xa6, 0xe3,
	0x76, 0xf5, 0x84, 0x16, 0x59, 0x84, 0x21, 0xd3, 0x91, 0x4a, 0x57, 0xc2, 0x80, 0x58, 0xc4, 0xab,
	0xac, 0x20, 0xa2, 0xf9, 0x50, 0x52, 0x2c, 0x22, 0xdf, 0x80, 0x85, 0x96, 0x73, 0xdc, 0xc2, 0x3b,
	0x8e, 0xfe, 0x71, 0xdc, 0x32, 0x72, 0x69, 0xa4, 0x12, 0xe0, 0x39, 0x0e, 0xd4, 0x90, 0x30, 0x07,
	0xe9, 0xdb, 0xae, 0x23, 0x47, 0xa6, 0xef, 0xd3, 0x48, 0x9c, 0x85, 0x29, 0x60, 0x59, 0x48, 0x6e,
	0xc1, 0x24, 0xf3, 0xbd, 0xd0, 0x38, 0xb9, 0x67, 0x04, 0xbe, 0xdb, 0x95, 0xc9, 0x70, 0x25, 0x10,
	0xf0, 0xaa, 0x17, 0xf7, 0xf6, 0x7d, 0x8c, 0x2e, 0xaf, 0x5a, 0x1d, 0x16, 0x07, 0x9e, 0xe1, 0x39,
	0x7e, 0xe6, 0xc1, 0x64, 0x6c, 0x4d, 0x26, 0xcc, 0xb9, 0x24, 0x20, 0x76, 0x1d, 0x3f, 0x79, 0xe8,
	0x18, 0xab, 0xb9, 0x92, 0xe6, 0x99, 0x67, 0x32, 0xa8, 0xd5, 0x8c, 0x63, 0xea, 0x85, 0x71, 0xf2,
	0xea, 0xbf, 0x67, 0x9e, 0x61, 0x20, 0x6b, 0x5d, 0x96, 0x73, 0x15, 0x95, 0x6f, 0x41, 0x41, 0x27,
	0x16, 0x71, 0xc8, 0xe2, 0xad, 0xff, 0x09, 0x59, 0xd6, 0xa0, 0x16, 0xab, 0xfe, 0x72, 0x11, 0x6a,
	0xe9, 0x7d, 0xc2, 0xff, 0x6f, 0x1e, 0xab, 0xff, 0xbc, 0x98, 0xbc, 0x42, 0x2c, 0xbf, 0xfd, 0x12,
	0x8c, 0x9e, 0xb8, 0x66, 0xb2, 0xc7, 0x0e, 0xeb, 0x23, 0xfc, 0xe7, 0xb6, 0x8d, 0x6f, 0xb9, 0x8a,
	0xcb, 0xdf, 0x32, 0x6c, 0x55, 0xfc, 0x22, 0x1a, 0x94, 0xc2, 0xa6, 0x25, 0x3d, 0x3d, 0xfc, 0x4f,
	0xc2, 0x60, 0x0e, 0x05, 0x56, 0x28, 0x53, 0x51, 0x18, 0x14, 0xad, 0x2c, 0x79, 0xcd, 0xa6, 0x7e,
	0x51, 0xdb, 0x4c, 0x8a, 0x76, 0xbe, 0xfc, 0x55, 0x52, 0x0b, 0x69, 0xae, 0xe1, 0xa3, 0x41, 0xf9,
	0xb2, 0xea, 0x6f, 0x15, 0x80, 0xf4, 0x83, 0x72, 0x03, 0x2e, 0xdf, 0x17, 0x99, 0xae, 0x44, 0xda,
	0x37, 0xb3, 0x59, 0x4a, 0xb2, 0x5d, 0xae, 0xf5, 0x5a, 0x27, 0x5e, 0x3f, 0x8a, 0x0c, 0x24, 0xb5,
	0x4e, 0xbc, 0x5e, 0x8c, 0x15, 0x40, 0x42, 0xc9, 0xad, 0x5e, 0x76, 0xea, 0xc4, 0x52, 0x23, 0x1c,
	0xd7, 0x67, 0x78, 0x95, 0xf2, 0xaf, 0x62, 0x45, 0xf5, 0xbf, 0x28, 0xc2, 0x04, 0xea, 0x55, 0x72,
	0xd0, 0x1f, 0x43, 0x25, 0xb9, 0x61, 0x2f, 0x9e, 0xb9, 0xed, 0x89, 0xc4, 0xd7, 0x17, 0x54, 0xbd,
	0x78, 0xe9, 0x37, 0x09, 0xc4, 0x7f, 0x02, 0x55, 0x87, 0x13, 0x92, 0x68, 0x68, 0x7e, 0x73, 0xeb,
	0x40, 0x44, 0xa6, 0x15, 0x05, 0x2e, 0x42, 0x08, 0x44, 0x6e, 0x7f, 0x6f, 0x39, 0x67, 0x18, 0x9d,
	0xf6, 0x73, 0x30, 0x87, 0xa8, 0x21, 0x57, 0x4d, 0x6c, 0xc7, 0x54, 0x56, 0x8c, 0x70, 0x82, 0xbe,
	0xda, 0xd3, 0x94, 0xf9, 0x82, 0x95, 0x86, 0xc5, 0x9c, 0x03, 0x7d, 0x13, 0xc9, 0x08, 0x15, 0xa0,
	0xac, 0xb2, 0xcc, 0x8b, 0x42, 0x7d, 0x86, 0x43, 0x1f, 0x44, 0x19, 0x90, 0xda, 0x77, 0x61, 0xa6,
	0x0f, 0x0f, 0x3d, 0xfd, 0x39, 0x4c, 0x79, 0xb8, 0xb0, 0xe6, 0x1c, 0xcb, 0xdf, 0x05, 0x4c, 0xf0,
	0xb8, 0xe3, 0xc4, 0xb1, 0x4b, 0x65, 0x51, 0xb1, 0xfa, 0x1f, 0x17, 0xe0, 0xaa, 0xd2, 0x20, 0xe5,
	0x6d, 0x3c, 0x75, 0x18, 0x2e, 0x07, 0xf9, 0x16, 0x4c, 0x2b, 0x0f, 0x69, 0xfe, 0x8a, 0x7f, 0x59,
	0x16, 0xab, 0x23, 0xf0, 0x5b, 0x30, 0xad, 0xfc, 0x93, 0xf9, 0xcb, 0xfb, 0x65, 0x59, 0xac, 0x00,
	0x1b, 0x70, 0x4b, 0x66, 0x20, 0xcb, 0xa6, 0xdb, 0x65, 0x46, 0x7c, 0x1a, 0x88, 0xc8, 0x50, 0xc3,
	0xa6, 0x2e, 0x8d, 0xd5, 0x95, 0xfd, 0x31, 0xbd, 0x26, 0xc0, 0x33, 0x89, 0x77, 0xd9, 0xe1, 0x69,
	0x80, 0xd1, 0xa2, 0x1b, 0x12, 0xb2, 0xfa, 0x3d, 0x18, 0xaf, 0xdb, 0xec, 0x82, 0xee, 0xc2, 0xf7,
	0xce, 0xd5, 0xb3, 0x07, 0x28, 0xd9, 0xbf, 0x5d, 0x80, 0x72, 0x3e, 0x75, 0x0b, 0x79, 0xa6, 0x6c,
	0xf6, 0xc2, 0xd7, 0x49, 0xfd, 0x92, 0x9a, 0xfa, 0x98, 0xce, 0x52, 0xb4, 0x8f, 0x7f, 0xd7, 0x3e,
	0x82, 0x61, 0x31, 0xad, 0x13, 0x30, 0xda, 0xae, 0x1f, 0x31, 0xea, 0xc7, 0x72, 0x3e, 0x85, 0xa7,
	0x94, 0x2b, 0x13, 0x05, 0x74, 0x48, 0x49, 0xcf, 0xa9, 0x2d, 0x43, 0x87, 0xb9, 0x06, 0x83, 0x76,
	0xc8, 0xbf, 0x00, 0x98, 0x7c, 0xe9, 0xc4, 0xdc, 0x36, 0x12, 0x94, 0xde, 0x86, 0x29, 0x97, 0x9a,
	0x36, 0xb7, 0x7f, 0x33, 0x26, 0x1c, 0x46, 0xa4, 0x4d, 0x88, 0x8a, 0x06, 0x1a, 0x73, 0x4f, 0xd2,
	0x0b, 0xcd, 0x69, 0x2a, 0x53, 0x95, 0xea, 0xa6, 0x28, 0x77, 0x1e, 0x01, 0x90, 0xe6, 0x34, 0x95,
	0xc9, 0x6b, 0x3a, 0x30, 0x7f, 0x2a, 0xda, 0x14, 0x6b, 0x22, 0x79, 0x50, 0x4d, 0xf8, 0x97, 0x5e,
	0x2d, 0xc3, 0xb2, 0x3d, 0xce, 0xfd, 0x50, 0xef, 0x84, 0xce, 0x9e, 0xf6, 0x17, 0x0e, 0x9e, 0xce,
	0xa1, 0x73, 0x54, 0xf7, 0x15, 0x50, 0x34, 0xd4, 0x61, 0x23, 0xfa, 0xde, 0x84, 0x33, 0x65, 0x46,
	0x56, 0x89, 0xd3, 0x46, 0xf4, 0xba, 0x7d, 0x1f, 0x96, 0x07, 0xdf, 0x4e, 0x37, 0xfa, 0xdb, 0x1c,
	0x91, 0x2f, 0xaa, 0xea, 0x6f, 0x0e, 0xba, 0x79, 0xbe, 0xd3, 0xdb, 0x95, 0x26, 0x7c, 0xa0, 0x48,
	0xb3, 0x38, 0x08, 0x43, 0x6a, 0x1b, 0xcc, 0xf1, 0x2d, 0x6a, 0xb4, 0x1b, 0xb1, 0xe9, 0xdb, 0x75,
	0x37, 0xf0, 0x29, 0x26, 0x84, 0xea, 0x84, 0xf8, 0x4a, 0x45, 0x5e, 0x95, 0x56, 0xdd, 0x6a, 0x08,
	0xd4, 0x06, 0xc7, 0x7c, 0x96, 0x22, 0x6e, 0x05, 0xd1, 0x73, 0x81, 0x46, 0x3e, 0x84, 0x05, 0xbe,
	0xb6, 0xc4, 0xeb, 0x70, 0x49, 0x83, 0x9c, 0x7f, 0xd1, 0x73, 0xf3, 0x64, 0xc8, 0x0f, 0x7c, 0xaa,
	0xcf, 0xc6, 0xa7, 0x01, 0x5a, 0xb3, 0x8a, 0xac, 0x19, 0xd3, 0xea, 0xbf, 0x3d, 0x0c, 0xb3, 0x03,
	0xe6, 0x01, 0xcf, 0xc8, 0x32, 0x94, 0xe4, 0xeb, 0x70, 0xc3, 0xfa, 0x94, 0x95, 0x62, 0x77, 0x18,
	0xf9, 0x39, 0x98, 0xc9, 0x30, 0x91, 0x7c, 0xe7, 0xa6, 0x78, 0xc1, 0x7c, 0xc5, 0xaf, 0x62, 0x86,
	0x95, 0x94, 0xff, 0xc4, 0xa3, 0xbe, 0xba, 0x16, 0xf7, 0x94, 0x70, 0x6e, 0xc6, 0x58, 0xf0, 0x4c,
	0x2f, 0x7a, 0xad, 0x3b, 0x7c, 0x28, 0x34, 0x25, 0x95, 0x4e, 0x4f, 0xad, 0x77, 0xc5, 0x08, 0x96,
	0xca, 0xad, 0x16, 0xfb, 0xdc, 0xdc, 0x05, 0xc3, 0x5f, 0x25, 0x77, 0xc1, 0x39, 0x29, 0x0b, 0x8c,
	0xd7, 0x65, 0x14, 0x11, 0x5b, 0x7d, 0x61, 0x0e, 0xa9, 0xfd, 0x4e, 0x01, 0xb4, 0xde, 0xd1, 0x14,
	0xc9, 0x84, 0x4d, 0xbf, 0x93, 0x5c, 0x09, 0xc2, 0x7b, 0x40, 0xc2, 0x43, 0x2e, 0x11, 0xb5, 0x52,
	0xdf, 0xbb, 0x30, 0x43, 0xc9, 0x2d, 0x18, 0xbe, 0x99, 0x68, 0xc3, 0xe2, 0xe5, 0x06, 0xe5, 0x00,
	0xd2, 0x46, 0x10, 0x01, 0xdf, 0x71, 0x93, 0x24, 0x46, 0xf1, 0xc8, 0x6e, 0xcb, 0x89, 0xbc, 0x53,
	0x33, 0xa2, 0xaa, 0x74, 0x0c, 0x6d, 0xa8, 0xfd, 0xb8, 0x45, 0xa3, 0xdc, 0x4b, 0x4b, 0xda, 0x38,
	0x6e, 0x75, 0x8a, 0x1d, 0xf0, 0x85, 0x06, 0x0d, 0x6a, 0x3f, 0x2a, 0xc0, 0xa5, 0xf5, 0x73, 0xa4,
	0xd2, 0x12, 0x5c, 0x69, 0xf7, 0xd5, 0xed, 0x05, 0x31, 0xba, 0xb9, 0xd0, 0xff, 0xc3, 0xad, 0x32,
	0xb9, 0x0b, 0xa6, 0x10, 0xf2, 0xf0, 0x2a, 0xf7, 0xaa, 0x4c, 0x4f, 0xad, 0x46, 0x2a, 0x30, 0xdb,
	0x4e, 0x0b, 0x95, 0x23, 0x48, 0xfb, 0xa2, 0x58, 0xfd, 0x3e, 0x0c, 0xe9, 0xa6, 0xd5, 0xce, 0xde,
	0x15, 0x29, 0x0c, 0xbc, 0x2b, 0x92, 0xf1, 0x3f, 0xe3, 0x5d, 0x11, 0x74, 0xd7, 0xe7, 0x2e, 0x92,
	0x94, 0xf2, 0x17, 0x49, 0xaa, 0xff, 0x51, 0xfa, 0xb1, 0xeb, 0x81, 0x2f, 0x37, 0x5b, 0xf9, 0xb1,
	0x1e, 0xcc, 0xc8, 0xdb, 0x58, 0x99, 0x77, 0xd4, 0x0b, 0x7f, 0x34, 0x69, 0x6d, 0x75, 0x4d, 0x90,
	0x4e, 0x4b, 0xb9, 0x96, 0x6d, 0x25, 0x5d, 0x30, 0xb8, 0xad, 0xa2, 0x22, 0xd5, 0x73, 0xda, 0xfa,
	0x5c, 0x0a, 0xb4, 0xed, 0xab, 0xb0, 0xf3, 0xea, 0xbf, 0x52, 0x80, 0x6b, 0xbb, 0xf8, 0x50, 0x58,
	0xd6, 0xe4, 0x3c, 0xe0, 0x5f, 0x25, 0xcf, 0xeb, 0xc5, 0x59, 0xbc, 0x3a, 0xde, 0xcf, 0x27, 0x3b,
	0x90, 0xa5, 0x7b, 0x32, 0x58, 0x11, 0x03, 0x53, 0xd2, 0x77, 0xc8, 0x8a, 0x98, 0x4e, 0x62, 0x92,
	0x97, 0xee, 0xca, 0xb7, 0xc8, 0xc8, 0x32, 0x68, 0x6d, 0x1a, 0xf9, 0xd4, 0xcd, 0xc0, 0x95, 0x10,
	0xae, 0x2c, 0xca, 0x15, 0x64, 0xf5, 0x11, 0xcc, 0xa5, 0x1f, 0xb9, 0xe3, 0xda, 0x2a, 0x58, 0xe6,
	0x3a, 0x8c, 0xb9, 0xae, 0x1d, 0xda, 0x46, 0x7c, 0x96, 0xd7, 0x2c, 0xb0, 0xf4, 0xf0, 0xac, 0xfa,
	0xf7, 0x86, 0x81, 0xa8, 0xf3, 0x68, 0x9d, 0xe2, 0xdb, 0xec, 0x5c, 0x5c, 0xde, 0x87, 0x44, 0x13,
	0x35, 0xa2, 0xa4, 0x38, 0xe5, 0x89, 0x39, 0xda, 0x87, 0xb3, 0x6d, 0xe7, 0xf4, 0xdb, 0x0c, 0x56,
	0x86, 0x61, 0x16, 0xfa, 0xf1, 0x70, 0x3c, 0xce, 0xc1, 0xcc, 0x3e, 0xac, 0xd8, 0x8f, 0x89, 0xdb,
	0x5d, 0xad, 0x2f, 0xf6, 0x42, 0xcd, 0x61, 0xf6, 0x81, 0x20, 0x75, 0xa0, 0x39, 0xfc, 0xb5, 0x0e,
	0x34, 0x7f, 0x98, 0x09, 0x95, 0x15, 0x4e, 0xac, 0x57, 0x3f, 0x22, 0xde, 0x3f, 0xb8, 0x49, 0xd0,
	0xec, 0x93, 0xa1, 0xf6, 0x5e, 0x93, 0x65, 0x42, 0x67, 0x7f, 0x12, 0xc0, 0x6f, 0x32, 0x83, 0x9e,
	0x61, 0xc4, 0xee, 0x28, 0xf6, 0xf5, 0x5b, 0x5f, 0xa5, 0x85, 0xbd, 0x26, 0xdb, 0x44, 0x22, 0xfa,
	0xb8, 0xaf, 0xfe, 0xac, 0xfe, 0xdd, 0x02, 0x8c, 0x27, 0x15, 0x03, 0x8f, 0x41, 0x63, 0x98, 0x90,
	0xf9, 0xab, 0x3d, 0x75, 0xf8, 0x73, 0x91, 0xc7, 0x29, 0xbf, 0xac, 0x03, 0x2b, 0x75, 0x24, 0x88,
	0x79, 0x6e, 0xc6, 0xdb, 0x3a, 0x35, 0xed, 0x7d, 0xdf, 0xed, 0xea, 0x32, 0x4f, 0x36, 0x2f, 0xae,
	0xbd, 0x07, 0x90, 0x02, 0xa1, 0x30, 0x56, 0x60, 0x52, 0x85, 0xe4, 0x3f, 0xf1, 0x0d, 0x03, 0xad,
	0x50, 0x9b, 0xeb, 0x09, 0x7e, 0xdd, 0x6b, 0x32, 0xed, 0x8d, 0xea, 0xbf, 0x57, 0x82, 0x59, 0x25,
	0x60, 0xb2, 0x79, 0x4a, 0x7e, 0x06, 0xe6, 0x3c, 0x1a, 0x59, 0x9d, 0xa8, 0x9b, 0x4f, 0x0a, 0x29,
	0xae, 0x0e, 0x3f, 0xbd, 0x68, 0x56, 0x98, 0x2c, 0xcd, 0x95, 0x5d, 0x41, 0x30, 0x97, 0x1a, 0x72,
	0xd6, 0xeb, 0x2f, 0xe4, 0x8d, 0x5b, 0x66, 0x6c, 0xba, 0xc1, 0x71, 0xbe, 0xf1, 0xe2, 0xd7, 0x68,
	0x7c, 0x5d, 0x10, 0xcc, 0x37, 0x6e, 0xf5, 0x17, 0x56, 0x77, 0x60, 0x76, 0x40, 0x47, 0xc9, 0x03,
	0x98, 0x3d, 0x8e, 0x42, 0x4b, 0x1d, 0xc4, 0x0e, 0xbc, 0x06, 0x3e, 0xc3, 0x21, 0x84, 0x3c, 0x55,
	0xee, 0xb0, 0x3d, 0x98, 0x1d, 0xd0, 0x32, 0x79, 0x04, 0x73, 0xf8, 0x7a, 0x88, 0xeb, 0x78, 0x4e,
	0x9c, 0xa6, 0xba, 0xc9, 0x93, 0x23, 0x1c, 0x64, 0x87, 0x43, 0x24, 0x69, 0x6d, 0xaa, 0x1b, 0x30,
	0xbe, 0xe1, 0x2b, 0xe3, 0xe7, 0x11, 0x54, 0x6c, 0x9f, 0xa9, 0xd8, 0x38, 0x71, 0x44, 0xa7, 0xe2,
	0xa4, 0x0b, 0x32, 0xb5, 0xb0, 0xcf, 0x44, 0xd0, 0x98, 0x38, 0xa8, 0x13, 0xd1, 0xd2, 0xd5, 0x7f,
	0x58, 0x84, 0x79, 0x39, 0x48, 0x4f, 0x9d, 0x23, 0xce, 0x82, 0xb1, 0x8c, 0x92, 0x59, 0x86, 0x72,
	0x4b, 0x95, 0x08, 0x5e, 0x2e, 0xa8, 0xac, 0xef, 0x53, 0x49, 0x05, 0xb2, 0xdb, 0x03, 0x98, 0x4f,
	0x21, 0x63, 0x93, 0xb5, 0x73, 0x96, 0x03, 0x47, 0x98, 0x4d, 0xea, 0x0f, 0x4d, 0xd6, 0x16, 0xbb,
	0x56, 0xed, 0x31, 0x4c, 0x3d, 0xcd, 0xd1, 0x49, 0x6e, 0x20, 0x0b, 0x96, 0x4d, 0x2a, 0xb5, 0x82,
	0x7c, 0x60, 0x0d, 0xc3, 0xb5, 0xb4, 0x62, 0xed, 0x37, 0x0a, 0x30, 0xfb, 0xb4, 0x9f, 0x22, 0x06,
	0x96, 0xf0, 0x9f, 0xb9, 0x7d, 0x1e, 0x5f, 0x3d, 0x4c, 0xf6, 0x72, 0x93, 0xb5, 0xe5, 0x1e, 0xcf,
	0x81, 0x9f, 0x33, 0x1a, 0x6d, 0xef, 0x7f, 0xd2, 0x71, 0x28, 0xb3, 0xd0, 0x9c, 0x9a, 0x87, 0x19,
	0xf1, 0x48, 0x14, 0x3e, 0xf7, 0x17, 0x99, 0x8e, 0x4f, 0x6d, 0x6d, 0x08, 0xd5, 0x92, 0x4d, 0x6c,
	0x9d, 0x97, 0xcb, 0x07, 0x5d, 0x6c, 0x6d, 0x4c, 0xe4, 0x1b, 0x77, 0x5d, 0x4e, 0x96, 0xa5, 0x27,
	0x42, 0xd3, 0xd5, 0x1f, 0x17, 0x60, 0x5a, 0xa7, 0x56, 0xd7, 0x72, 0xe9, 0x9a, 0x23, 0xad, 0xf5,
	0xdb, 0x40, 0x22, 0x51, 0x64, 0x1c, 0x39, 0x7e, 0x4e, 0x85, 0xe6, 0x63, 0xa4, 0x45, 0x39, 0xf8,
	0x0e, 0x26, 0xf6, 0x4f, 0xf4, 0x56, 0xe1, 0xa7, 0x93, 0x11, 0x5f, 0x49, 0x29, 0xa6, 0x32, 0x7a,
	0x2b, 0x79, 0x34, 0xf2, 0x32, 0x5c, 0x6a, 0x37, 0x42, 0xd3, 0xa2, 0xc9, 0x7b, 0x6c, 0x9b, 0x67,
	0x16, 0xa5, 0x36, 0xb5, 0xb5, 0x42, 0xed, 0xa7, 0x61, 0x56, 0x0f, 0x4e, 0xd7, 0xeb, 0x0d, 0xa9,
	0x6d, 0x49, 0x9c, 0xcc, 0xa0, 0xcf, 0xc0, 0x14, 0x37, 0x2d, 0xe5, 0x45, 0x38, 0xb4, 0x36, 0xf9,
	0x3c, 0xa4, 0xbf, 0x8b, 0x28, 0x59, 0x92, 0xcf, 0x17, 0xe9, 0xd6, 0x93, 0x7b, 0x73, 0x89, 0x22,
	0x34, 0x54, 0xfb, 0xcb, 0x97, 0x60, 0xba, 0xd1, 0x93, 0xab, 0x17, 0x3b, 0xe7, 0xf8, 0xc7, 0x2e,
	0xdd, 0x70, 0x98, 0x18, 0x64, 0x59, 0xa5, 0xbd, 0x81, 0x0e, 0xeb, 0x2d, 0x27, 0x62, 0xf1, 0x6e,
	0xc7, 0x8d, 0x9d, 0x3e, 0x00, 0x40, 0x87, 0x35, 0xba, 0x01, 0x6c, 0x6a, 0xef, 0x35, 0xd9, 0x96,
	0x48, 0x2a, 0xa4, 0xea, 0xe7, 0xc8, 0x4d, 0xb8, 0x2e, 0x50, 0xb6, 0xdc, 0x0e, 0x6b, 0xe9, 0xd4,
	0x0a, 0x22, 0x9b, 0xcf, 0x88, 0xe7, 0x28, 0x5f, 0x85, 0x56, 0x21, 0x6f, 0xc2, 0x12, 0xee, 0x16,
	0xd4, 0x75, 0xfc, 0xcf, 0x3a, 0x0e, 0x87, 0x53, 0x6f, 0x9b, 0xa8, 0xf4, 0x00, 0xda, 0x22, 0x3e,
	0xb1, 0x98, 0xcd, 0x44, 0x87, 0x62, 0x53, 0x55, 0x5f, 0x43, 0xbd, 0x71, 0x97, 0xc6, 0x51, 0xc0,
	0xf5, 0x50, 0xcc, 0xd8, 0xa0, 0xea, 0x96, 0x49, 0x0d, 0xae, 0xb5, 0x65, 0x1e, 0xbc, 0x86, 0x6f,
	0x86, 0xac, 0x15, 0xc4, 0x18, 0xad, 0xb9, 0xaf, 0xee, 0x0c, 0x68, 0x77, 0xc9, 0x32, 0xbc, 0xd9,
	0xde, 0xd8, 0x3c, 0xd0, 0x37, 0xd7, 0xeb, 0x87, 0x9b, 0x1b, 0x0d, 0xd7, 0x3c, 0x49, 0x1e, 0x1e,
	0xc4, 0x47, 0xc6, 0x14, 0xe4, 0x37, 0xc5, 0x99, 0x63, 0x02, 0xa9, 0x87, 0xd6, 0x8b, 0xbb, 0xaa,
	0x72, 0x8b, 0xdc, 0x80, 0xab, 0x6a, 0x26, 0xa4, 0x7b, 0x64, 0x3f, 0x14, 0x07, 0xf7, 0xf2, 0x2d,
	0xda, 0x03, 0x9c, 0x9d, 0x17, 0x8c, 0x3d, 0xf7, 0x6d, 0x1a, 0xbd, 0x60, 0xd6, 0x56, 0xe0, 0xda,
	0x34, 0xd2, 0x3e, 0xc5, 0xb1, 0x3c, 0xbf, 0x5d, 0x1b, 0xf9, 0x20, 0xd7, 0x9a, 0x2f, 0x32, 0x63,
	0xf1, 0xe1, 0xfd, 0x94, 0x46, 0x98, 0x90, 0x40, 0x26, 0x6c, 0xd2, 0xce, 0xc8, 0x4d, 0xb8, 0xd6,
	0x96, 0x0f, 0x13, 0x75, 0xdd, 0xc0, 0xb4, 0x9f, 0x9a, 0xec, 0x29, 0x1a, 0x4b, 0xc9, 0xb8, 0xfc,
	0x42, 0x81, 0xac, 0xc2, 0x7b, 0xd9, 0x07, 0xda, 0x1a, 0xae, 0x63, 0xd1, 0xa7, 0x26, 0xc3, 0xd9,
	0x0e, 0x5d, 0xaa, 0x1e, 0x9d, 0x53, 0x18, 0x7f, 0xae, 0x40, 0x96, 0xe0, 0xb2, 0x48, 0x4e, 0xc0,
	0x3f, 0x8a, 0xda, 0x5b, 0x8e, 0x4b, 0xb7, 0x6d, 0x4c, 0xa6, 0xcc, 0x19, 0x5c, 0xfb, 0xf5, 0x02,
	0xf9, 0x00, 0x96, 0x33, 0xc3, 0x83, 0xcf, 0x13, 0x21, 0x0b, 0x71, 0x63, 0x0e, 0x0f, 0x76, 0x5c,
	0x33, 0x61, 0xa0, 0x7f, 0xab, 0x80, 0xfd, 0xfc, 0x72, 0xa0, 0xdf, 0x2a, 0x90, 0x15, 0x78, 0x87,
	0xd3, 0xdc, 0x54, 0xb3, 0x23, 0xe6, 0x32, 0xc9, 0x83, 0x25, 0x2e, 0xe0, 0x29, 0xf8, 0xbf, 0x52,
	0x20, 0xf3, 0xa0, 0xb5, 0x95, 0x9f, 0x47, 0x15, 0xff, 0x8d, 0x02, 0x79, 0x13, 0xae, 0xb7, 0x77,
	0x9d, 0x33, 0xf1, 0x2c, 0x9e, 0x1c, 0xaa, 0x4d, 0x0c, 0x1c, 0x4e, 0x06, 0xe5, 0x3f, 0x28, 0x90,
	0xab, 0x50, 0x11, 0x23, 0x97, 0x81, 0x52, 0xd5, 0xbf, 0x23, 0x46, 0x60, 0xaf, 0xc9, 0xc4, 0x23,
	0x75, 0x98, 0xf2, 0x0d, 0x8d, 0x0e, 0x11, 0x00, 0xcb, 0xb4, 0xff, 0xa4, 0x40, 0x34, 0x98, 0x68,
	0x7f, 0x12, 0x34, 0x14, 0xce, 0x7f, 0x59, 0x20, 0x37, 0xf0, 0x79, 0xce, 0xc4, 0x65, 0xd6, 0xeb,
	0x31, 0xd3, 0xfe, 0xb1, 0x18, 0x87, 0x74, 0xd8, 0xb0, 0xfd, 0x46, 0x0b, 0xbd, 0x4b, 0x8a, 0xce,
	0xef, 0x15, 0xc8, 0x02, 0xcc, 0xb4, 0x45, 0x87, 0x77, 0x3e, 0xbd, 0xaf, 0xca, 0xff, 0xb7, 0x02,
	0x79, 0x0b, 0x96, 0x04, 0xeb, 0x60, 0x7c, 0x54, 0xdd, 0xfa, 0xac, 0xe3, 0x70, 0x4c, 0x3c, 0xe2,
	0x57, 0x60, 0x7f, 0x20, 0xda, 0xf8, 0xf2, 0xb1, 0xfb, 0xc5, 0xa2, 0x34, 0xa3, 0x1c, 0x4f, 0x3e,
	0xde, 0xaa, 0x6a, 0xfe, 0x4c, 0x11, 0x47, 0x55, 0xbd, 0xc5, 0xa7, 0x8a, 0x7f, 0xbd, 0x88, 0xa3,
	0x8a, 0x8e, 0xd4, 0x3d, 0xd3, 0x5c, 0x33, 0x19, 0x45, 0x76, 0x10, 0xfb, 0x98, 0x82, 0xfa, 0xcd,
	0x22, 0x0e, 0xc1, 0x16, 0x1f, 0x7b, 0xd1, 0x7f, 0x64, 0xb5, 0x86, 0xf3, 0x79, 0x32, 0x3d, 0xff,
	0x4e, 0x11, 0x47, 0x36, 0xb3, 0x04, 0xbd, 0x23, 0xf1, 0xb0, 0xeb, 0xbe, 0xbf, 0xee, 0x06, 0x8c,
	0x6a, 0xff, 0xae, 0x20, 0x82, 0xcc, 0xc2, 0x79, 0xc4, 0xf1, 0x8f, 0xeb, 0xcd, 0xa6, 0xe3, 0x3b,
	0x71, 0x57, 0x11, 0xf9, 0xf7, 0xc5, 0x03, 0xb8, 0x83, 0x46, 0xef, 0xef, 0x14, 0xc9, 0xfb, 0x70,
	0x4b, 0x54, 0xe1, 0x13, 0x7c, 0x2c, 0x7e, 0xce, 0xa8, 0xbd, 0x19, 0x3a, 0x2c, 0xb0, 0x69, 0x03,
	0x1f, 0xb5, 0xb2, 0x92, 0xde, 0xfc, 0xa7, 0x45, 0x1c, 0xd3, 0xb4, 0x37, 0x9b, 0xeb, 0xdb, 0x3e,
	0xbe, 0x33, 0x94, 0x13, 0x3b, 0xff, 0xb0, 0x48, 0xe6, 0xf8, 0xe6, 0x26, 0xbc, 0x35, 0xaa, 0xf4,
	0xbf, 0x2f, 0x92, 0x2b, 0x70, 0xa9, 0xbd, 0x66, 0xc6, 0x56, 0xeb, 0xa0, 0xe3, 0xba, 0x38, 0x0d,
	0x09, 0x87, 0xfd, 0x7e, 0x91, 0xbc, 0xc3, 0x65, 0x0d, 0x7e, 0x9b, 0x18, 0x8c, 0x97, 0x4e, 0xdc,
	0x0a, 0x3a, 0x31, 0xff, 0xb0, 0xe7, 0xcc, 0x3c, 0x4e, 0x08, 0xfd, 0xb3, 0x22, 0xb9, 0x0e, 0xd5,
	0xf6, 0xfa, 0xc7, 0xea, 0x73, 0xd5, 0xb1, 0xa6, 0x02, 0xf8, 0x3f, 0x8b, 0xc8, 0x12, 0x7d, 0x43,
	0xf5, 0x7f, 0x17, 0xc9, 0xdb, 0x70, 0x23, 0x23, 0x79, 0xf1, 0x4a, 0x68, 0xd3, 0xb4, 0xe4, 0xbb,
	0xb3, 0x0a, 0xff, 0x97, 0x4a, 0xe4, 0x31, 0xdc, 0xcb, 0x7c, 0xa6, 0x9a, 0xde, 0x03, 0x0e, 0xc0,
	0xe2, 0xe7, 0xbe, 0xeb, 0xf8, 0x98, 0x6f, 0x41, 0x8e, 0x53, 0xf2, 0x15, 0x3f, 0x2e, 0x91, 0xcb,
	0xb0, 0xd0, 0x1e, 0x3c, 0x2c, 0xff, 0x7a, 0x09, 0x9b, 0xcf, 0x48, 0x01, 0x66, 0xa1, 0xb8, 0x53,
	0xd2, 0x57, 0xca, 0xbc, 0x7f, 0xa3, 0x44, 0x6e, 0x41, 0x2d, 0x03, 0x77, 0xf7, 0x1c, 0xc0, 0xbf,
	0x58, 0x22, 0x1f, 0xc2, 0xfd, 0x2c, 0xe0, 0x85, 0x3b, 0xfa, 0x1b, 0xa5, 0x9e, 0xa5, 0x55, 0xdf,
	0x6c, 0x24, 0xda, 0x9a, 0x02, 0xfa, 0x4b, 0x25, 0x1c, 0x47, 0xdd, 0xb4, 0xda, 0xf5, 0x4c, 0x8a,
	0x51, 0xed, 0x2f, 0x97, 0x50, 0xf4, 0x5c, 0xb8, 0xb1, 0xdf, 0x2e, 0x91, 0x2a, 0xcc, 0xb7, 0xb7,
	0x5c, 0x33, 0x5e, 0xeb, 0x34, 0x9b, 0x34, 0xe2, 0xf2, 0x5a, 0xd6, 0xfd, 0xcd, 0x12, 0x72, 0xc5,
	0xc7, 0x91, 0x69, 0x77, 0x4c, 0x77, 0xe7, 0x94, 0xd5, 0xc3, 0xd0, 0x4d, 0x38, 0xf7, 0xef, 0xf6,
	0xce, 0x84, 0x5c, 0xa7, 0x7b, 0x4d, 0x86, 0x43, 0xab, 0xee, 0xf2, 0xe2, 0x8b, 0xea, 0xb8, 0xd4,
	0x15, 0xe6, 0x3f, 0x28, 0x89, 0x47, 0x9f, 0x07, 0x7c, 0xd6, 0x7f, 0x5d, 0x22, 0xcb, 0x70, 0x53,
	0xac, 0x18, 0x8c, 0x84, 0xd9, 0x35, 0xc3, 0x94, 0x13, 0x5c, 0x93, 0x25, 0x1d, 0xff, 0x1f, 0xc5,
	0x74, 0xe2, 0x32, 0x16, 0x07, 0x12, 0x5b, 0xc9, 0x83, 0xdc, 0xda, 0xff, 0x54, 0x42, 0xa1, 0x9e,
	0xd9, 0x28, 0xb0, 0x4b, 0xfb, 0x61, 0xfa, 0x9d, 0x2c, 0xf3, 0xa1, 0xff, 0x44, 0xcc, 0xbe, 0x7c,
	0x98, 0x2e, 0xec, 0x3e, 0x0f, 0x45, 0xfe, 0x54, 0xb5, 0xad, 0x29, 0xb8, 0x7f, 0x2e, 0x66, 0xbf,
	0xbe, 0xd9, 0x10, 0x0a, 0x81, 0xce, 0xd7, 0x20, 0x8b, 0xd7, 0x4c, 0xab, 0x9d, 0xff, 0x8c, 0xff,
	0x2b, 0x01, 0xc4, 0x25, 0x85, 0xe2, 0xdb, 0x73, 0x06, 0x00, 0xfe, 0x41, 0x09, 0x65, 0x88, 0x10,
	0xcd, 0x2e, 0x65, 0x4c, 0xb1, 0x51, 0xf2, 0x9d, 0xff, 0xa2, 0x44, 0x6a, 0x70, 0xb5, 0xfd, 0x82,
	0x46, 0x4e, 0xb3, 0x2b, 0x77, 0xc6, 0xde, 0x5d, 0xee, 0x4f, 0x0f, 0xe1, 0x16, 0xd0, 0xdb, 0x2f,
	0x55, 0xfd, 0xe7, 0x93, 0xea, 0x5c, 0x6f, 0x54, 0xf5, 0x2f, 0x0f, 0x91, 0xdb, 0xf0, 0x6e, 0xc2,
	0x32, 0x3b, 0x26, 0x8b, 0xf9, 0xbf, 0x89, 0xa4, 0x91, 0x3c, 0x94, 0x76, 0xfa, 0xc7, 0x43, 0x39,
	0x1e, 0xe3, 0x08, 0x3a, 0xb5, 0x4e, 0xce, 0x85, 0xff, 0x95, 0x21, 0x1c, 0x0d, 0xa5, 0xc7, 0x49,
	0x39, 0xe2, 0x85, 0x71, 0x77, 0x73, 0x9d, 0x4b, 0xdd, 0x44, 0xa7, 0xf9, 0xd5, 0x21, 0x9c, 0xd3,
	0xfa, 0x66, 0x63, 0x73, 0xbd, 0x8f, 0x35, 0xfe, 0xea, 0x10, 0x0e, 0xd5, 0xb6, 0x78, 0xea, 0x2d,
	0x79, 0xcc, 0x34, 0x23, 0x30, 0xff, 0x1a, 0xd7, 0xaf, 0x49, 0x3b, 0x55, 0x97, 0x55, 0xc5, 0xdf,
	0x12, 0xa8, 0x5c, 0xbe, 0xd2, 0xdd, 0x0e, 0x5e, 0x5a, 0x97, 0xaa, 0x8e, 0x82, 0xf8, 0xfb, 0x43,
	0xe4, 0x11, 0xdc, 0x3d, 0x5f, 0xac, 0xf4, 0x0d, 0x8a, 0x42, 0xfc, 0xcf, 0x87, 0x90, 0x97, 0x37,
	0x8f, 0x1d, 0x7b, 0xd7, 0x0c, 0x71, 0xc7, 0x54, 0x55, 0xff, 0xad, 0xec, 0xce, 0xd6, 0x1d, 0xf9,
	0x2d, 0xaa, 0xe2, 0x7f, 0x96, 0xdd, 0x91, 0x6f, 0x65, 0x45, 0xc1, 0x59, 0x77, 0xff, 0x84, 0x46,
	0x7b, 0xcd, 0xa4, 0x3b, 0xff, 0xeb, 0x10, 0x4e, 0x3a, 0x32, 0x77, 0xc2, 0xfe, 0x32, 0x95, 0x9b,
	0x82, 0xf9, 0x3f, 0x04, 0x79, 0xf1, 0x64, 0x59, 0x56, 0x6d, 0xf8, 0x62, 0x98, 0x5c, 0x83, 0x45,
	0xc9, 0x31, 0x82, 0xa7, 0x5b, 0xa6, 0x93, 0x8a, 0xf3, 0x3f, 0x3b, 0x9c, 0xae, 0x31, 0xc1, 0xed,
	0x5c, 0x9a, 0x23, 0xb8, 0x0c, 0x4f, 0x55, 0x90, 0xbf, 0x36, 0x8c, 0x13, 0x7d, 0xe1, 0x85, 0xfd,
	0x6f, 0x0e, 0xd7, 0xfe, 0xb5, 0x22, 0x68, 0xd2, 0x0c, 0xdc, 0xea, 0xf8, 0x42, 0xc3, 0x10, 0xa6,
	0xc1, 0xc6, 0x56, 0x43, 0x9e, 0x22, 0xa2, 0xb2, 0x66, 0x25, 0x79, 0x4f, 0xf1, 0xc9, 0x70, 0x37,
	0xe8, 0xd8, 0xdc, 0x24, 0xfa, 0xd8, 0x8c, 0xe9, 0xa9, 0xd9, 0x95, 0x49, 0x39, 0xeb, 0x2f, 0x76,
	0xb5, 0x31, 0xb4, 0xd9, 0x76, 0xf9, 0xce, 0x7f, 0x62, 0x6a, 0x1a, 0x5a, 0x12, 0xd2, 0x81, 0xfb,
	0x62, 0x57, 0x5b, 0x42, 0x74, 0x9c, 0x4d, 0xe1, 0xc7, 0xe4, 0x03, 0xb1, 0xab, 0x7d, 0x84, 0xe9,
	0x65, 0xbe, 0xe7, 0xbc, 0xd8, 0xd5, 0xbe, 0x10, 0xea, 0x4d, 0xfd, 0xe3, 0x86, 0x4a, 0xa6, 0xfa,
	0x45, 0x11, 0xdf, 0x6d, 0xfa, 0x6e, 0xc7, 0x0b, 0xd7, 0x82, 0x33, 0x0e, 0x32, 0x94, 0xdd, 0x14,
	0x13, 0xb0, 0x31, 0x2c, 0x95, 0x29, 0x59, 0x93, 0x52, 0x0d, 0xc9, 0x6d, 0xd7, 0x77, 0x93, 0x92,
	0x25, 0x52, 0x86, 0xf1, 0xf6, 0x41, 0xc0, 0xa8, 0x63, 0xf3, 0xf1, 0x17, 0xaf, 0xd0, 0xcb, 0x6a,
	0xb6, 0xef, 0xd7, 0x5f, 0x36, 0xb4, 0x2f, 0xbe, 0x28, 0xd4, 0x3e, 0x86, 0x99, 0xbe, 0x88, 0x05,
	0xf1, 0xfe, 0x54, 0xd0, 0x89, 0xd0, 0xc1, 0x82, 0x21, 0xe6, 0xa6, 0xe3, 0x76, 0x65, 0x5c, 0xf9,
	0x4b, 0x4a, 0xdb, 0x6e, 0x57, 0x7a, 0xcd, 0x77, 0x03, 0x3f, 0x6e, 0xb9, 0x5d, 0xad, 0x54, 0x33,
	0x61, 0x2a, 0xef, 0xe2, 0xcf, 0x3d, 0xf2, 0x9f, 0x73, 0xda, 0x14, 0xf0, 0x9d, 0xfb, 0xd4, 0x6d,
	0x2f, 0xef, 0xb8, 0x88, 0x33, 0xf1, 0xc3, 0x40, 0x7e, 0xb2, 0x4c, 0x5e, 0xa5, 0xe2, 0xa9, 0xb4,
	0xa1, 0xda, 0x32, 0x4c, 0x64, 0xb2, 0xf0, 0x62, 0x03, 0xdf, 0x7b, 0xfc, 0xd0, 0x78, 0x78, 0x5f,
	0xa5, 0xfb, 0x0a, 0xad, 0x87, 0xf7, 0x5d, 0xaa, 0x15, 0x6a, 0xcb, 0x30, 0xfa, 0x6c, 0xb7, 0x91,
	0xdc, 0xa7, 0xdf, 0x7c, 0xb6, 0x2b, 0xdf, 0xd7, 0xda, 0x79, 0xb6, 0x2b, 0x5d, 0xff, 0x07, 0xeb,
	0xcf, 0x76, 0xb5, 0x62, 0x6d, 0x03, 0xa6, 0xc4, 0x6b, 0xfe, 0xca, 0x92, 0xe3, 0xc6, 0x80, 0x8c,
	0xa5, 0xcc, 0x55, 0x68, 0x6f, 0x60, 0x38, 0x93, 0x28, 0x4b, 0x9f, 0xe4, 0xd7, 0x0f, 0xd6, 0xb5,
	0xe1, 0xb5, 0x65, 0x58, 0xb4, 0x02, 0x2f, 0xef, 0xb0, 0x41, 0xa7, 0xdd, 0x51, 0xa7, 0xf9, 0xe9,
	0x04, 0xfe, 0x14, 0x57, 0x38, 0xfe, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x50, 0x14, 0xdb, 0x43,
	0xe6, 0xd0, 0x00, 0x00,
}
