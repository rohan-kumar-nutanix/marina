// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hyperint/hyperint.proto

package hyperint

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/nutanix-core/acs-aos-go/nutanix/util-slbufs/util/sl_bufs/net"
	math "math"
	stretch_params "github.com/nutanix-core/acs-aos-go/pithos/stretch_params"
	arithmos "github.com/nutanix-core/acs-aos-go/stats/arithmos"
	config "github.com/nutanix-core/acs-aos-go/zeus/config"
)

import (
	"errors"
	util_net "github.com/nutanix-core/acs-aos-go/nutanix/util-go/net"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type HyperintError_Type int32

const (
	HyperintError_kNoError            HyperintError_Type = 0
	HyperintError_kRetry              HyperintError_Type = 1
	HyperintError_kCanceled           HyperintError_Type = 2
	HyperintError_kTimeout            HyperintError_Type = 3
	HyperintError_kMalformedRequest   HyperintError_Type = 4
	HyperintError_kMethodNotSupported HyperintError_Type = 5
	HyperintError_kNotFound           HyperintError_Type = 6
	HyperintError_kOther              HyperintError_Type = 100
)

var HyperintError_Type_name = map[int32]string{
	0:   "kNoError",
	1:   "kRetry",
	2:   "kCanceled",
	3:   "kTimeout",
	4:   "kMalformedRequest",
	5:   "kMethodNotSupported",
	6:   "kNotFound",
	100: "kOther",
}

var HyperintError_Type_value = map[string]int32{
	"kNoError":            0,
	"kRetry":              1,
	"kCanceled":           2,
	"kTimeout":            3,
	"kMalformedRequest":   4,
	"kMethodNotSupported": 5,
	"kNotFound":           6,
	"kOther":              100,
}

func (x HyperintError_Type) Enum() *HyperintError_Type {
	p := new(HyperintError_Type)
	*p = x
	return p
}

func (x HyperintError_Type) String() string {
	return proto.EnumName(HyperintError_Type_name, int32(x))
}

func (x *HyperintError_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HyperintError_Type_value, data, "HyperintError_Type")
	if err != nil {
		return err
	}
	*x = HyperintError_Type(value)
	return nil
}

func (HyperintError_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{0, 0}
}

type VirtualCd_Type int32

const (
	// Virtual CD is a file on Nutanix NFS servers.
	VirtualCd_kFileOnNfs VirtualCd_Type = 0
)

var VirtualCd_Type_name = map[int32]string{
	0: "kFileOnNfs",
}

var VirtualCd_Type_value = map[string]int32{
	"kFileOnNfs": 0,
}

func (x VirtualCd_Type) Enum() *VirtualCd_Type {
	p := new(VirtualCd_Type)
	*p = x
	return p
}

func (x VirtualCd_Type) String() string {
	return proto.EnumName(VirtualCd_Type_name, int32(x))
}

func (x *VirtualCd_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VirtualCd_Type_value, data, "VirtualCd_Type")
	if err != nil {
		return err
	}
	*x = VirtualCd_Type(value)
	return nil
}

func (VirtualCd_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{4, 0}
}

type VirtualCd_AdapterType int32

const (
	// Virtual CD is attached to a SCSI controller.
	VirtualCd_kSCSI VirtualCd_AdapterType = 0
	// Virtual CD is attached to an IDE controller.
	VirtualCd_kIDE VirtualCd_AdapterType = 1
	// Virtual CD is attached to an SPAPR controller.
	VirtualCd_kSPAPR VirtualCd_AdapterType = 2
	// Virtual CD is attached to PCI controller.
	VirtualCd_kPCI VirtualCd_AdapterType = 3
	// Virtual CD is attached to SATA controller.
	VirtualCd_kSATA VirtualCd_AdapterType = 4
	// Virtual CD is attached to an NVME controller.
	VirtualCd_kNVME VirtualCd_AdapterType = 5
)

var VirtualCd_AdapterType_name = map[int32]string{
	0: "kSCSI",
	1: "kIDE",
	2: "kSPAPR",
	3: "kPCI",
	4: "kSATA",
	5: "kNVME",
}

var VirtualCd_AdapterType_value = map[string]int32{
	"kSCSI":  0,
	"kIDE":   1,
	"kSPAPR": 2,
	"kPCI":   3,
	"kSATA":  4,
	"kNVME":  5,
}

func (x VirtualCd_AdapterType) Enum() *VirtualCd_AdapterType {
	p := new(VirtualCd_AdapterType)
	*p = x
	return p
}

func (x VirtualCd_AdapterType) String() string {
	return proto.EnumName(VirtualCd_AdapterType_name, int32(x))
}

func (x *VirtualCd_AdapterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VirtualCd_AdapterType_value, data, "VirtualCd_AdapterType")
	if err != nil {
		return err
	}
	*x = VirtualCd_AdapterType(value)
	return nil
}

func (VirtualCd_AdapterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{4, 1}
}

type VirtualDisk_Type int32

const (
	// Virtual Disk is a file on NFS (Nutanix and non-Nutanix) servers.
	VirtualDisk_kFileOnNfs VirtualDisk_Type = 0
	// Virtual Disk is a file on the hypervisor-specific file system volume
	// on top of a direct-attached storage on the ESX.
	VirtualDisk_kFileOnDas VirtualDisk_Type = 1
	// Virtual Disk is a file on the hypervisor-specific file system on top of
	// one or more shared Nutanix iScsi VDisk.
	VirtualDisk_kFileOnSharedIscsiVDisk VirtualDisk_Type = 2
	// Virtual Disk is mapped to a Nutanix iSCSI VDisk.
	VirtualDisk_kIscsiVDisk VirtualDisk_Type = 3
	// Virtual Disk is mapped to a direct-attached storage device on the ESX.
	VirtualDisk_kDas VirtualDisk_Type = 4
)

var VirtualDisk_Type_name = map[int32]string{
	0: "kFileOnNfs",
	1: "kFileOnDas",
	2: "kFileOnSharedIscsiVDisk",
	3: "kIscsiVDisk",
	4: "kDas",
}

var VirtualDisk_Type_value = map[string]int32{
	"kFileOnNfs":              0,
	"kFileOnDas":              1,
	"kFileOnSharedIscsiVDisk": 2,
	"kIscsiVDisk":             3,
	"kDas":                    4,
}

func (x VirtualDisk_Type) Enum() *VirtualDisk_Type {
	p := new(VirtualDisk_Type)
	*p = x
	return p
}

func (x VirtualDisk_Type) String() string {
	return proto.EnumName(VirtualDisk_Type_name, int32(x))
}

func (x *VirtualDisk_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VirtualDisk_Type_value, data, "VirtualDisk_Type")
	if err != nil {
		return err
	}
	*x = VirtualDisk_Type(value)
	return nil
}

func (VirtualDisk_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 0}
}

type VirtualDisk_AdapterType int32

const (
	// Virtual Disk is attached to a SCSI controller.
	// iSCSI disks will always have SCSI emulation.
	VirtualDisk_kSCSI VirtualDisk_AdapterType = 0
	// Virtual Disk is attached to an IDE controller.
	VirtualDisk_kIDE VirtualDisk_AdapterType = 1
	// Virtual Disk is attached to an SPAPR controller.
	VirtualDisk_kSPAPR VirtualDisk_AdapterType = 2
	// Virtual Disk is attached to PCI controller.
	VirtualDisk_kPCI VirtualDisk_AdapterType = 3
	// Virtual Disk is attached to SATA controller.
	VirtualDisk_kSATA VirtualDisk_AdapterType = 4
	// Virtual disk is attached to an NVME controller.
	VirtualDisk_kNVME VirtualDisk_AdapterType = 5
)

var VirtualDisk_AdapterType_name = map[int32]string{
	0: "kSCSI",
	1: "kIDE",
	2: "kSPAPR",
	3: "kPCI",
	4: "kSATA",
	5: "kNVME",
}

var VirtualDisk_AdapterType_value = map[string]int32{
	"kSCSI":  0,
	"kIDE":   1,
	"kSPAPR": 2,
	"kPCI":   3,
	"kSATA":  4,
	"kNVME":  5,
}

func (x VirtualDisk_AdapterType) Enum() *VirtualDisk_AdapterType {
	p := new(VirtualDisk_AdapterType)
	*p = x
	return p
}

func (x VirtualDisk_AdapterType) String() string {
	return proto.EnumName(VirtualDisk_AdapterType_name, int32(x))
}

func (x *VirtualDisk_AdapterType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VirtualDisk_AdapterType_value, data, "VirtualDisk_AdapterType")
	if err != nil {
		return err
	}
	*x = VirtualDisk_AdapterType(value)
	return nil
}

func (VirtualDisk_AdapterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 1}
}

// The type of file. This indicates how the file is used by the VM. The
// number of elements in this field will be equal to that of 'nfs_file_path'.
type VmFileConfig_Type int32

const (
	VmFileConfig_kConfig   VmFileConfig_Type = 0
	VmFileConfig_kLog      VmFileConfig_Type = 1
	VmFileConfig_kDisk     VmFileConfig_Type = 2
	VmFileConfig_kTmpDisk  VmFileConfig_Type = 3
	VmFileConfig_kSnapshot VmFileConfig_Type = 4
	VmFileConfig_kISO      VmFileConfig_Type = 5
	VmFileConfig_kNVRAM    VmFileConfig_Type = 6
)

var VmFileConfig_Type_name = map[int32]string{
	0: "kConfig",
	1: "kLog",
	2: "kDisk",
	3: "kTmpDisk",
	4: "kSnapshot",
	5: "kISO",
	6: "kNVRAM",
}

var VmFileConfig_Type_value = map[string]int32{
	"kConfig":   0,
	"kLog":      1,
	"kDisk":     2,
	"kTmpDisk":  3,
	"kSnapshot": 4,
	"kISO":      5,
	"kNVRAM":    6,
}

func (x VmFileConfig_Type) Enum() *VmFileConfig_Type {
	p := new(VmFileConfig_Type)
	*p = x
	return p
}

func (x VmFileConfig_Type) String() string {
	return proto.EnumName(VmFileConfig_Type_name, int32(x))
}

func (x *VmFileConfig_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmFileConfig_Type_value, data, "VmFileConfig_Type")
	if err != nil {
		return err
	}
	*x = VmFileConfig_Type(value)
	return nil
}

func (VmFileConfig_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{6, 0}
}

type VirtualNetworkAdapterConfig_MacAddressType int32

const (
	// Static MAC address.
	VirtualNetworkAdapterConfig_kStatic VirtualNetworkAdapterConfig_MacAddressType = 0
	// MAC address assigned by hypervisor.
	VirtualNetworkAdapterConfig_kAssigned VirtualNetworkAdapterConfig_MacAddressType = 1
	// MAC address assigned by Management Server.
	VirtualNetworkAdapterConfig_kMSAssigned VirtualNetworkAdapterConfig_MacAddressType = 2
)

var VirtualNetworkAdapterConfig_MacAddressType_name = map[int32]string{
	0: "kStatic",
	1: "kAssigned",
	2: "kMSAssigned",
}

var VirtualNetworkAdapterConfig_MacAddressType_value = map[string]int32{
	"kStatic":     0,
	"kAssigned":   1,
	"kMSAssigned": 2,
}

func (x VirtualNetworkAdapterConfig_MacAddressType) Enum() *VirtualNetworkAdapterConfig_MacAddressType {
	p := new(VirtualNetworkAdapterConfig_MacAddressType)
	*p = x
	return p
}

func (x VirtualNetworkAdapterConfig_MacAddressType) String() string {
	return proto.EnumName(VirtualNetworkAdapterConfig_MacAddressType_name, int32(x))
}

func (x *VirtualNetworkAdapterConfig_MacAddressType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VirtualNetworkAdapterConfig_MacAddressType_value, data, "VirtualNetworkAdapterConfig_MacAddressType")
	if err != nil {
		return err
	}
	*x = VirtualNetworkAdapterConfig_MacAddressType(value)
	return nil
}

func (VirtualNetworkAdapterConfig_MacAddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{7, 0}
}

// The current power state of the virtual machine.
type VmInfo_PowerState int32

const (
	// The virtual machine is powered off.
	VmInfo_kPoweredOff VmInfo_PowerState = 0
	// The virtual machine is powered on.
	VmInfo_kPoweredOn VmInfo_PowerState = 1
	// The virtual machine is suspended/saved/hibernated.
	// Releases both CPU and memory resources.
	VmInfo_kSuspended VmInfo_PowerState = 2
	// The virtual machine is paused/put to sleep.
	// Releases the CPU resources; Memory resources will continue to be held.
	VmInfo_kPaused VmInfo_PowerState = 3
	// One of the many transient states that a virtual machine
	// can be in.
	VmInfo_kOther VmInfo_PowerState = 4
)

var VmInfo_PowerState_name = map[int32]string{
	0: "kPoweredOff",
	1: "kPoweredOn",
	2: "kSuspended",
	3: "kPaused",
	4: "kOther",
}

var VmInfo_PowerState_value = map[string]int32{
	"kPoweredOff": 0,
	"kPoweredOn":  1,
	"kSuspended":  2,
	"kPaused":     3,
	"kOther":      4,
}

func (x VmInfo_PowerState) Enum() *VmInfo_PowerState {
	p := new(VmInfo_PowerState)
	*p = x
	return p
}

func (x VmInfo_PowerState) String() string {
	return proto.EnumName(VmInfo_PowerState_name, int32(x))
}

func (x *VmInfo_PowerState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VmInfo_PowerState_value, data, "VmInfo_PowerState")
	if err != nil {
		return err
	}
	*x = VmInfo_PowerState(value)
	return nil
}

func (VmInfo_PowerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{9, 0}
}

// Errors that may be encountered when getting node information.
type GetNodeInfoRet_Error int32

const (
	GetNodeInfoRet_kNoError          GetNodeInfoRet_Error = 0
	GetNodeInfoRet_kNodeNotFound     GetNodeInfoRet_Error = 1
	GetNodeInfoRet_kNodeNotReachable GetNodeInfoRet_Error = 2
	GetNodeInfoRet_kOther            GetNodeInfoRet_Error = 3
)

var GetNodeInfoRet_Error_name = map[int32]string{
	0: "kNoError",
	1: "kNodeNotFound",
	2: "kNodeNotReachable",
	3: "kOther",
}

var GetNodeInfoRet_Error_value = map[string]int32{
	"kNoError":          0,
	"kNodeNotFound":     1,
	"kNodeNotReachable": 2,
	"kOther":            3,
}

func (x GetNodeInfoRet_Error) Enum() *GetNodeInfoRet_Error {
	p := new(GetNodeInfoRet_Error)
	*p = x
	return p
}

func (x GetNodeInfoRet_Error) String() string {
	return proto.EnumName(GetNodeInfoRet_Error_name, int32(x))
}

func (x *GetNodeInfoRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetNodeInfoRet_Error_value, data, "GetNodeInfoRet_Error")
	if err != nil {
		return err
	}
	*x = GetNodeInfoRet_Error(value)
	return nil
}

func (GetNodeInfoRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{20, 0}
}

// Errors that may be encountered when getting VM information.
type GetVmInfoRet_Error int32

const (
	GetVmInfoRet_kNoError    GetVmInfoRet_Error = 0
	GetVmInfoRet_kVmNotFound GetVmInfoRet_Error = 1
	GetVmInfoRet_kOther      GetVmInfoRet_Error = 2
	// ones arising out of problem accessing the VM file on
	// the file system, VM or host not being in valid state
	// to perform the operation and other communication
	// issues.
	GetVmInfoRet_kRetry GetVmInfoRet_Error = 3
)

var GetVmInfoRet_Error_name = map[int32]string{
	0: "kNoError",
	1: "kVmNotFound",
	2: "kOther",
	3: "kRetry",
}

var GetVmInfoRet_Error_value = map[string]int32{
	"kNoError":    0,
	"kVmNotFound": 1,
	"kOther":      2,
	"kRetry":      3,
}

func (x GetVmInfoRet_Error) Enum() *GetVmInfoRet_Error {
	p := new(GetVmInfoRet_Error)
	*p = x
	return p
}

func (x GetVmInfoRet_Error) String() string {
	return proto.EnumName(GetVmInfoRet_Error_name, int32(x))
}

func (x *GetVmInfoRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetVmInfoRet_Error_value, data, "GetVmInfoRet_Error")
	if err != nil {
		return err
	}
	*x = GetVmInfoRet_Error(value)
	return nil
}

func (GetVmInfoRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{22, 0}
}

// Errors that may be encountered when managing VM snapshots.
type SnapshotVmRet_Error int32

const (
	SnapshotVmRet_kNoError                SnapshotVmRet_Error = 0
	SnapshotVmRet_kUnknown                SnapshotVmRet_Error = 1
	SnapshotVmRet_kVmNotFound             SnapshotVmRet_Error = 2
	SnapshotVmRet_kRetry                  SnapshotVmRet_Error = 3
	SnapshotVmRet_kSnapshotDuplicate      SnapshotVmRet_Error = 4
	SnapshotVmRet_kSnapshotNotFound       SnapshotVmRet_Error = 5
	SnapshotVmRet_kNotSupported           SnapshotVmRet_Error = 6
	SnapshotVmRet_kDatastoreNotFound      SnapshotVmRet_Error = 7
	SnapshotVmRet_kOther                  SnapshotVmRet_Error = 8
	SnapshotVmRet_kVmNotCbrCapable        SnapshotVmRet_Error = 9
	SnapshotVmRet_kHypervisorNotsupported SnapshotVmRet_Error = 100
)

var SnapshotVmRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kUnknown",
	2:   "kVmNotFound",
	3:   "kRetry",
	4:   "kSnapshotDuplicate",
	5:   "kSnapshotNotFound",
	6:   "kNotSupported",
	7:   "kDatastoreNotFound",
	8:   "kOther",
	9:   "kVmNotCbrCapable",
	100: "kHypervisorNotsupported",
}

var SnapshotVmRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kUnknown":                1,
	"kVmNotFound":             2,
	"kRetry":                  3,
	"kSnapshotDuplicate":      4,
	"kSnapshotNotFound":       5,
	"kNotSupported":           6,
	"kDatastoreNotFound":      7,
	"kOther":                  8,
	"kVmNotCbrCapable":        9,
	"kHypervisorNotsupported": 100,
}

func (x SnapshotVmRet_Error) Enum() *SnapshotVmRet_Error {
	p := new(SnapshotVmRet_Error)
	*p = x
	return p
}

func (x SnapshotVmRet_Error) String() string {
	return proto.EnumName(SnapshotVmRet_Error_name, int32(x))
}

func (x *SnapshotVmRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SnapshotVmRet_Error_value, data, "SnapshotVmRet_Error")
	if err != nil {
		return err
	}
	*x = SnapshotVmRet_Error(value)
	return nil
}

func (SnapshotVmRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{24, 0}
}

type AdjustVmSnapshotRet_Error int32

const (
	AdjustVmSnapshotRet_kNoError                AdjustVmSnapshotRet_Error = 0
	AdjustVmSnapshotRet_kUnknown                AdjustVmSnapshotRet_Error = 1
	AdjustVmSnapshotRet_kNfsMountError          AdjustVmSnapshotRet_Error = 2
	AdjustVmSnapshotRet_kNfsLookupError         AdjustVmSnapshotRet_Error = 3
	AdjustVmSnapshotRet_kNfsRenameError         AdjustVmSnapshotRet_Error = 4
	AdjustVmSnapshotRet_kHypervisorNotsupported AdjustVmSnapshotRet_Error = 100
)

var AdjustVmSnapshotRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kUnknown",
	2:   "kNfsMountError",
	3:   "kNfsLookupError",
	4:   "kNfsRenameError",
	100: "kHypervisorNotsupported",
}

var AdjustVmSnapshotRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kUnknown":                1,
	"kNfsMountError":          2,
	"kNfsLookupError":         3,
	"kNfsRenameError":         4,
	"kHypervisorNotsupported": 100,
}

func (x AdjustVmSnapshotRet_Error) Enum() *AdjustVmSnapshotRet_Error {
	p := new(AdjustVmSnapshotRet_Error)
	*p = x
	return p
}

func (x AdjustVmSnapshotRet_Error) String() string {
	return proto.EnumName(AdjustVmSnapshotRet_Error_name, int32(x))
}

func (x *AdjustVmSnapshotRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AdjustVmSnapshotRet_Error_value, data, "AdjustVmSnapshotRet_Error")
	if err != nil {
		return err
	}
	*x = AdjustVmSnapshotRet_Error(value)
	return nil
}

func (AdjustVmSnapshotRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{26, 0}
}

// Errors that may be encountered when changing VMs' states.
type ChangeVmStateRet_Error int32

const (
	ChangeVmStateRet_kNoError    ChangeVmStateRet_Error = 0
	ChangeVmStateRet_kVmNotFound ChangeVmStateRet_Error = 1
	ChangeVmStateRet_kBusy       ChangeVmStateRet_Error = 2
	ChangeVmStateRet_kOther      ChangeVmStateRet_Error = 3
	// ones arising out of problem accessing the VM file on
	// the file system, VM or host not being in valid state
	// to perform the operation, resource usage policy
	// violation, license limitation, unsupported
	// VM config file location, VM being a template and
	// other communication issues.
	ChangeVmStateRet_kHypervisorNotsupported ChangeVmStateRet_Error = 100
)

var ChangeVmStateRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVmNotFound",
	2:   "kBusy",
	3:   "kOther",
	100: "kHypervisorNotsupported",
}

var ChangeVmStateRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kVmNotFound":             1,
	"kBusy":                   2,
	"kOther":                  3,
	"kHypervisorNotsupported": 100,
}

func (x ChangeVmStateRet_Error) Enum() *ChangeVmStateRet_Error {
	p := new(ChangeVmStateRet_Error)
	*p = x
	return p
}

func (x ChangeVmStateRet_Error) String() string {
	return proto.EnumName(ChangeVmStateRet_Error_name, int32(x))
}

func (x *ChangeVmStateRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChangeVmStateRet_Error_value, data, "ChangeVmStateRet_Error")
	if err != nil {
		return err
	}
	*x = ChangeVmStateRet_Error(value)
	return nil
}

func (ChangeVmStateRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{28, 0}
}

type RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType int32

const (
	RegisterVmArg_RegisterVm_EntityDbIncarnationId_kVirtualDisk RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType = 1
	RegisterVmArg_RegisterVm_EntityDbIncarnationId_kVirtualNic  RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType = 2
	RegisterVmArg_RegisterVm_EntityDbIncarnationId_kVirtualGpu  RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType = 3
)

var RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType_name = map[int32]string{
	1: "kVirtualDisk",
	2: "kVirtualNic",
	3: "kVirtualGpu",
}

var RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType_value = map[string]int32{
	"kVirtualDisk": 1,
	"kVirtualNic":  2,
	"kVirtualGpu":  3,
}

func (x RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType) Enum() *RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType {
	p := new(RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType)
	*p = x
	return p
}

func (x RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType) String() string {
	return proto.EnumName(RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType_name, int32(x))
}

func (x *RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType_value, data, "RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType")
	if err != nil {
		return err
	}
	*x = RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType(value)
	return nil
}

func (RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{29, 0, 0, 0}
}

// Errors that may be encountered when registering VMs.
type RegisterVmRet_Error int32

const (
	RegisterVmRet_kNoError               RegisterVmRet_Error = 0
	RegisterVmRet_kNotFound              RegisterVmRet_Error = 1
	RegisterVmRet_kInvalidState          RegisterVmRet_Error = 2
	RegisterVmRet_kInsufficientResources RegisterVmRet_Error = 3
	RegisterVmRet_kUnknownError          RegisterVmRet_Error = 4
	RegisterVmRet_kInvalidNode           RegisterVmRet_Error = 5
	RegisterVmRet_kIncompatibleHost      RegisterVmRet_Error = 6
	// the host.
	RegisterVmRet_kTimeout RegisterVmRet_Error = 7
	// Acropolis.
	RegisterVmRet_kRetry                  RegisterVmRet_Error = 8
	RegisterVmRet_kNetworkNotFound        RegisterVmRet_Error = 9
	RegisterVmRet_kInUse                  RegisterVmRet_Error = 10
	RegisterVmRet_kAddressPoolExhausted   RegisterVmRet_Error = 11
	RegisterVmRet_kHypervisorNotsupported RegisterVmRet_Error = 100
)

var RegisterVmRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNotFound",
	2:   "kInvalidState",
	3:   "kInsufficientResources",
	4:   "kUnknownError",
	5:   "kInvalidNode",
	6:   "kIncompatibleHost",
	7:   "kTimeout",
	8:   "kRetry",
	9:   "kNetworkNotFound",
	10:  "kInUse",
	11:  "kAddressPoolExhausted",
	100: "kHypervisorNotsupported",
}

var RegisterVmRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kNotFound":               1,
	"kInvalidState":           2,
	"kInsufficientResources":  3,
	"kUnknownError":           4,
	"kInvalidNode":            5,
	"kIncompatibleHost":       6,
	"kTimeout":                7,
	"kRetry":                  8,
	"kNetworkNotFound":        9,
	"kInUse":                  10,
	"kAddressPoolExhausted":   11,
	"kHypervisorNotsupported": 100,
}

func (x RegisterVmRet_Error) Enum() *RegisterVmRet_Error {
	p := new(RegisterVmRet_Error)
	*p = x
	return p
}

func (x RegisterVmRet_Error) String() string {
	return proto.EnumName(RegisterVmRet_Error_name, int32(x))
}

func (x *RegisterVmRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RegisterVmRet_Error_value, data, "RegisterVmRet_Error")
	if err != nil {
		return err
	}
	*x = RegisterVmRet_Error(value)
	return nil
}

func (RegisterVmRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{30, 0}
}

// Errors that may be encountered while getting the datastore.
type GetDatastoresRet_Error int32

const (
	GetDatastoresRet_kNoError      GetDatastoresRet_Error = 0
	GetDatastoresRet_kNodeNotFound GetDatastoresRet_Error = 1
	GetDatastoresRet_kOther        GetDatastoresRet_Error = 2
	// ones arising out of host not being in valid state
	// to perform the operation and other communication
	// issues.
	GetDatastoresRet_kHypervisorNotsupported GetDatastoresRet_Error = 100
)

var GetDatastoresRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNodeNotFound",
	2:   "kOther",
	100: "kHypervisorNotsupported",
}

var GetDatastoresRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kNodeNotFound":           1,
	"kOther":                  2,
	"kHypervisorNotsupported": 100,
}

func (x GetDatastoresRet_Error) Enum() *GetDatastoresRet_Error {
	p := new(GetDatastoresRet_Error)
	*p = x
	return p
}

func (x GetDatastoresRet_Error) String() string {
	return proto.EnumName(GetDatastoresRet_Error_name, int32(x))
}

func (x *GetDatastoresRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetDatastoresRet_Error_value, data, "GetDatastoresRet_Error")
	if err != nil {
		return err
	}
	*x = GetDatastoresRet_Error(value)
	return nil
}

func (GetDatastoresRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{32, 0}
}

// Errors that may be encountered while mounting the NFS share (container).
type MountDatastoreRet_Error int32

const (
	MountDatastoreRet_kNoError           MountDatastoreRet_Error = 0
	MountDatastoreRet_kNodeNotFound      MountDatastoreRet_Error = 1
	MountDatastoreRet_kContainerNotFound MountDatastoreRet_Error = 2
	MountDatastoreRet_kDatastoreExist    MountDatastoreRet_Error = 3
	MountDatastoreRet_kOther             MountDatastoreRet_Error = 4
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	MountDatastoreRet_kHypervisorNotsupported MountDatastoreRet_Error = 100
)

var MountDatastoreRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNodeNotFound",
	2:   "kContainerNotFound",
	3:   "kDatastoreExist",
	4:   "kOther",
	100: "kHypervisorNotsupported",
}

var MountDatastoreRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kNodeNotFound":           1,
	"kContainerNotFound":      2,
	"kDatastoreExist":         3,
	"kOther":                  4,
	"kHypervisorNotsupported": 100,
}

func (x MountDatastoreRet_Error) Enum() *MountDatastoreRet_Error {
	p := new(MountDatastoreRet_Error)
	*p = x
	return p
}

func (x MountDatastoreRet_Error) String() string {
	return proto.EnumName(MountDatastoreRet_Error_name, int32(x))
}

func (x *MountDatastoreRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MountDatastoreRet_Error_value, data, "MountDatastoreRet_Error")
	if err != nil {
		return err
	}
	*x = MountDatastoreRet_Error(value)
	return nil
}

func (MountDatastoreRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{34, 0}
}

// Errors that may be encountered while unmounting the datastore.
type UnmountDatastoreRet_Error int32

const (
	UnmountDatastoreRet_kNoError           UnmountDatastoreRet_Error = 0
	UnmountDatastoreRet_kNodeNotFound      UnmountDatastoreRet_Error = 1
	UnmountDatastoreRet_kContainerNotFound UnmountDatastoreRet_Error = 2
	UnmountDatastoreRet_kDatastoreNotFound UnmountDatastoreRet_Error = 3
	UnmountDatastoreRet_kDatastoreInUse    UnmountDatastoreRet_Error = 4
	UnmountDatastoreRet_kOther             UnmountDatastoreRet_Error = 5
	// including ones arising out of host not being in
	// valid state to perform the operation and other
	// communication issues.
	UnmountDatastoreRet_kHypervisorNotsupported UnmountDatastoreRet_Error = 100
)

var UnmountDatastoreRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNodeNotFound",
	2:   "kContainerNotFound",
	3:   "kDatastoreNotFound",
	4:   "kDatastoreInUse",
	5:   "kOther",
	100: "kHypervisorNotsupported",
}

var UnmountDatastoreRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kNodeNotFound":           1,
	"kContainerNotFound":      2,
	"kDatastoreNotFound":      3,
	"kDatastoreInUse":         4,
	"kOther":                  5,
	"kHypervisorNotsupported": 100,
}

func (x UnmountDatastoreRet_Error) Enum() *UnmountDatastoreRet_Error {
	p := new(UnmountDatastoreRet_Error)
	*p = x
	return p
}

func (x UnmountDatastoreRet_Error) String() string {
	return proto.EnumName(UnmountDatastoreRet_Error_name, int32(x))
}

func (x *UnmountDatastoreRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(UnmountDatastoreRet_Error_value, data, "UnmountDatastoreRet_Error")
	if err != nil {
		return err
	}
	*x = UnmountDatastoreRet_Error(value)
	return nil
}

func (UnmountDatastoreRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{36, 0}
}

// Errors that may be encountered when attaching the virtual disk.
type AttachVirtualCdRet_Error int32

const (
	AttachVirtualCdRet_kNoError    AttachVirtualCdRet_Error = 0
	AttachVirtualCdRet_kVmNotFound AttachVirtualCdRet_Error = 1
	AttachVirtualCdRet_kNoFreeSlot AttachVirtualCdRet_Error = 2
	// attach virtual CD.
	AttachVirtualCdRet_kBusy AttachVirtualCdRet_Error = 3
	// is expecting an answer to a question.
	AttachVirtualCdRet_kOther AttachVirtualCdRet_Error = 100
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	AttachVirtualCdRet_kHypervisorNotsupported AttachVirtualCdRet_Error = 101
)

var AttachVirtualCdRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVmNotFound",
	2:   "kNoFreeSlot",
	3:   "kBusy",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var AttachVirtualCdRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kVmNotFound":             1,
	"kNoFreeSlot":             2,
	"kBusy":                   3,
	"kOther":                  100,
	"kHypervisorNotsupported": 101,
}

func (x AttachVirtualCdRet_Error) Enum() *AttachVirtualCdRet_Error {
	p := new(AttachVirtualCdRet_Error)
	*p = x
	return p
}

func (x AttachVirtualCdRet_Error) String() string {
	return proto.EnumName(AttachVirtualCdRet_Error_name, int32(x))
}

func (x *AttachVirtualCdRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AttachVirtualCdRet_Error_value, data, "AttachVirtualCdRet_Error")
	if err != nil {
		return err
	}
	*x = AttachVirtualCdRet_Error(value)
	return nil
}

func (AttachVirtualCdRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{38, 0}
}

// Errors that may be encountered when detaching a virtual CD.
type DetachVirtualCdRet_Error int32

const (
	DetachVirtualCdRet_kNoError           DetachVirtualCdRet_Error = 0
	DetachVirtualCdRet_kVmNotFound        DetachVirtualCdRet_Error = 1
	DetachVirtualCdRet_kVirtualCdNotFound DetachVirtualCdRet_Error = 2
	DetachVirtualCdRet_kBusy              DetachVirtualCdRet_Error = 3
	// is expecting an answer to a question.
	DetachVirtualCdRet_kOther DetachVirtualCdRet_Error = 100
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	DetachVirtualCdRet_kHypervisorNotsupported DetachVirtualCdRet_Error = 101
)

var DetachVirtualCdRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVmNotFound",
	2:   "kVirtualCdNotFound",
	3:   "kBusy",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var DetachVirtualCdRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kVmNotFound":             1,
	"kVirtualCdNotFound":      2,
	"kBusy":                   3,
	"kOther":                  100,
	"kHypervisorNotsupported": 101,
}

func (x DetachVirtualCdRet_Error) Enum() *DetachVirtualCdRet_Error {
	p := new(DetachVirtualCdRet_Error)
	*p = x
	return p
}

func (x DetachVirtualCdRet_Error) String() string {
	return proto.EnumName(DetachVirtualCdRet_Error_name, int32(x))
}

func (x *DetachVirtualCdRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DetachVirtualCdRet_Error_value, data, "DetachVirtualCdRet_Error")
	if err != nil {
		return err
	}
	*x = DetachVirtualCdRet_Error(value)
	return nil
}

func (DetachVirtualCdRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{40, 0}
}

// Errors that may be encountered when attaching the virtual disk.
type AttachVirtualDiskRet_Error int32

const (
	AttachVirtualDiskRet_kNoError                 AttachVirtualDiskRet_Error = 0
	AttachVirtualDiskRet_kVmNotFound              AttachVirtualDiskRet_Error = 1
	AttachVirtualDiskRet_kVirtualDiskNotFound     AttachVirtualDiskRet_Error = 2
	AttachVirtualDiskRet_kVirtualDiskUpdateFailed AttachVirtualDiskRet_Error = 3
	AttachVirtualDiskRet_kBusy                    AttachVirtualDiskRet_Error = 4
	// is expecting an answer to a question.
	AttachVirtualDiskRet_kOther AttachVirtualDiskRet_Error = 100
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	AttachVirtualDiskRet_kHypervisorNotsupported AttachVirtualDiskRet_Error = 101
)

var AttachVirtualDiskRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVmNotFound",
	2:   "kVirtualDiskNotFound",
	3:   "kVirtualDiskUpdateFailed",
	4:   "kBusy",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var AttachVirtualDiskRet_Error_value = map[string]int32{
	"kNoError":                 0,
	"kVmNotFound":              1,
	"kVirtualDiskNotFound":     2,
	"kVirtualDiskUpdateFailed": 3,
	"kBusy":                    4,
	"kOther":                   100,
	"kHypervisorNotsupported":  101,
}

func (x AttachVirtualDiskRet_Error) Enum() *AttachVirtualDiskRet_Error {
	p := new(AttachVirtualDiskRet_Error)
	*p = x
	return p
}

func (x AttachVirtualDiskRet_Error) String() string {
	return proto.EnumName(AttachVirtualDiskRet_Error_name, int32(x))
}

func (x *AttachVirtualDiskRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AttachVirtualDiskRet_Error_value, data, "AttachVirtualDiskRet_Error")
	if err != nil {
		return err
	}
	*x = AttachVirtualDiskRet_Error(value)
	return nil
}

func (AttachVirtualDiskRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{42, 0}
}

// Errors that may be encountered when detaching a virtual disk.
type DetachVirtualDiskRet_Error int32

const (
	DetachVirtualDiskRet_kNoError             DetachVirtualDiskRet_Error = 0
	DetachVirtualDiskRet_kVmNotFound          DetachVirtualDiskRet_Error = 1
	DetachVirtualDiskRet_kVirtualDiskNotFound DetachVirtualDiskRet_Error = 2
	DetachVirtualDiskRet_kBusy                DetachVirtualDiskRet_Error = 3
	// is expecting an answer to a question.
	DetachVirtualDiskRet_kDiskInEsxSnapshot DetachVirtualDiskRet_Error = 4
	DetachVirtualDiskRet_kInvalidDiskSpec   DetachVirtualDiskRet_Error = 5
	DetachVirtualDiskRet_kOther             DetachVirtualDiskRet_Error = 100
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	DetachVirtualDiskRet_kHypervisorNotsupported DetachVirtualDiskRet_Error = 101
)

var DetachVirtualDiskRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVmNotFound",
	2:   "kVirtualDiskNotFound",
	3:   "kBusy",
	4:   "kDiskInEsxSnapshot",
	5:   "kInvalidDiskSpec",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var DetachVirtualDiskRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kVmNotFound":             1,
	"kVirtualDiskNotFound":    2,
	"kBusy":                   3,
	"kDiskInEsxSnapshot":      4,
	"kInvalidDiskSpec":        5,
	"kOther":                  100,
	"kHypervisorNotsupported": 101,
}

func (x DetachVirtualDiskRet_Error) Enum() *DetachVirtualDiskRet_Error {
	p := new(DetachVirtualDiskRet_Error)
	*p = x
	return p
}

func (x DetachVirtualDiskRet_Error) String() string {
	return proto.EnumName(DetachVirtualDiskRet_Error_name, int32(x))
}

func (x *DetachVirtualDiskRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DetachVirtualDiskRet_Error_value, data, "DetachVirtualDiskRet_Error")
	if err != nil {
		return err
	}
	*x = DetachVirtualDiskRet_Error(value)
	return nil
}

func (DetachVirtualDiskRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{44, 0}
}

// Errors that may be encountered when attaching the virtual disk.
type ModifyVirtualDiskRet_Error int32

const (
	ModifyVirtualDiskRet_kNoError                 ModifyVirtualDiskRet_Error = 0
	ModifyVirtualDiskRet_kVirtualDiskUpdateFailed ModifyVirtualDiskRet_Error = 1
	ModifyVirtualDiskRet_kOther                   ModifyVirtualDiskRet_Error = 100
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	ModifyVirtualDiskRet_kHypervisorNotsupported ModifyVirtualDiskRet_Error = 101
)

var ModifyVirtualDiskRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVirtualDiskUpdateFailed",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var ModifyVirtualDiskRet_Error_value = map[string]int32{
	"kNoError":                 0,
	"kVirtualDiskUpdateFailed": 1,
	"kOther":                   100,
	"kHypervisorNotsupported":  101,
}

func (x ModifyVirtualDiskRet_Error) Enum() *ModifyVirtualDiskRet_Error {
	p := new(ModifyVirtualDiskRet_Error)
	*p = x
	return p
}

func (x ModifyVirtualDiskRet_Error) String() string {
	return proto.EnumName(ModifyVirtualDiskRet_Error_name, int32(x))
}

func (x *ModifyVirtualDiskRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ModifyVirtualDiskRet_Error_value, data, "ModifyVirtualDiskRet_Error")
	if err != nil {
		return err
	}
	*x = ModifyVirtualDiskRet_Error(value)
	return nil
}

func (ModifyVirtualDiskRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{46, 0}
}

// Errors that may be encountered when creating a VM.
type CreateVmRet_Error int32

const (
	CreateVmRet_kNoError              CreateVmRet_Error = 0
	CreateVmRet_kInvalidNode          CreateVmRet_Error = 1
	CreateVmRet_kInvalidVmConfig      CreateVmRet_Error = 2
	CreateVmRet_kInvalidStorageConfig CreateVmRet_Error = 3
	CreateVmRet_kInvalidNetworkConfig CreateVmRet_Error = 4
	CreateVmRet_kOther                CreateVmRet_Error = 100
	// ones arising out of host not being in valid
	// state to perform the operation and other
	// communication issues.
	CreateVmRet_kHypervisorNotsupported CreateVmRet_Error = 101
)

var CreateVmRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kInvalidNode",
	2:   "kInvalidVmConfig",
	3:   "kInvalidStorageConfig",
	4:   "kInvalidNetworkConfig",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var CreateVmRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kInvalidNode":            1,
	"kInvalidVmConfig":        2,
	"kInvalidStorageConfig":   3,
	"kInvalidNetworkConfig":   4,
	"kOther":                  100,
	"kHypervisorNotsupported": 101,
}

func (x CreateVmRet_Error) Enum() *CreateVmRet_Error {
	p := new(CreateVmRet_Error)
	*p = x
	return p
}

func (x CreateVmRet_Error) String() string {
	return proto.EnumName(CreateVmRet_Error_name, int32(x))
}

func (x *CreateVmRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CreateVmRet_Error_value, data, "CreateVmRet_Error")
	if err != nil {
		return err
	}
	*x = CreateVmRet_Error(value)
	return nil
}

func (CreateVmRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{48, 0}
}

// Errors that may be encountered when cloning a VM.
type CloneVmRet_Error int32

const (
	CloneVmRet_kNoError                CloneVmRet_Error = 0
	CloneVmRet_kVmNotFound             CloneVmRet_Error = 1
	CloneVmRet_kTaskNotFound           CloneVmRet_Error = 2
	CloneVmRet_kOther                  CloneVmRet_Error = 100
	CloneVmRet_kHypervisorNotSupported CloneVmRet_Error = 101
)

var CloneVmRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kVmNotFound",
	2:   "kTaskNotFound",
	100: "kOther",
	101: "kHypervisorNotSupported",
}

var CloneVmRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kVmNotFound":             1,
	"kTaskNotFound":           2,
	"kOther":                  100,
	"kHypervisorNotSupported": 101,
}

func (x CloneVmRet_Error) Enum() *CloneVmRet_Error {
	p := new(CloneVmRet_Error)
	*p = x
	return p
}

func (x CloneVmRet_Error) String() string {
	return proto.EnumName(CloneVmRet_Error_name, int32(x))
}

func (x *CloneVmRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CloneVmRet_Error_value, data, "CloneVmRet_Error")
	if err != nil {
		return err
	}
	*x = CloneVmRet_Error(value)
	return nil
}

func (CloneVmRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{50, 0}
}

// The various types of configurations that can be performed on a node.
type ConfigureHypervNodeArg_ConfigurationType int32

const (
	// All configuration types below apply only to nodes running Hyper-V.
	ConfigureHypervNodeArg_kSetDefaultVmVhdLocation       ConfigureHypervNodeArg_ConfigurationType = 1
	ConfigureHypervNodeArg_kJoinDomain                    ConfigureHypervNodeArg_ConfigurationType = 2
	ConfigureHypervNodeArg_kUnjoinFromDomain              ConfigureHypervNodeArg_ConfigurationType = 3
	ConfigureHypervNodeArg_kCreateFailoverCluster         ConfigureHypervNodeArg_ConfigurationType = 4
	ConfigureHypervNodeArg_kAddNodeToFailoverCluster      ConfigureHypervNodeArg_ConfigurationType = 5
	ConfigureHypervNodeArg_kRemoveNodeFromFailoverCluster ConfigureHypervNodeArg_ConfigurationType = 6
	ConfigureHypervNodeArg_kRestartComputer               ConfigureHypervNodeArg_ConfigurationType = 7
)

var ConfigureHypervNodeArg_ConfigurationType_name = map[int32]string{
	1: "kSetDefaultVmVhdLocation",
	2: "kJoinDomain",
	3: "kUnjoinFromDomain",
	4: "kCreateFailoverCluster",
	5: "kAddNodeToFailoverCluster",
	6: "kRemoveNodeFromFailoverCluster",
	7: "kRestartComputer",
}

var ConfigureHypervNodeArg_ConfigurationType_value = map[string]int32{
	"kSetDefaultVmVhdLocation":       1,
	"kJoinDomain":                    2,
	"kUnjoinFromDomain":              3,
	"kCreateFailoverCluster":         4,
	"kAddNodeToFailoverCluster":      5,
	"kRemoveNodeFromFailoverCluster": 6,
	"kRestartComputer":               7,
}

func (x ConfigureHypervNodeArg_ConfigurationType) Enum() *ConfigureHypervNodeArg_ConfigurationType {
	p := new(ConfigureHypervNodeArg_ConfigurationType)
	*p = x
	return p
}

func (x ConfigureHypervNodeArg_ConfigurationType) String() string {
	return proto.EnumName(ConfigureHypervNodeArg_ConfigurationType_name, int32(x))
}

func (x *ConfigureHypervNodeArg_ConfigurationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigureHypervNodeArg_ConfigurationType_value, data, "ConfigureHypervNodeArg_ConfigurationType")
	if err != nil {
		return err
	}
	*x = ConfigureHypervNodeArg_ConfigurationType(value)
	return nil
}

func (ConfigureHypervNodeArg_ConfigurationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{51, 0}
}

// Errors that may be encountered when configuring a Hyper-V node.
type ConfigureHypervNodeRet_Error int32

const (
	ConfigureHypervNodeRet_kNoError      ConfigureHypervNodeRet_Error = 0
	ConfigureHypervNodeRet_kNodeNotFound ConfigureHypervNodeRet_Error = 1
	ConfigureHypervNodeRet_kOther        ConfigureHypervNodeRet_Error = 100
	// including ones arising out of host
	// not being in valid state to perform
	// the operation and other
	// communication issues.
	ConfigureHypervNodeRet_kHypervisorNotsupported ConfigureHypervNodeRet_Error = 101
)

var ConfigureHypervNodeRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNodeNotFound",
	100: "kOther",
	101: "kHypervisorNotsupported",
}

var ConfigureHypervNodeRet_Error_value = map[string]int32{
	"kNoError":                0,
	"kNodeNotFound":           1,
	"kOther":                  100,
	"kHypervisorNotsupported": 101,
}

func (x ConfigureHypervNodeRet_Error) Enum() *ConfigureHypervNodeRet_Error {
	p := new(ConfigureHypervNodeRet_Error)
	*p = x
	return p
}

func (x ConfigureHypervNodeRet_Error) String() string {
	return proto.EnumName(ConfigureHypervNodeRet_Error_name, int32(x))
}

func (x *ConfigureHypervNodeRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigureHypervNodeRet_Error_value, data, "ConfigureHypervNodeRet_Error")
	if err != nil {
		return err
	}
	*x = ConfigureHypervNodeRet_Error(value)
	return nil
}

func (ConfigureHypervNodeRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{52, 0}
}

// Enumeration for the type of information to publish.
type PublishToArithmosArg_InformationType int32

const (
	PublishToArithmosArg_kAllAvailable  PublishToArithmosArg_InformationType = 1
	PublishToArithmosArg_kConfiguration PublishToArithmosArg_InformationType = 2
	PublishToArithmosArg_kPerformance   PublishToArithmosArg_InformationType = 3
)

var PublishToArithmosArg_InformationType_name = map[int32]string{
	1: "kAllAvailable",
	2: "kConfiguration",
	3: "kPerformance",
}

var PublishToArithmosArg_InformationType_value = map[string]int32{
	"kAllAvailable":  1,
	"kConfiguration": 2,
	"kPerformance":   3,
}

func (x PublishToArithmosArg_InformationType) Enum() *PublishToArithmosArg_InformationType {
	p := new(PublishToArithmosArg_InformationType)
	*p = x
	return p
}

func (x PublishToArithmosArg_InformationType) String() string {
	return proto.EnumName(PublishToArithmosArg_InformationType_name, int32(x))
}

func (x *PublishToArithmosArg_InformationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PublishToArithmosArg_InformationType_value, data, "PublishToArithmosArg_InformationType")
	if err != nil {
		return err
	}
	*x = PublishToArithmosArg_InformationType(value)
	return nil
}

func (PublishToArithmosArg_InformationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{53, 0}
}

// Enumeration for the entity type.
type PublishToArithmosArg_EntityType int32

const (
	PublishToArithmosArg_kAll  PublishToArithmosArg_EntityType = 1
	PublishToArithmosArg_kNode PublishToArithmosArg_EntityType = 2
	PublishToArithmosArg_kVm   PublishToArithmosArg_EntityType = 3
)

var PublishToArithmosArg_EntityType_name = map[int32]string{
	1: "kAll",
	2: "kNode",
	3: "kVm",
}

var PublishToArithmosArg_EntityType_value = map[string]int32{
	"kAll":  1,
	"kNode": 2,
	"kVm":   3,
}

func (x PublishToArithmosArg_EntityType) Enum() *PublishToArithmosArg_EntityType {
	p := new(PublishToArithmosArg_EntityType)
	*p = x
	return p
}

func (x PublishToArithmosArg_EntityType) String() string {
	return proto.EnumName(PublishToArithmosArg_EntityType_name, int32(x))
}

func (x *PublishToArithmosArg_EntityType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PublishToArithmosArg_EntityType_value, data, "PublishToArithmosArg_EntityType")
	if err != nil {
		return err
	}
	*x = PublishToArithmosArg_EntityType(value)
	return nil
}

func (PublishToArithmosArg_EntityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{53, 1}
}

type PublishToArithmosRet_Error int32

const (
	PublishToArithmosRet_kNoError        PublishToArithmosRet_Error = 1
	PublishToArithmosRet_kNodeNotFound   PublishToArithmosRet_Error = 2
	PublishToArithmosRet_kEntityNotFound PublishToArithmosRet_Error = 3
	PublishToArithmosRet_kOther          PublishToArithmosRet_Error = 4
)

var PublishToArithmosRet_Error_name = map[int32]string{
	1: "kNoError",
	2: "kNodeNotFound",
	3: "kEntityNotFound",
	4: "kOther",
}

var PublishToArithmosRet_Error_value = map[string]int32{
	"kNoError":        1,
	"kNodeNotFound":   2,
	"kEntityNotFound": 3,
	"kOther":          4,
}

func (x PublishToArithmosRet_Error) Enum() *PublishToArithmosRet_Error {
	p := new(PublishToArithmosRet_Error)
	*p = x
	return p
}

func (x PublishToArithmosRet_Error) String() string {
	return proto.EnumName(PublishToArithmosRet_Error_name, int32(x))
}

func (x *PublishToArithmosRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PublishToArithmosRet_Error_value, data, "PublishToArithmosRet_Error")
	if err != nil {
		return err
	}
	*x = PublishToArithmosRet_Error(value)
	return nil
}

func (PublishToArithmosRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{54, 0}
}

// The various types of configurations that can be performed on a cluster that
// includes a compute node running Hyper-V.
type ConfigureHypervClusterArg_ConfigurationType int32

const (
	// Joins the NDFS cluster to the same AD domain that the Hyper-V compute
	// nodes are a part of.
	ConfigureHypervClusterArg_kJoinNdfsClusterToDomain ConfigureHypervClusterArg_ConfigurationType = 1
	// Unjoins the NDFS cluster from the AD domain that it is a part of.
	ConfigureHypervClusterArg_kUnjoinNdfsClusterFromDomain ConfigureHypervClusterArg_ConfigurationType = 2
	// Renames the NDFS cluster in AD.
	ConfigureHypervClusterArg_kRenameNdfsCluster ConfigureHypervClusterArg_ConfigurationType = 3
	// Modifies the DNS host address (A) record of the NDFS cluster to use the
	// new virtual IP.
	ConfigureHypervClusterArg_kChangeNdfsClusterVip ConfigureHypervClusterArg_ConfigurationType = 4
	// Enables Kerberos for SMB by setting the service principal name(s) in the
	// computer object representing the NDFS cluster in AD.
	ConfigureHypervClusterArg_kAddSpn ConfigureHypervClusterArg_ConfigurationType = 5
	// Disables Kerberos for SMB by clearing the service principal name(s) in
	// the computer object representing the NDFS cluster in AD.
	ConfigureHypervClusterArg_kRemoveSpn ConfigureHypervClusterArg_ConfigurationType = 6
)

var ConfigureHypervClusterArg_ConfigurationType_name = map[int32]string{
	1: "kJoinNdfsClusterToDomain",
	2: "kUnjoinNdfsClusterFromDomain",
	3: "kRenameNdfsCluster",
	4: "kChangeNdfsClusterVip",
	5: "kAddSpn",
	6: "kRemoveSpn",
}

var ConfigureHypervClusterArg_ConfigurationType_value = map[string]int32{
	"kJoinNdfsClusterToDomain":     1,
	"kUnjoinNdfsClusterFromDomain": 2,
	"kRenameNdfsCluster":           3,
	"kChangeNdfsClusterVip":        4,
	"kAddSpn":                      5,
	"kRemoveSpn":                   6,
}

func (x ConfigureHypervClusterArg_ConfigurationType) Enum() *ConfigureHypervClusterArg_ConfigurationType {
	p := new(ConfigureHypervClusterArg_ConfigurationType)
	*p = x
	return p
}

func (x ConfigureHypervClusterArg_ConfigurationType) String() string {
	return proto.EnumName(ConfigureHypervClusterArg_ConfigurationType_name, int32(x))
}

func (x *ConfigureHypervClusterArg_ConfigurationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigureHypervClusterArg_ConfigurationType_value, data, "ConfigureHypervClusterArg_ConfigurationType")
	if err != nil {
		return err
	}
	*x = ConfigureHypervClusterArg_ConfigurationType(value)
	return nil
}

func (ConfigureHypervClusterArg_ConfigurationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{55, 0}
}

// Errors that may be encountered when configuring a Hyper-V cluster.
type ConfigureHypervClusterRet_Error int32

const (
	ConfigureHypervClusterRet_kNoError               ConfigureHypervClusterRet_Error = 0
	ConfigureHypervClusterRet_kNoHypervNodeAvailable ConfigureHypervClusterRet_Error = 1
	// accessible in the cluster.
	ConfigureHypervClusterRet_kInvalidConfigurationType ConfigureHypervClusterRet_Error = 2
	// request.
	ConfigureHypervClusterRet_kMandatoryArgumentsMissing ConfigureHypervClusterRet_Error = 3
	// the specified configuration type
	// are missing.
	ConfigureHypervClusterRet_kOther ConfigureHypervClusterRet_Error = 100
)

var ConfigureHypervClusterRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNoHypervNodeAvailable",
	2:   "kInvalidConfigurationType",
	3:   "kMandatoryArgumentsMissing",
	100: "kOther",
}

var ConfigureHypervClusterRet_Error_value = map[string]int32{
	"kNoError":                   0,
	"kNoHypervNodeAvailable":     1,
	"kInvalidConfigurationType":  2,
	"kMandatoryArgumentsMissing": 3,
	"kOther":                     100,
}

func (x ConfigureHypervClusterRet_Error) Enum() *ConfigureHypervClusterRet_Error {
	p := new(ConfigureHypervClusterRet_Error)
	*p = x
	return p
}

func (x ConfigureHypervClusterRet_Error) String() string {
	return proto.EnumName(ConfigureHypervClusterRet_Error_name, int32(x))
}

func (x *ConfigureHypervClusterRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigureHypervClusterRet_Error_value, data, "ConfigureHypervClusterRet_Error")
	if err != nil {
		return err
	}
	*x = ConfigureHypervClusterRet_Error(value)
	return nil
}

func (ConfigureHypervClusterRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{56, 0}
}

// Errors that may be encountered when getting network adapter information
// from the node(s).
type GetNetworkAdapterRet_Error int32

const (
	GetNetworkAdapterRet_kNoError      GetNetworkAdapterRet_Error = 0
	GetNetworkAdapterRet_kNodeNotFound GetNetworkAdapterRet_Error = 1
	GetNetworkAdapterRet_kOther        GetNetworkAdapterRet_Error = 100
)

var GetNetworkAdapterRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNodeNotFound",
	100: "kOther",
}

var GetNetworkAdapterRet_Error_value = map[string]int32{
	"kNoError":      0,
	"kNodeNotFound": 1,
	"kOther":        100,
}

func (x GetNetworkAdapterRet_Error) Enum() *GetNetworkAdapterRet_Error {
	p := new(GetNetworkAdapterRet_Error)
	*p = x
	return p
}

func (x GetNetworkAdapterRet_Error) String() string {
	return proto.EnumName(GetNetworkAdapterRet_Error_name, int32(x))
}

func (x *GetNetworkAdapterRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetNetworkAdapterRet_Error_value, data, "GetNetworkAdapterRet_Error")
	if err != nil {
		return err
	}
	*x = GetNetworkAdapterRet_Error(value)
	return nil
}

func (GetNetworkAdapterRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{58, 0}
}

type GetHypervFailoverClusterRet_Error int32

const (
	GetHypervFailoverClusterRet_kNoError          GetHypervFailoverClusterRet_Error = 0
	GetHypervFailoverClusterRet_kNotFound         GetHypervFailoverClusterRet_Error = 1
	GetHypervFailoverClusterRet_kNodeNotReachable GetHypervFailoverClusterRet_Error = 2
	// the failover cluster information.
	GetHypervFailoverClusterRet_kOther GetHypervFailoverClusterRet_Error = 100
)

var GetHypervFailoverClusterRet_Error_name = map[int32]string{
	0:   "kNoError",
	1:   "kNotFound",
	2:   "kNodeNotReachable",
	100: "kOther",
}

var GetHypervFailoverClusterRet_Error_value = map[string]int32{
	"kNoError":          0,
	"kNotFound":         1,
	"kNodeNotReachable": 2,
	"kOther":            100,
}

func (x GetHypervFailoverClusterRet_Error) Enum() *GetHypervFailoverClusterRet_Error {
	p := new(GetHypervFailoverClusterRet_Error)
	*p = x
	return p
}

func (x GetHypervFailoverClusterRet_Error) String() string {
	return proto.EnumName(GetHypervFailoverClusterRet_Error_name, int32(x))
}

func (x *GetHypervFailoverClusterRet_Error) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(GetHypervFailoverClusterRet_Error_value, data, "GetHypervFailoverClusterRet_Error")
	if err != nil {
		return err
	}
	*x = GetHypervFailoverClusterRet_Error(value)
	return nil
}

func (GetHypervFailoverClusterRet_Error) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{61, 0}
}

type HyperintError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HyperintError) Reset()         { *m = HyperintError{} }
func (m *HyperintError) String() string { return proto.CompactTextString(m) }
func (*HyperintError) ProtoMessage()    {}
func (*HyperintError) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{0}
}

func (m *HyperintError) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HyperintError.Unmarshal(m, b)
}
func (m *HyperintError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HyperintError.Marshal(b, m, deterministic)
}
func (m *HyperintError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HyperintError.Merge(m, src)
}
func (m *HyperintError) XXX_Size() int {
	return xxx_messageInfo_HyperintError.Size(m)
}
func (m *HyperintError) XXX_DiscardUnknown() {
	xxx_messageInfo_HyperintError.DiscardUnknown(m)
}

var xxx_messageInfo_HyperintError proto.InternalMessageInfo

// Message that describes the network adapters. TODO: Must be reconciled with
// other network/adapter-related messages.
type NetworkAdapter struct {
	// Name of the network adapter.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Description of the network adapter.
	Description *string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// Whether the network adapter is physical or virtual.
	Virtual *bool `protobuf:"varint,3,opt,name=virtual" json:"virtual,omitempty"`
	// The MAC address of the network adapter.
	MacAddress *string `protobuf:"bytes,4,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// Whether DHCP is enabled on the adapter.
	DhcpEnabled *bool `protobuf:"varint,5,opt,name=dhcp_enabled,json=dhcpEnabled" json:"dhcp_enabled,omitempty"`
	// List of IP v4 addresses configured.
	Ipv4Addresses []string `protobuf:"bytes,6,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// The gateway configured for use.
	DefaultGateway *string `protobuf:"bytes,7,opt,name=default_gateway,json=defaultGateway" json:"default_gateway,omitempty"`
	// Name servers configured for use.
	NameServers []string `protobuf:"bytes,8,rep,name=name_servers,json=nameServers" json:"name_servers,omitempty"`
	// The speed of the network link to which the network adapter is connected to
	// in bits per seconds (bps).
	LinkSpeedBps *int64 `protobuf:"varint,9,opt,name=link_speed_bps,json=linkSpeedBps" json:"link_speed_bps,omitempty"`
	// The description of the operational status of the network adapter.
	StatusDescription    *string  `protobuf:"bytes,10,opt,name=status_description,json=statusDescription" json:"status_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkAdapter) Reset()         { *m = NetworkAdapter{} }
func (m *NetworkAdapter) String() string { return proto.CompactTextString(m) }
func (*NetworkAdapter) ProtoMessage()    {}
func (*NetworkAdapter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{1}
}

func (m *NetworkAdapter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkAdapter.Unmarshal(m, b)
}
func (m *NetworkAdapter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkAdapter.Marshal(b, m, deterministic)
}
func (m *NetworkAdapter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAdapter.Merge(m, src)
}
func (m *NetworkAdapter) XXX_Size() int {
	return xxx_messageInfo_NetworkAdapter.Size(m)
}
func (m *NetworkAdapter) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAdapter.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAdapter proto.InternalMessageInfo

func (m *NetworkAdapter) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetworkAdapter) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *NetworkAdapter) GetVirtual() bool {
	if m != nil && m.Virtual != nil {
		return *m.Virtual
	}
	return false
}

func (m *NetworkAdapter) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *NetworkAdapter) GetDhcpEnabled() bool {
	if m != nil && m.DhcpEnabled != nil {
		return *m.DhcpEnabled
	}
	return false
}

func (m *NetworkAdapter) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *NetworkAdapter) GetDefaultGateway() string {
	if m != nil && m.DefaultGateway != nil {
		return *m.DefaultGateway
	}
	return ""
}

func (m *NetworkAdapter) GetNameServers() []string {
	if m != nil {
		return m.NameServers
	}
	return nil
}

func (m *NetworkAdapter) GetLinkSpeedBps() int64 {
	if m != nil && m.LinkSpeedBps != nil {
		return *m.LinkSpeedBps
	}
	return 0
}

func (m *NetworkAdapter) GetStatusDescription() string {
	if m != nil && m.StatusDescription != nil {
		return *m.StatusDescription
	}
	return ""
}

type VmBootConfig struct {
	// Requires UEFI firmware.
	UefiFirmware *bool `protobuf:"varint,1,opt,name=uefi_firmware,json=uefiFirmware,def=0" json:"uefi_firmware,omitempty"`
	// User VM secure boot.
	SecureBoot *bool `protobuf:"varint,2,opt,name=secure_boot,json=secureBoot,def=0" json:"secure_boot,omitempty"`
	// Expose hardware virtualization support to guest.
	HardwareVirtualization *bool    `protobuf:"varint,3,opt,name=hardware_virtualization,json=hardwareVirtualization,def=0" json:"hardware_virtualization,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *VmBootConfig) Reset()         { *m = VmBootConfig{} }
func (m *VmBootConfig) String() string { return proto.CompactTextString(m) }
func (*VmBootConfig) ProtoMessage()    {}
func (*VmBootConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{2}
}

func (m *VmBootConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmBootConfig.Unmarshal(m, b)
}
func (m *VmBootConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmBootConfig.Marshal(b, m, deterministic)
}
func (m *VmBootConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmBootConfig.Merge(m, src)
}
func (m *VmBootConfig) XXX_Size() int {
	return xxx_messageInfo_VmBootConfig.Size(m)
}
func (m *VmBootConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmBootConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmBootConfig proto.InternalMessageInfo

const Default_VmBootConfig_UefiFirmware bool = false
const Default_VmBootConfig_SecureBoot bool = false
const Default_VmBootConfig_HardwareVirtualization bool = false

func (m *VmBootConfig) GetUefiFirmware() bool {
	if m != nil && m.UefiFirmware != nil {
		return *m.UefiFirmware
	}
	return Default_VmBootConfig_UefiFirmware
}

func (m *VmBootConfig) GetSecureBoot() bool {
	if m != nil && m.SecureBoot != nil {
		return *m.SecureBoot
	}
	return Default_VmBootConfig_SecureBoot
}

func (m *VmBootConfig) GetHardwareVirtualization() bool {
	if m != nil && m.HardwareVirtualization != nil {
		return *m.HardwareVirtualization
	}
	return Default_VmBootConfig_HardwareVirtualization
}

type VmConfig struct {
	// Number of vCPUs
	NumVcpus *int32 `protobuf:"varint,1,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// Configured CPU reservation in Hz.
	CpuReservationHz *int64 `protobuf:"varint,2,opt,name=cpu_reservation_hz,json=cpuReservationHz" json:"cpu_reservation_hz,omitempty"`
	// Size of the configured memory for the virtual machine in bytes.
	MemSizeBytes *int64 `protobuf:"varint,3,opt,name=mem_size_bytes,json=memSizeBytes" json:"mem_size_bytes,omitempty"`
	// Configured memory reservation in bytes.
	MemReservedBytes *int64 `protobuf:"varint,4,opt,name=mem_reserved_bytes,json=memReservedBytes" json:"mem_reserved_bytes,omitempty"`
	// Number of Ethernet adapters configured.
	NumNetworkAdapters *int32 `protobuf:"varint,5,opt,name=num_network_adapters,json=numNetworkAdapters" json:"num_network_adapters,omitempty"`
	// Number of virtual disks attached to the VM.
	NumVirtualDisks *int32 `protobuf:"varint,6,opt,name=num_virtual_disks,json=numVirtualDisks" json:"num_virtual_disks,omitempty"`
	// Name of the OS on the VM.
	GuestOsName *string `protobuf:"bytes,7,opt,name=guest_os_name,json=guestOsName" json:"guest_os_name,omitempty"`
	// List of virtual disks attached to the VM.
	VirtualDisks []*VirtualDisk `protobuf:"bytes,8,rep,name=virtual_disks,json=virtualDisks" json:"virtual_disks,omitempty"`
	// The hypervisor type.
	HypervisorType *config.ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,9,opt,name=hypervisor_type,json=hypervisorType,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType" json:"hypervisor_type,omitempty"`
	// Number of virtual CDs attached to the VM.
	NumVirtualCds *int32 `protobuf:"varint,10,opt,name=num_virtual_cds,json=numVirtualCds" json:"num_virtual_cds,omitempty"`
	// List of virtual CDs attached to the VM.
	VirtualCds []*VirtualCd `protobuf:"bytes,11,rep,name=virtual_cds,json=virtualCds" json:"virtual_cds,omitempty"`
	// Configuration path of the VM configuration file (eg. .vmx or .xml)
	ConfigFilePath *string `protobuf:"bytes,12,opt,name=config_file_path,json=configFilePath" json:"config_file_path,omitempty"`
	// Location of the hypervisor snapshot directory. All the hypervisor snapshot
	// related files are placed here. Usually, this value is same as that of
	// the location of 'config_file_path', but can be modified by user. This is
	// not related to the location of Nutanix CBR snapshots.
	SnapshotDirPath *string `protobuf:"bytes,13,opt,name=snapshot_dir_path,json=snapshotDirPath" json:"snapshot_dir_path,omitempty"`
	// Number of cores per vcpu.
	NumCoresPerVcpu *int32 `protobuf:"varint,14,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// Whether virtual disk uuids are reported to the guest operating system as
	// uuids/serial numbers. For ESX, this property is true if disk.enableUUID
	// advanced configuration option is enabled for this VM.
	VirtualDiskUuidReportedToGuest *bool `protobuf:"varint,15,opt,name=virtual_disk_uuid_reported_to_guest,json=virtualDiskUuidReportedToGuest" json:"virtual_disk_uuid_reported_to_guest,omitempty"`
	// Whether guest virtual machine ip addresses can be detected and reported by
	// the hypervisor. For ESX, this is set to true if vmware tools are
	// installed.
	IpAddressDetectionEnabled *bool `protobuf:"varint,16,opt,name=ip_address_detection_enabled,json=ipAddressDetectionEnabled" json:"ip_address_detection_enabled,omitempty"`
	// Boot configuration.
	BootConfig *VmBootConfig `protobuf:"bytes,17,opt,name=boot_config,json=bootConfig" json:"boot_config,omitempty"`
	// Number of threads per core.
	NumThreadsPerCore    *int32   `protobuf:"varint,18,opt,name=num_threads_per_core,json=numThreadsPerCore" json:"num_threads_per_core,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmConfig) Reset()         { *m = VmConfig{} }
func (m *VmConfig) String() string { return proto.CompactTextString(m) }
func (*VmConfig) ProtoMessage()    {}
func (*VmConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{3}
}

func (m *VmConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmConfig.Unmarshal(m, b)
}
func (m *VmConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmConfig.Marshal(b, m, deterministic)
}
func (m *VmConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmConfig.Merge(m, src)
}
func (m *VmConfig) XXX_Size() int {
	return xxx_messageInfo_VmConfig.Size(m)
}
func (m *VmConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmConfig proto.InternalMessageInfo

func (m *VmConfig) GetNumVcpus() int32 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *VmConfig) GetCpuReservationHz() int64 {
	if m != nil && m.CpuReservationHz != nil {
		return *m.CpuReservationHz
	}
	return 0
}

func (m *VmConfig) GetMemSizeBytes() int64 {
	if m != nil && m.MemSizeBytes != nil {
		return *m.MemSizeBytes
	}
	return 0
}

func (m *VmConfig) GetMemReservedBytes() int64 {
	if m != nil && m.MemReservedBytes != nil {
		return *m.MemReservedBytes
	}
	return 0
}

func (m *VmConfig) GetNumNetworkAdapters() int32 {
	if m != nil && m.NumNetworkAdapters != nil {
		return *m.NumNetworkAdapters
	}
	return 0
}

func (m *VmConfig) GetNumVirtualDisks() int32 {
	if m != nil && m.NumVirtualDisks != nil {
		return *m.NumVirtualDisks
	}
	return 0
}

func (m *VmConfig) GetGuestOsName() string {
	if m != nil && m.GuestOsName != nil {
		return *m.GuestOsName
	}
	return ""
}

func (m *VmConfig) GetVirtualDisks() []*VirtualDisk {
	if m != nil {
		return m.VirtualDisks
	}
	return nil
}

func (m *VmConfig) GetHypervisorType() config.ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return config.ConfigurationProto_ManagementServer_kVMware
}

func (m *VmConfig) GetNumVirtualCds() int32 {
	if m != nil && m.NumVirtualCds != nil {
		return *m.NumVirtualCds
	}
	return 0
}

func (m *VmConfig) GetVirtualCds() []*VirtualCd {
	if m != nil {
		return m.VirtualCds
	}
	return nil
}

func (m *VmConfig) GetConfigFilePath() string {
	if m != nil && m.ConfigFilePath != nil {
		return *m.ConfigFilePath
	}
	return ""
}

func (m *VmConfig) GetSnapshotDirPath() string {
	if m != nil && m.SnapshotDirPath != nil {
		return *m.SnapshotDirPath
	}
	return ""
}

func (m *VmConfig) GetNumCoresPerVcpu() int32 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *VmConfig) GetVirtualDiskUuidReportedToGuest() bool {
	if m != nil && m.VirtualDiskUuidReportedToGuest != nil {
		return *m.VirtualDiskUuidReportedToGuest
	}
	return false
}

func (m *VmConfig) GetIpAddressDetectionEnabled() bool {
	if m != nil && m.IpAddressDetectionEnabled != nil {
		return *m.IpAddressDetectionEnabled
	}
	return false
}

func (m *VmConfig) GetBootConfig() *VmBootConfig {
	if m != nil {
		return m.BootConfig
	}
	return nil
}

func (m *VmConfig) GetNumThreadsPerCore() int32 {
	if m != nil && m.NumThreadsPerCore != nil {
		return *m.NumThreadsPerCore
	}
	return 0
}

type VirtualCd struct {
	// The type of the virtual CD device attached to the virtual machine.
	// This field should be set even for empty CD-ROMs.
	Type *VirtualCd_Type `protobuf:"varint,1,req,name=type,enum=nutanix.hyperint.VirtualCd_Type" json:"type,omitempty"`
	// Valid if 'type' is 'kFileOnNfs'.
	FileOnNfs *VirtualCd_FileOnNfs `protobuf:"bytes,2,opt,name=file_on_nfs,json=fileOnNfs" json:"file_on_nfs,omitempty"`
	// Adapter type of the virtual CD device.
	AdapterType *VirtualCd_AdapterType `protobuf:"varint,9,opt,name=adapter_type,json=adapterType,enum=nutanix.hyperint.VirtualCd_AdapterType" json:"adapter_type,omitempty"`
	// Device label as specified in virtual machine configuration.
	CdLabel *string `protobuf:"bytes,10,opt,name=cd_label,json=cdLabel" json:"cd_label,omitempty"`
	// Is device connected to the VM?
	IsConnected *bool `protobuf:"varint,11,opt,name=is_connected,json=isConnected,def=1" json:"is_connected,omitempty"`
	// Index of the device within the adapter type. This is used to represent
	// device ordering within the adapter type (SCSI or IDE).
	DeviceIndex *int32 `protobuf:"varint,12,opt,name=device_index,json=deviceIndex" json:"device_index,omitempty"`
	// Whether the CD-ROM is empty.
	Empty                *bool    `protobuf:"varint,13,opt,name=empty" json:"empty,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualCd) Reset()         { *m = VirtualCd{} }
func (m *VirtualCd) String() string { return proto.CompactTextString(m) }
func (*VirtualCd) ProtoMessage()    {}
func (*VirtualCd) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{4}
}

func (m *VirtualCd) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualCd.Unmarshal(m, b)
}
func (m *VirtualCd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualCd.Marshal(b, m, deterministic)
}
func (m *VirtualCd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualCd.Merge(m, src)
}
func (m *VirtualCd) XXX_Size() int {
	return xxx_messageInfo_VirtualCd.Size(m)
}
func (m *VirtualCd) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualCd.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualCd proto.InternalMessageInfo

const Default_VirtualCd_IsConnected bool = true

func (m *VirtualCd) GetType() VirtualCd_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VirtualCd_kFileOnNfs
}

func (m *VirtualCd) GetFileOnNfs() *VirtualCd_FileOnNfs {
	if m != nil {
		return m.FileOnNfs
	}
	return nil
}

func (m *VirtualCd) GetAdapterType() VirtualCd_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return VirtualCd_kSCSI
}

func (m *VirtualCd) GetCdLabel() string {
	if m != nil && m.CdLabel != nil {
		return *m.CdLabel
	}
	return ""
}

func (m *VirtualCd) GetIsConnected() bool {
	if m != nil && m.IsConnected != nil {
		return *m.IsConnected
	}
	return Default_VirtualCd_IsConnected
}

func (m *VirtualCd) GetDeviceIndex() int32 {
	if m != nil && m.DeviceIndex != nil {
		return *m.DeviceIndex
	}
	return 0
}

func (m *VirtualCd) GetEmpty() bool {
	if m != nil && m.Empty != nil {
		return *m.Empty
	}
	return false
}

type VirtualCd_FileOnNfs struct {
	// NFS file pathname.
	FilePathName *string `protobuf:"bytes,1,opt,name=file_path_name,json=filePathName" json:"file_path_name,omitempty"`
	// Pathname to the NFS folder.
	RemotePath *string `protobuf:"bytes,3,opt,name=remote_path,json=remotePath" json:"remote_path,omitempty"`
	// IP address or host name of the NFS server.
	Server *string `protobuf:"bytes,2,opt,name=server" json:"server,omitempty"`
	// Source NFS Path of the Vitual CD.
	SourceNfsPath        *string  `protobuf:"bytes,4,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualCd_FileOnNfs) Reset()         { *m = VirtualCd_FileOnNfs{} }
func (m *VirtualCd_FileOnNfs) String() string { return proto.CompactTextString(m) }
func (*VirtualCd_FileOnNfs) ProtoMessage()    {}
func (*VirtualCd_FileOnNfs) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{4, 0}
}

func (m *VirtualCd_FileOnNfs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualCd_FileOnNfs.Unmarshal(m, b)
}
func (m *VirtualCd_FileOnNfs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualCd_FileOnNfs.Marshal(b, m, deterministic)
}
func (m *VirtualCd_FileOnNfs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualCd_FileOnNfs.Merge(m, src)
}
func (m *VirtualCd_FileOnNfs) XXX_Size() int {
	return xxx_messageInfo_VirtualCd_FileOnNfs.Size(m)
}
func (m *VirtualCd_FileOnNfs) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualCd_FileOnNfs.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualCd_FileOnNfs proto.InternalMessageInfo

func (m *VirtualCd_FileOnNfs) GetFilePathName() string {
	if m != nil && m.FilePathName != nil {
		return *m.FilePathName
	}
	return ""
}

func (m *VirtualCd_FileOnNfs) GetRemotePath() string {
	if m != nil && m.RemotePath != nil {
		return *m.RemotePath
	}
	return ""
}

func (m *VirtualCd_FileOnNfs) GetServer() string {
	if m != nil && m.Server != nil {
		return *m.Server
	}
	return ""
}

func (m *VirtualCd_FileOnNfs) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

type VirtualDisk struct {
	//  The type of the virtual disk device attached to the virtual machine.
	Type *VirtualDisk_Type `protobuf:"varint,1,req,name=type,enum=nutanix.hyperint.VirtualDisk_Type" json:"type,omitempty"`
	// The value of 'type' determines which of the following optional properties
	// would be set. One and only one of the following five properties would
	// be set for any Virtual Disk.
	FileOnNfs              *VirtualDisk_FileOnNfs              `protobuf:"bytes,2,opt,name=file_on_nfs,json=fileOnNfs" json:"file_on_nfs,omitempty"`
	FileOnDas              *VirtualDisk_FileOnDas              `protobuf:"bytes,3,opt,name=file_on_das,json=fileOnDas" json:"file_on_das,omitempty"`
	FileOnSharedIscsiVdisk *VirtualDisk_FileOnSharedIscsiVDisk `protobuf:"bytes,4,opt,name=file_on_shared_iscsi_vdisk,json=fileOnSharedIscsiVdisk" json:"file_on_shared_iscsi_vdisk,omitempty"`
	IscsiVdisk             *VirtualDisk_IscsiVDisk             `protobuf:"bytes,5,opt,name=iscsi_vdisk,json=iscsiVdisk" json:"iscsi_vdisk,omitempty"`
	Das                    *VirtualDisk_Das                    `protobuf:"bytes,6,opt,name=das" json:"das,omitempty"`
	// Virtual disk capacity in bytes.
	CapacityBytes *int64 `protobuf:"varint,7,opt,name=capacity_bytes,json=capacityBytes" json:"capacity_bytes,omitempty"`
	// The UUID of the virtual disk.
	Uuid *string `protobuf:"bytes,8,opt,name=uuid" json:"uuid,omitempty"`
	// Adapter type of the virtual disk device.
	AdapterType *VirtualDisk_AdapterType `protobuf:"varint,9,opt,name=adapter_type,json=adapterType,enum=nutanix.hyperint.VirtualDisk_AdapterType" json:"adapter_type,omitempty"`
	// Disk label as specified in virtual machine configuration.
	DiskLabel *string `protobuf:"bytes,10,opt,name=disk_label,json=diskLabel" json:"disk_label,omitempty"`
	// Whether the virtual disk is thin provisioned.
	IsThinProvisioned *bool `protobuf:"varint,13,opt,name=is_thin_provisioned,json=isThinProvisioned" json:"is_thin_provisioned,omitempty"`
	// Index of the device within the adapter type. This is used to represent
	// device ordering within the adapter type (SCSI or IDE).
	DeviceIndex *int32 `protobuf:"varint,11,opt,name=device_index,json=deviceIndex" json:"device_index,omitempty"`
	// Whether the virtual disk is shared.
	IsShared             *bool    `protobuf:"varint,12,opt,name=is_shared,json=isShared" json:"is_shared,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDisk) Reset()         { *m = VirtualDisk{} }
func (m *VirtualDisk) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk) ProtoMessage()    {}
func (*VirtualDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5}
}

func (m *VirtualDisk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk.Unmarshal(m, b)
}
func (m *VirtualDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk.Marshal(b, m, deterministic)
}
func (m *VirtualDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk.Merge(m, src)
}
func (m *VirtualDisk) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk.Size(m)
}
func (m *VirtualDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk proto.InternalMessageInfo

func (m *VirtualDisk) GetType() VirtualDisk_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return VirtualDisk_kFileOnNfs
}

func (m *VirtualDisk) GetFileOnNfs() *VirtualDisk_FileOnNfs {
	if m != nil {
		return m.FileOnNfs
	}
	return nil
}

func (m *VirtualDisk) GetFileOnDas() *VirtualDisk_FileOnDas {
	if m != nil {
		return m.FileOnDas
	}
	return nil
}

func (m *VirtualDisk) GetFileOnSharedIscsiVdisk() *VirtualDisk_FileOnSharedIscsiVDisk {
	if m != nil {
		return m.FileOnSharedIscsiVdisk
	}
	return nil
}

func (m *VirtualDisk) GetIscsiVdisk() *VirtualDisk_IscsiVDisk {
	if m != nil {
		return m.IscsiVdisk
	}
	return nil
}

func (m *VirtualDisk) GetDas() *VirtualDisk_Das {
	if m != nil {
		return m.Das
	}
	return nil
}

func (m *VirtualDisk) GetCapacityBytes() int64 {
	if m != nil && m.CapacityBytes != nil {
		return *m.CapacityBytes
	}
	return 0
}

func (m *VirtualDisk) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *VirtualDisk) GetAdapterType() VirtualDisk_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return VirtualDisk_kSCSI
}

func (m *VirtualDisk) GetDiskLabel() string {
	if m != nil && m.DiskLabel != nil {
		return *m.DiskLabel
	}
	return ""
}

func (m *VirtualDisk) GetIsThinProvisioned() bool {
	if m != nil && m.IsThinProvisioned != nil {
		return *m.IsThinProvisioned
	}
	return false
}

func (m *VirtualDisk) GetDeviceIndex() int32 {
	if m != nil && m.DeviceIndex != nil {
		return *m.DeviceIndex
	}
	return 0
}

func (m *VirtualDisk) GetIsShared() bool {
	if m != nil && m.IsShared != nil {
		return *m.IsShared
	}
	return false
}

type VirtualDisk_FileOnNfs struct {
	// NFS file pathname.
	FilePathName *string `protobuf:"bytes,1,req,name=file_path_name,json=filePathName" json:"file_path_name,omitempty"`
	// IP address or host name of the NFS server.
	Server *string `protobuf:"bytes,2,req,name=server" json:"server,omitempty"`
	// Pathname to the NFS folder.
	RemotePath *string `protobuf:"bytes,3,req,name=remote_path,json=remotePath" json:"remote_path,omitempty"`
	// NFS file pathnames of the disk extents that back the virtual disk.
	// Since the disk extents can themselves come from different datastores/
	// containers, the following list entries include the container name
	// in the pathname.
	DiskExtentFilePathName []string `protobuf:"bytes,4,rep,name=disk_extent_file_path_name,json=diskExtentFilePathName" json:"disk_extent_file_path_name,omitempty"`
	// Whether the virtual disk is a flat file. Flat files are self contained files
	// that don't depend on a parent virtual disk file. Examples are
	// delta disks (vmware) or a differencing disks (hyper-v).
	IsFlatFile *bool `protobuf:"varint,5,opt,name=is_flat_file,json=isFlatFile" json:"is_flat_file,omitempty"`
	// Container id where the disk resides.
	ContainerId *int64 `protobuf:"varint,6,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Source NFS Path of the disk.
	SourceNfsPath        *string  `protobuf:"bytes,7,opt,name=source_nfs_path,json=sourceNfsPath" json:"source_nfs_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDisk_FileOnNfs) Reset()         { *m = VirtualDisk_FileOnNfs{} }
func (m *VirtualDisk_FileOnNfs) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk_FileOnNfs) ProtoMessage()    {}
func (*VirtualDisk_FileOnNfs) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 0}
}

func (m *VirtualDisk_FileOnNfs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk_FileOnNfs.Unmarshal(m, b)
}
func (m *VirtualDisk_FileOnNfs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk_FileOnNfs.Marshal(b, m, deterministic)
}
func (m *VirtualDisk_FileOnNfs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk_FileOnNfs.Merge(m, src)
}
func (m *VirtualDisk_FileOnNfs) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk_FileOnNfs.Size(m)
}
func (m *VirtualDisk_FileOnNfs) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk_FileOnNfs.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk_FileOnNfs proto.InternalMessageInfo

func (m *VirtualDisk_FileOnNfs) GetFilePathName() string {
	if m != nil && m.FilePathName != nil {
		return *m.FilePathName
	}
	return ""
}

func (m *VirtualDisk_FileOnNfs) GetServer() string {
	if m != nil && m.Server != nil {
		return *m.Server
	}
	return ""
}

func (m *VirtualDisk_FileOnNfs) GetRemotePath() string {
	if m != nil && m.RemotePath != nil {
		return *m.RemotePath
	}
	return ""
}

func (m *VirtualDisk_FileOnNfs) GetDiskExtentFilePathName() []string {
	if m != nil {
		return m.DiskExtentFilePathName
	}
	return nil
}

func (m *VirtualDisk_FileOnNfs) GetIsFlatFile() bool {
	if m != nil && m.IsFlatFile != nil {
		return *m.IsFlatFile
	}
	return false
}

func (m *VirtualDisk_FileOnNfs) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VirtualDisk_FileOnNfs) GetSourceNfsPath() string {
	if m != nil && m.SourceNfsPath != nil {
		return *m.SourceNfsPath
	}
	return ""
}

type VirtualDisk_FileOnDas struct {
	// Pathname to the file.
	FilePathName         *string  `protobuf:"bytes,1,req,name=file_path_name,json=filePathName" json:"file_path_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDisk_FileOnDas) Reset()         { *m = VirtualDisk_FileOnDas{} }
func (m *VirtualDisk_FileOnDas) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk_FileOnDas) ProtoMessage()    {}
func (*VirtualDisk_FileOnDas) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 1}
}

func (m *VirtualDisk_FileOnDas) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk_FileOnDas.Unmarshal(m, b)
}
func (m *VirtualDisk_FileOnDas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk_FileOnDas.Marshal(b, m, deterministic)
}
func (m *VirtualDisk_FileOnDas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk_FileOnDas.Merge(m, src)
}
func (m *VirtualDisk_FileOnDas) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk_FileOnDas.Size(m)
}
func (m *VirtualDisk_FileOnDas) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk_FileOnDas.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk_FileOnDas proto.InternalMessageInfo

func (m *VirtualDisk_FileOnDas) GetFilePathName() string {
	if m != nil && m.FilePathName != nil {
		return *m.FilePathName
	}
	return ""
}

type VirtualDisk_IscsiTarget struct {
	// The IP addresses through which the target can be reached.
	Addresses []string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty"`
	// The name of the iSCSI target.
	TargetName           *string  `protobuf:"bytes,2,req,name=target_name,json=targetName" json:"target_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDisk_IscsiTarget) Reset()         { *m = VirtualDisk_IscsiTarget{} }
func (m *VirtualDisk_IscsiTarget) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk_IscsiTarget) ProtoMessage()    {}
func (*VirtualDisk_IscsiTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 2}
}

func (m *VirtualDisk_IscsiTarget) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk_IscsiTarget.Unmarshal(m, b)
}
func (m *VirtualDisk_IscsiTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk_IscsiTarget.Marshal(b, m, deterministic)
}
func (m *VirtualDisk_IscsiTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk_IscsiTarget.Merge(m, src)
}
func (m *VirtualDisk_IscsiTarget) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk_IscsiTarget.Size(m)
}
func (m *VirtualDisk_IscsiTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk_IscsiTarget.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk_IscsiTarget proto.InternalMessageInfo

func (m *VirtualDisk_IscsiTarget) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *VirtualDisk_IscsiTarget) GetTargetName() string {
	if m != nil && m.TargetName != nil {
		return *m.TargetName
	}
	return ""
}

type VirtualDisk_FileOnSharedIscsiVDisk struct {
	// Pathname to the file.
	FilePathName *string `protobuf:"bytes,1,req,name=file_path_name,json=filePathName" json:"file_path_name,omitempty"`
	// iSCSI targets corresponding to the shared VDisk(s) that form the basis
	// of the file system upon which this file resides.
	IscsiTarget          []*VirtualDisk_IscsiTarget `protobuf:"bytes,2,rep,name=iscsi_target,json=iscsiTarget" json:"iscsi_target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *VirtualDisk_FileOnSharedIscsiVDisk) Reset()         { *m = VirtualDisk_FileOnSharedIscsiVDisk{} }
func (m *VirtualDisk_FileOnSharedIscsiVDisk) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk_FileOnSharedIscsiVDisk) ProtoMessage()    {}
func (*VirtualDisk_FileOnSharedIscsiVDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 3}
}

func (m *VirtualDisk_FileOnSharedIscsiVDisk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk_FileOnSharedIscsiVDisk.Unmarshal(m, b)
}
func (m *VirtualDisk_FileOnSharedIscsiVDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk_FileOnSharedIscsiVDisk.Marshal(b, m, deterministic)
}
func (m *VirtualDisk_FileOnSharedIscsiVDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk_FileOnSharedIscsiVDisk.Merge(m, src)
}
func (m *VirtualDisk_FileOnSharedIscsiVDisk) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk_FileOnSharedIscsiVDisk.Size(m)
}
func (m *VirtualDisk_FileOnSharedIscsiVDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk_FileOnSharedIscsiVDisk.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk_FileOnSharedIscsiVDisk proto.InternalMessageInfo

func (m *VirtualDisk_FileOnSharedIscsiVDisk) GetFilePathName() string {
	if m != nil && m.FilePathName != nil {
		return *m.FilePathName
	}
	return ""
}

func (m *VirtualDisk_FileOnSharedIscsiVDisk) GetIscsiTarget() []*VirtualDisk_IscsiTarget {
	if m != nil {
		return m.IscsiTarget
	}
	return nil
}

type VirtualDisk_IscsiVDisk struct {
	// The iSCSI target corresponding to the VDisk.
	IscsiTarget          *VirtualDisk_IscsiTarget `protobuf:"bytes,1,req,name=iscsi_target,json=iscsiTarget" json:"iscsi_target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *VirtualDisk_IscsiVDisk) Reset()         { *m = VirtualDisk_IscsiVDisk{} }
func (m *VirtualDisk_IscsiVDisk) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk_IscsiVDisk) ProtoMessage()    {}
func (*VirtualDisk_IscsiVDisk) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 4}
}

func (m *VirtualDisk_IscsiVDisk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk_IscsiVDisk.Unmarshal(m, b)
}
func (m *VirtualDisk_IscsiVDisk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk_IscsiVDisk.Marshal(b, m, deterministic)
}
func (m *VirtualDisk_IscsiVDisk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk_IscsiVDisk.Merge(m, src)
}
func (m *VirtualDisk_IscsiVDisk) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk_IscsiVDisk.Size(m)
}
func (m *VirtualDisk_IscsiVDisk) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk_IscsiVDisk.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk_IscsiVDisk proto.InternalMessageInfo

func (m *VirtualDisk_IscsiVDisk) GetIscsiTarget() *VirtualDisk_IscsiTarget {
	if m != nil {
		return m.IscsiTarget
	}
	return nil
}

type VirtualDisk_Das struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualDisk_Das) Reset()         { *m = VirtualDisk_Das{} }
func (m *VirtualDisk_Das) String() string { return proto.CompactTextString(m) }
func (*VirtualDisk_Das) ProtoMessage()    {}
func (*VirtualDisk_Das) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{5, 5}
}

func (m *VirtualDisk_Das) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualDisk_Das.Unmarshal(m, b)
}
func (m *VirtualDisk_Das) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualDisk_Das.Marshal(b, m, deterministic)
}
func (m *VirtualDisk_Das) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualDisk_Das.Merge(m, src)
}
func (m *VirtualDisk_Das) XXX_Size() int {
	return xxx_messageInfo_VirtualDisk_Das.Size(m)
}
func (m *VirtualDisk_Das) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualDisk_Das.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualDisk_Das proto.InternalMessageInfo

type VmFileConfig struct {
	// Collection of NFS files that compose this VM. The files must exist on a
	// Nutanix datastore and the paths must be absolute, i.e., have format:
	//   "/<container>/path/to/file".
	//
	// The ordering of the returned files is important when used in the context
	// of registering a new VM. For example, if the VM info was used to snapshot
	// the VM's file and register a new VM, the snapshot files should be
	// presented in the same order as the source files that were read from this
	// field.
	NfsFilePath          []string            `protobuf:"bytes,1,rep,name=nfs_file_path,json=nfsFilePath" json:"nfs_file_path,omitempty"`
	Type                 []VmFileConfig_Type `protobuf:"varint,2,rep,name=type,enum=nutanix.hyperint.VmFileConfig_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *VmFileConfig) Reset()         { *m = VmFileConfig{} }
func (m *VmFileConfig) String() string { return proto.CompactTextString(m) }
func (*VmFileConfig) ProtoMessage()    {}
func (*VmFileConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{6}
}

func (m *VmFileConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmFileConfig.Unmarshal(m, b)
}
func (m *VmFileConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmFileConfig.Marshal(b, m, deterministic)
}
func (m *VmFileConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmFileConfig.Merge(m, src)
}
func (m *VmFileConfig) XXX_Size() int {
	return xxx_messageInfo_VmFileConfig.Size(m)
}
func (m *VmFileConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmFileConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmFileConfig proto.InternalMessageInfo

func (m *VmFileConfig) GetNfsFilePath() []string {
	if m != nil {
		return m.NfsFilePath
	}
	return nil
}

func (m *VmFileConfig) GetType() []VmFileConfig_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

type VirtualNetworkAdapterConfig struct {
	// Name of the virtual switch or portgroup. This is a deprecated field,
	// replaced by 'l2_network_config'.
	NetworkName *string `protobuf:"bytes,1,opt,name=network_name,json=networkName" json:"network_name,omitempty"`
	// Type/Emulation of the Virtual adapter. For vmware, "pcnet32" or "e1000" or
	// "vmxnet3". For Hyper-v it could be "legacy" or "network".
	AdapterType *string `protobuf:"bytes,2,opt,name=adapter_type,json=adapterType" json:"adapter_type,omitempty"`
	// Descriptive label for this network adapter.
	Label *string `protobuf:"bytes,3,opt,name=label" json:"label,omitempty"`
	// MAC address of the adapter.
	MacAddress *string `protobuf:"bytes,4,opt,name=mac_address,json=macAddress" json:"mac_address,omitempty"`
	// Type of MAC address.
	MacAddressType *VirtualNetworkAdapterConfig_MacAddressType `protobuf:"varint,5,opt,name=mac_address_type,json=macAddressType,enum=nutanix.hyperint.VirtualNetworkAdapterConfig_MacAddressType" json:"mac_address_type,omitempty"`
	// Indicates if Wake-on-LAN is enabled.
	WakeOnLanElabled *bool `protobuf:"varint,6,opt,name=wake_on_lan_elabled,json=wakeOnLanElabled" json:"wake_on_lan_elabled,omitempty"`
	// Indicates if this adapter is connected to the VM.
	Connected *bool `protobuf:"varint,7,opt,name=connected" json:"connected,omitempty"`
	// Ipv4-addresses of the adapter.
	Ipv4Addresses []string `protobuf:"bytes,8,rep,name=ipv4_addresses,json=ipv4Addresses" json:"ipv4_addresses,omitempty"`
	// Ipv6-addresses of the adapter.
	Ipv6Addresses []string `protobuf:"bytes,9,rep,name=ipv6_addresses,json=ipv6Addresses" json:"ipv6_addresses,omitempty"`
	// Port-ID - Port Id or port name of the adapter. This field is used to
	// uniquely identify the adapter instance within the VM.
	PortId *string `protobuf:"bytes,10,opt,name=port_id,json=portId" json:"port_id,omitempty"`
	// Host nic ids that this adapter is attached to.
	// This field is used for capturing network performance metrics and set
	// only when publishing VM level stats to Arithmos.
	HostNicIds []string `protobuf:"bytes,11,rep,name=host_nic_ids,json=hostNicIds" json:"host_nic_ids,omitempty"`
	// L2 network config of this adapter.
	L2NetworkConfig *VmL2NetworkConfig `protobuf:"bytes,12,opt,name=l2_network_config,json=l2NetworkConfig" json:"l2_network_config,omitempty"`
	// Virtual NIC UUID.
	Uuid                 *string  `protobuf:"bytes,13,opt,name=uuid" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VirtualNetworkAdapterConfig) Reset()         { *m = VirtualNetworkAdapterConfig{} }
func (m *VirtualNetworkAdapterConfig) String() string { return proto.CompactTextString(m) }
func (*VirtualNetworkAdapterConfig) ProtoMessage()    {}
func (*VirtualNetworkAdapterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{7}
}

func (m *VirtualNetworkAdapterConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VirtualNetworkAdapterConfig.Unmarshal(m, b)
}
func (m *VirtualNetworkAdapterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VirtualNetworkAdapterConfig.Marshal(b, m, deterministic)
}
func (m *VirtualNetworkAdapterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkAdapterConfig.Merge(m, src)
}
func (m *VirtualNetworkAdapterConfig) XXX_Size() int {
	return xxx_messageInfo_VirtualNetworkAdapterConfig.Size(m)
}
func (m *VirtualNetworkAdapterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkAdapterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkAdapterConfig proto.InternalMessageInfo

func (m *VirtualNetworkAdapterConfig) GetNetworkName() string {
	if m != nil && m.NetworkName != nil {
		return *m.NetworkName
	}
	return ""
}

func (m *VirtualNetworkAdapterConfig) GetAdapterType() string {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return ""
}

func (m *VirtualNetworkAdapterConfig) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *VirtualNetworkAdapterConfig) GetMacAddress() string {
	if m != nil && m.MacAddress != nil {
		return *m.MacAddress
	}
	return ""
}

func (m *VirtualNetworkAdapterConfig) GetMacAddressType() VirtualNetworkAdapterConfig_MacAddressType {
	if m != nil && m.MacAddressType != nil {
		return *m.MacAddressType
	}
	return VirtualNetworkAdapterConfig_kStatic
}

func (m *VirtualNetworkAdapterConfig) GetWakeOnLanElabled() bool {
	if m != nil && m.WakeOnLanElabled != nil {
		return *m.WakeOnLanElabled
	}
	return false
}

func (m *VirtualNetworkAdapterConfig) GetConnected() bool {
	if m != nil && m.Connected != nil {
		return *m.Connected
	}
	return false
}

func (m *VirtualNetworkAdapterConfig) GetIpv4Addresses() []string {
	if m != nil {
		return m.Ipv4Addresses
	}
	return nil
}

func (m *VirtualNetworkAdapterConfig) GetIpv6Addresses() []string {
	if m != nil {
		return m.Ipv6Addresses
	}
	return nil
}

func (m *VirtualNetworkAdapterConfig) GetPortId() string {
	if m != nil && m.PortId != nil {
		return *m.PortId
	}
	return ""
}

func (m *VirtualNetworkAdapterConfig) GetHostNicIds() []string {
	if m != nil {
		return m.HostNicIds
	}
	return nil
}

func (m *VirtualNetworkAdapterConfig) GetL2NetworkConfig() *VmL2NetworkConfig {
	if m != nil {
		return m.L2NetworkConfig
	}
	return nil
}

func (m *VirtualNetworkAdapterConfig) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

type VmNetworkConfig struct {
	// Set of virtual network adapters.
	Adapters             []*VirtualNetworkAdapterConfig `protobuf:"bytes,1,rep,name=adapters" json:"adapters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *VmNetworkConfig) Reset()         { *m = VmNetworkConfig{} }
func (m *VmNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*VmNetworkConfig) ProtoMessage()    {}
func (*VmNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{8}
}

func (m *VmNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmNetworkConfig.Unmarshal(m, b)
}
func (m *VmNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmNetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmNetworkConfig.Merge(m, src)
}
func (m *VmNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmNetworkConfig.Size(m)
}
func (m *VmNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmNetworkConfig proto.InternalMessageInfo

func (m *VmNetworkConfig) GetAdapters() []*VirtualNetworkAdapterConfig {
	if m != nil {
		return m.Adapters
	}
	return nil
}

type VmInfo struct {
	// The ID of the virtual machine.
	VmId *string `protobuf:"bytes,1,req,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// The display name of the virtual machine.
	DisplayName *string `protobuf:"bytes,2,req,name=display_name,json=displayName" json:"display_name,omitempty"`
	// IP addresses assigned to all the configured network adapters.
	// This list can include v4 and v6 IP addresses. Can potentially be
	// used to identify the Nutanix SVM.
	IpAddresses []string `protobuf:"bytes,3,rep,name=ip_addresses,json=ipAddresses" json:"ip_addresses,omitempty"`
	// The id of the node that's hosting this virtual machine.
	// Set for all VMs on ESX/Hyper-V. Set for powered-on VMs on AHV.
	NodeId *int64 `protobuf:"varint,4,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The configuration of the virtual machine.
	VmConfig *VmConfig `protobuf:"bytes,5,opt,name=vm_config,json=vmConfig" json:"vm_config,omitempty"`
	// The files that compose this virtual machine. Note that only files that
	// reside on the Nutanix datastore are included.
	VmFileConfig *VmFileConfig `protobuf:"bytes,6,opt,name=vm_file_config,json=vmFileConfig" json:"vm_file_config,omitempty"`
	// The power state of the virtual machine.
	PowerState *VmInfo_PowerState `protobuf:"varint,7,opt,name=power_state,json=powerState,enum=nutanix.hyperint.VmInfo_PowerState" json:"power_state,omitempty"`
	// Network configuration of the virtual machine.
	VmNetworkConfig *VmNetworkConfig `protobuf:"bytes,8,opt,name=vm_network_config,json=vmNetworkConfig" json:"vm_network_config,omitempty"`
	// Whether the virtual machine is a Nutanix CVM.
	// True if 1, false otherwise.
	IsCvm *int64 `protobuf:"varint,9,opt,name=is_cvm,json=isCvm,def=0" json:"is_cvm,omitempty"`
	// Nutanix Containers associated with this VM.
	Containers []*config.ConfigurationProto_Container `protobuf:"bytes,10,rep,name=containers" json:"containers,omitempty"`
	// Optional opaque metadata to be restored during RegisterVm. This is only
	// returned when include_vm_opaque_data is set to true in GetVmInfoArg.
	VmOpaqueData []byte `protobuf:"bytes,11,opt,name=vm_opaque_data,json=vmOpaqueData" json:"vm_opaque_data,omitempty"`
	// Whether the VM is CBR capable.
	IsCbrCapable *bool `protobuf:"varint,12,opt,name=is_cbr_capable,json=isCbrCapable" json:"is_cbr_capable,omitempty"`
	// Indicates the reason if 'is_cbr_capable' is false.
	CbrNotCapableReason *string `protobuf:"bytes,13,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Set if the VM does not need app consistent snapshots in its
	// current state. For example, VM not being powered on, or guest tools
	// not running etc.
	AppConsistentSnapshotRequired *bool `protobuf:"varint,14,opt,name=app_consistent_snapshot_required,json=appConsistentSnapshotRequired" json:"app_consistent_snapshot_required,omitempty"`
	// Reason why app consistent snapshot is not required if
	// 'app_consistent_snapshot_required' is false.
	AppConsistentSnapshotNotRequiredReason *string `protobuf:"bytes,15,opt,name=app_consistent_snapshot_not_required_reason,json=appConsistentSnapshotNotRequiredReason" json:"app_consistent_snapshot_not_required_reason,omitempty"`
	// Virtual hardware version for this virtual machine. This value is
	// specific to the hypervisor.
	VirtualHardwareVersion *int32 `protobuf:"varint,16,opt,name=virtual_hardware_version,json=virtualHardwareVersion" json:"virtual_hardware_version,omitempty"`
	// Node uuid.
	// Set for all VMs on ESX/Hyper-V. Set for powered-on VMs on AHV.
	NodeUuid []byte `protobuf:"bytes,17,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// Boolean flag indicating whether the VmInfo object is representing a
	// volume group or a virtual machine. This is needed primarily so that in
	// future release when volume groups are first class citizens consumers of
	// this object can distinguish between the two.
	IsVolumeGroup    *bool                        `protobuf:"varint,18,opt,name=is_volume_group,json=isVolumeGroup" json:"is_volume_group,omitempty"`
	AttachedVgConfig []*VmInfo_VgAttachmentConfig `protobuf:"bytes,19,rep,name=attached_vg_config,json=attachedVgConfig" json:"attached_vg_config,omitempty"`
	// BIOS uuid for the VM.
	BiosUuid *string `protobuf:"bytes,20,opt,name=bios_uuid,json=biosUuid" json:"bios_uuid,omitempty"`
	// Whether the VM has any active tasks that might impact VM state.
	// Valid for ESX only.
	IsVmTaskInProgress *bool `protobuf:"varint,21,opt,name=is_vm_task_in_progress,json=isVmTaskInProgress" json:"is_vm_task_in_progress,omitempty"`
	// Stretch params id of the VM if Stretch is enabled.
	StretchParamsId      *stretch_params.StretchParams_UniversalId `protobuf:"bytes,22,opt,name=stretch_params_id,json=stretchParamsId" json:"stretch_params_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *VmInfo) Reset()         { *m = VmInfo{} }
func (m *VmInfo) String() string { return proto.CompactTextString(m) }
func (*VmInfo) ProtoMessage()    {}
func (*VmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{9}
}

func (m *VmInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmInfo.Unmarshal(m, b)
}
func (m *VmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmInfo.Marshal(b, m, deterministic)
}
func (m *VmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmInfo.Merge(m, src)
}
func (m *VmInfo) XXX_Size() int {
	return xxx_messageInfo_VmInfo.Size(m)
}
func (m *VmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VmInfo proto.InternalMessageInfo

const Default_VmInfo_IsCvm int64 = 0

func (m *VmInfo) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *VmInfo) GetDisplayName() string {
	if m != nil && m.DisplayName != nil {
		return *m.DisplayName
	}
	return ""
}

func (m *VmInfo) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *VmInfo) GetNodeId() int64 {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return 0
}

func (m *VmInfo) GetVmConfig() *VmConfig {
	if m != nil {
		return m.VmConfig
	}
	return nil
}

func (m *VmInfo) GetVmFileConfig() *VmFileConfig {
	if m != nil {
		return m.VmFileConfig
	}
	return nil
}

func (m *VmInfo) GetPowerState() VmInfo_PowerState {
	if m != nil && m.PowerState != nil {
		return *m.PowerState
	}
	return VmInfo_kPoweredOff
}

func (m *VmInfo) GetVmNetworkConfig() *VmNetworkConfig {
	if m != nil {
		return m.VmNetworkConfig
	}
	return nil
}

func (m *VmInfo) GetIsCvm() int64 {
	if m != nil && m.IsCvm != nil {
		return *m.IsCvm
	}
	return Default_VmInfo_IsCvm
}

func (m *VmInfo) GetContainers() []*config.ConfigurationProto_Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *VmInfo) GetVmOpaqueData() []byte {
	if m != nil {
		return m.VmOpaqueData
	}
	return nil
}

func (m *VmInfo) GetIsCbrCapable() bool {
	if m != nil && m.IsCbrCapable != nil {
		return *m.IsCbrCapable
	}
	return false
}

func (m *VmInfo) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VmInfo) GetAppConsistentSnapshotRequired() bool {
	if m != nil && m.AppConsistentSnapshotRequired != nil {
		return *m.AppConsistentSnapshotRequired
	}
	return false
}

func (m *VmInfo) GetAppConsistentSnapshotNotRequiredReason() string {
	if m != nil && m.AppConsistentSnapshotNotRequiredReason != nil {
		return *m.AppConsistentSnapshotNotRequiredReason
	}
	return ""
}

func (m *VmInfo) GetVirtualHardwareVersion() int32 {
	if m != nil && m.VirtualHardwareVersion != nil {
		return *m.VirtualHardwareVersion
	}
	return 0
}

func (m *VmInfo) GetNodeUuid() []byte {
	if m != nil {
		return m.NodeUuid
	}
	return nil
}

func (m *VmInfo) GetIsVolumeGroup() bool {
	if m != nil && m.IsVolumeGroup != nil {
		return *m.IsVolumeGroup
	}
	return false
}

func (m *VmInfo) GetAttachedVgConfig() []*VmInfo_VgAttachmentConfig {
	if m != nil {
		return m.AttachedVgConfig
	}
	return nil
}

func (m *VmInfo) GetBiosUuid() string {
	if m != nil && m.BiosUuid != nil {
		return *m.BiosUuid
	}
	return ""
}

func (m *VmInfo) GetIsVmTaskInProgress() bool {
	if m != nil && m.IsVmTaskInProgress != nil {
		return *m.IsVmTaskInProgress
	}
	return false
}

func (m *VmInfo) GetStretchParamsId() *stretch_params.StretchParams_UniversalId {
	if m != nil {
		return m.StretchParamsId
	}
	return nil
}

// Info about VGs attached to this VM.
type VmInfo_VgAttachmentConfig struct {
	// The ID of volume group attached to this VM.
	VgId *string `protobuf:"bytes,1,opt,name=vg_id,json=vgId" json:"vg_id,omitempty"`
	// Scsi Index where this VG is attached
	DeviceIndex *int32 `protobuf:"varint,2,opt,name=device_index,json=deviceIndex" json:"device_index,omitempty"`
	// Disk label for the atached VG.
	DiskLabel *string `protobuf:"bytes,3,opt,name=disk_label,json=diskLabel" json:"disk_label,omitempty"`
	// Whether the VG is shared.
	IsShared *bool `protobuf:"varint,4,opt,name=is_shared,json=isShared" json:"is_shared,omitempty"`
	// Name of the volume group.
	Name                 *string  `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmInfo_VgAttachmentConfig) Reset()         { *m = VmInfo_VgAttachmentConfig{} }
func (m *VmInfo_VgAttachmentConfig) String() string { return proto.CompactTextString(m) }
func (*VmInfo_VgAttachmentConfig) ProtoMessage()    {}
func (*VmInfo_VgAttachmentConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{9, 0}
}

func (m *VmInfo_VgAttachmentConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmInfo_VgAttachmentConfig.Unmarshal(m, b)
}
func (m *VmInfo_VgAttachmentConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmInfo_VgAttachmentConfig.Marshal(b, m, deterministic)
}
func (m *VmInfo_VgAttachmentConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmInfo_VgAttachmentConfig.Merge(m, src)
}
func (m *VmInfo_VgAttachmentConfig) XXX_Size() int {
	return xxx_messageInfo_VmInfo_VgAttachmentConfig.Size(m)
}
func (m *VmInfo_VgAttachmentConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmInfo_VgAttachmentConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmInfo_VgAttachmentConfig proto.InternalMessageInfo

func (m *VmInfo_VgAttachmentConfig) GetVgId() string {
	if m != nil && m.VgId != nil {
		return *m.VgId
	}
	return ""
}

func (m *VmInfo_VgAttachmentConfig) GetDeviceIndex() int32 {
	if m != nil && m.DeviceIndex != nil {
		return *m.DeviceIndex
	}
	return 0
}

func (m *VmInfo_VgAttachmentConfig) GetDiskLabel() string {
	if m != nil && m.DiskLabel != nil {
		return *m.DiskLabel
	}
	return ""
}

func (m *VmInfo_VgAttachmentConfig) GetIsShared() bool {
	if m != nil && m.IsShared != nil {
		return *m.IsShared
	}
	return false
}

func (m *VmInfo_VgAttachmentConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type DatastoreInfo struct {
	// The id of the node that's mounting the NFS share (container).
	NodeId *int64 `protobuf:"varint,1,req,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The id of the container that's used to mount the NFS share.
	ContainerId *int64 `protobuf:"varint,2,req,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Mount point of the NFS share.
	MountPoint *string `protobuf:"bytes,3,opt,name=mount_point,json=mountPoint" json:"mount_point,omitempty"`
	// Name of the container
	ContainerName *string `protobuf:"bytes,4,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	// The name of the datastore.
	DatastoreName *string `protobuf:"bytes,5,opt,name=datastore_name,json=datastoreName" json:"datastore_name,omitempty"`
	// IP address of the node that's mounting the NFS share (container).
	HostIpAddress *string `protobuf:"bytes,6,opt,name=host_ip_address,json=hostIpAddress" json:"host_ip_address,omitempty"`
	// Total capacity of the NFS mount.
	Capacity *int64 `protobuf:"varint,7,opt,name=capacity" json:"capacity,omitempty"`
	// Free capacity of the NFS mount.
	FreeSpace *int64 `protobuf:"varint,8,opt,name=free_space,json=freeSpace" json:"free_space,omitempty"`
	// List of virtual machines that are running on this NFS mount.
	VmIds []string `protobuf:"bytes,9,rep,name=vm_ids,json=vmIds" json:"vm_ids,omitempty"`
	// List of the names of the virtual machines that are running
	// on this NFS mount.
	VmNames []string `protobuf:"bytes,10,rep,name=vm_names,json=vmNames" json:"vm_names,omitempty"`
	// Nutanix container as identified by the Hypervisor. In case of Vsphere,
	// this will be the generated UUID for the datastore.
	DatastoreUuid *string `protobuf:"bytes,11,opt,name=datastore_uuid,json=datastoreUuid" json:"datastore_uuid,omitempty"`
	// The service vm uuid of node that's mounting the NFS share (container).
	NodeUuid *string `protobuf:"bytes,12,opt,name=node_uuid,json=nodeUuid" json:"node_uuid,omitempty"`
	// The uuid of the container that's used to mount the NFS share.
	ContainerUuid        *string  `protobuf:"bytes,13,opt,name=container_uuid,json=containerUuid" json:"container_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatastoreInfo) Reset()         { *m = DatastoreInfo{} }
func (m *DatastoreInfo) String() string { return proto.CompactTextString(m) }
func (*DatastoreInfo) ProtoMessage()    {}
func (*DatastoreInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{10}
}

func (m *DatastoreInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DatastoreInfo.Unmarshal(m, b)
}
func (m *DatastoreInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DatastoreInfo.Marshal(b, m, deterministic)
}
func (m *DatastoreInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatastoreInfo.Merge(m, src)
}
func (m *DatastoreInfo) XXX_Size() int {
	return xxx_messageInfo_DatastoreInfo.Size(m)
}
func (m *DatastoreInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DatastoreInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DatastoreInfo proto.InternalMessageInfo

func (m *DatastoreInfo) GetNodeId() int64 {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return 0
}

func (m *DatastoreInfo) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *DatastoreInfo) GetMountPoint() string {
	if m != nil && m.MountPoint != nil {
		return *m.MountPoint
	}
	return ""
}

func (m *DatastoreInfo) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *DatastoreInfo) GetDatastoreName() string {
	if m != nil && m.DatastoreName != nil {
		return *m.DatastoreName
	}
	return ""
}

func (m *DatastoreInfo) GetHostIpAddress() string {
	if m != nil && m.HostIpAddress != nil {
		return *m.HostIpAddress
	}
	return ""
}

func (m *DatastoreInfo) GetCapacity() int64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return 0
}

func (m *DatastoreInfo) GetFreeSpace() int64 {
	if m != nil && m.FreeSpace != nil {
		return *m.FreeSpace
	}
	return 0
}

func (m *DatastoreInfo) GetVmIds() []string {
	if m != nil {
		return m.VmIds
	}
	return nil
}

func (m *DatastoreInfo) GetVmNames() []string {
	if m != nil {
		return m.VmNames
	}
	return nil
}

func (m *DatastoreInfo) GetDatastoreUuid() string {
	if m != nil && m.DatastoreUuid != nil {
		return *m.DatastoreUuid
	}
	return ""
}

func (m *DatastoreInfo) GetNodeUuid() string {
	if m != nil && m.NodeUuid != nil {
		return *m.NodeUuid
	}
	return ""
}

func (m *DatastoreInfo) GetContainerUuid() string {
	if m != nil && m.ContainerUuid != nil {
		return *m.ContainerUuid
	}
	return ""
}

// Host virtual network configuration information. Currently this message only
// contains L2 network indentifiers. This will be enhanced in future releases
// to include configuration parameters of the network.
type HostL2NetworkConfig struct {
	// Friendly name of the network config. This is used to render the network
	// config in the UI. If the network name is modified, Cerebro will update
	// the friendly name. If the network is deleted, then this will be set to
	// the name that existed as of the last sync.
	FriendlyName           *string                                     `protobuf:"bytes,1,opt,name=friendly_name,json=friendlyName" json:"friendly_name,omitempty"`
	VmwareNetworkConfig    *HostL2NetworkConfig_VMwareNetworkConfig    `protobuf:"bytes,2,opt,name=vmware_network_config,json=vmwareNetworkConfig" json:"vmware_network_config,omitempty"`
	HypervNetworkConfig    *HostL2NetworkConfig_HyperVNetworkConfig    `protobuf:"bytes,3,opt,name=hyperv_network_config,json=hypervNetworkConfig" json:"hyperv_network_config,omitempty"`
	AcropolisNetworkConfig *HostL2NetworkConfig_AcropolisNetworkConfig `protobuf:"bytes,4,opt,name=acropolis_network_config,json=acropolisNetworkConfig" json:"acropolis_network_config,omitempty"`
	AwsNetworkConfig       *HostL2NetworkConfig_AWSNetworkConfig       `protobuf:"bytes,5,opt,name=aws_network_config,json=awsNetworkConfig" json:"aws_network_config,omitempty"`
	AzureNetworkConfig     *HostL2NetworkConfig_AzureNetworkConfig     `protobuf:"bytes,6,opt,name=azure_network_config,json=azureNetworkConfig" json:"azure_network_config,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                                    `json:"-"`
	XXX_unrecognized       []byte                                      `json:"-"`
	XXX_sizecache          int32                                       `json:"-"`
}

func (m *HostL2NetworkConfig) Reset()         { *m = HostL2NetworkConfig{} }
func (m *HostL2NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*HostL2NetworkConfig) ProtoMessage()    {}
func (*HostL2NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{11}
}

func (m *HostL2NetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostL2NetworkConfig.Unmarshal(m, b)
}
func (m *HostL2NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostL2NetworkConfig.Marshal(b, m, deterministic)
}
func (m *HostL2NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostL2NetworkConfig.Merge(m, src)
}
func (m *HostL2NetworkConfig) XXX_Size() int {
	return xxx_messageInfo_HostL2NetworkConfig.Size(m)
}
func (m *HostL2NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostL2NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostL2NetworkConfig proto.InternalMessageInfo

func (m *HostL2NetworkConfig) GetFriendlyName() string {
	if m != nil && m.FriendlyName != nil {
		return *m.FriendlyName
	}
	return ""
}

func (m *HostL2NetworkConfig) GetVmwareNetworkConfig() *HostL2NetworkConfig_VMwareNetworkConfig {
	if m != nil {
		return m.VmwareNetworkConfig
	}
	return nil
}

func (m *HostL2NetworkConfig) GetHypervNetworkConfig() *HostL2NetworkConfig_HyperVNetworkConfig {
	if m != nil {
		return m.HypervNetworkConfig
	}
	return nil
}

func (m *HostL2NetworkConfig) GetAcropolisNetworkConfig() *HostL2NetworkConfig_AcropolisNetworkConfig {
	if m != nil {
		return m.AcropolisNetworkConfig
	}
	return nil
}

func (m *HostL2NetworkConfig) GetAwsNetworkConfig() *HostL2NetworkConfig_AWSNetworkConfig {
	if m != nil {
		return m.AwsNetworkConfig
	}
	return nil
}

func (m *HostL2NetworkConfig) GetAzureNetworkConfig() *HostL2NetworkConfig_AzureNetworkConfig {
	if m != nil {
		return m.AzureNetworkConfig
	}
	return nil
}

// L2 network configuration for Vmware.
type HostL2NetworkConfig_VMwareNetworkConfig struct {
	// Name of the portgroup.
	PortGroupName *string `protobuf:"bytes,1,opt,name=port_group_name,json=portGroupName" json:"port_group_name,omitempty"`
	// Whether it is distributed portgroup.
	IsDistributedPortGroup *bool    `protobuf:"varint,2,opt,name=is_distributed_port_group,json=isDistributedPortGroup" json:"is_distributed_port_group,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *HostL2NetworkConfig_VMwareNetworkConfig) Reset() {
	*m = HostL2NetworkConfig_VMwareNetworkConfig{}
}
func (m *HostL2NetworkConfig_VMwareNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*HostL2NetworkConfig_VMwareNetworkConfig) ProtoMessage()    {}
func (*HostL2NetworkConfig_VMwareNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{11, 0}
}

func (m *HostL2NetworkConfig_VMwareNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostL2NetworkConfig_VMwareNetworkConfig.Unmarshal(m, b)
}
func (m *HostL2NetworkConfig_VMwareNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostL2NetworkConfig_VMwareNetworkConfig.Marshal(b, m, deterministic)
}
func (m *HostL2NetworkConfig_VMwareNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostL2NetworkConfig_VMwareNetworkConfig.Merge(m, src)
}
func (m *HostL2NetworkConfig_VMwareNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_HostL2NetworkConfig_VMwareNetworkConfig.Size(m)
}
func (m *HostL2NetworkConfig_VMwareNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostL2NetworkConfig_VMwareNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostL2NetworkConfig_VMwareNetworkConfig proto.InternalMessageInfo

func (m *HostL2NetworkConfig_VMwareNetworkConfig) GetPortGroupName() string {
	if m != nil && m.PortGroupName != nil {
		return *m.PortGroupName
	}
	return ""
}

func (m *HostL2NetworkConfig_VMwareNetworkConfig) GetIsDistributedPortGroup() bool {
	if m != nil && m.IsDistributedPortGroup != nil {
		return *m.IsDistributedPortGroup
	}
	return false
}

// L2 network configuration for HyperV.
type HostL2NetworkConfig_HyperVNetworkConfig struct {
	// Name of the virtual switch.
	NetworkName          *string  `protobuf:"bytes,1,opt,name=network_name,json=networkName" json:"network_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostL2NetworkConfig_HyperVNetworkConfig) Reset() {
	*m = HostL2NetworkConfig_HyperVNetworkConfig{}
}
func (m *HostL2NetworkConfig_HyperVNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*HostL2NetworkConfig_HyperVNetworkConfig) ProtoMessage()    {}
func (*HostL2NetworkConfig_HyperVNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{11, 1}
}

func (m *HostL2NetworkConfig_HyperVNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostL2NetworkConfig_HyperVNetworkConfig.Unmarshal(m, b)
}
func (m *HostL2NetworkConfig_HyperVNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostL2NetworkConfig_HyperVNetworkConfig.Marshal(b, m, deterministic)
}
func (m *HostL2NetworkConfig_HyperVNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostL2NetworkConfig_HyperVNetworkConfig.Merge(m, src)
}
func (m *HostL2NetworkConfig_HyperVNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_HostL2NetworkConfig_HyperVNetworkConfig.Size(m)
}
func (m *HostL2NetworkConfig_HyperVNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostL2NetworkConfig_HyperVNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostL2NetworkConfig_HyperVNetworkConfig proto.InternalMessageInfo

func (m *HostL2NetworkConfig_HyperVNetworkConfig) GetNetworkName() string {
	if m != nil && m.NetworkName != nil {
		return *m.NetworkName
	}
	return ""
}

// L2 network configuration for Acropolis.
type HostL2NetworkConfig_AcropolisNetworkConfig struct {
	// UUID of the Acropolis network config.
	NetworkUuid          []byte   `protobuf:"bytes,1,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostL2NetworkConfig_AcropolisNetworkConfig) Reset() {
	*m = HostL2NetworkConfig_AcropolisNetworkConfig{}
}
func (m *HostL2NetworkConfig_AcropolisNetworkConfig) String() string {
	return proto.CompactTextString(m)
}
func (*HostL2NetworkConfig_AcropolisNetworkConfig) ProtoMessage() {}
func (*HostL2NetworkConfig_AcropolisNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{11, 2}
}

func (m *HostL2NetworkConfig_AcropolisNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostL2NetworkConfig_AcropolisNetworkConfig.Unmarshal(m, b)
}
func (m *HostL2NetworkConfig_AcropolisNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostL2NetworkConfig_AcropolisNetworkConfig.Marshal(b, m, deterministic)
}
func (m *HostL2NetworkConfig_AcropolisNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostL2NetworkConfig_AcropolisNetworkConfig.Merge(m, src)
}
func (m *HostL2NetworkConfig_AcropolisNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_HostL2NetworkConfig_AcropolisNetworkConfig.Size(m)
}
func (m *HostL2NetworkConfig_AcropolisNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostL2NetworkConfig_AcropolisNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostL2NetworkConfig_AcropolisNetworkConfig proto.InternalMessageInfo

func (m *HostL2NetworkConfig_AcropolisNetworkConfig) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

// L2 network configuration for AWS.
type HostL2NetworkConfig_AWSNetworkConfig struct {
	// Private address subnet id within VPC in the cloud.
	SubnetId             *string  `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId" json:"subnet_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostL2NetworkConfig_AWSNetworkConfig) Reset()         { *m = HostL2NetworkConfig_AWSNetworkConfig{} }
func (m *HostL2NetworkConfig_AWSNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*HostL2NetworkConfig_AWSNetworkConfig) ProtoMessage()    {}
func (*HostL2NetworkConfig_AWSNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{11, 3}
}

func (m *HostL2NetworkConfig_AWSNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostL2NetworkConfig_AWSNetworkConfig.Unmarshal(m, b)
}
func (m *HostL2NetworkConfig_AWSNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostL2NetworkConfig_AWSNetworkConfig.Marshal(b, m, deterministic)
}
func (m *HostL2NetworkConfig_AWSNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostL2NetworkConfig_AWSNetworkConfig.Merge(m, src)
}
func (m *HostL2NetworkConfig_AWSNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_HostL2NetworkConfig_AWSNetworkConfig.Size(m)
}
func (m *HostL2NetworkConfig_AWSNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostL2NetworkConfig_AWSNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostL2NetworkConfig_AWSNetworkConfig proto.InternalMessageInfo

func (m *HostL2NetworkConfig_AWSNetworkConfig) GetSubnetId() string {
	if m != nil && m.SubnetId != nil {
		return *m.SubnetId
	}
	return ""
}

// L2 network configuration for Azure.
type HostL2NetworkConfig_AzureNetworkConfig struct {
	// Private address subnet id within VPC in the cloud.
	SubnetId *string `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId" json:"subnet_id,omitempty"`
	// In Azure we can have same 'subnet_id' in different VPCs. This field
	// denotes the VPN in which this subnet belongs.
	VpnName              *string  `protobuf:"bytes,2,opt,name=vpn_name,json=vpnName" json:"vpn_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostL2NetworkConfig_AzureNetworkConfig) Reset() {
	*m = HostL2NetworkConfig_AzureNetworkConfig{}
}
func (m *HostL2NetworkConfig_AzureNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*HostL2NetworkConfig_AzureNetworkConfig) ProtoMessage()    {}
func (*HostL2NetworkConfig_AzureNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{11, 4}
}

func (m *HostL2NetworkConfig_AzureNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostL2NetworkConfig_AzureNetworkConfig.Unmarshal(m, b)
}
func (m *HostL2NetworkConfig_AzureNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostL2NetworkConfig_AzureNetworkConfig.Marshal(b, m, deterministic)
}
func (m *HostL2NetworkConfig_AzureNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostL2NetworkConfig_AzureNetworkConfig.Merge(m, src)
}
func (m *HostL2NetworkConfig_AzureNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_HostL2NetworkConfig_AzureNetworkConfig.Size(m)
}
func (m *HostL2NetworkConfig_AzureNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HostL2NetworkConfig_AzureNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HostL2NetworkConfig_AzureNetworkConfig proto.InternalMessageInfo

func (m *HostL2NetworkConfig_AzureNetworkConfig) GetSubnetId() string {
	if m != nil && m.SubnetId != nil {
		return *m.SubnetId
	}
	return ""
}

func (m *HostL2NetworkConfig_AzureNetworkConfig) GetVpnName() string {
	if m != nil && m.VpnName != nil {
		return *m.VpnName
	}
	return ""
}

// VM L2 network (vlan) configuration information. The VmL2NetworkConfig is
// different from the HostL2NetworkConfig, in that it only contains the
// identifiers of the networks and will not contain details of the
// configuration of the network.
type VmL2NetworkConfig struct {
	VmwareNetworkConfig    *VmL2NetworkConfig_VMwareVmNetworkConfig    `protobuf:"bytes,1,opt,name=vmware_network_config,json=vmwareNetworkConfig" json:"vmware_network_config,omitempty"`
	HypervNetworkConfig    *VmL2NetworkConfig_HyperVVmNetworkConfig    `protobuf:"bytes,2,opt,name=hyperv_network_config,json=hypervNetworkConfig" json:"hyperv_network_config,omitempty"`
	AcropolisNetworkConfig *VmL2NetworkConfig_AcropolisVmNetworkConfig `protobuf:"bytes,3,opt,name=acropolis_network_config,json=acropolisNetworkConfig" json:"acropolis_network_config,omitempty"`
	AwsNetworkConfig       *VmL2NetworkConfig_AWSVmNetworkConfig       `protobuf:"bytes,4,opt,name=aws_network_config,json=awsNetworkConfig" json:"aws_network_config,omitempty"`
	AzureNetworkConfig     *VmL2NetworkConfig_AzureVmNetworkConfig     `protobuf:"bytes,5,opt,name=azure_network_config,json=azureNetworkConfig" json:"azure_network_config,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                                    `json:"-"`
	XXX_unrecognized       []byte                                      `json:"-"`
	XXX_sizecache          int32                                       `json:"-"`
}

func (m *VmL2NetworkConfig) Reset()         { *m = VmL2NetworkConfig{} }
func (m *VmL2NetworkConfig) String() string { return proto.CompactTextString(m) }
func (*VmL2NetworkConfig) ProtoMessage()    {}
func (*VmL2NetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{12}
}

func (m *VmL2NetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmL2NetworkConfig.Unmarshal(m, b)
}
func (m *VmL2NetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmL2NetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmL2NetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmL2NetworkConfig.Merge(m, src)
}
func (m *VmL2NetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmL2NetworkConfig.Size(m)
}
func (m *VmL2NetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmL2NetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmL2NetworkConfig proto.InternalMessageInfo

func (m *VmL2NetworkConfig) GetVmwareNetworkConfig() *VmL2NetworkConfig_VMwareVmNetworkConfig {
	if m != nil {
		return m.VmwareNetworkConfig
	}
	return nil
}

func (m *VmL2NetworkConfig) GetHypervNetworkConfig() *VmL2NetworkConfig_HyperVVmNetworkConfig {
	if m != nil {
		return m.HypervNetworkConfig
	}
	return nil
}

func (m *VmL2NetworkConfig) GetAcropolisNetworkConfig() *VmL2NetworkConfig_AcropolisVmNetworkConfig {
	if m != nil {
		return m.AcropolisNetworkConfig
	}
	return nil
}

func (m *VmL2NetworkConfig) GetAwsNetworkConfig() *VmL2NetworkConfig_AWSVmNetworkConfig {
	if m != nil {
		return m.AwsNetworkConfig
	}
	return nil
}

func (m *VmL2NetworkConfig) GetAzureNetworkConfig() *VmL2NetworkConfig_AzureVmNetworkConfig {
	if m != nil {
		return m.AzureNetworkConfig
	}
	return nil
}

// L2 network configuration for Vmware.
type VmL2NetworkConfig_VMwareVmNetworkConfig struct {
	// Name of the portgroup.
	PortGroupName        *string  `protobuf:"bytes,1,opt,name=port_group_name,json=portGroupName" json:"port_group_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) Reset() {
	*m = VmL2NetworkConfig_VMwareVmNetworkConfig{}
}
func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*VmL2NetworkConfig_VMwareVmNetworkConfig) ProtoMessage()    {}
func (*VmL2NetworkConfig_VMwareVmNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{12, 0}
}

func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmL2NetworkConfig_VMwareVmNetworkConfig.Unmarshal(m, b)
}
func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmL2NetworkConfig_VMwareVmNetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmL2NetworkConfig_VMwareVmNetworkConfig.Merge(m, src)
}
func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmL2NetworkConfig_VMwareVmNetworkConfig.Size(m)
}
func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmL2NetworkConfig_VMwareVmNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmL2NetworkConfig_VMwareVmNetworkConfig proto.InternalMessageInfo

func (m *VmL2NetworkConfig_VMwareVmNetworkConfig) GetPortGroupName() string {
	if m != nil && m.PortGroupName != nil {
		return *m.PortGroupName
	}
	return ""
}

// L2 network configuration for HyperV.
type VmL2NetworkConfig_HyperVVmNetworkConfig struct {
	// Name of the virtual switch.
	NetworkName          *string  `protobuf:"bytes,1,opt,name=network_name,json=networkName" json:"network_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) Reset() {
	*m = VmL2NetworkConfig_HyperVVmNetworkConfig{}
}
func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*VmL2NetworkConfig_HyperVVmNetworkConfig) ProtoMessage()    {}
func (*VmL2NetworkConfig_HyperVVmNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{12, 1}
}

func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmL2NetworkConfig_HyperVVmNetworkConfig.Unmarshal(m, b)
}
func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmL2NetworkConfig_HyperVVmNetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmL2NetworkConfig_HyperVVmNetworkConfig.Merge(m, src)
}
func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmL2NetworkConfig_HyperVVmNetworkConfig.Size(m)
}
func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmL2NetworkConfig_HyperVVmNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmL2NetworkConfig_HyperVVmNetworkConfig proto.InternalMessageInfo

func (m *VmL2NetworkConfig_HyperVVmNetworkConfig) GetNetworkName() string {
	if m != nil && m.NetworkName != nil {
		return *m.NetworkName
	}
	return ""
}

// L2 network configuration for Acropolis.
type VmL2NetworkConfig_AcropolisVmNetworkConfig struct {
	// UUID of the Acropolis network config.
	NetworkUuid          []byte   `protobuf:"bytes,1,opt,name=network_uuid,json=networkUuid" json:"network_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) Reset() {
	*m = VmL2NetworkConfig_AcropolisVmNetworkConfig{}
}
func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) String() string {
	return proto.CompactTextString(m)
}
func (*VmL2NetworkConfig_AcropolisVmNetworkConfig) ProtoMessage() {}
func (*VmL2NetworkConfig_AcropolisVmNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{12, 2}
}

func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmL2NetworkConfig_AcropolisVmNetworkConfig.Unmarshal(m, b)
}
func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmL2NetworkConfig_AcropolisVmNetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmL2NetworkConfig_AcropolisVmNetworkConfig.Merge(m, src)
}
func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmL2NetworkConfig_AcropolisVmNetworkConfig.Size(m)
}
func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmL2NetworkConfig_AcropolisVmNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmL2NetworkConfig_AcropolisVmNetworkConfig proto.InternalMessageInfo

func (m *VmL2NetworkConfig_AcropolisVmNetworkConfig) GetNetworkUuid() []byte {
	if m != nil {
		return m.NetworkUuid
	}
	return nil
}

// L2 network configuration for AWS.
type VmL2NetworkConfig_AWSVmNetworkConfig struct {
	// Private address subnet id within VPC in the cloud.
	SubnetId             *string  `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId" json:"subnet_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmL2NetworkConfig_AWSVmNetworkConfig) Reset()         { *m = VmL2NetworkConfig_AWSVmNetworkConfig{} }
func (m *VmL2NetworkConfig_AWSVmNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*VmL2NetworkConfig_AWSVmNetworkConfig) ProtoMessage()    {}
func (*VmL2NetworkConfig_AWSVmNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{12, 3}
}

func (m *VmL2NetworkConfig_AWSVmNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmL2NetworkConfig_AWSVmNetworkConfig.Unmarshal(m, b)
}
func (m *VmL2NetworkConfig_AWSVmNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmL2NetworkConfig_AWSVmNetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmL2NetworkConfig_AWSVmNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmL2NetworkConfig_AWSVmNetworkConfig.Merge(m, src)
}
func (m *VmL2NetworkConfig_AWSVmNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmL2NetworkConfig_AWSVmNetworkConfig.Size(m)
}
func (m *VmL2NetworkConfig_AWSVmNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmL2NetworkConfig_AWSVmNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmL2NetworkConfig_AWSVmNetworkConfig proto.InternalMessageInfo

func (m *VmL2NetworkConfig_AWSVmNetworkConfig) GetSubnetId() string {
	if m != nil && m.SubnetId != nil {
		return *m.SubnetId
	}
	return ""
}

// L2 network configuration for Azure.
type VmL2NetworkConfig_AzureVmNetworkConfig struct {
	// Private address subnet id within VPC in the cloud.
	SubnetId *string `protobuf:"bytes,1,opt,name=subnet_id,json=subnetId" json:"subnet_id,omitempty"`
	// In Azure we can have same 'subnet_id' in different VPCs. This field
	// denotes the VPN in which this subnet belongs.
	VpnName              *string  `protobuf:"bytes,2,opt,name=vpn_name,json=vpnName" json:"vpn_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VmL2NetworkConfig_AzureVmNetworkConfig) Reset() {
	*m = VmL2NetworkConfig_AzureVmNetworkConfig{}
}
func (m *VmL2NetworkConfig_AzureVmNetworkConfig) String() string { return proto.CompactTextString(m) }
func (*VmL2NetworkConfig_AzureVmNetworkConfig) ProtoMessage()    {}
func (*VmL2NetworkConfig_AzureVmNetworkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{12, 4}
}

func (m *VmL2NetworkConfig_AzureVmNetworkConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VmL2NetworkConfig_AzureVmNetworkConfig.Unmarshal(m, b)
}
func (m *VmL2NetworkConfig_AzureVmNetworkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VmL2NetworkConfig_AzureVmNetworkConfig.Marshal(b, m, deterministic)
}
func (m *VmL2NetworkConfig_AzureVmNetworkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VmL2NetworkConfig_AzureVmNetworkConfig.Merge(m, src)
}
func (m *VmL2NetworkConfig_AzureVmNetworkConfig) XXX_Size() int {
	return xxx_messageInfo_VmL2NetworkConfig_AzureVmNetworkConfig.Size(m)
}
func (m *VmL2NetworkConfig_AzureVmNetworkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VmL2NetworkConfig_AzureVmNetworkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VmL2NetworkConfig_AzureVmNetworkConfig proto.InternalMessageInfo

func (m *VmL2NetworkConfig_AzureVmNetworkConfig) GetSubnetId() string {
	if m != nil && m.SubnetId != nil {
		return *m.SubnetId
	}
	return ""
}

func (m *VmL2NetworkConfig_AzureVmNetworkConfig) GetVpnName() string {
	if m != nil && m.VpnName != nil {
		return *m.VpnName
	}
	return ""
}

// L2 network (vlan) mapping between the source cluster and the destination
// cluster for a remote site.
type L2NetworkMapping struct {
	// Host L2NetworkConfig of the source cluster.
	SrcNetworkConfig *HostL2NetworkConfig `protobuf:"bytes,1,opt,name=src_network_config,json=srcNetworkConfig" json:"src_network_config,omitempty"`
	// Host L2NetworkConfig of the destination cluster.
	DstNetworkConfig     *HostL2NetworkConfig `protobuf:"bytes,2,opt,name=dst_network_config,json=dstNetworkConfig" json:"dst_network_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *L2NetworkMapping) Reset()         { *m = L2NetworkMapping{} }
func (m *L2NetworkMapping) String() string { return proto.CompactTextString(m) }
func (*L2NetworkMapping) ProtoMessage()    {}
func (*L2NetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{13}
}

func (m *L2NetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_L2NetworkMapping.Unmarshal(m, b)
}
func (m *L2NetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_L2NetworkMapping.Marshal(b, m, deterministic)
}
func (m *L2NetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2NetworkMapping.Merge(m, src)
}
func (m *L2NetworkMapping) XXX_Size() int {
	return xxx_messageInfo_L2NetworkMapping.Size(m)
}
func (m *L2NetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_L2NetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_L2NetworkMapping proto.InternalMessageInfo

func (m *L2NetworkMapping) GetSrcNetworkConfig() *HostL2NetworkConfig {
	if m != nil {
		return m.SrcNetworkConfig
	}
	return nil
}

func (m *L2NetworkMapping) GetDstNetworkConfig() *HostL2NetworkConfig {
	if m != nil {
		return m.DstNetworkConfig
	}
	return nil
}

// IP address pool/range mapping between the source and the destination
// cluster.
type L3NetworkMapping struct {
	AddressMapping       []*L3NetworkMapping_AddressMapping `protobuf:"bytes,1,rep,name=address_mapping,json=addressMapping" json:"address_mapping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *L3NetworkMapping) Reset()         { *m = L3NetworkMapping{} }
func (m *L3NetworkMapping) String() string { return proto.CompactTextString(m) }
func (*L3NetworkMapping) ProtoMessage()    {}
func (*L3NetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{14}
}

func (m *L3NetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_L3NetworkMapping.Unmarshal(m, b)
}
func (m *L3NetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_L3NetworkMapping.Marshal(b, m, deterministic)
}
func (m *L3NetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3NetworkMapping.Merge(m, src)
}
func (m *L3NetworkMapping) XXX_Size() int {
	return xxx_messageInfo_L3NetworkMapping.Size(m)
}
func (m *L3NetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_L3NetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_L3NetworkMapping proto.InternalMessageInfo

func (m *L3NetworkMapping) GetAddressMapping() []*L3NetworkMapping_AddressMapping {
	if m != nil {
		return m.AddressMapping
	}
	return nil
}

// IP address pool mapping of the source and the destination cluster. Pool is
// the range of IPs between 'src_start_ip_address' and 'src_end_ip_address'.
// Both start address and end address are included in the address range for
// the pool.
type L3NetworkMapping_AddressMapping struct {
	// Source cluster address pool.
	SrcStartIpAddress []byte `protobuf:"bytes,1,opt,name=src_start_ip_address,json=srcStartIpAddress" json:"src_start_ip_address,omitempty"`
	SrcEndIpAddress   []byte `protobuf:"bytes,2,opt,name=src_end_ip_address,json=srcEndIpAddress" json:"src_end_ip_address,omitempty"`
	// Start IP address in the destination cluster address pool. Since the
	// size of the source and the destination address pools is same, storing
	// only the start address of the destination address pool. End address can
	// be derived from this.
	//
	// If this field is omitted, any IP address that matches the source range
	// will be expunged.
	DstStartIpAddress    []byte   `protobuf:"bytes,3,opt,name=dst_start_ip_address,json=dstStartIpAddress" json:"dst_start_ip_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *L3NetworkMapping_AddressMapping) Reset()         { *m = L3NetworkMapping_AddressMapping{} }
func (m *L3NetworkMapping_AddressMapping) String() string { return proto.CompactTextString(m) }
func (*L3NetworkMapping_AddressMapping) ProtoMessage()    {}
func (*L3NetworkMapping_AddressMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{14, 0}
}

func (m *L3NetworkMapping_AddressMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_L3NetworkMapping_AddressMapping.Unmarshal(m, b)
}
func (m *L3NetworkMapping_AddressMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_L3NetworkMapping_AddressMapping.Marshal(b, m, deterministic)
}
func (m *L3NetworkMapping_AddressMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L3NetworkMapping_AddressMapping.Merge(m, src)
}
func (m *L3NetworkMapping_AddressMapping) XXX_Size() int {
	return xxx_messageInfo_L3NetworkMapping_AddressMapping.Size(m)
}
func (m *L3NetworkMapping_AddressMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_L3NetworkMapping_AddressMapping.DiscardUnknown(m)
}

var xxx_messageInfo_L3NetworkMapping_AddressMapping proto.InternalMessageInfo

func (m *L3NetworkMapping_AddressMapping) GetSrcStartIpAddress() []byte {
	if m != nil {
		return m.SrcStartIpAddress
	}
	return nil
}

func (m *L3NetworkMapping_AddressMapping) GetSrcEndIpAddress() []byte {
	if m != nil {
		return m.SrcEndIpAddress
	}
	return nil
}

func (m *L3NetworkMapping_AddressMapping) GetDstStartIpAddress() []byte {
	if m != nil {
		return m.DstStartIpAddress
	}
	return nil
}

// A network mapping consists of L2 network mapping and L3 network mapping
// between a source and a destination cluster. This mapping is for a single
// source network.
type NetworkMapping struct {
	// L2 network mapping.
	L2Mapping *L2NetworkMapping `protobuf:"bytes,1,opt,name=l2_mapping,json=l2Mapping" json:"l2_mapping,omitempty"`
	// L3 network mapping.
	L3Mapping            *L3NetworkMapping `protobuf:"bytes,2,opt,name=l3_mapping,json=l3Mapping" json:"l3_mapping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *NetworkMapping) Reset()         { *m = NetworkMapping{} }
func (m *NetworkMapping) String() string { return proto.CompactTextString(m) }
func (*NetworkMapping) ProtoMessage()    {}
func (*NetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{15}
}

func (m *NetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkMapping.Unmarshal(m, b)
}
func (m *NetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkMapping.Marshal(b, m, deterministic)
}
func (m *NetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMapping.Merge(m, src)
}
func (m *NetworkMapping) XXX_Size() int {
	return xxx_messageInfo_NetworkMapping.Size(m)
}
func (m *NetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMapping proto.InternalMessageInfo

func (m *NetworkMapping) GetL2Mapping() *L2NetworkMapping {
	if m != nil {
		return m.L2Mapping
	}
	return nil
}

func (m *NetworkMapping) GetL3Mapping() *L3NetworkMapping {
	if m != nil {
		return m.L3Mapping
	}
	return nil
}

// Representation of all the network mappings corresponding to a remote site.
// Each remote site will have exactly one HostNetworkMapping.
type HostNetworkMapping struct {
	// Unique identifer for this network mapping.
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Set to contain information of the network mappings.
	NetworkMappings []*NetworkMapping `protobuf:"bytes,2,rep,name=network_mappings,json=networkMappings" json:"network_mappings,omitempty"`
	// Timestamp when this network mapping was last modified. This is used
	// during syncing of network mappings with remote.
	LastModifiedTimestamp *int64 `protobuf:"varint,3,opt,name=last_modified_timestamp,json=lastModifiedTimestamp" json:"last_modified_timestamp,omitempty"`
	// Wall time when this network mapping will be marked for removal. During
	// garbage collection of network mapping if no remote site is referring to
	// this network mapping we will set this timestamp and after some time we
	// will delete this network mapping.
	DeleteTimestamp      *int64   `protobuf:"varint,4,opt,name=delete_timestamp,json=deleteTimestamp" json:"delete_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HostNetworkMapping) Reset()         { *m = HostNetworkMapping{} }
func (m *HostNetworkMapping) String() string { return proto.CompactTextString(m) }
func (*HostNetworkMapping) ProtoMessage()    {}
func (*HostNetworkMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{16}
}

func (m *HostNetworkMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HostNetworkMapping.Unmarshal(m, b)
}
func (m *HostNetworkMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HostNetworkMapping.Marshal(b, m, deterministic)
}
func (m *HostNetworkMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostNetworkMapping.Merge(m, src)
}
func (m *HostNetworkMapping) XXX_Size() int {
	return xxx_messageInfo_HostNetworkMapping.Size(m)
}
func (m *HostNetworkMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_HostNetworkMapping.DiscardUnknown(m)
}

var xxx_messageInfo_HostNetworkMapping proto.InternalMessageInfo

func (m *HostNetworkMapping) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *HostNetworkMapping) GetNetworkMappings() []*NetworkMapping {
	if m != nil {
		return m.NetworkMappings
	}
	return nil
}

func (m *HostNetworkMapping) GetLastModifiedTimestamp() int64 {
	if m != nil && m.LastModifiedTimestamp != nil {
		return *m.LastModifiedTimestamp
	}
	return 0
}

func (m *HostNetworkMapping) GetDeleteTimestamp() int64 {
	if m != nil && m.DeleteTimestamp != nil {
		return *m.DeleteTimestamp
	}
	return 0
}

// List of all the network mappings present on the cluster. This object is
// stored in a Zookeeper node.
type NetworkMappingRepository struct {
	// List of network mappings to be stored in zookeeper.
	NetworkMappingVec []*HostNetworkMapping `protobuf:"bytes,1,rep,name=network_mapping_vec,json=networkMappingVec" json:"network_mapping_vec,omitempty"`
	// The logical timestamp that works like versioning. This is used when
	// updating the Zookeeper node to serialize the updates.
	LogicalTimestamp     *int64   `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkMappingRepository) Reset()         { *m = NetworkMappingRepository{} }
func (m *NetworkMappingRepository) String() string { return proto.CompactTextString(m) }
func (*NetworkMappingRepository) ProtoMessage()    {}
func (*NetworkMappingRepository) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{17}
}

func (m *NetworkMappingRepository) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkMappingRepository.Unmarshal(m, b)
}
func (m *NetworkMappingRepository) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkMappingRepository.Marshal(b, m, deterministic)
}
func (m *NetworkMappingRepository) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkMappingRepository.Merge(m, src)
}
func (m *NetworkMappingRepository) XXX_Size() int {
	return xxx_messageInfo_NetworkMappingRepository.Size(m)
}
func (m *NetworkMappingRepository) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkMappingRepository.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkMappingRepository proto.InternalMessageInfo

func (m *NetworkMappingRepository) GetNetworkMappingVec() []*HostNetworkMapping {
	if m != nil {
		return m.NetworkMappingVec
	}
	return nil
}

func (m *NetworkMappingRepository) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

type Credential struct {
	// Logon name of the account.
	LogonName *string `protobuf:"bytes,1,opt,name=logon_name,json=logonName" json:"logon_name,omitempty"`
	// Password of the account.
	Password             *string  `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Credential) Reset()         { *m = Credential{} }
func (m *Credential) String() string { return proto.CompactTextString(m) }
func (*Credential) ProtoMessage()    {}
func (*Credential) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{18}
}

func (m *Credential) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Credential.Unmarshal(m, b)
}
func (m *Credential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Credential.Marshal(b, m, deterministic)
}
func (m *Credential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Credential.Merge(m, src)
}
func (m *Credential) XXX_Size() int {
	return xxx_messageInfo_Credential.Size(m)
}
func (m *Credential) XXX_DiscardUnknown() {
	xxx_messageInfo_Credential.DiscardUnknown(m)
}

var xxx_messageInfo_Credential proto.InternalMessageInfo

func (m *Credential) GetLogonName() string {
	if m != nil && m.LogonName != nil {
		return *m.LogonName
	}
	return ""
}

func (m *Credential) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

type GetNodeInfoArg struct {
	// List of the IDs of the nodes. When left empty, only the configuration of
	// the local node is returned. When populated, the order of elements in the
	// list determines the order of the elements in the returned result list.
	NodeIds              []int64  `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNodeInfoArg) Reset()         { *m = GetNodeInfoArg{} }
func (m *GetNodeInfoArg) String() string { return proto.CompactTextString(m) }
func (*GetNodeInfoArg) ProtoMessage()    {}
func (*GetNodeInfoArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{19}
}

func (m *GetNodeInfoArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNodeInfoArg.Unmarshal(m, b)
}
func (m *GetNodeInfoArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNodeInfoArg.Marshal(b, m, deterministic)
}
func (m *GetNodeInfoArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNodeInfoArg.Merge(m, src)
}
func (m *GetNodeInfoArg) XXX_Size() int {
	return xxx_messageInfo_GetNodeInfoArg.Size(m)
}
func (m *GetNodeInfoArg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNodeInfoArg.DiscardUnknown(m)
}

var xxx_messageInfo_GetNodeInfoArg proto.InternalMessageInfo

func (m *GetNodeInfoArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

type GetNodeInfoRet struct {
	NodeInfoResults      []*GetNodeInfoRet_NodeInfoResult `protobuf:"bytes,1,rep,name=node_info_results,json=nodeInfoResults" json:"node_info_results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *GetNodeInfoRet) Reset()         { *m = GetNodeInfoRet{} }
func (m *GetNodeInfoRet) String() string { return proto.CompactTextString(m) }
func (*GetNodeInfoRet) ProtoMessage()    {}
func (*GetNodeInfoRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{20}
}

func (m *GetNodeInfoRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNodeInfoRet.Unmarshal(m, b)
}
func (m *GetNodeInfoRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNodeInfoRet.Marshal(b, m, deterministic)
}
func (m *GetNodeInfoRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNodeInfoRet.Merge(m, src)
}
func (m *GetNodeInfoRet) XXX_Size() int {
	return xxx_messageInfo_GetNodeInfoRet.Size(m)
}
func (m *GetNodeInfoRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNodeInfoRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetNodeInfoRet proto.InternalMessageInfo

func (m *GetNodeInfoRet) GetNodeInfoResults() []*GetNodeInfoRet_NodeInfoResult {
	if m != nil {
		return m.NodeInfoResults
	}
	return nil
}

type GetNodeInfoRet_NodeInfoResult struct {
	// A non-default value indicates either the absence of a node with a given
	// ID or some error in processing the node for the requested information.
	Error *GetNodeInfoRet_Error `protobuf:"varint,1,opt,name=error,enum=nutanix.hyperint.GetNodeInfoRet_Error,def=0" json:"error,omitempty"`
	// Information about the looked up node. If not set, then no node with
	// the matching ID value is found.
	Node *arithmos.Node `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	// List of network adapters on the host along with their configuration.
	NetworkAdapters      []*NetworkAdapter `protobuf:"bytes,3,rep,name=network_adapters,json=networkAdapters" json:"network_adapters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetNodeInfoRet_NodeInfoResult) Reset()         { *m = GetNodeInfoRet_NodeInfoResult{} }
func (m *GetNodeInfoRet_NodeInfoResult) String() string { return proto.CompactTextString(m) }
func (*GetNodeInfoRet_NodeInfoResult) ProtoMessage()    {}
func (*GetNodeInfoRet_NodeInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{20, 0}
}

func (m *GetNodeInfoRet_NodeInfoResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNodeInfoRet_NodeInfoResult.Unmarshal(m, b)
}
func (m *GetNodeInfoRet_NodeInfoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNodeInfoRet_NodeInfoResult.Marshal(b, m, deterministic)
}
func (m *GetNodeInfoRet_NodeInfoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNodeInfoRet_NodeInfoResult.Merge(m, src)
}
func (m *GetNodeInfoRet_NodeInfoResult) XXX_Size() int {
	return xxx_messageInfo_GetNodeInfoRet_NodeInfoResult.Size(m)
}
func (m *GetNodeInfoRet_NodeInfoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNodeInfoRet_NodeInfoResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetNodeInfoRet_NodeInfoResult proto.InternalMessageInfo

const Default_GetNodeInfoRet_NodeInfoResult_Error GetNodeInfoRet_Error = GetNodeInfoRet_kNoError

func (m *GetNodeInfoRet_NodeInfoResult) GetError() GetNodeInfoRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_GetNodeInfoRet_NodeInfoResult_Error
}

func (m *GetNodeInfoRet_NodeInfoResult) GetNode() *arithmos.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GetNodeInfoRet_NodeInfoResult) GetNetworkAdapters() []*NetworkAdapter {
	if m != nil {
		return m.NetworkAdapters
	}
	return nil
}

type GetVmInfoArg struct {
	// The IDs of the node to get the virtual machines running on them.
	NodeIds []int64 `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	// List of the IDs of the virtual machines. The order of virtual machine
	// IDs in this list determines the order of the virtual machines in the
	// returned list. Refer to parameter 'cluster_wide' for a definition of
	// the scope of the lookup.
	VmIds []string `protobuf:"bytes,2,rep,name=vm_ids,json=vmIds" json:"vm_ids,omitempty"`
	// List of the names of the containers. When specified, the result will
	// include only those virtual machines that use any of the specified
	// containers.
	ContainerNames []string `protobuf:"bytes,3,rep,name=container_names,json=containerNames" json:"container_names,omitempty"`
	// List of names of VMs. When specified, the result will include only those
	// virtual machines that have any of the vm names. We only support exact
	// match with the names in vm_names.
	VmNames []string `protobuf:"bytes,4,rep,name=vm_names,json=vmNames" json:"vm_names,omitempty"`
	// Set of path names one of each VM to be searched. hyperint will pick
	// the correct configuration file and query the hypervisor.
	VmPaths []*GetVmInfoArg_VmPaths `protobuf:"bytes,5,rep,name=vm_paths,json=vmPaths" json:"vm_paths,omitempty"`
	// This parameter is meant for use in conjunction with 'vm_ids' or
	// 'container_names' and  defines the scope of the search for VMs that
	// match the criteria specified.
	// If 'cluster_wide' is not set to true, then, only the
	// locally-running VMs among the specified 'vm_ids' would be returned.
	// Otherwise, virtual machines with matching vm_ids from across the cluster
	// would be returned.
	ClusterWide *bool `protobuf:"varint,11,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// The returned VmInfo will include the configuration of a VM only
	// when 'include_vm_config' is true.
	IncludeVmConfig *bool `protobuf:"varint,12,opt,name=include_vm_config,json=includeVmConfig,def=0" json:"include_vm_config,omitempty"`
	// The returned VmInfo will include the file layout of a VM only
	// when 'include_vm_file_config' is true.
	IncludeVmFileConfig *bool `protobuf:"varint,13,opt,name=include_vm_file_config,json=includeVmFileConfig,def=0" json:"include_vm_file_config,omitempty"`
	// When set to true, only VMs that can participate in Nutanix Converged
	// Backup and Recovery (CBR) will be included in the returned listing.
	OnlyCbrCapableVms *bool `protobuf:"varint,14,opt,name=only_cbr_capable_vms,json=onlyCbrCapableVms,def=0" json:"only_cbr_capable_vms,omitempty"`
	// The returned VmInfo will include the network configuration information
	// of a VM only when 'include_vm_network_config' is true.
	IncludeVmNetworkConfig *bool `protobuf:"varint,15,opt,name=include_vm_network_config,json=includeVmNetworkConfig,def=0" json:"include_vm_network_config,omitempty"`
	// Set of IP addresses for locating the the VM. VMs with IP addresses
	// in any of the network interfaces will be returned.
	IpAddresses []string `protobuf:"bytes,16,rep,name=ip_addresses,json=ipAddresses" json:"ip_addresses,omitempty"`
	// If true, the returned VmInfo will include VM opaque data, if there is any.
	IncludeVmOpaqueData *bool `protobuf:"varint,17,opt,name=include_vm_opaque_data,json=includeVmOpaqueData" json:"include_vm_opaque_data,omitempty"`
	// If true, treat vm_names as patterns instead of exact matches.
	// This is currently not supported.
	PatternMatchVmNames *bool `protobuf:"varint,18,opt,name=pattern_match_vm_names,json=patternMatchVmNames,def=0" json:"pattern_match_vm_names,omitempty"`
	// The returned VmInfo will include the virtual disks and CDs information
	// of a VM only when 'include_vm_storage_config' and 'include_vm_config'
	// are true.
	IncludeVmStorageConfig *bool `protobuf:"varint,19,opt,name=include_vm_storage_config,json=includeVmStorageConfig,def=1" json:"include_vm_storage_config,omitempty"`
	// The returned VmInfo will include info about VGs attached to this
	// VM only if this flag is true.
	IncludeAttachedVgConfig *bool `protobuf:"varint,20,opt,name=include_attached_vg_config,json=includeAttachedVgConfig,def=0" json:"include_attached_vg_config,omitempty"`
	// The returned VmInfo will include stretch params id of the VM
	// only if this flag is set to true.
	IncludeStretchParamsId *bool    `protobuf:"varint,21,opt,name=include_stretch_params_id,json=includeStretchParamsId,def=0" json:"include_stretch_params_id,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *GetVmInfoArg) Reset()         { *m = GetVmInfoArg{} }
func (m *GetVmInfoArg) String() string { return proto.CompactTextString(m) }
func (*GetVmInfoArg) ProtoMessage()    {}
func (*GetVmInfoArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{21}
}

func (m *GetVmInfoArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVmInfoArg.Unmarshal(m, b)
}
func (m *GetVmInfoArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVmInfoArg.Marshal(b, m, deterministic)
}
func (m *GetVmInfoArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVmInfoArg.Merge(m, src)
}
func (m *GetVmInfoArg) XXX_Size() int {
	return xxx_messageInfo_GetVmInfoArg.Size(m)
}
func (m *GetVmInfoArg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVmInfoArg.DiscardUnknown(m)
}

var xxx_messageInfo_GetVmInfoArg proto.InternalMessageInfo

const Default_GetVmInfoArg_ClusterWide bool = true
const Default_GetVmInfoArg_IncludeVmConfig bool = false
const Default_GetVmInfoArg_IncludeVmFileConfig bool = false
const Default_GetVmInfoArg_OnlyCbrCapableVms bool = false
const Default_GetVmInfoArg_IncludeVmNetworkConfig bool = false
const Default_GetVmInfoArg_PatternMatchVmNames bool = false
const Default_GetVmInfoArg_IncludeVmStorageConfig bool = true
const Default_GetVmInfoArg_IncludeAttachedVgConfig bool = false
const Default_GetVmInfoArg_IncludeStretchParamsId bool = false

func (m *GetVmInfoArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

func (m *GetVmInfoArg) GetVmIds() []string {
	if m != nil {
		return m.VmIds
	}
	return nil
}

func (m *GetVmInfoArg) GetContainerNames() []string {
	if m != nil {
		return m.ContainerNames
	}
	return nil
}

func (m *GetVmInfoArg) GetVmNames() []string {
	if m != nil {
		return m.VmNames
	}
	return nil
}

func (m *GetVmInfoArg) GetVmPaths() []*GetVmInfoArg_VmPaths {
	if m != nil {
		return m.VmPaths
	}
	return nil
}

func (m *GetVmInfoArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_GetVmInfoArg_ClusterWide
}

func (m *GetVmInfoArg) GetIncludeVmConfig() bool {
	if m != nil && m.IncludeVmConfig != nil {
		return *m.IncludeVmConfig
	}
	return Default_GetVmInfoArg_IncludeVmConfig
}

func (m *GetVmInfoArg) GetIncludeVmFileConfig() bool {
	if m != nil && m.IncludeVmFileConfig != nil {
		return *m.IncludeVmFileConfig
	}
	return Default_GetVmInfoArg_IncludeVmFileConfig
}

func (m *GetVmInfoArg) GetOnlyCbrCapableVms() bool {
	if m != nil && m.OnlyCbrCapableVms != nil {
		return *m.OnlyCbrCapableVms
	}
	return Default_GetVmInfoArg_OnlyCbrCapableVms
}

func (m *GetVmInfoArg) GetIncludeVmNetworkConfig() bool {
	if m != nil && m.IncludeVmNetworkConfig != nil {
		return *m.IncludeVmNetworkConfig
	}
	return Default_GetVmInfoArg_IncludeVmNetworkConfig
}

func (m *GetVmInfoArg) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (m *GetVmInfoArg) GetIncludeVmOpaqueData() bool {
	if m != nil && m.IncludeVmOpaqueData != nil {
		return *m.IncludeVmOpaqueData
	}
	return false
}

func (m *GetVmInfoArg) GetPatternMatchVmNames() bool {
	if m != nil && m.PatternMatchVmNames != nil {
		return *m.PatternMatchVmNames
	}
	return Default_GetVmInfoArg_PatternMatchVmNames
}

func (m *GetVmInfoArg) GetIncludeVmStorageConfig() bool {
	if m != nil && m.IncludeVmStorageConfig != nil {
		return *m.IncludeVmStorageConfig
	}
	return Default_GetVmInfoArg_IncludeVmStorageConfig
}

func (m *GetVmInfoArg) GetIncludeAttachedVgConfig() bool {
	if m != nil && m.IncludeAttachedVgConfig != nil {
		return *m.IncludeAttachedVgConfig
	}
	return Default_GetVmInfoArg_IncludeAttachedVgConfig
}

func (m *GetVmInfoArg) GetIncludeStretchParamsId() bool {
	if m != nil && m.IncludeStretchParamsId != nil {
		return *m.IncludeStretchParamsId
	}
	return Default_GetVmInfoArg_IncludeStretchParamsId
}

type GetVmInfoArg_VmPaths struct {
	// List of nfs file paths pertaining to the VM.
	NfsPaths             []string `protobuf:"bytes,1,rep,name=nfs_paths,json=nfsPaths" json:"nfs_paths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVmInfoArg_VmPaths) Reset()         { *m = GetVmInfoArg_VmPaths{} }
func (m *GetVmInfoArg_VmPaths) String() string { return proto.CompactTextString(m) }
func (*GetVmInfoArg_VmPaths) ProtoMessage()    {}
func (*GetVmInfoArg_VmPaths) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{21, 0}
}

func (m *GetVmInfoArg_VmPaths) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVmInfoArg_VmPaths.Unmarshal(m, b)
}
func (m *GetVmInfoArg_VmPaths) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVmInfoArg_VmPaths.Marshal(b, m, deterministic)
}
func (m *GetVmInfoArg_VmPaths) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVmInfoArg_VmPaths.Merge(m, src)
}
func (m *GetVmInfoArg_VmPaths) XXX_Size() int {
	return xxx_messageInfo_GetVmInfoArg_VmPaths.Size(m)
}
func (m *GetVmInfoArg_VmPaths) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVmInfoArg_VmPaths.DiscardUnknown(m)
}

var xxx_messageInfo_GetVmInfoArg_VmPaths proto.InternalMessageInfo

func (m *GetVmInfoArg_VmPaths) GetNfsPaths() []string {
	if m != nil {
		return m.NfsPaths
	}
	return nil
}

type GetVmInfoRet struct {
	VmInfoResults        []*GetVmInfoRet_VmInfoResult `protobuf:"bytes,1,rep,name=vm_info_results,json=vmInfoResults" json:"vm_info_results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *GetVmInfoRet) Reset()         { *m = GetVmInfoRet{} }
func (m *GetVmInfoRet) String() string { return proto.CompactTextString(m) }
func (*GetVmInfoRet) ProtoMessage()    {}
func (*GetVmInfoRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{22}
}

func (m *GetVmInfoRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVmInfoRet.Unmarshal(m, b)
}
func (m *GetVmInfoRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVmInfoRet.Marshal(b, m, deterministic)
}
func (m *GetVmInfoRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVmInfoRet.Merge(m, src)
}
func (m *GetVmInfoRet) XXX_Size() int {
	return xxx_messageInfo_GetVmInfoRet.Size(m)
}
func (m *GetVmInfoRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVmInfoRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetVmInfoRet proto.InternalMessageInfo

func (m *GetVmInfoRet) GetVmInfoResults() []*GetVmInfoRet_VmInfoResult {
	if m != nil {
		return m.VmInfoResults
	}
	return nil
}

type GetVmInfoRet_VmInfoResult struct {
	// Information about the looked up virtual machine.
	VmInfo *VmInfo `protobuf:"bytes,1,opt,name=vm_info,json=vmInfo" json:"vm_info,omitempty"`
	// A non-default value indicates either the absence of a virtual machine
	// with a given ID or some error in processing the virtual machine for the
	// requested information.
	Error                *GetVmInfoRet_Error `protobuf:"varint,2,opt,name=error,enum=nutanix.hyperint.GetVmInfoRet_Error,def=0" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetVmInfoRet_VmInfoResult) Reset()         { *m = GetVmInfoRet_VmInfoResult{} }
func (m *GetVmInfoRet_VmInfoResult) String() string { return proto.CompactTextString(m) }
func (*GetVmInfoRet_VmInfoResult) ProtoMessage()    {}
func (*GetVmInfoRet_VmInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{22, 0}
}

func (m *GetVmInfoRet_VmInfoResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVmInfoRet_VmInfoResult.Unmarshal(m, b)
}
func (m *GetVmInfoRet_VmInfoResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVmInfoRet_VmInfoResult.Marshal(b, m, deterministic)
}
func (m *GetVmInfoRet_VmInfoResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVmInfoRet_VmInfoResult.Merge(m, src)
}
func (m *GetVmInfoRet_VmInfoResult) XXX_Size() int {
	return xxx_messageInfo_GetVmInfoRet_VmInfoResult.Size(m)
}
func (m *GetVmInfoRet_VmInfoResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVmInfoRet_VmInfoResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetVmInfoRet_VmInfoResult proto.InternalMessageInfo

const Default_GetVmInfoRet_VmInfoResult_Error GetVmInfoRet_Error = GetVmInfoRet_kNoError

func (m *GetVmInfoRet_VmInfoResult) GetVmInfo() *VmInfo {
	if m != nil {
		return m.VmInfo
	}
	return nil
}

func (m *GetVmInfoRet_VmInfoResult) GetError() GetVmInfoRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_GetVmInfoRet_VmInfoResult_Error
}

type SnapshotVmArg struct {
	// This parameter defines the scope of the request. If 'cluster_wide' is not
	// set to true, then, only the locally-running VMs among the specified VM ids
	// would be acted upon. Otherwise, virtual machines with matching VM ids from
	// across the cluster would also be acted upon.
	ClusterWide *bool `protobuf:"varint,1,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// List of remove snapshot operations. This operation is performed first,
	// before creating new snapshots.
	RemoveSnapshots []*SnapshotVmArg_RemoveSnapshot `protobuf:"bytes,3,rep,name=remove_snapshots,json=removeSnapshots" json:"remove_snapshots,omitempty"`
	// List of snapshot create operations. Create snapshot is performed after
	// all snapshot removals are completed. In the event of a failure, this
	// enables Cerebro to ensure only one snapshot is created per replication.
	CreateSnapshots []*SnapshotVmArg_CreateSnapshot `protobuf:"bytes,2,rep,name=create_snapshots,json=createSnapshots" json:"create_snapshots,omitempty"`
	// List of query snapshot operations. Query snapshot should not be performed
	// in parallel with creation and removal operations.
	QuerySnapshots       []*SnapshotVmArg_QuerySnapshot `protobuf:"bytes,4,rep,name=query_snapshots,json=querySnapshots" json:"query_snapshots,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *SnapshotVmArg) Reset()         { *m = SnapshotVmArg{} }
func (m *SnapshotVmArg) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmArg) ProtoMessage()    {}
func (*SnapshotVmArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{23}
}

func (m *SnapshotVmArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmArg.Unmarshal(m, b)
}
func (m *SnapshotVmArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmArg.Marshal(b, m, deterministic)
}
func (m *SnapshotVmArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmArg.Merge(m, src)
}
func (m *SnapshotVmArg) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmArg.Size(m)
}
func (m *SnapshotVmArg) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmArg.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmArg proto.InternalMessageInfo

const Default_SnapshotVmArg_ClusterWide bool = true

func (m *SnapshotVmArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_SnapshotVmArg_ClusterWide
}

func (m *SnapshotVmArg) GetRemoveSnapshots() []*SnapshotVmArg_RemoveSnapshot {
	if m != nil {
		return m.RemoveSnapshots
	}
	return nil
}

func (m *SnapshotVmArg) GetCreateSnapshots() []*SnapshotVmArg_CreateSnapshot {
	if m != nil {
		return m.CreateSnapshots
	}
	return nil
}

func (m *SnapshotVmArg) GetQuerySnapshots() []*SnapshotVmArg_QuerySnapshot {
	if m != nil {
		return m.QuerySnapshots
	}
	return nil
}

type SnapshotVmArg_RemoveSnapshot struct {
	// Unique id of the target VM.
	VmId *string `protobuf:"bytes,1,req,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Id of the snapshot to be removed. Snapshot ids are not unique across
	// VMs. Snapshots can be removed either by id or by name, but at least
	// one of these two fields must be set. Snapshot Id takes higher precedence
	// when both parameters are specified.
	SnapshotId *string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId" json:"snapshot_id,omitempty"`
	// Name of the snapshot to be removed. Snapshot names may not be unique,
	// so when snapshot_id is not present, snapshot is removed only when it
	// can uniquely identify a snapshot. Also see
	// 'delete_all_matching_snapshots' below.
	SnapshotName *string `protobuf:"bytes,3,opt,name=snapshot_name,json=snapshotName" json:"snapshot_name,omitempty"`
	// Whether to remove all matching snapshots. This is useful when there
	// are multiple snapshots of the same name. If this is not set, and
	// multiple snaphots are found, an error will be returned.
	DeleteAllMatchingSnapshots *bool    `protobuf:"varint,4,opt,name=delete_all_matching_snapshots,json=deleteAllMatchingSnapshots,def=0" json:"delete_all_matching_snapshots,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *SnapshotVmArg_RemoveSnapshot) Reset()         { *m = SnapshotVmArg_RemoveSnapshot{} }
func (m *SnapshotVmArg_RemoveSnapshot) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmArg_RemoveSnapshot) ProtoMessage()    {}
func (*SnapshotVmArg_RemoveSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{23, 0}
}

func (m *SnapshotVmArg_RemoveSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmArg_RemoveSnapshot.Unmarshal(m, b)
}
func (m *SnapshotVmArg_RemoveSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmArg_RemoveSnapshot.Marshal(b, m, deterministic)
}
func (m *SnapshotVmArg_RemoveSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmArg_RemoveSnapshot.Merge(m, src)
}
func (m *SnapshotVmArg_RemoveSnapshot) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmArg_RemoveSnapshot.Size(m)
}
func (m *SnapshotVmArg_RemoveSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmArg_RemoveSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmArg_RemoveSnapshot proto.InternalMessageInfo

const Default_SnapshotVmArg_RemoveSnapshot_DeleteAllMatchingSnapshots bool = false

func (m *SnapshotVmArg_RemoveSnapshot) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *SnapshotVmArg_RemoveSnapshot) GetSnapshotId() string {
	if m != nil && m.SnapshotId != nil {
		return *m.SnapshotId
	}
	return ""
}

func (m *SnapshotVmArg_RemoveSnapshot) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *SnapshotVmArg_RemoveSnapshot) GetDeleteAllMatchingSnapshots() bool {
	if m != nil && m.DeleteAllMatchingSnapshots != nil {
		return *m.DeleteAllMatchingSnapshots
	}
	return Default_SnapshotVmArg_RemoveSnapshot_DeleteAllMatchingSnapshots
}

type SnapshotVmArg_CreateSnapshot struct {
	// Unique id of the target VM.
	VmId *string `protobuf:"bytes,1,req,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Name of the snapshot.
	SnapshotName *string `protobuf:"bytes,2,req,name=snapshot_name,json=snapshotName" json:"snapshot_name,omitempty"`
	// Snapshot description. Since snapshots can be managed by the user using
	// other tools, it is advised to give proper description for the snapshot
	// so that users will not delete the snapshot.
	SnapshotDescription  *string  `protobuf:"bytes,3,opt,name=snapshot_description,json=snapshotDescription" json:"snapshot_description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotVmArg_CreateSnapshot) Reset()         { *m = SnapshotVmArg_CreateSnapshot{} }
func (m *SnapshotVmArg_CreateSnapshot) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmArg_CreateSnapshot) ProtoMessage()    {}
func (*SnapshotVmArg_CreateSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{23, 1}
}

func (m *SnapshotVmArg_CreateSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmArg_CreateSnapshot.Unmarshal(m, b)
}
func (m *SnapshotVmArg_CreateSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmArg_CreateSnapshot.Marshal(b, m, deterministic)
}
func (m *SnapshotVmArg_CreateSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmArg_CreateSnapshot.Merge(m, src)
}
func (m *SnapshotVmArg_CreateSnapshot) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmArg_CreateSnapshot.Size(m)
}
func (m *SnapshotVmArg_CreateSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmArg_CreateSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmArg_CreateSnapshot proto.InternalMessageInfo

func (m *SnapshotVmArg_CreateSnapshot) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *SnapshotVmArg_CreateSnapshot) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *SnapshotVmArg_CreateSnapshot) GetSnapshotDescription() string {
	if m != nil && m.SnapshotDescription != nil {
		return *m.SnapshotDescription
	}
	return ""
}

type SnapshotVmArg_QuerySnapshot struct {
	// Unique id of the target VM.
	VmId *string `protobuf:"bytes,1,req,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Name of the snapshot.
	SnapshotName *string `protobuf:"bytes,2,req,name=snapshot_name,json=snapshotName" json:"snapshot_name,omitempty"`
	// Task handle to query the snapshot operation progress.
	TaskHandle           *string  `protobuf:"bytes,3,opt,name=task_handle,json=taskHandle" json:"task_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotVmArg_QuerySnapshot) Reset()         { *m = SnapshotVmArg_QuerySnapshot{} }
func (m *SnapshotVmArg_QuerySnapshot) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmArg_QuerySnapshot) ProtoMessage()    {}
func (*SnapshotVmArg_QuerySnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{23, 2}
}

func (m *SnapshotVmArg_QuerySnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmArg_QuerySnapshot.Unmarshal(m, b)
}
func (m *SnapshotVmArg_QuerySnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmArg_QuerySnapshot.Marshal(b, m, deterministic)
}
func (m *SnapshotVmArg_QuerySnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmArg_QuerySnapshot.Merge(m, src)
}
func (m *SnapshotVmArg_QuerySnapshot) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmArg_QuerySnapshot.Size(m)
}
func (m *SnapshotVmArg_QuerySnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmArg_QuerySnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmArg_QuerySnapshot proto.InternalMessageInfo

func (m *SnapshotVmArg_QuerySnapshot) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *SnapshotVmArg_QuerySnapshot) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *SnapshotVmArg_QuerySnapshot) GetTaskHandle() string {
	if m != nil && m.TaskHandle != nil {
		return *m.TaskHandle
	}
	return ""
}

type SnapshotVmRet struct {
	// List of results for the remove snapshot operations, one for each entry in
	// the request.
	RemoveSnapshotResults []*SnapshotVmRet_RemoveSnapshotResult `protobuf:"bytes,2,rep,name=remove_snapshot_results,json=removeSnapshotResults" json:"remove_snapshot_results,omitempty"`
	// List of results for the create snapshot operations, one for each entry in
	// the request.
	CreateSnapshotResults []*SnapshotVmRet_CreateSnapshotResult `protobuf:"bytes,3,rep,name=create_snapshot_results,json=createSnapshotResults" json:"create_snapshot_results,omitempty"`
	// List of results for the query snapshot operations, one for each entry in
	// the request.
	QuerySnapshotResults []*SnapshotVmRet_QuerySnapshotResult `protobuf:"bytes,4,rep,name=query_snapshot_results,json=querySnapshotResults" json:"query_snapshot_results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *SnapshotVmRet) Reset()         { *m = SnapshotVmRet{} }
func (m *SnapshotVmRet) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmRet) ProtoMessage()    {}
func (*SnapshotVmRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{24}
}

func (m *SnapshotVmRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmRet.Unmarshal(m, b)
}
func (m *SnapshotVmRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmRet.Marshal(b, m, deterministic)
}
func (m *SnapshotVmRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmRet.Merge(m, src)
}
func (m *SnapshotVmRet) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmRet.Size(m)
}
func (m *SnapshotVmRet) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmRet.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmRet proto.InternalMessageInfo

func (m *SnapshotVmRet) GetRemoveSnapshotResults() []*SnapshotVmRet_RemoveSnapshotResult {
	if m != nil {
		return m.RemoveSnapshotResults
	}
	return nil
}

func (m *SnapshotVmRet) GetCreateSnapshotResults() []*SnapshotVmRet_CreateSnapshotResult {
	if m != nil {
		return m.CreateSnapshotResults
	}
	return nil
}

func (m *SnapshotVmRet) GetQuerySnapshotResults() []*SnapshotVmRet_QuerySnapshotResult {
	if m != nil {
		return m.QuerySnapshotResults
	}
	return nil
}

type SnapshotVmRet_RemoveSnapshotResult struct {
	// Status of the remove snapshot operation.
	Error *SnapshotVmRet_Error `protobuf:"varint,1,req,name=error,enum=nutanix.hyperint.SnapshotVmRet_Error" json:"error,omitempty"`
	// Unique id of the VM on snapshot is removed.
	VmId                 *string  `protobuf:"bytes,2,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotVmRet_RemoveSnapshotResult) Reset()         { *m = SnapshotVmRet_RemoveSnapshotResult{} }
func (m *SnapshotVmRet_RemoveSnapshotResult) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmRet_RemoveSnapshotResult) ProtoMessage()    {}
func (*SnapshotVmRet_RemoveSnapshotResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{24, 0}
}

func (m *SnapshotVmRet_RemoveSnapshotResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmRet_RemoveSnapshotResult.Unmarshal(m, b)
}
func (m *SnapshotVmRet_RemoveSnapshotResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmRet_RemoveSnapshotResult.Marshal(b, m, deterministic)
}
func (m *SnapshotVmRet_RemoveSnapshotResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmRet_RemoveSnapshotResult.Merge(m, src)
}
func (m *SnapshotVmRet_RemoveSnapshotResult) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmRet_RemoveSnapshotResult.Size(m)
}
func (m *SnapshotVmRet_RemoveSnapshotResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmRet_RemoveSnapshotResult.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmRet_RemoveSnapshotResult proto.InternalMessageInfo

func (m *SnapshotVmRet_RemoveSnapshotResult) GetError() SnapshotVmRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return SnapshotVmRet_kNoError
}

func (m *SnapshotVmRet_RemoveSnapshotResult) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

type SnapshotVmRet_CreateSnapshotResult struct {
	// Status of the create snapshot operation.
	Error *SnapshotVmRet_Error `protobuf:"varint,1,req,name=error,enum=nutanix.hyperint.SnapshotVmRet_Error" json:"error,omitempty"`
	// Handle to the create snapshot task to query the snapshot progress.
	TaskHandle           *string  `protobuf:"bytes,2,opt,name=task_handle,json=taskHandle" json:"task_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotVmRet_CreateSnapshotResult) Reset()         { *m = SnapshotVmRet_CreateSnapshotResult{} }
func (m *SnapshotVmRet_CreateSnapshotResult) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmRet_CreateSnapshotResult) ProtoMessage()    {}
func (*SnapshotVmRet_CreateSnapshotResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{24, 1}
}

func (m *SnapshotVmRet_CreateSnapshotResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmRet_CreateSnapshotResult.Unmarshal(m, b)
}
func (m *SnapshotVmRet_CreateSnapshotResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmRet_CreateSnapshotResult.Marshal(b, m, deterministic)
}
func (m *SnapshotVmRet_CreateSnapshotResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmRet_CreateSnapshotResult.Merge(m, src)
}
func (m *SnapshotVmRet_CreateSnapshotResult) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmRet_CreateSnapshotResult.Size(m)
}
func (m *SnapshotVmRet_CreateSnapshotResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmRet_CreateSnapshotResult.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmRet_CreateSnapshotResult proto.InternalMessageInfo

func (m *SnapshotVmRet_CreateSnapshotResult) GetError() SnapshotVmRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return SnapshotVmRet_kNoError
}

func (m *SnapshotVmRet_CreateSnapshotResult) GetTaskHandle() string {
	if m != nil && m.TaskHandle != nil {
		return *m.TaskHandle
	}
	return ""
}

type SnapshotVmRet_QuerySnapshotResult struct {
	// Status of the query snapshot operation.
	Error *SnapshotVmRet_Error `protobuf:"varint,1,req,name=error,enum=nutanix.hyperint.SnapshotVmRet_Error" json:"error,omitempty"`
	// Unique id of the VM where snapshot is created.
	VmId *string `protobuf:"bytes,2,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Id of the snapshot that was created.
	SnapshotId *string `protobuf:"bytes,3,opt,name=snapshot_id,json=snapshotId" json:"snapshot_id,omitempty"`
	// Information about the virtual machine.
	VmInfo               *VmInfo  `protobuf:"bytes,4,opt,name=vm_info,json=vmInfo" json:"vm_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotVmRet_QuerySnapshotResult) Reset()         { *m = SnapshotVmRet_QuerySnapshotResult{} }
func (m *SnapshotVmRet_QuerySnapshotResult) String() string { return proto.CompactTextString(m) }
func (*SnapshotVmRet_QuerySnapshotResult) ProtoMessage()    {}
func (*SnapshotVmRet_QuerySnapshotResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{24, 2}
}

func (m *SnapshotVmRet_QuerySnapshotResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotVmRet_QuerySnapshotResult.Unmarshal(m, b)
}
func (m *SnapshotVmRet_QuerySnapshotResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotVmRet_QuerySnapshotResult.Marshal(b, m, deterministic)
}
func (m *SnapshotVmRet_QuerySnapshotResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotVmRet_QuerySnapshotResult.Merge(m, src)
}
func (m *SnapshotVmRet_QuerySnapshotResult) XXX_Size() int {
	return xxx_messageInfo_SnapshotVmRet_QuerySnapshotResult.Size(m)
}
func (m *SnapshotVmRet_QuerySnapshotResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotVmRet_QuerySnapshotResult.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotVmRet_QuerySnapshotResult proto.InternalMessageInfo

func (m *SnapshotVmRet_QuerySnapshotResult) GetError() SnapshotVmRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return SnapshotVmRet_kNoError
}

func (m *SnapshotVmRet_QuerySnapshotResult) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *SnapshotVmRet_QuerySnapshotResult) GetSnapshotId() string {
	if m != nil && m.SnapshotId != nil {
		return *m.SnapshotId
	}
	return ""
}

func (m *SnapshotVmRet_QuerySnapshotResult) GetVmInfo() *VmInfo {
	if m != nil {
		return m.VmInfo
	}
	return nil
}

type AdjustVmSnapshotArg struct {
	Snapshots            []*AdjustVmSnapshotArg_VmSnapshot `protobuf:"bytes,1,rep,name=snapshots" json:"snapshots,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *AdjustVmSnapshotArg) Reset()         { *m = AdjustVmSnapshotArg{} }
func (m *AdjustVmSnapshotArg) String() string { return proto.CompactTextString(m) }
func (*AdjustVmSnapshotArg) ProtoMessage()    {}
func (*AdjustVmSnapshotArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{25}
}

func (m *AdjustVmSnapshotArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AdjustVmSnapshotArg.Unmarshal(m, b)
}
func (m *AdjustVmSnapshotArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AdjustVmSnapshotArg.Marshal(b, m, deterministic)
}
func (m *AdjustVmSnapshotArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustVmSnapshotArg.Merge(m, src)
}
func (m *AdjustVmSnapshotArg) XXX_Size() int {
	return xxx_messageInfo_AdjustVmSnapshotArg.Size(m)
}
func (m *AdjustVmSnapshotArg) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustVmSnapshotArg.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustVmSnapshotArg proto.InternalMessageInfo

func (m *AdjustVmSnapshotArg) GetSnapshots() []*AdjustVmSnapshotArg_VmSnapshot {
	if m != nil {
		return m.Snapshots
	}
	return nil
}

type AdjustVmSnapshotArg_VmSnapshot struct {
	// Id of the snapshot.
	SnapshotId *string `protobuf:"bytes,1,req,name=snapshot_id,json=snapshotId" json:"snapshot_id,omitempty"`
	// Name of the snapshot.
	SnapshotName *string `protobuf:"bytes,2,req,name=snapshot_name,json=snapshotName" json:"snapshot_name,omitempty"`
	// List of nfs file paths that represent a vm snapshot. These paths are
	// expected in /nfs_export/file_path format.
	NfsFilePath          []string `protobuf:"bytes,3,rep,name=nfs_file_path,json=nfsFilePath" json:"nfs_file_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdjustVmSnapshotArg_VmSnapshot) Reset()         { *m = AdjustVmSnapshotArg_VmSnapshot{} }
func (m *AdjustVmSnapshotArg_VmSnapshot) String() string { return proto.CompactTextString(m) }
func (*AdjustVmSnapshotArg_VmSnapshot) ProtoMessage()    {}
func (*AdjustVmSnapshotArg_VmSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{25, 0}
}

func (m *AdjustVmSnapshotArg_VmSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AdjustVmSnapshotArg_VmSnapshot.Unmarshal(m, b)
}
func (m *AdjustVmSnapshotArg_VmSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AdjustVmSnapshotArg_VmSnapshot.Marshal(b, m, deterministic)
}
func (m *AdjustVmSnapshotArg_VmSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustVmSnapshotArg_VmSnapshot.Merge(m, src)
}
func (m *AdjustVmSnapshotArg_VmSnapshot) XXX_Size() int {
	return xxx_messageInfo_AdjustVmSnapshotArg_VmSnapshot.Size(m)
}
func (m *AdjustVmSnapshotArg_VmSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustVmSnapshotArg_VmSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustVmSnapshotArg_VmSnapshot proto.InternalMessageInfo

func (m *AdjustVmSnapshotArg_VmSnapshot) GetSnapshotId() string {
	if m != nil && m.SnapshotId != nil {
		return *m.SnapshotId
	}
	return ""
}

func (m *AdjustVmSnapshotArg_VmSnapshot) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *AdjustVmSnapshotArg_VmSnapshot) GetNfsFilePath() []string {
	if m != nil {
		return m.NfsFilePath
	}
	return nil
}

type AdjustVmSnapshotRet struct {
	Results              []*AdjustVmSnapshotRet_AdjustVmSnapshotResult `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *AdjustVmSnapshotRet) Reset()         { *m = AdjustVmSnapshotRet{} }
func (m *AdjustVmSnapshotRet) String() string { return proto.CompactTextString(m) }
func (*AdjustVmSnapshotRet) ProtoMessage()    {}
func (*AdjustVmSnapshotRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{26}
}

func (m *AdjustVmSnapshotRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AdjustVmSnapshotRet.Unmarshal(m, b)
}
func (m *AdjustVmSnapshotRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AdjustVmSnapshotRet.Marshal(b, m, deterministic)
}
func (m *AdjustVmSnapshotRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustVmSnapshotRet.Merge(m, src)
}
func (m *AdjustVmSnapshotRet) XXX_Size() int {
	return xxx_messageInfo_AdjustVmSnapshotRet.Size(m)
}
func (m *AdjustVmSnapshotRet) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustVmSnapshotRet.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustVmSnapshotRet proto.InternalMessageInfo

func (m *AdjustVmSnapshotRet) GetResults() []*AdjustVmSnapshotRet_AdjustVmSnapshotResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type AdjustVmSnapshotRet_AdjustVmSnapshotResult struct {
	// Status of the AdjustVmSnapshot operation.
	Error *AdjustVmSnapshotRet_Error `protobuf:"varint,1,req,name=error,enum=nutanix.hyperint.AdjustVmSnapshotRet_Error" json:"error,omitempty"`
	// List of files removed in the process of adjusting the VM to boot from
	// the snapshotted Nfs files.
	RemovedNfsFilePath   []string `protobuf:"bytes,2,rep,name=removed_nfs_file_path,json=removedNfsFilePath" json:"removed_nfs_file_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) Reset() {
	*m = AdjustVmSnapshotRet_AdjustVmSnapshotResult{}
}
func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) String() string {
	return proto.CompactTextString(m)
}
func (*AdjustVmSnapshotRet_AdjustVmSnapshotResult) ProtoMessage() {}
func (*AdjustVmSnapshotRet_AdjustVmSnapshotResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{26, 0}
}

func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AdjustVmSnapshotRet_AdjustVmSnapshotResult.Unmarshal(m, b)
}
func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AdjustVmSnapshotRet_AdjustVmSnapshotResult.Marshal(b, m, deterministic)
}
func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustVmSnapshotRet_AdjustVmSnapshotResult.Merge(m, src)
}
func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) XXX_Size() int {
	return xxx_messageInfo_AdjustVmSnapshotRet_AdjustVmSnapshotResult.Size(m)
}
func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustVmSnapshotRet_AdjustVmSnapshotResult.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustVmSnapshotRet_AdjustVmSnapshotResult proto.InternalMessageInfo

func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) GetError() AdjustVmSnapshotRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return AdjustVmSnapshotRet_kNoError
}

func (m *AdjustVmSnapshotRet_AdjustVmSnapshotResult) GetRemovedNfsFilePath() []string {
	if m != nil {
		return m.RemovedNfsFilePath
	}
	return nil
}

type ChangeVmStateArg struct {
	// List of running VMs that should be stopped.
	StopVmIds []string `protobuf:"bytes,1,rep,name=stop_vm_ids,json=stopVmIds" json:"stop_vm_ids,omitempty"`
	// List of VMs that should be destroyed. This is the similar to unregister,
	// but the VMs files should be additionally removed by the operation.
	DestroyVmIds []string `protobuf:"bytes,2,rep,name=destroy_vm_ids,json=destroyVmIds" json:"destroy_vm_ids,omitempty"`
	// List of stopped VMs that should be started.
	StartVmIds []string `protobuf:"bytes,3,rep,name=start_vm_ids,json=startVmIds" json:"start_vm_ids,omitempty"`
	// This parameter defines the scope of the lookup of the specified VM ids.
	// If 'cluster_wide' is not set to true, then, only the
	// locally-running VMs among the specified VM ids would be acted upon.
	// Otherwise, virtual machines with matching VM ids from across the cluster
	// would be acted upon.
	ClusterWide *bool `protobuf:"varint,4,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// Shutdown VMs before powering off. This is a hint to the hypervisor to
	// attempt to shutdown the guest OS in the VM before powering off.
	ShutdownGuest *bool `protobuf:"varint,5,opt,name=shutdown_guest,json=shutdownGuest,def=0" json:"shutdown_guest,omitempty"`
	// Max timeout value for waiting for guest to shutdown. If the guest shutdown
	// is not compelted by this time, the VM will be powered off.
	ShutdownGuestTimeoutInSeconds *int32 `protobuf:"varint,6,opt,name=shutdown_guest_timeout_in_seconds,json=shutdownGuestTimeoutInSeconds,def=60" json:"shutdown_guest_timeout_in_seconds,omitempty"`
	// If this option is set, then unregister the VMs specified for deletion, but
	// do not remove the associated files. Currently this option is used
	// internally, and not supported on any hypervisor.
	UnregisterOnly       *bool    `protobuf:"varint,7,opt,name=unregister_only,json=unregisterOnly,def=0" json:"unregister_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeVmStateArg) Reset()         { *m = ChangeVmStateArg{} }
func (m *ChangeVmStateArg) String() string { return proto.CompactTextString(m) }
func (*ChangeVmStateArg) ProtoMessage()    {}
func (*ChangeVmStateArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{27}
}

func (m *ChangeVmStateArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChangeVmStateArg.Unmarshal(m, b)
}
func (m *ChangeVmStateArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChangeVmStateArg.Marshal(b, m, deterministic)
}
func (m *ChangeVmStateArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeVmStateArg.Merge(m, src)
}
func (m *ChangeVmStateArg) XXX_Size() int {
	return xxx_messageInfo_ChangeVmStateArg.Size(m)
}
func (m *ChangeVmStateArg) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeVmStateArg.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeVmStateArg proto.InternalMessageInfo

const Default_ChangeVmStateArg_ClusterWide bool = true
const Default_ChangeVmStateArg_ShutdownGuest bool = false
const Default_ChangeVmStateArg_ShutdownGuestTimeoutInSeconds int32 = 60
const Default_ChangeVmStateArg_UnregisterOnly bool = false

func (m *ChangeVmStateArg) GetStopVmIds() []string {
	if m != nil {
		return m.StopVmIds
	}
	return nil
}

func (m *ChangeVmStateArg) GetDestroyVmIds() []string {
	if m != nil {
		return m.DestroyVmIds
	}
	return nil
}

func (m *ChangeVmStateArg) GetStartVmIds() []string {
	if m != nil {
		return m.StartVmIds
	}
	return nil
}

func (m *ChangeVmStateArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_ChangeVmStateArg_ClusterWide
}

func (m *ChangeVmStateArg) GetShutdownGuest() bool {
	if m != nil && m.ShutdownGuest != nil {
		return *m.ShutdownGuest
	}
	return Default_ChangeVmStateArg_ShutdownGuest
}

func (m *ChangeVmStateArg) GetShutdownGuestTimeoutInSeconds() int32 {
	if m != nil && m.ShutdownGuestTimeoutInSeconds != nil {
		return *m.ShutdownGuestTimeoutInSeconds
	}
	return Default_ChangeVmStateArg_ShutdownGuestTimeoutInSeconds
}

func (m *ChangeVmStateArg) GetUnregisterOnly() bool {
	if m != nil && m.UnregisterOnly != nil {
		return *m.UnregisterOnly
	}
	return Default_ChangeVmStateArg_UnregisterOnly
}

type ChangeVmStateRet struct {
	// Errors encountered when stopping VMs. Each index's value corresponds to
	// the same index in the requests 'stop_vm_id'.
	StopVmErrors []ChangeVmStateRet_Error `protobuf:"varint,1,rep,name=stop_vm_errors,json=stopVmErrors,enum=nutanix.hyperint.ChangeVmStateRet_Error" json:"stop_vm_errors,omitempty"`
	// Errors encountered when destroying VMs. Each index's value corresponds
	// to the same index in the requests 'destroy_vm_id'.
	DestroyVmErrors []ChangeVmStateRet_Error `protobuf:"varint,2,rep,name=destroy_vm_errors,json=destroyVmErrors,enum=nutanix.hyperint.ChangeVmStateRet_Error" json:"destroy_vm_errors,omitempty"`
	// Errors encountered when starting VMs. Each index's value corresponds to
	// the same index in the requests 'start_vm_id'.
	StartVmErrors        []ChangeVmStateRet_Error `protobuf:"varint,3,rep,name=start_vm_errors,json=startVmErrors,enum=nutanix.hyperint.ChangeVmStateRet_Error" json:"start_vm_errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ChangeVmStateRet) Reset()         { *m = ChangeVmStateRet{} }
func (m *ChangeVmStateRet) String() string { return proto.CompactTextString(m) }
func (*ChangeVmStateRet) ProtoMessage()    {}
func (*ChangeVmStateRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{28}
}

func (m *ChangeVmStateRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChangeVmStateRet.Unmarshal(m, b)
}
func (m *ChangeVmStateRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChangeVmStateRet.Marshal(b, m, deterministic)
}
func (m *ChangeVmStateRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeVmStateRet.Merge(m, src)
}
func (m *ChangeVmStateRet) XXX_Size() int {
	return xxx_messageInfo_ChangeVmStateRet.Size(m)
}
func (m *ChangeVmStateRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeVmStateRet.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeVmStateRet proto.InternalMessageInfo

func (m *ChangeVmStateRet) GetStopVmErrors() []ChangeVmStateRet_Error {
	if m != nil {
		return m.StopVmErrors
	}
	return nil
}

func (m *ChangeVmStateRet) GetDestroyVmErrors() []ChangeVmStateRet_Error {
	if m != nil {
		return m.DestroyVmErrors
	}
	return nil
}

func (m *ChangeVmStateRet) GetStartVmErrors() []ChangeVmStateRet_Error {
	if m != nil {
		return m.StartVmErrors
	}
	return nil
}

type RegisterVmArg struct {
	RegisterVm []*RegisterVmArg_RegisterVm `protobuf:"bytes,1,rep,name=register_vm,json=registerVm" json:"register_vm,omitempty"`
	// This parameter defines the scope of the request. If 'cluster_wide' is
	// set to true, then request will be sent to all relevant nodes that are
	// specified in the request. Otherwise, the request is sent to only the
	// local node.
	ClusterWide *bool `protobuf:"varint,2,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// Mapping of Hypervisor datastore UUIDs from snapshot source cluster to the
	// vstore names on the target cluster where the VMs are being registered.
	SrcDatastoreUuid []string `protobuf:"bytes,3,rep,name=src_datastore_uuid,json=srcDatastoreUuid" json:"src_datastore_uuid,omitempty"`
	TargetVstoreName []string `protobuf:"bytes,4,rep,name=target_vstore_name,json=targetVstoreName" json:"target_vstore_name,omitempty"`
	// This map describes the network mapping between the network on source and
	// destination cluster. Let's say mapping is 'src_network:dst_network', it
	// means that all the VMs which were on 'src_network' on source cluster now
	// will be started on 'dst_network' on destination cluster.
	//
	// When clear_identity is set, the VM's MAC and IP addresses are generally
	// expunged. Alternatively, the network mapping may be used to provide an
	// explicit mapping from the original address to new address. Note that it is
	// not an error to provide an identity mapping.
	//
	// If the this field maps a source network to an unset destination network,
	// the behavior is hypervisor-dependent. Either the NIC will be restored in a
	// disconnected state, or the NIC will be removed from the VM entirely. Note
	// that this behavior has compatibility implications.
	NetworkMapping *HostNetworkMapping `protobuf:"bytes,5,opt,name=network_mapping,json=networkMapping" json:"network_mapping,omitempty"`
	// Parameter to determine whether the saved state of the VM will be removed
	// or not in case of processor incompatibilities. Valid only for Hyper-V.
	RemoveSavedStateOnProcessorIncompatibility *bool `protobuf:"varint,6,opt,name=remove_saved_state_on_processor_incompatibility,json=removeSavedStateOnProcessorIncompatibility,def=1" json:"remove_saved_state_on_processor_incompatibility,omitempty"`
	// Incarnation ID required by IDF when the VM entity is migrated from some
	// other cluster to the current cluster.
	DbIncarnationId      *uint64  `protobuf:"varint,7,opt,name=db_incarnation_id,json=dbIncarnationId" json:"db_incarnation_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterVmArg) Reset()         { *m = RegisterVmArg{} }
func (m *RegisterVmArg) String() string { return proto.CompactTextString(m) }
func (*RegisterVmArg) ProtoMessage()    {}
func (*RegisterVmArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{29}
}

func (m *RegisterVmArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterVmArg.Unmarshal(m, b)
}
func (m *RegisterVmArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterVmArg.Marshal(b, m, deterministic)
}
func (m *RegisterVmArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterVmArg.Merge(m, src)
}
func (m *RegisterVmArg) XXX_Size() int {
	return xxx_messageInfo_RegisterVmArg.Size(m)
}
func (m *RegisterVmArg) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterVmArg.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterVmArg proto.InternalMessageInfo

const Default_RegisterVmArg_ClusterWide bool = true
const Default_RegisterVmArg_RemoveSavedStateOnProcessorIncompatibility bool = true

func (m *RegisterVmArg) GetRegisterVm() []*RegisterVmArg_RegisterVm {
	if m != nil {
		return m.RegisterVm
	}
	return nil
}

func (m *RegisterVmArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_RegisterVmArg_ClusterWide
}

func (m *RegisterVmArg) GetSrcDatastoreUuid() []string {
	if m != nil {
		return m.SrcDatastoreUuid
	}
	return nil
}

func (m *RegisterVmArg) GetTargetVstoreName() []string {
	if m != nil {
		return m.TargetVstoreName
	}
	return nil
}

func (m *RegisterVmArg) GetNetworkMapping() *HostNetworkMapping {
	if m != nil {
		return m.NetworkMapping
	}
	return nil
}

func (m *RegisterVmArg) GetRemoveSavedStateOnProcessorIncompatibility() bool {
	if m != nil && m.RemoveSavedStateOnProcessorIncompatibility != nil {
		return *m.RemoveSavedStateOnProcessorIncompatibility
	}
	return Default_RegisterVmArg_RemoveSavedStateOnProcessorIncompatibility
}

func (m *RegisterVmArg) GetDbIncarnationId() uint64 {
	if m != nil && m.DbIncarnationId != nil {
		return *m.DbIncarnationId
	}
	return 0
}

// Information about a VM that should be registered with the hypervisor.
type RegisterVmArg_RegisterVm struct {
	// The name that the VM should be registered with. If a VM with the same
	// name already exists, hyperint will perform necessary checks to figure
	// out whether the request is a replay. If so, the request is turned into a
	// no-op, otherwise hyperint must choose a new VM name for the VM (e.g.,
	// add a "(#)" suffix as done in vSphere). Clients can discover the
	// registered name by inspecting the result.
	VmName *string `protobuf:"bytes,1,req,name=vm_name,json=vmName" json:"vm_name,omitempty"`
	// The list of NFS files that compose this VM. The files' absolute paths do
	// not need to be identical to the set retrieved from GetVmInfo(), however
	// they are expected to map 1:1 to the original "template" VM's files
	// (set in 'original_nfs_file_paths' below) and supplied in the same order.
	//
	// For example, if the following files backed a VM and were presented in
	// the given order in a GetVmInfo() request, snapshots of these files may
	// be used to register a new VM, however their order must also be
	// consistent:
	//   'original_nfs_file_paths':       'nfs_file_paths':
	//     /ctr/orig_vm/test.vmx       ->   /ctr/new_vm/test.vmx
	//     /ctr/orig_vm/test.vmdk      ->   /ctr/new_vm/test.vmdk
	//     /ctr/orig_vm/test-flat.vmdk ->   /ctr/new_vm/test-flat.vmdk
	NfsFilePaths []string `protobuf:"bytes,2,rep,name=nfs_file_paths,json=nfsFilePaths" json:"nfs_file_paths,omitempty"`
	// The list of NFS files that were used as the template to construct this
	// VM. These are provided to help the hypervisor modify paths in
	// configuration files. These must be presented in the order they were
	// received in the response to GetVmInfo().
	OriginalNfsFilePaths []string `protobuf:"bytes,3,rep,name=original_nfs_file_paths,json=originalNfsFilePaths" json:"original_nfs_file_paths,omitempty"`
	// Whether information specific to the VM should be cleared before
	// registering the VM with the hypervisor. If true, then preexisting
	// identifier information (which may consist of a machine ID, MAC address,
	// static IP, etc.) will be cleared from the VM's configuration so as to
	// prevent potential conflicts with another VM.
	//
	// For network identifiers in particular, refer to the network_mapping
	// field below, which may be used to specify the new identifiers
	// explicitly.
	//
	// For managing hypervisor agnostic VM UUIDs, if this flag is set, we will
	// use the VM UUID as specified in uhura_interface.VmRegister.vm_uuid as the
	// hypervisor agnostic VM UUID for non-AHV VMs. If this flag is not set, we
	// will use uhura_interface.VmRegister.vm_uuid as a hyperviosr agnostic VM
	// UUID to check if the corresponding VM alread exists on AHV.
	ClearIdentity *bool `protobuf:"varint,4,opt,name=clear_identity,json=clearIdentity" json:"clear_identity,omitempty"`
	// Indicate whether the vm needs to be reverted to one of its snapshots.
	// If VM needs application consistent snapshots then set this to revert
	// the vm state to the application consistent snapshot.
	RevertToSnapshotName *string `protobuf:"bytes,5,opt,name=revert_to_snapshot_name,json=revertToSnapshotName" json:"revert_to_snapshot_name,omitempty"`
	// The opaque metadata reported by hyperint during GetVmInfo, if any.
	VmOpaqueData []byte `protobuf:"bytes,6,opt,name=vm_opaque_data,json=vmOpaqueData" json:"vm_opaque_data,omitempty"`
	// Optional node information where the VM should be registered.
	// If absent, the VM will be registered in the local node.
	NodeId *int64 `protobuf:"varint,7,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// List of disk labels to be excluded on registration. Hyperint will
	// modify the configuration file of the VM to exclude/disable the specific
	// disk labels before registration.
	VmDiskLabelsToExclude []string `protobuf:"bytes,8,rep,name=vm_disk_labels_to_exclude,json=vmDiskLabelsToExclude" json:"vm_disk_labels_to_exclude,omitempty"`
	// CD label to exclude. If specified, the CD-ROM device for the label
	// will be reset (ie, CD-ROM device will be empty).
	CdLabelToReset *string `protobuf:"bytes,9,opt,name=cd_label_to_reset,json=cdLabelToReset" json:"cd_label_to_reset,omitempty"`
	// Whether to inherit scsi serial number of the source Vdisk.
	InheritScsiSerialNumber *bool `protobuf:"varint,10,opt,name=inherit_scsi_serial_number,json=inheritScsiSerialNumber" json:"inherit_scsi_serial_number,omitempty"`
	// Optional hypervisor type for the node where the VM should be registered.
	HypervisorType *config.ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,11,opt,name=hypervisor_type,json=hypervisorType,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType" json:"hypervisor_type,omitempty"`
	// Set hypervisor agnostic uuid of the newly created VM. Valid only for
	// AHV, if clear_identity is set to true.
	HypervisorAgnosticVmUuid []byte `protobuf:"bytes,12,opt,name=hypervisor_agnostic_vm_uuid,json=hypervisorAgnosticVmUuid" json:"hypervisor_agnostic_vm_uuid,omitempty"`
	// Clear network from VMX file before registering. This is applicable only
	// for ESX.
	SkipNetworkRecovery *bool `protobuf:"varint,13,opt,name=skip_network_recovery,json=skipNetworkRecovery" json:"skip_network_recovery,omitempty"`
	// Source VM uuid of which this VM is clone of.
	SourceVmUuid []byte `protobuf:"bytes,14,opt,name=source_vm_uuid,json=sourceVmUuid" json:"source_vm_uuid,omitempty"`
	// Preserve mac address for the VM. MAC address will be preserved even if
	// clear_identity is true. This field has no effect if clear_identity is
	// set to false.
	PreserveMacAddress *bool `protobuf:"varint,15,opt,name=preserve_mac_address,json=preserveMacAddress" json:"preserve_mac_address,omitempty"`
	// Preserve disk uuids of the VM. Disk uuids will be preserved only if
	// this is true, irrespective of clear_identity value.
	PreserveVmDiskUuids *bool `protobuf:"varint,16,opt,name=preserve_vm_disk_uuids,json=preserveVmDiskUuids" json:"preserve_vm_disk_uuids,omitempty"`
	// Map of the VM child entities and their respective incarnation IDs.
	// Applicable only for AHV. Should not be specified for other hypervisors.
	ChildEntityDbIncarnationIdList []*RegisterVmArg_RegisterVm_EntityDbIncarnationId `protobuf:"bytes,17,rep,name=child_entity_db_incarnation_id_list,json=childEntityDbIncarnationIdList" json:"child_entity_db_incarnation_id_list,omitempty"`
	// IP address for the VM will be preserved if preserve_ipam_ip_address is
	// true, even if clear_identity is true. If clear_identity is false,
	// this field has no effect.
	PreserveIpamIpAddress *bool `protobuf:"varint,18,opt,name=preserve_ipam_ip_address,json=preserveIpamIpAddress" json:"preserve_ipam_ip_address,omitempty"`
	// Preserve NIC uuids of the VM. NIC uuids will be preserved only if this
	// is true, irrespective of clear_identity value.
	PreserveVmNicUuids   *bool    `protobuf:"varint,19,opt,name=preserve_vm_nic_uuids,json=preserveVmNicUuids" json:"preserve_vm_nic_uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterVmArg_RegisterVm) Reset()         { *m = RegisterVmArg_RegisterVm{} }
func (m *RegisterVmArg_RegisterVm) String() string { return proto.CompactTextString(m) }
func (*RegisterVmArg_RegisterVm) ProtoMessage()    {}
func (*RegisterVmArg_RegisterVm) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{29, 0}
}

func (m *RegisterVmArg_RegisterVm) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterVmArg_RegisterVm.Unmarshal(m, b)
}
func (m *RegisterVmArg_RegisterVm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterVmArg_RegisterVm.Marshal(b, m, deterministic)
}
func (m *RegisterVmArg_RegisterVm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterVmArg_RegisterVm.Merge(m, src)
}
func (m *RegisterVmArg_RegisterVm) XXX_Size() int {
	return xxx_messageInfo_RegisterVmArg_RegisterVm.Size(m)
}
func (m *RegisterVmArg_RegisterVm) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterVmArg_RegisterVm.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterVmArg_RegisterVm proto.InternalMessageInfo

func (m *RegisterVmArg_RegisterVm) GetVmName() string {
	if m != nil && m.VmName != nil {
		return *m.VmName
	}
	return ""
}

func (m *RegisterVmArg_RegisterVm) GetNfsFilePaths() []string {
	if m != nil {
		return m.NfsFilePaths
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetOriginalNfsFilePaths() []string {
	if m != nil {
		return m.OriginalNfsFilePaths
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetClearIdentity() bool {
	if m != nil && m.ClearIdentity != nil {
		return *m.ClearIdentity
	}
	return false
}

func (m *RegisterVmArg_RegisterVm) GetRevertToSnapshotName() string {
	if m != nil && m.RevertToSnapshotName != nil {
		return *m.RevertToSnapshotName
	}
	return ""
}

func (m *RegisterVmArg_RegisterVm) GetVmOpaqueData() []byte {
	if m != nil {
		return m.VmOpaqueData
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetNodeId() int64 {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return 0
}

func (m *RegisterVmArg_RegisterVm) GetVmDiskLabelsToExclude() []string {
	if m != nil {
		return m.VmDiskLabelsToExclude
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetCdLabelToReset() string {
	if m != nil && m.CdLabelToReset != nil {
		return *m.CdLabelToReset
	}
	return ""
}

func (m *RegisterVmArg_RegisterVm) GetInheritScsiSerialNumber() bool {
	if m != nil && m.InheritScsiSerialNumber != nil {
		return *m.InheritScsiSerialNumber
	}
	return false
}

func (m *RegisterVmArg_RegisterVm) GetHypervisorType() config.ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return config.ConfigurationProto_ManagementServer_kVMware
}

func (m *RegisterVmArg_RegisterVm) GetHypervisorAgnosticVmUuid() []byte {
	if m != nil {
		return m.HypervisorAgnosticVmUuid
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetSkipNetworkRecovery() bool {
	if m != nil && m.SkipNetworkRecovery != nil {
		return *m.SkipNetworkRecovery
	}
	return false
}

func (m *RegisterVmArg_RegisterVm) GetSourceVmUuid() []byte {
	if m != nil {
		return m.SourceVmUuid
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetPreserveMacAddress() bool {
	if m != nil && m.PreserveMacAddress != nil {
		return *m.PreserveMacAddress
	}
	return false
}

func (m *RegisterVmArg_RegisterVm) GetPreserveVmDiskUuids() bool {
	if m != nil && m.PreserveVmDiskUuids != nil {
		return *m.PreserveVmDiskUuids
	}
	return false
}

func (m *RegisterVmArg_RegisterVm) GetChildEntityDbIncarnationIdList() []*RegisterVmArg_RegisterVm_EntityDbIncarnationId {
	if m != nil {
		return m.ChildEntityDbIncarnationIdList
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm) GetPreserveIpamIpAddress() bool {
	if m != nil && m.PreserveIpamIpAddress != nil {
		return *m.PreserveIpamIpAddress
	}
	return false
}

func (m *RegisterVmArg_RegisterVm) GetPreserveVmNicUuids() bool {
	if m != nil && m.PreserveVmNicUuids != nil {
		return *m.PreserveVmNicUuids
	}
	return false
}

type RegisterVmArg_RegisterVm_EntityDbIncarnationId struct {
	// Required. UUID of the entity.
	EntityUuid []byte `protobuf:"bytes,1,opt,name=entity_uuid,json=entityUuid" json:"entity_uuid,omitempty"`
	// Required. Type of the child entity.
	EntityType *RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType `protobuf:"varint,2,opt,name=entity_type,json=entityType,enum=nutanix.hyperint.RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType" json:"entity_type,omitempty"`
	// Required. Incarnation ID required by IDF when an entity is migrated
	// from some other cluster to the current cluster.
	DbIncarnationId      *uint64  `protobuf:"varint,3,opt,name=db_incarnation_id,json=dbIncarnationId" json:"db_incarnation_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) Reset() {
	*m = RegisterVmArg_RegisterVm_EntityDbIncarnationId{}
}
func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) String() string {
	return proto.CompactTextString(m)
}
func (*RegisterVmArg_RegisterVm_EntityDbIncarnationId) ProtoMessage() {}
func (*RegisterVmArg_RegisterVm_EntityDbIncarnationId) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{29, 0, 0}
}

func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterVmArg_RegisterVm_EntityDbIncarnationId.Unmarshal(m, b)
}
func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterVmArg_RegisterVm_EntityDbIncarnationId.Marshal(b, m, deterministic)
}
func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterVmArg_RegisterVm_EntityDbIncarnationId.Merge(m, src)
}
func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) XXX_Size() int {
	return xxx_messageInfo_RegisterVmArg_RegisterVm_EntityDbIncarnationId.Size(m)
}
func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterVmArg_RegisterVm_EntityDbIncarnationId.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterVmArg_RegisterVm_EntityDbIncarnationId proto.InternalMessageInfo

func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) GetEntityUuid() []byte {
	if m != nil {
		return m.EntityUuid
	}
	return nil
}

func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) GetEntityType() RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return RegisterVmArg_RegisterVm_EntityDbIncarnationId_kVirtualDisk
}

func (m *RegisterVmArg_RegisterVm_EntityDbIncarnationId) GetDbIncarnationId() uint64 {
	if m != nil && m.DbIncarnationId != nil {
		return *m.DbIncarnationId
	}
	return 0
}

type RegisterVmRet struct {
	// VM registration results. Each index's value will correspond to the same
	// index in the requests 'vm_info'.
	VmResult             []*RegisterVmRet_VmResult `protobuf:"bytes,1,rep,name=vm_result,json=vmResult" json:"vm_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *RegisterVmRet) Reset()         { *m = RegisterVmRet{} }
func (m *RegisterVmRet) String() string { return proto.CompactTextString(m) }
func (*RegisterVmRet) ProtoMessage()    {}
func (*RegisterVmRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{30}
}

func (m *RegisterVmRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterVmRet.Unmarshal(m, b)
}
func (m *RegisterVmRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterVmRet.Marshal(b, m, deterministic)
}
func (m *RegisterVmRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterVmRet.Merge(m, src)
}
func (m *RegisterVmRet) XXX_Size() int {
	return xxx_messageInfo_RegisterVmRet.Size(m)
}
func (m *RegisterVmRet) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterVmRet.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterVmRet proto.InternalMessageInfo

func (m *RegisterVmRet) GetVmResult() []*RegisterVmRet_VmResult {
	if m != nil {
		return m.VmResult
	}
	return nil
}

type RegisterVmRet_VmResult struct {
	// Information about the registered VM. If not set, then an error was
	// encountered during registration and 'error' will be set.
	VmInfo *VmInfo `protobuf:"bytes,1,opt,name=vm_info,json=vmInfo" json:"vm_info,omitempty"`
	// Resulting error encountered when registering the VM. If not set or
	// 'kNoError', registration of the VM with the hypervisor succeeded.
	Error *RegisterVmRet_Error `protobuf:"varint,2,opt,name=error,enum=nutanix.hyperint.RegisterVmRet_Error,def=0" json:"error,omitempty"`
	// Resulting warning encountered when registering the VM. If not set then
	// there was no warning encountered for the VM. Valid when error is
	// kNoError.
	WarningMsg           *string  `protobuf:"bytes,3,opt,name=warning_msg,json=warningMsg" json:"warning_msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterVmRet_VmResult) Reset()         { *m = RegisterVmRet_VmResult{} }
func (m *RegisterVmRet_VmResult) String() string { return proto.CompactTextString(m) }
func (*RegisterVmRet_VmResult) ProtoMessage()    {}
func (*RegisterVmRet_VmResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{30, 0}
}

func (m *RegisterVmRet_VmResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterVmRet_VmResult.Unmarshal(m, b)
}
func (m *RegisterVmRet_VmResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterVmRet_VmResult.Marshal(b, m, deterministic)
}
func (m *RegisterVmRet_VmResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterVmRet_VmResult.Merge(m, src)
}
func (m *RegisterVmRet_VmResult) XXX_Size() int {
	return xxx_messageInfo_RegisterVmRet_VmResult.Size(m)
}
func (m *RegisterVmRet_VmResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterVmRet_VmResult.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterVmRet_VmResult proto.InternalMessageInfo

const Default_RegisterVmRet_VmResult_Error RegisterVmRet_Error = RegisterVmRet_kNoError

func (m *RegisterVmRet_VmResult) GetVmInfo() *VmInfo {
	if m != nil {
		return m.VmInfo
	}
	return nil
}

func (m *RegisterVmRet_VmResult) GetError() RegisterVmRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_RegisterVmRet_VmResult_Error
}

func (m *RegisterVmRet_VmResult) GetWarningMsg() string {
	if m != nil && m.WarningMsg != nil {
		return *m.WarningMsg
	}
	return ""
}

type GetDatastoresArg struct {
	// List of the IDs of the nodes. When left empty, only the datastores of
	// the local node are returned. When populated, the order of elements in the
	// list determines the order of the elements in the returned result list.
	NodeIds              []int64  `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDatastoresArg) Reset()         { *m = GetDatastoresArg{} }
func (m *GetDatastoresArg) String() string { return proto.CompactTextString(m) }
func (*GetDatastoresArg) ProtoMessage()    {}
func (*GetDatastoresArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{31}
}

func (m *GetDatastoresArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetDatastoresArg.Unmarshal(m, b)
}
func (m *GetDatastoresArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetDatastoresArg.Marshal(b, m, deterministic)
}
func (m *GetDatastoresArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDatastoresArg.Merge(m, src)
}
func (m *GetDatastoresArg) XXX_Size() int {
	return xxx_messageInfo_GetDatastoresArg.Size(m)
}
func (m *GetDatastoresArg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDatastoresArg.DiscardUnknown(m)
}

var xxx_messageInfo_GetDatastoresArg proto.InternalMessageInfo

func (m *GetDatastoresArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

type GetDatastoresRet struct {
	// Get datastores results. Each index's value will correspond to the same
	// index in the request's 'node_ids'.
	DatastoresResults    []*GetDatastoresRet_GetDatastoresResult `protobuf:"bytes,1,rep,name=datastores_results,json=datastoresResults" json:"datastores_results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *GetDatastoresRet) Reset()         { *m = GetDatastoresRet{} }
func (m *GetDatastoresRet) String() string { return proto.CompactTextString(m) }
func (*GetDatastoresRet) ProtoMessage()    {}
func (*GetDatastoresRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{32}
}

func (m *GetDatastoresRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetDatastoresRet.Unmarshal(m, b)
}
func (m *GetDatastoresRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetDatastoresRet.Marshal(b, m, deterministic)
}
func (m *GetDatastoresRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDatastoresRet.Merge(m, src)
}
func (m *GetDatastoresRet) XXX_Size() int {
	return xxx_messageInfo_GetDatastoresRet.Size(m)
}
func (m *GetDatastoresRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDatastoresRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetDatastoresRet proto.InternalMessageInfo

func (m *GetDatastoresRet) GetDatastoresResults() []*GetDatastoresRet_GetDatastoresResult {
	if m != nil {
		return m.DatastoresResults
	}
	return nil
}

type GetDatastoresRet_GetDatastoresResult struct {
	// The list of the datastores (NFS mounts) in the node (hypervisor).
	// This list can be empty when the node (hypervisor) does not have any
	// datastores (NFS mount) or if there is an error.
	DatastoreInfoList []*DatastoreInfo `protobuf:"bytes,1,rep,name=datastore_info_list,json=datastoreInfoList" json:"datastore_info_list,omitempty"`
	// Resulting error encountered while retrieving the list of datastores
	// (NFS mount). If not set or 'kNoError' then the request to the hypervisor
	// is succeeded.
	Error                *GetDatastoresRet_Error `protobuf:"varint,2,opt,name=error,enum=nutanix.hyperint.GetDatastoresRet_Error,def=0" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *GetDatastoresRet_GetDatastoresResult) Reset()         { *m = GetDatastoresRet_GetDatastoresResult{} }
func (m *GetDatastoresRet_GetDatastoresResult) String() string { return proto.CompactTextString(m) }
func (*GetDatastoresRet_GetDatastoresResult) ProtoMessage()    {}
func (*GetDatastoresRet_GetDatastoresResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{32, 0}
}

func (m *GetDatastoresRet_GetDatastoresResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetDatastoresRet_GetDatastoresResult.Unmarshal(m, b)
}
func (m *GetDatastoresRet_GetDatastoresResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetDatastoresRet_GetDatastoresResult.Marshal(b, m, deterministic)
}
func (m *GetDatastoresRet_GetDatastoresResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDatastoresRet_GetDatastoresResult.Merge(m, src)
}
func (m *GetDatastoresRet_GetDatastoresResult) XXX_Size() int {
	return xxx_messageInfo_GetDatastoresRet_GetDatastoresResult.Size(m)
}
func (m *GetDatastoresRet_GetDatastoresResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDatastoresRet_GetDatastoresResult.DiscardUnknown(m)
}

var xxx_messageInfo_GetDatastoresRet_GetDatastoresResult proto.InternalMessageInfo

const Default_GetDatastoresRet_GetDatastoresResult_Error GetDatastoresRet_Error = GetDatastoresRet_kNoError

func (m *GetDatastoresRet_GetDatastoresResult) GetDatastoreInfoList() []*DatastoreInfo {
	if m != nil {
		return m.DatastoreInfoList
	}
	return nil
}

func (m *GetDatastoresRet_GetDatastoresResult) GetError() GetDatastoresRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_GetDatastoresRet_GetDatastoresResult_Error
}

type MountDatastoreArg struct {
	// List of the IDs of the nodes. When left empty, only the the local node is
	// used to create/mount the datastore. When populated, the order of elements
	// in the list determines the order of elements in the returned result list.
	NodeIds []int64 `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	// The name of the datastore to mount.
	DatastoreName *string `protobuf:"bytes,2,opt,name=datastore_name,json=datastoreName" json:"datastore_name,omitempty"`
	// Unique ID of the container associated with this datastore.
	ContainerId *int64 `protobuf:"varint,3,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// The name of the container associated with this datastore.
	ContainerName *string `protobuf:"bytes,4,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	// Setting readonly to true would make the node (hypervisor) have read-only
	// access to the NFS share (container).
	Readonly *bool `protobuf:"varint,5,opt,name=readonly,def=0" json:"readonly,omitempty"`
	// The target path of the NFS share.
	TargetPath           *string  `protobuf:"bytes,6,opt,name=target_path,json=targetPath" json:"target_path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MountDatastoreArg) Reset()         { *m = MountDatastoreArg{} }
func (m *MountDatastoreArg) String() string { return proto.CompactTextString(m) }
func (*MountDatastoreArg) ProtoMessage()    {}
func (*MountDatastoreArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{33}
}

func (m *MountDatastoreArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MountDatastoreArg.Unmarshal(m, b)
}
func (m *MountDatastoreArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MountDatastoreArg.Marshal(b, m, deterministic)
}
func (m *MountDatastoreArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountDatastoreArg.Merge(m, src)
}
func (m *MountDatastoreArg) XXX_Size() int {
	return xxx_messageInfo_MountDatastoreArg.Size(m)
}
func (m *MountDatastoreArg) XXX_DiscardUnknown() {
	xxx_messageInfo_MountDatastoreArg.DiscardUnknown(m)
}

var xxx_messageInfo_MountDatastoreArg proto.InternalMessageInfo

const Default_MountDatastoreArg_Readonly bool = false

func (m *MountDatastoreArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

func (m *MountDatastoreArg) GetDatastoreName() string {
	if m != nil && m.DatastoreName != nil {
		return *m.DatastoreName
	}
	return ""
}

func (m *MountDatastoreArg) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *MountDatastoreArg) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

func (m *MountDatastoreArg) GetReadonly() bool {
	if m != nil && m.Readonly != nil {
		return *m.Readonly
	}
	return Default_MountDatastoreArg_Readonly
}

func (m *MountDatastoreArg) GetTargetPath() string {
	if m != nil && m.TargetPath != nil {
		return *m.TargetPath
	}
	return ""
}

type MountDatastoreRet struct {
	// Mount datastore results. Each index's value will correspond to the same
	// index in the request's 'node_ids'.
	MountDatastoreResults []*MountDatastoreRet_MountDatastoreResult `protobuf:"bytes,1,rep,name=mount_datastore_results,json=mountDatastoreResults" json:"mount_datastore_results,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                  `json:"-"`
	XXX_unrecognized      []byte                                    `json:"-"`
	XXX_sizecache         int32                                     `json:"-"`
}

func (m *MountDatastoreRet) Reset()         { *m = MountDatastoreRet{} }
func (m *MountDatastoreRet) String() string { return proto.CompactTextString(m) }
func (*MountDatastoreRet) ProtoMessage()    {}
func (*MountDatastoreRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{34}
}

func (m *MountDatastoreRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MountDatastoreRet.Unmarshal(m, b)
}
func (m *MountDatastoreRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MountDatastoreRet.Marshal(b, m, deterministic)
}
func (m *MountDatastoreRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountDatastoreRet.Merge(m, src)
}
func (m *MountDatastoreRet) XXX_Size() int {
	return xxx_messageInfo_MountDatastoreRet.Size(m)
}
func (m *MountDatastoreRet) XXX_DiscardUnknown() {
	xxx_messageInfo_MountDatastoreRet.DiscardUnknown(m)
}

var xxx_messageInfo_MountDatastoreRet proto.InternalMessageInfo

func (m *MountDatastoreRet) GetMountDatastoreResults() []*MountDatastoreRet_MountDatastoreResult {
	if m != nil {
		return m.MountDatastoreResults
	}
	return nil
}

type MountDatastoreRet_MountDatastoreResult struct {
	// This is the newly created NFS mount. If there is an error, then this
	// will not be set.
	DatastoreInfo *DatastoreInfo `protobuf:"bytes,1,opt,name=datastore_info,json=datastoreInfo" json:"datastore_info,omitempty"`
	// Resulting error encountered while retrieving the newly created datastore
	// (NFS mount). If not set or 'kNoError' then the request to the hypervisor
	// is succeeded.
	Error                *MountDatastoreRet_Error `protobuf:"varint,2,opt,name=error,enum=nutanix.hyperint.MountDatastoreRet_Error,def=0" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *MountDatastoreRet_MountDatastoreResult) Reset() {
	*m = MountDatastoreRet_MountDatastoreResult{}
}
func (m *MountDatastoreRet_MountDatastoreResult) String() string { return proto.CompactTextString(m) }
func (*MountDatastoreRet_MountDatastoreResult) ProtoMessage()    {}
func (*MountDatastoreRet_MountDatastoreResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{34, 0}
}

func (m *MountDatastoreRet_MountDatastoreResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MountDatastoreRet_MountDatastoreResult.Unmarshal(m, b)
}
func (m *MountDatastoreRet_MountDatastoreResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MountDatastoreRet_MountDatastoreResult.Marshal(b, m, deterministic)
}
func (m *MountDatastoreRet_MountDatastoreResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountDatastoreRet_MountDatastoreResult.Merge(m, src)
}
func (m *MountDatastoreRet_MountDatastoreResult) XXX_Size() int {
	return xxx_messageInfo_MountDatastoreRet_MountDatastoreResult.Size(m)
}
func (m *MountDatastoreRet_MountDatastoreResult) XXX_DiscardUnknown() {
	xxx_messageInfo_MountDatastoreRet_MountDatastoreResult.DiscardUnknown(m)
}

var xxx_messageInfo_MountDatastoreRet_MountDatastoreResult proto.InternalMessageInfo

const Default_MountDatastoreRet_MountDatastoreResult_Error MountDatastoreRet_Error = MountDatastoreRet_kNoError

func (m *MountDatastoreRet_MountDatastoreResult) GetDatastoreInfo() *DatastoreInfo {
	if m != nil {
		return m.DatastoreInfo
	}
	return nil
}

func (m *MountDatastoreRet_MountDatastoreResult) GetError() MountDatastoreRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_MountDatastoreRet_MountDatastoreResult_Error
}

type UnmountDatastoreArg struct {
	// List of the IDs of the nodes. When left empty, only the the local node is
	// used to delete/unmount the datastore. When populated, the order of the
	// elements in the list determines the order of the elements in the returned
	// result list.
	NodeIds []int64 `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	// NFS share on the host system to be unmounted.
	MountPoint *string `protobuf:"bytes,2,opt,name=mount_point,json=mountPoint" json:"mount_point,omitempty"`
	// Unique ID assigned to the container by the Nutanix software.
	ContainerId          *int64   `protobuf:"varint,3,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnmountDatastoreArg) Reset()         { *m = UnmountDatastoreArg{} }
func (m *UnmountDatastoreArg) String() string { return proto.CompactTextString(m) }
func (*UnmountDatastoreArg) ProtoMessage()    {}
func (*UnmountDatastoreArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{35}
}

func (m *UnmountDatastoreArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnmountDatastoreArg.Unmarshal(m, b)
}
func (m *UnmountDatastoreArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnmountDatastoreArg.Marshal(b, m, deterministic)
}
func (m *UnmountDatastoreArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnmountDatastoreArg.Merge(m, src)
}
func (m *UnmountDatastoreArg) XXX_Size() int {
	return xxx_messageInfo_UnmountDatastoreArg.Size(m)
}
func (m *UnmountDatastoreArg) XXX_DiscardUnknown() {
	xxx_messageInfo_UnmountDatastoreArg.DiscardUnknown(m)
}

var xxx_messageInfo_UnmountDatastoreArg proto.InternalMessageInfo

func (m *UnmountDatastoreArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

func (m *UnmountDatastoreArg) GetMountPoint() string {
	if m != nil && m.MountPoint != nil {
		return *m.MountPoint
	}
	return ""
}

func (m *UnmountDatastoreArg) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

type UnmountDatastoreRet struct {
	// Unmount datastore results. Each index's value will correspond to the same
	// index in the request's 'node_ids'.
	UnmountDatastoreResults []*UnmountDatastoreRet_UnmountDatastoreResult `protobuf:"bytes,1,rep,name=unmount_datastore_results,json=unmountDatastoreResults" json:"unmount_datastore_results,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                                      `json:"-"`
	XXX_unrecognized        []byte                                        `json:"-"`
	XXX_sizecache           int32                                         `json:"-"`
}

func (m *UnmountDatastoreRet) Reset()         { *m = UnmountDatastoreRet{} }
func (m *UnmountDatastoreRet) String() string { return proto.CompactTextString(m) }
func (*UnmountDatastoreRet) ProtoMessage()    {}
func (*UnmountDatastoreRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{36}
}

func (m *UnmountDatastoreRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnmountDatastoreRet.Unmarshal(m, b)
}
func (m *UnmountDatastoreRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnmountDatastoreRet.Marshal(b, m, deterministic)
}
func (m *UnmountDatastoreRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnmountDatastoreRet.Merge(m, src)
}
func (m *UnmountDatastoreRet) XXX_Size() int {
	return xxx_messageInfo_UnmountDatastoreRet.Size(m)
}
func (m *UnmountDatastoreRet) XXX_DiscardUnknown() {
	xxx_messageInfo_UnmountDatastoreRet.DiscardUnknown(m)
}

var xxx_messageInfo_UnmountDatastoreRet proto.InternalMessageInfo

func (m *UnmountDatastoreRet) GetUnmountDatastoreResults() []*UnmountDatastoreRet_UnmountDatastoreResult {
	if m != nil {
		return m.UnmountDatastoreResults
	}
	return nil
}

type UnmountDatastoreRet_UnmountDatastoreResult struct {
	// Resulting error encountered while unmounting the NFS mount (datastore).
	// If not set or 'kNoError' then the request to the hypervisor is success.
	Error                *UnmountDatastoreRet_Error `protobuf:"varint,2,opt,name=error,enum=nutanix.hyperint.UnmountDatastoreRet_Error,def=0" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *UnmountDatastoreRet_UnmountDatastoreResult) Reset() {
	*m = UnmountDatastoreRet_UnmountDatastoreResult{}
}
func (m *UnmountDatastoreRet_UnmountDatastoreResult) String() string {
	return proto.CompactTextString(m)
}
func (*UnmountDatastoreRet_UnmountDatastoreResult) ProtoMessage() {}
func (*UnmountDatastoreRet_UnmountDatastoreResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{36, 0}
}

func (m *UnmountDatastoreRet_UnmountDatastoreResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UnmountDatastoreRet_UnmountDatastoreResult.Unmarshal(m, b)
}
func (m *UnmountDatastoreRet_UnmountDatastoreResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UnmountDatastoreRet_UnmountDatastoreResult.Marshal(b, m, deterministic)
}
func (m *UnmountDatastoreRet_UnmountDatastoreResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnmountDatastoreRet_UnmountDatastoreResult.Merge(m, src)
}
func (m *UnmountDatastoreRet_UnmountDatastoreResult) XXX_Size() int {
	return xxx_messageInfo_UnmountDatastoreRet_UnmountDatastoreResult.Size(m)
}
func (m *UnmountDatastoreRet_UnmountDatastoreResult) XXX_DiscardUnknown() {
	xxx_messageInfo_UnmountDatastoreRet_UnmountDatastoreResult.DiscardUnknown(m)
}

var xxx_messageInfo_UnmountDatastoreRet_UnmountDatastoreResult proto.InternalMessageInfo

const Default_UnmountDatastoreRet_UnmountDatastoreResult_Error UnmountDatastoreRet_Error = UnmountDatastoreRet_kNoError

func (m *UnmountDatastoreRet_UnmountDatastoreResult) GetError() UnmountDatastoreRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_UnmountDatastoreRet_UnmountDatastoreResult_Error
}

type AttachVirtualCdArg struct {
	// UUID of the virtual machine.
	VmId *string `protobuf:"bytes,1,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// NFS path to the virtual cd.
	// Virtual CDs are always attached to first available IDE CD/DVD-ROM slots.
	// This will result in unmounting any ISO image already attached to the
	// IDE CD-ROM slot.
	NfsFilePath *string `protobuf:"bytes,2,opt,name=nfs_file_path,json=nfsFilePath" json:"nfs_file_path,omitempty"`
	// This parameter defines the scope of the request. If 'cluster_wide' is not
	// set to true, then only VMs local to the hyperint service are considered.
	// Otherwise, the request is sent to all nodes of the cluster to locate the
	// virtual machine and attach the virtual CD.
	ClusterWide *bool `protobuf:"varint,3,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// Idempotency token.
	Uuid *string `protobuf:"bytes,4,opt,name=uuid" json:"uuid,omitempty"`
	// CD label where the virtual CD will be attached.
	CdLabel              *string  `protobuf:"bytes,5,opt,name=cd_label,json=cdLabel" json:"cd_label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachVirtualCdArg) Reset()         { *m = AttachVirtualCdArg{} }
func (m *AttachVirtualCdArg) String() string { return proto.CompactTextString(m) }
func (*AttachVirtualCdArg) ProtoMessage()    {}
func (*AttachVirtualCdArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{37}
}

func (m *AttachVirtualCdArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachVirtualCdArg.Unmarshal(m, b)
}
func (m *AttachVirtualCdArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachVirtualCdArg.Marshal(b, m, deterministic)
}
func (m *AttachVirtualCdArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachVirtualCdArg.Merge(m, src)
}
func (m *AttachVirtualCdArg) XXX_Size() int {
	return xxx_messageInfo_AttachVirtualCdArg.Size(m)
}
func (m *AttachVirtualCdArg) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachVirtualCdArg.DiscardUnknown(m)
}

var xxx_messageInfo_AttachVirtualCdArg proto.InternalMessageInfo

const Default_AttachVirtualCdArg_ClusterWide bool = true

func (m *AttachVirtualCdArg) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *AttachVirtualCdArg) GetNfsFilePath() string {
	if m != nil && m.NfsFilePath != nil {
		return *m.NfsFilePath
	}
	return ""
}

func (m *AttachVirtualCdArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_AttachVirtualCdArg_ClusterWide
}

func (m *AttachVirtualCdArg) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

func (m *AttachVirtualCdArg) GetCdLabel() string {
	if m != nil && m.CdLabel != nil {
		return *m.CdLabel
	}
	return ""
}

type AttachVirtualCdRet struct {
	// Virtual CD attach result.
	AttachResult *AttachVirtualCdRet_Error `protobuf:"varint,1,opt,name=attach_result,json=attachResult,enum=nutanix.hyperint.AttachVirtualCdRet_Error" json:"attach_result,omitempty"`
	// CD label where the virtual CD was attached.
	CdLabel              *string  `protobuf:"bytes,2,opt,name=cd_label,json=cdLabel" json:"cd_label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachVirtualCdRet) Reset()         { *m = AttachVirtualCdRet{} }
func (m *AttachVirtualCdRet) String() string { return proto.CompactTextString(m) }
func (*AttachVirtualCdRet) ProtoMessage()    {}
func (*AttachVirtualCdRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{38}
}

func (m *AttachVirtualCdRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachVirtualCdRet.Unmarshal(m, b)
}
func (m *AttachVirtualCdRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachVirtualCdRet.Marshal(b, m, deterministic)
}
func (m *AttachVirtualCdRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachVirtualCdRet.Merge(m, src)
}
func (m *AttachVirtualCdRet) XXX_Size() int {
	return xxx_messageInfo_AttachVirtualCdRet.Size(m)
}
func (m *AttachVirtualCdRet) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachVirtualCdRet.DiscardUnknown(m)
}

var xxx_messageInfo_AttachVirtualCdRet proto.InternalMessageInfo

func (m *AttachVirtualCdRet) GetAttachResult() AttachVirtualCdRet_Error {
	if m != nil && m.AttachResult != nil {
		return *m.AttachResult
	}
	return AttachVirtualCdRet_kNoError
}

func (m *AttachVirtualCdRet) GetCdLabel() string {
	if m != nil && m.CdLabel != nil {
		return *m.CdLabel
	}
	return ""
}

type DetachVirtualCdArg struct {
	// UUID of the VM.
	VmId *string `protobuf:"bytes,1,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Virtual CD label to be detached (for example, ide0:0).
	CdLabel *string `protobuf:"bytes,2,opt,name=cd_label,json=cdLabel" json:"cd_label,omitempty"`
	// This parameter defines the scope of the request. If 'cluster_wide' is not
	// set to true, then only VMs local to the hyperint service are considered.
	// Otherwise, the request is sent to all nodes of the cluster to locate the
	// virtual machine and detach the virtual CD.
	ClusterWide *bool `protobuf:"varint,3,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// Ignore non-existent cd_label instead of generating an error.
	IgnoreNonExistentCd *bool `protobuf:"varint,4,opt,name=ignore_non_existent_cd,json=ignoreNonExistentCd,def=0" json:"ignore_non_existent_cd,omitempty"`
	// Force unmount of CD-ROM. Applicable for ESX.
	ForceUnmount         *bool    `protobuf:"varint,5,opt,name=force_unmount,json=forceUnmount" json:"force_unmount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachVirtualCdArg) Reset()         { *m = DetachVirtualCdArg{} }
func (m *DetachVirtualCdArg) String() string { return proto.CompactTextString(m) }
func (*DetachVirtualCdArg) ProtoMessage()    {}
func (*DetachVirtualCdArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{39}
}

func (m *DetachVirtualCdArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetachVirtualCdArg.Unmarshal(m, b)
}
func (m *DetachVirtualCdArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetachVirtualCdArg.Marshal(b, m, deterministic)
}
func (m *DetachVirtualCdArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachVirtualCdArg.Merge(m, src)
}
func (m *DetachVirtualCdArg) XXX_Size() int {
	return xxx_messageInfo_DetachVirtualCdArg.Size(m)
}
func (m *DetachVirtualCdArg) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachVirtualCdArg.DiscardUnknown(m)
}

var xxx_messageInfo_DetachVirtualCdArg proto.InternalMessageInfo

const Default_DetachVirtualCdArg_ClusterWide bool = true
const Default_DetachVirtualCdArg_IgnoreNonExistentCd bool = false

func (m *DetachVirtualCdArg) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *DetachVirtualCdArg) GetCdLabel() string {
	if m != nil && m.CdLabel != nil {
		return *m.CdLabel
	}
	return ""
}

func (m *DetachVirtualCdArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_DetachVirtualCdArg_ClusterWide
}

func (m *DetachVirtualCdArg) GetIgnoreNonExistentCd() bool {
	if m != nil && m.IgnoreNonExistentCd != nil {
		return *m.IgnoreNonExistentCd
	}
	return Default_DetachVirtualCdArg_IgnoreNonExistentCd
}

func (m *DetachVirtualCdArg) GetForceUnmount() bool {
	if m != nil && m.ForceUnmount != nil {
		return *m.ForceUnmount
	}
	return false
}

type DetachVirtualCdRet struct {
	// Overall result for detach virtual CD.
	DetachResult         *DetachVirtualCdRet_Error `protobuf:"varint,1,opt,name=detach_result,json=detachResult,enum=nutanix.hyperint.DetachVirtualCdRet_Error" json:"detach_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *DetachVirtualCdRet) Reset()         { *m = DetachVirtualCdRet{} }
func (m *DetachVirtualCdRet) String() string { return proto.CompactTextString(m) }
func (*DetachVirtualCdRet) ProtoMessage()    {}
func (*DetachVirtualCdRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{40}
}

func (m *DetachVirtualCdRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetachVirtualCdRet.Unmarshal(m, b)
}
func (m *DetachVirtualCdRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetachVirtualCdRet.Marshal(b, m, deterministic)
}
func (m *DetachVirtualCdRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachVirtualCdRet.Merge(m, src)
}
func (m *DetachVirtualCdRet) XXX_Size() int {
	return xxx_messageInfo_DetachVirtualCdRet.Size(m)
}
func (m *DetachVirtualCdRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachVirtualCdRet.DiscardUnknown(m)
}

var xxx_messageInfo_DetachVirtualCdRet proto.InternalMessageInfo

func (m *DetachVirtualCdRet) GetDetachResult() DetachVirtualCdRet_Error {
	if m != nil && m.DetachResult != nil {
		return *m.DetachResult
	}
	return DetachVirtualCdRet_kNoError
}

type AttachVirtualDiskArg struct {
	// UUID of the virtual machine.
	VmId         *string                                 `protobuf:"bytes,1,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	VirtualDisks []*AttachVirtualDiskArg_VirtualDiskSpec `protobuf:"bytes,2,rep,name=virtual_disks,json=virtualDisks" json:"virtual_disks,omitempty"`
	// This parameter defines the scope of the request. If 'cluster_wide' is not
	// set to true, then only VMs local to the hyperint service are considered.
	// Otherwise, the request is sent to all nodes of the cluster to locate the
	// virtual machine and attach the virtual disks.
	ClusterWide *bool `protobuf:"varint,3,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// Generate new virtual disk uuid before attach. Applies to all virtual
	// disks.
	GenerateNewDiskUuid  *bool    `protobuf:"varint,4,opt,name=generate_new_disk_uuid,json=generateNewDiskUuid,def=0" json:"generate_new_disk_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachVirtualDiskArg) Reset()         { *m = AttachVirtualDiskArg{} }
func (m *AttachVirtualDiskArg) String() string { return proto.CompactTextString(m) }
func (*AttachVirtualDiskArg) ProtoMessage()    {}
func (*AttachVirtualDiskArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{41}
}

func (m *AttachVirtualDiskArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachVirtualDiskArg.Unmarshal(m, b)
}
func (m *AttachVirtualDiskArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachVirtualDiskArg.Marshal(b, m, deterministic)
}
func (m *AttachVirtualDiskArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachVirtualDiskArg.Merge(m, src)
}
func (m *AttachVirtualDiskArg) XXX_Size() int {
	return xxx_messageInfo_AttachVirtualDiskArg.Size(m)
}
func (m *AttachVirtualDiskArg) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachVirtualDiskArg.DiscardUnknown(m)
}

var xxx_messageInfo_AttachVirtualDiskArg proto.InternalMessageInfo

const Default_AttachVirtualDiskArg_ClusterWide bool = true
const Default_AttachVirtualDiskArg_GenerateNewDiskUuid bool = false

func (m *AttachVirtualDiskArg) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *AttachVirtualDiskArg) GetVirtualDisks() []*AttachVirtualDiskArg_VirtualDiskSpec {
	if m != nil {
		return m.VirtualDisks
	}
	return nil
}

func (m *AttachVirtualDiskArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_AttachVirtualDiskArg_ClusterWide
}

func (m *AttachVirtualDiskArg) GetGenerateNewDiskUuid() bool {
	if m != nil && m.GenerateNewDiskUuid != nil {
		return *m.GenerateNewDiskUuid
	}
	return Default_AttachVirtualDiskArg_GenerateNewDiskUuid
}

// Virtual disks information. Disk attach is an atomic operation,
// either all or no virtual disks will be attached. The slot (controller,
// location) - for example, scsi1:1, will be auto-selected by the hypervisor.
type AttachVirtualDiskArg_VirtualDiskSpec struct {
	// NFS path to the virtual disk.
	NfsFilePath *string `protobuf:"bytes,1,opt,name=nfs_file_path,json=nfsFilePath" json:"nfs_file_path,omitempty"`
	// Adapter type for this virtual disk.
	AdapterType *VirtualDisk_AdapterType `protobuf:"varint,2,opt,name=adapter_type,json=adapterType,enum=nutanix.hyperint.VirtualDisk_AdapterType" json:"adapter_type,omitempty"`
	// Idempotency token.
	Uuid                 *string  `protobuf:"bytes,3,opt,name=uuid" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachVirtualDiskArg_VirtualDiskSpec) Reset()         { *m = AttachVirtualDiskArg_VirtualDiskSpec{} }
func (m *AttachVirtualDiskArg_VirtualDiskSpec) String() string { return proto.CompactTextString(m) }
func (*AttachVirtualDiskArg_VirtualDiskSpec) ProtoMessage()    {}
func (*AttachVirtualDiskArg_VirtualDiskSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{41, 0}
}

func (m *AttachVirtualDiskArg_VirtualDiskSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachVirtualDiskArg_VirtualDiskSpec.Unmarshal(m, b)
}
func (m *AttachVirtualDiskArg_VirtualDiskSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachVirtualDiskArg_VirtualDiskSpec.Marshal(b, m, deterministic)
}
func (m *AttachVirtualDiskArg_VirtualDiskSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachVirtualDiskArg_VirtualDiskSpec.Merge(m, src)
}
func (m *AttachVirtualDiskArg_VirtualDiskSpec) XXX_Size() int {
	return xxx_messageInfo_AttachVirtualDiskArg_VirtualDiskSpec.Size(m)
}
func (m *AttachVirtualDiskArg_VirtualDiskSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachVirtualDiskArg_VirtualDiskSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AttachVirtualDiskArg_VirtualDiskSpec proto.InternalMessageInfo

func (m *AttachVirtualDiskArg_VirtualDiskSpec) GetNfsFilePath() string {
	if m != nil && m.NfsFilePath != nil {
		return *m.NfsFilePath
	}
	return ""
}

func (m *AttachVirtualDiskArg_VirtualDiskSpec) GetAdapterType() VirtualDisk_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return VirtualDisk_kSCSI
}

func (m *AttachVirtualDiskArg_VirtualDiskSpec) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

type AttachVirtualDiskRet struct {
	// Overall virtual disk attach result. Virtual disk attach is an atomic
	// operation - either all or no virtual disks will be attached.
	AttachResult     *AttachVirtualDiskRet_Error              `protobuf:"varint,1,opt,name=attach_result,json=attachResult,enum=nutanix.hyperint.AttachVirtualDiskRet_Error" json:"attach_result,omitempty"`
	AttachedDiskInfo []*AttachVirtualDiskRet_AttachedDiskInfo `protobuf:"bytes,2,rep,name=attached_disk_info,json=attachedDiskInfo" json:"attached_disk_info,omitempty"`
	// Optional error detail.
	ErrorDetail          *string  `protobuf:"bytes,3,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachVirtualDiskRet) Reset()         { *m = AttachVirtualDiskRet{} }
func (m *AttachVirtualDiskRet) String() string { return proto.CompactTextString(m) }
func (*AttachVirtualDiskRet) ProtoMessage()    {}
func (*AttachVirtualDiskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{42}
}

func (m *AttachVirtualDiskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachVirtualDiskRet.Unmarshal(m, b)
}
func (m *AttachVirtualDiskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachVirtualDiskRet.Marshal(b, m, deterministic)
}
func (m *AttachVirtualDiskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachVirtualDiskRet.Merge(m, src)
}
func (m *AttachVirtualDiskRet) XXX_Size() int {
	return xxx_messageInfo_AttachVirtualDiskRet.Size(m)
}
func (m *AttachVirtualDiskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachVirtualDiskRet.DiscardUnknown(m)
}

var xxx_messageInfo_AttachVirtualDiskRet proto.InternalMessageInfo

func (m *AttachVirtualDiskRet) GetAttachResult() AttachVirtualDiskRet_Error {
	if m != nil && m.AttachResult != nil {
		return *m.AttachResult
	}
	return AttachVirtualDiskRet_kNoError
}

func (m *AttachVirtualDiskRet) GetAttachedDiskInfo() []*AttachVirtualDiskRet_AttachedDiskInfo {
	if m != nil {
		return m.AttachedDiskInfo
	}
	return nil
}

func (m *AttachVirtualDiskRet) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

// Information about attached disks.
type AttachVirtualDiskRet_AttachedDiskInfo struct {
	// Disk label (for example, scsi0:0) where the virtual disk was attached on
	// a successful operation. This indicate the location of the virtual disk
	// within the VM.
	DiskLabel *string `protobuf:"bytes,1,opt,name=disk_label,json=diskLabel" json:"disk_label,omitempty"`
	// Disk uuid corresponding to the disk label.
	DiskUuid             *string  `protobuf:"bytes,2,opt,name=disk_uuid,json=diskUuid" json:"disk_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachVirtualDiskRet_AttachedDiskInfo) Reset()         { *m = AttachVirtualDiskRet_AttachedDiskInfo{} }
func (m *AttachVirtualDiskRet_AttachedDiskInfo) String() string { return proto.CompactTextString(m) }
func (*AttachVirtualDiskRet_AttachedDiskInfo) ProtoMessage()    {}
func (*AttachVirtualDiskRet_AttachedDiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{42, 0}
}

func (m *AttachVirtualDiskRet_AttachedDiskInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachVirtualDiskRet_AttachedDiskInfo.Unmarshal(m, b)
}
func (m *AttachVirtualDiskRet_AttachedDiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachVirtualDiskRet_AttachedDiskInfo.Marshal(b, m, deterministic)
}
func (m *AttachVirtualDiskRet_AttachedDiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachVirtualDiskRet_AttachedDiskInfo.Merge(m, src)
}
func (m *AttachVirtualDiskRet_AttachedDiskInfo) XXX_Size() int {
	return xxx_messageInfo_AttachVirtualDiskRet_AttachedDiskInfo.Size(m)
}
func (m *AttachVirtualDiskRet_AttachedDiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachVirtualDiskRet_AttachedDiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AttachVirtualDiskRet_AttachedDiskInfo proto.InternalMessageInfo

func (m *AttachVirtualDiskRet_AttachedDiskInfo) GetDiskLabel() string {
	if m != nil && m.DiskLabel != nil {
		return *m.DiskLabel
	}
	return ""
}

func (m *AttachVirtualDiskRet_AttachedDiskInfo) GetDiskUuid() string {
	if m != nil && m.DiskUuid != nil {
		return *m.DiskUuid
	}
	return ""
}

type DetachVirtualDiskArg struct {
	// UUID of the VM.
	VmId *string `protobuf:"bytes,1,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Virtual disk labels to be detached (for example, scsi0:0).
	// Detach is an atomic operation, either all or no virtual disks will be
	// detached.
	DiskLabels []string `protobuf:"bytes,2,rep,name=disk_labels,json=diskLabels" json:"disk_labels,omitempty"`
	// This parameter defines the scope of the request. If 'cluster_wide' is not
	// set to true, then only VMs local to the hyperint service are considered.
	// Otherwise, the request is sent to all nodes of the cluster to locate the
	// virtual machine and detach the virtual disks.
	ClusterWide *bool `protobuf:"varint,3,opt,name=cluster_wide,json=clusterWide,def=1" json:"cluster_wide,omitempty"`
	// Ignore non-existent disk labels instead of generating an error.
	IgnoreNonExistentDisks *bool    `protobuf:"varint,4,opt,name=ignore_non_existent_disks,json=ignoreNonExistentDisks,def=0" json:"ignore_non_existent_disks,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *DetachVirtualDiskArg) Reset()         { *m = DetachVirtualDiskArg{} }
func (m *DetachVirtualDiskArg) String() string { return proto.CompactTextString(m) }
func (*DetachVirtualDiskArg) ProtoMessage()    {}
func (*DetachVirtualDiskArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{43}
}

func (m *DetachVirtualDiskArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetachVirtualDiskArg.Unmarshal(m, b)
}
func (m *DetachVirtualDiskArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetachVirtualDiskArg.Marshal(b, m, deterministic)
}
func (m *DetachVirtualDiskArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachVirtualDiskArg.Merge(m, src)
}
func (m *DetachVirtualDiskArg) XXX_Size() int {
	return xxx_messageInfo_DetachVirtualDiskArg.Size(m)
}
func (m *DetachVirtualDiskArg) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachVirtualDiskArg.DiscardUnknown(m)
}

var xxx_messageInfo_DetachVirtualDiskArg proto.InternalMessageInfo

const Default_DetachVirtualDiskArg_ClusterWide bool = true
const Default_DetachVirtualDiskArg_IgnoreNonExistentDisks bool = false

func (m *DetachVirtualDiskArg) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *DetachVirtualDiskArg) GetDiskLabels() []string {
	if m != nil {
		return m.DiskLabels
	}
	return nil
}

func (m *DetachVirtualDiskArg) GetClusterWide() bool {
	if m != nil && m.ClusterWide != nil {
		return *m.ClusterWide
	}
	return Default_DetachVirtualDiskArg_ClusterWide
}

func (m *DetachVirtualDiskArg) GetIgnoreNonExistentDisks() bool {
	if m != nil && m.IgnoreNonExistentDisks != nil {
		return *m.IgnoreNonExistentDisks
	}
	return Default_DetachVirtualDiskArg_IgnoreNonExistentDisks
}

type DetachVirtualDiskRet struct {
	// Overall result for detach virtual disks. Detach is an atomic operation,
	// either all or no virtual disks will be detached.
	DetachResult *DetachVirtualDiskRet_Error `protobuf:"varint,1,opt,name=detach_result,json=detachResult,enum=nutanix.hyperint.DetachVirtualDiskRet_Error" json:"detach_result,omitempty"`
	// Additional error detail.
	ErrorDetail          *string  `protobuf:"bytes,2,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachVirtualDiskRet) Reset()         { *m = DetachVirtualDiskRet{} }
func (m *DetachVirtualDiskRet) String() string { return proto.CompactTextString(m) }
func (*DetachVirtualDiskRet) ProtoMessage()    {}
func (*DetachVirtualDiskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{44}
}

func (m *DetachVirtualDiskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetachVirtualDiskRet.Unmarshal(m, b)
}
func (m *DetachVirtualDiskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetachVirtualDiskRet.Marshal(b, m, deterministic)
}
func (m *DetachVirtualDiskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachVirtualDiskRet.Merge(m, src)
}
func (m *DetachVirtualDiskRet) XXX_Size() int {
	return xxx_messageInfo_DetachVirtualDiskRet.Size(m)
}
func (m *DetachVirtualDiskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachVirtualDiskRet.DiscardUnknown(m)
}

var xxx_messageInfo_DetachVirtualDiskRet proto.InternalMessageInfo

func (m *DetachVirtualDiskRet) GetDetachResult() DetachVirtualDiskRet_Error {
	if m != nil && m.DetachResult != nil {
		return *m.DetachResult
	}
	return DetachVirtualDiskRet_kNoError
}

func (m *DetachVirtualDiskRet) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

type ModifyVirtualDiskArg struct {
	// Path name for NFS backed virtual disks. One entry for each virtual disk
	// pointing to the primary virtual disk file (for example, a.vmdk).
	NfsFilePaths []string `protobuf:"bytes,1,rep,name=nfs_file_paths,json=nfsFilePaths" json:"nfs_file_paths,omitempty"`
	// Generate new virtual disk uuid.
	GenerateNewUuid      *bool    `protobuf:"varint,2,opt,name=generate_new_uuid,json=generateNewUuid" json:"generate_new_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModifyVirtualDiskArg) Reset()         { *m = ModifyVirtualDiskArg{} }
func (m *ModifyVirtualDiskArg) String() string { return proto.CompactTextString(m) }
func (*ModifyVirtualDiskArg) ProtoMessage()    {}
func (*ModifyVirtualDiskArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{45}
}

func (m *ModifyVirtualDiskArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModifyVirtualDiskArg.Unmarshal(m, b)
}
func (m *ModifyVirtualDiskArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModifyVirtualDiskArg.Marshal(b, m, deterministic)
}
func (m *ModifyVirtualDiskArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyVirtualDiskArg.Merge(m, src)
}
func (m *ModifyVirtualDiskArg) XXX_Size() int {
	return xxx_messageInfo_ModifyVirtualDiskArg.Size(m)
}
func (m *ModifyVirtualDiskArg) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyVirtualDiskArg.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyVirtualDiskArg proto.InternalMessageInfo

func (m *ModifyVirtualDiskArg) GetNfsFilePaths() []string {
	if m != nil {
		return m.NfsFilePaths
	}
	return nil
}

func (m *ModifyVirtualDiskArg) GetGenerateNewUuid() bool {
	if m != nil && m.GenerateNewUuid != nil {
		return *m.GenerateNewUuid
	}
	return false
}

type ModifyVirtualDiskRet struct {
	// Virtual disk modify result, one per virtual disk.
	ModifyResults []ModifyVirtualDiskRet_Error `protobuf:"varint,1,rep,name=modify_results,json=modifyResults,enum=nutanix.hyperint.ModifyVirtualDiskRet_Error" json:"modify_results,omitempty"`
	// Set of new uuids - one per virtual disk. Entry will be empty if there
	// was an error in modifying the specific virtual disk.
	NewUuids             []string `protobuf:"bytes,2,rep,name=new_uuids,json=newUuids" json:"new_uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModifyVirtualDiskRet) Reset()         { *m = ModifyVirtualDiskRet{} }
func (m *ModifyVirtualDiskRet) String() string { return proto.CompactTextString(m) }
func (*ModifyVirtualDiskRet) ProtoMessage()    {}
func (*ModifyVirtualDiskRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{46}
}

func (m *ModifyVirtualDiskRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModifyVirtualDiskRet.Unmarshal(m, b)
}
func (m *ModifyVirtualDiskRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModifyVirtualDiskRet.Marshal(b, m, deterministic)
}
func (m *ModifyVirtualDiskRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyVirtualDiskRet.Merge(m, src)
}
func (m *ModifyVirtualDiskRet) XXX_Size() int {
	return xxx_messageInfo_ModifyVirtualDiskRet.Size(m)
}
func (m *ModifyVirtualDiskRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyVirtualDiskRet.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyVirtualDiskRet proto.InternalMessageInfo

func (m *ModifyVirtualDiskRet) GetModifyResults() []ModifyVirtualDiskRet_Error {
	if m != nil {
		return m.ModifyResults
	}
	return nil
}

func (m *ModifyVirtualDiskRet) GetNewUuids() []string {
	if m != nil {
		return m.NewUuids
	}
	return nil
}

type CreateVmArg struct {
	// VM UUID for idempotency.
	VmId *string `protobuf:"bytes,1,opt,name=vm_id,json=vmId" json:"vm_id,omitempty"`
	// Name of the virtual machine.
	VmName *string `protobuf:"bytes,2,opt,name=vm_name,json=vmName" json:"vm_name,omitempty"`
	// Number of vCPUs.
	NumVcpus *uint32 `protobuf:"varint,3,opt,name=num_vcpus,json=numVcpus" json:"num_vcpus,omitempty"`
	// Number of cores per vCPU.
	NumCoresPerVcpu *uint32 `protobuf:"varint,4,opt,name=num_cores_per_vcpu,json=numCoresPerVcpu" json:"num_cores_per_vcpu,omitempty"`
	// vCPU reservation in hertz.
	// Recommended value: May not be supported by hypervisor.
	VcpuReservationHz *uint64 `protobuf:"varint,5,opt,name=vcpu_reservation_hz,json=vcpuReservationHz" json:"vcpu_reservation_hz,omitempty"`
	// Memory size in bytes.
	MemorySizeBytes *uint64 `protobuf:"varint,6,opt,name=memory_size_bytes,json=memorySizeBytes" json:"memory_size_bytes,omitempty"`
	// Memory reservation size in bytes.
	// Recommended value: May not be supported by hypervisor.
	MemoryReservationBytes *uint64                                   `protobuf:"varint,7,opt,name=memory_reservation_bytes,json=memoryReservationBytes" json:"memory_reservation_bytes,omitempty"`
	VirtualStorageDevices  []*CreateVmArg_VirtualStorageDeviceConfig `protobuf:"bytes,8,rep,name=virtual_storage_devices,json=virtualStorageDevices" json:"virtual_storage_devices,omitempty"`
	// VM placement parameters.
	// The hypervisor type for VM placement.
	HypervisorType *config.ConfigurationProto_ManagementServer_HypervisorType `protobuf:"varint,9,opt,name=hypervisor_type,json=hypervisorType,enum=nutanix.zeus.ConfigurationProto_ManagementServer_HypervisorType" json:"hypervisor_type,omitempty"`
	// Node service VM ID where the VM needs to be placed.
	NodeId          *int64                                       `protobuf:"varint,10,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	NetworkAdapters []*CreateVmArg_VirtualL2NetworkAdapterConfig `protobuf:"bytes,11,rep,name=network_adapters,json=networkAdapters" json:"network_adapters,omitempty"`
	// Container on which the VM configuration files should be created.
	// Applicable for ESX, Hyper-V.
	VmContainerName *string `protobuf:"bytes,12,opt,name=vm_container_name,json=vmContainerName" json:"vm_container_name,omitempty"`
	// Guest OS ID for VMware.
	GuestOsId *string `protobuf:"bytes,13,opt,name=guest_os_id,json=guestOsId" json:"guest_os_id,omitempty"`
	// Guest OS name.
	GuestOsName *string `protobuf:"bytes,14,opt,name=guest_os_name,json=guestOsName" json:"guest_os_name,omitempty"`
	// This is specific to ESX. If specified, the VM configuration directory
	// will be placed under vm_path_prefix instead of directly under the
	// vm_contianer_name.
	VmPathPrefix *string `protobuf:"bytes,15,opt,name=vm_path_prefix,json=vmPathPrefix" json:"vm_path_prefix,omitempty"`
	// Boot configuration.
	BootConfig           *VmBootConfig `protobuf:"bytes,16,opt,name=boot_config,json=bootConfig" json:"boot_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CreateVmArg) Reset()         { *m = CreateVmArg{} }
func (m *CreateVmArg) String() string { return proto.CompactTextString(m) }
func (*CreateVmArg) ProtoMessage()    {}
func (*CreateVmArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{47}
}

func (m *CreateVmArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateVmArg.Unmarshal(m, b)
}
func (m *CreateVmArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateVmArg.Marshal(b, m, deterministic)
}
func (m *CreateVmArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVmArg.Merge(m, src)
}
func (m *CreateVmArg) XXX_Size() int {
	return xxx_messageInfo_CreateVmArg.Size(m)
}
func (m *CreateVmArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVmArg.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVmArg proto.InternalMessageInfo

func (m *CreateVmArg) GetVmId() string {
	if m != nil && m.VmId != nil {
		return *m.VmId
	}
	return ""
}

func (m *CreateVmArg) GetVmName() string {
	if m != nil && m.VmName != nil {
		return *m.VmName
	}
	return ""
}

func (m *CreateVmArg) GetNumVcpus() uint32 {
	if m != nil && m.NumVcpus != nil {
		return *m.NumVcpus
	}
	return 0
}

func (m *CreateVmArg) GetNumCoresPerVcpu() uint32 {
	if m != nil && m.NumCoresPerVcpu != nil {
		return *m.NumCoresPerVcpu
	}
	return 0
}

func (m *CreateVmArg) GetVcpuReservationHz() uint64 {
	if m != nil && m.VcpuReservationHz != nil {
		return *m.VcpuReservationHz
	}
	return 0
}

func (m *CreateVmArg) GetMemorySizeBytes() uint64 {
	if m != nil && m.MemorySizeBytes != nil {
		return *m.MemorySizeBytes
	}
	return 0
}

func (m *CreateVmArg) GetMemoryReservationBytes() uint64 {
	if m != nil && m.MemoryReservationBytes != nil {
		return *m.MemoryReservationBytes
	}
	return 0
}

func (m *CreateVmArg) GetVirtualStorageDevices() []*CreateVmArg_VirtualStorageDeviceConfig {
	if m != nil {
		return m.VirtualStorageDevices
	}
	return nil
}

func (m *CreateVmArg) GetHypervisorType() config.ConfigurationProto_ManagementServer_HypervisorType {
	if m != nil && m.HypervisorType != nil {
		return *m.HypervisorType
	}
	return config.ConfigurationProto_ManagementServer_kVMware
}

func (m *CreateVmArg) GetNodeId() int64 {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return 0
}

func (m *CreateVmArg) GetNetworkAdapters() []*CreateVmArg_VirtualL2NetworkAdapterConfig {
	if m != nil {
		return m.NetworkAdapters
	}
	return nil
}

func (m *CreateVmArg) GetVmContainerName() string {
	if m != nil && m.VmContainerName != nil {
		return *m.VmContainerName
	}
	return ""
}

func (m *CreateVmArg) GetGuestOsId() string {
	if m != nil && m.GuestOsId != nil {
		return *m.GuestOsId
	}
	return ""
}

func (m *CreateVmArg) GetGuestOsName() string {
	if m != nil && m.GuestOsName != nil {
		return *m.GuestOsName
	}
	return ""
}

func (m *CreateVmArg) GetVmPathPrefix() string {
	if m != nil && m.VmPathPrefix != nil {
		return *m.VmPathPrefix
	}
	return ""
}

func (m *CreateVmArg) GetBootConfig() *VmBootConfig {
	if m != nil {
		return m.BootConfig
	}
	return nil
}

// Information about virtual storage device.
type CreateVmArg_VirtualStorageDeviceConfig struct {
	// Whether this device denotes a virtual cdrom.
	IsCdrom *bool `protobuf:"varint,1,opt,name=is_cdrom,json=isCdrom" json:"is_cdrom,omitempty"`
	// For cdrom: an empty 'nfs_path' along with 'is_cdrom_empty' indicates
	//            if the cdrom device is empty.
	// For disk: NFS path to existing virtual disk.
	//           Exactly one of 'nfs_path' or 'capacity_bytes' should be set.
	// The underlying implementation can clone from this NFS path.
	// The original file should be untouched.
	NfsPath *string `protobuf:"bytes,2,opt,name=nfs_path,json=nfsPath" json:"nfs_path,omitempty"`
	// Device adapter type.
	AdapterType *VirtualDisk_AdapterType `protobuf:"varint,3,opt,name=adapter_type,json=adapterType,enum=nutanix.hyperint.VirtualDisk_AdapterType" json:"adapter_type,omitempty"`
	// Index number of the device for the adapter type. This value is used
	// to preserve ordering of devices for the adapter type.
	Index *uint32 `protobuf:"varint,4,opt,name=index" json:"index,omitempty"`
	// Whether the virtual cdrom device is empty.
	IsCdromEmpty *bool `protobuf:"varint,5,opt,name=is_cdrom_empty,json=isCdromEmpty" json:"is_cdrom_empty,omitempty"`
	// The following fields are applicable only for virtual disks.
	// Capacity in bytes for new virtual disk.
	CapacityBytes *uint64 `protobuf:"varint,6,opt,name=capacity_bytes,json=capacityBytes" json:"capacity_bytes,omitempty"`
	// Whether the disk is thin provisioned.
	IsThinProvisioned *bool `protobuf:"varint,7,opt,name=is_thin_provisioned,json=isThinProvisioned" json:"is_thin_provisioned,omitempty"`
	// Container name for new virtual disk. If unset, default VM container
	// (vm_container_name) will be used.
	ContainerName        *string  `protobuf:"bytes,8,opt,name=container_name,json=containerName" json:"container_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) Reset() {
	*m = CreateVmArg_VirtualStorageDeviceConfig{}
}
func (m *CreateVmArg_VirtualStorageDeviceConfig) String() string { return proto.CompactTextString(m) }
func (*CreateVmArg_VirtualStorageDeviceConfig) ProtoMessage()    {}
func (*CreateVmArg_VirtualStorageDeviceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{47, 0}
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateVmArg_VirtualStorageDeviceConfig.Unmarshal(m, b)
}
func (m *CreateVmArg_VirtualStorageDeviceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateVmArg_VirtualStorageDeviceConfig.Marshal(b, m, deterministic)
}
func (m *CreateVmArg_VirtualStorageDeviceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVmArg_VirtualStorageDeviceConfig.Merge(m, src)
}
func (m *CreateVmArg_VirtualStorageDeviceConfig) XXX_Size() int {
	return xxx_messageInfo_CreateVmArg_VirtualStorageDeviceConfig.Size(m)
}
func (m *CreateVmArg_VirtualStorageDeviceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVmArg_VirtualStorageDeviceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVmArg_VirtualStorageDeviceConfig proto.InternalMessageInfo

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetIsCdrom() bool {
	if m != nil && m.IsCdrom != nil {
		return *m.IsCdrom
	}
	return false
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetNfsPath() string {
	if m != nil && m.NfsPath != nil {
		return *m.NfsPath
	}
	return ""
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetAdapterType() VirtualDisk_AdapterType {
	if m != nil && m.AdapterType != nil {
		return *m.AdapterType
	}
	return VirtualDisk_kSCSI
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetIsCdromEmpty() bool {
	if m != nil && m.IsCdromEmpty != nil {
		return *m.IsCdromEmpty
	}
	return false
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetCapacityBytes() uint64 {
	if m != nil && m.CapacityBytes != nil {
		return *m.CapacityBytes
	}
	return 0
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetIsThinProvisioned() bool {
	if m != nil && m.IsThinProvisioned != nil {
		return *m.IsThinProvisioned
	}
	return false
}

func (m *CreateVmArg_VirtualStorageDeviceConfig) GetContainerName() string {
	if m != nil && m.ContainerName != nil {
		return *m.ContainerName
	}
	return ""
}

// Virtual L2 network adapter configuration.
type CreateVmArg_VirtualL2NetworkAdapterConfig struct {
	// L2 network configuration.
	L2Config             *VmL2NetworkConfig `protobuf:"bytes,1,opt,name=l2_config,json=l2Config" json:"l2_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) Reset() {
	*m = CreateVmArg_VirtualL2NetworkAdapterConfig{}
}
func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) String() string { return proto.CompactTextString(m) }
func (*CreateVmArg_VirtualL2NetworkAdapterConfig) ProtoMessage()    {}
func (*CreateVmArg_VirtualL2NetworkAdapterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{47, 1}
}

func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateVmArg_VirtualL2NetworkAdapterConfig.Unmarshal(m, b)
}
func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateVmArg_VirtualL2NetworkAdapterConfig.Marshal(b, m, deterministic)
}
func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVmArg_VirtualL2NetworkAdapterConfig.Merge(m, src)
}
func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) XXX_Size() int {
	return xxx_messageInfo_CreateVmArg_VirtualL2NetworkAdapterConfig.Size(m)
}
func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVmArg_VirtualL2NetworkAdapterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVmArg_VirtualL2NetworkAdapterConfig proto.InternalMessageInfo

func (m *CreateVmArg_VirtualL2NetworkAdapterConfig) GetL2Config() *VmL2NetworkConfig {
	if m != nil {
		return m.L2Config
	}
	return nil
}

type CreateVmRet struct {
	// Overall result for the create VM request.
	CreateResult *CreateVmRet_Error `protobuf:"varint,1,opt,name=create_result,json=createResult,enum=nutanix.hyperint.CreateVmRet_Error" json:"create_result,omitempty"`
	// If successful, information about the newly created VM.
	VmInfo               *VmInfo  `protobuf:"bytes,2,opt,name=vm_info,json=vmInfo" json:"vm_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVmRet) Reset()         { *m = CreateVmRet{} }
func (m *CreateVmRet) String() string { return proto.CompactTextString(m) }
func (*CreateVmRet) ProtoMessage()    {}
func (*CreateVmRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{48}
}

func (m *CreateVmRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateVmRet.Unmarshal(m, b)
}
func (m *CreateVmRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateVmRet.Marshal(b, m, deterministic)
}
func (m *CreateVmRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVmRet.Merge(m, src)
}
func (m *CreateVmRet) XXX_Size() int {
	return xxx_messageInfo_CreateVmRet.Size(m)
}
func (m *CreateVmRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVmRet.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVmRet proto.InternalMessageInfo

func (m *CreateVmRet) GetCreateResult() CreateVmRet_Error {
	if m != nil && m.CreateResult != nil {
		return *m.CreateResult
	}
	return CreateVmRet_kNoError
}

func (m *CreateVmRet) GetVmInfo() *VmInfo {
	if m != nil {
		return m.VmInfo
	}
	return nil
}

type CloneVmArg struct {
	// Only one of 'create_clone' or 'query_clone_task' should be populated.
	//
	// Configuration for creating VM clone.
	CreateClone *CloneVmArg_CreateClone `protobuf:"bytes,1,opt,name=create_clone,json=createClone" json:"create_clone,omitempty"`
	// Configuration for querying VM clone.
	QueryCloneTask       *CloneVmArg_QueryCloneTask `protobuf:"bytes,2,opt,name=query_clone_task,json=queryCloneTask" json:"query_clone_task,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *CloneVmArg) Reset()         { *m = CloneVmArg{} }
func (m *CloneVmArg) String() string { return proto.CompactTextString(m) }
func (*CloneVmArg) ProtoMessage()    {}
func (*CloneVmArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{49}
}

func (m *CloneVmArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloneVmArg.Unmarshal(m, b)
}
func (m *CloneVmArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloneVmArg.Marshal(b, m, deterministic)
}
func (m *CloneVmArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneVmArg.Merge(m, src)
}
func (m *CloneVmArg) XXX_Size() int {
	return xxx_messageInfo_CloneVmArg.Size(m)
}
func (m *CloneVmArg) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneVmArg.DiscardUnknown(m)
}

var xxx_messageInfo_CloneVmArg proto.InternalMessageInfo

func (m *CloneVmArg) GetCreateClone() *CloneVmArg_CreateClone {
	if m != nil {
		return m.CreateClone
	}
	return nil
}

func (m *CloneVmArg) GetQueryCloneTask() *CloneVmArg_QueryCloneTask {
	if m != nil {
		return m.QueryCloneTask
	}
	return nil
}

type CloneVmArg_CreateClone struct {
	// UUID of virtual machine which is to be cloned.
	SourceVmId           *string  `protobuf:"bytes,1,opt,name=source_vm_id,json=sourceVmId" json:"source_vm_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloneVmArg_CreateClone) Reset()         { *m = CloneVmArg_CreateClone{} }
func (m *CloneVmArg_CreateClone) String() string { return proto.CompactTextString(m) }
func (*CloneVmArg_CreateClone) ProtoMessage()    {}
func (*CloneVmArg_CreateClone) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{49, 0}
}

func (m *CloneVmArg_CreateClone) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloneVmArg_CreateClone.Unmarshal(m, b)
}
func (m *CloneVmArg_CreateClone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloneVmArg_CreateClone.Marshal(b, m, deterministic)
}
func (m *CloneVmArg_CreateClone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneVmArg_CreateClone.Merge(m, src)
}
func (m *CloneVmArg_CreateClone) XXX_Size() int {
	return xxx_messageInfo_CloneVmArg_CreateClone.Size(m)
}
func (m *CloneVmArg_CreateClone) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneVmArg_CreateClone.DiscardUnknown(m)
}

var xxx_messageInfo_CloneVmArg_CreateClone proto.InternalMessageInfo

func (m *CloneVmArg_CreateClone) GetSourceVmId() string {
	if m != nil && m.SourceVmId != nil {
		return *m.SourceVmId
	}
	return ""
}

type CloneVmArg_QueryCloneTask struct {
	// Required. Task handle for VM clone task.
	TaskHandle           *string  `protobuf:"bytes,1,opt,name=task_handle,json=taskHandle" json:"task_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloneVmArg_QueryCloneTask) Reset()         { *m = CloneVmArg_QueryCloneTask{} }
func (m *CloneVmArg_QueryCloneTask) String() string { return proto.CompactTextString(m) }
func (*CloneVmArg_QueryCloneTask) ProtoMessage()    {}
func (*CloneVmArg_QueryCloneTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{49, 1}
}

func (m *CloneVmArg_QueryCloneTask) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloneVmArg_QueryCloneTask.Unmarshal(m, b)
}
func (m *CloneVmArg_QueryCloneTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloneVmArg_QueryCloneTask.Marshal(b, m, deterministic)
}
func (m *CloneVmArg_QueryCloneTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneVmArg_QueryCloneTask.Merge(m, src)
}
func (m *CloneVmArg_QueryCloneTask) XXX_Size() int {
	return xxx_messageInfo_CloneVmArg_QueryCloneTask.Size(m)
}
func (m *CloneVmArg_QueryCloneTask) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneVmArg_QueryCloneTask.DiscardUnknown(m)
}

var xxx_messageInfo_CloneVmArg_QueryCloneTask proto.InternalMessageInfo

func (m *CloneVmArg_QueryCloneTask) GetTaskHandle() string {
	if m != nil && m.TaskHandle != nil {
		return *m.TaskHandle
	}
	return ""
}

type CloneVmRet struct {
	// Only one of 'create_clone_result' or 'query_clone_result' will be
	// populated.
	//
	// Result of a create VM clone request.
	CreateCloneResult *CloneVmRet_CreateCloneResult `protobuf:"bytes,1,opt,name=create_clone_result,json=createCloneResult" json:"create_clone_result,omitempty"`
	// Result of query VM clone request.
	QueryCloneResult     *CloneVmRet_QueryCloneResult `protobuf:"bytes,2,opt,name=query_clone_result,json=queryCloneResult" json:"query_clone_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *CloneVmRet) Reset()         { *m = CloneVmRet{} }
func (m *CloneVmRet) String() string { return proto.CompactTextString(m) }
func (*CloneVmRet) ProtoMessage()    {}
func (*CloneVmRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{50}
}

func (m *CloneVmRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloneVmRet.Unmarshal(m, b)
}
func (m *CloneVmRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloneVmRet.Marshal(b, m, deterministic)
}
func (m *CloneVmRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneVmRet.Merge(m, src)
}
func (m *CloneVmRet) XXX_Size() int {
	return xxx_messageInfo_CloneVmRet.Size(m)
}
func (m *CloneVmRet) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneVmRet.DiscardUnknown(m)
}

var xxx_messageInfo_CloneVmRet proto.InternalMessageInfo

func (m *CloneVmRet) GetCreateCloneResult() *CloneVmRet_CreateCloneResult {
	if m != nil {
		return m.CreateCloneResult
	}
	return nil
}

func (m *CloneVmRet) GetQueryCloneResult() *CloneVmRet_QueryCloneResult {
	if m != nil {
		return m.QueryCloneResult
	}
	return nil
}

type CloneVmRet_CreateCloneResult struct {
	// Overall result for the clone VM request.
	CloneResult *CloneVmRet_Error `protobuf:"varint,1,opt,name=clone_result,json=cloneResult,enum=nutanix.hyperint.CloneVmRet_Error" json:"clone_result,omitempty"`
	// Handle to the create clone task to query the cloning progress. This will
	// be populated only if the clone request was successful i.e.
	// 'clone_result' is kNoError.
	TaskHandle           *string  `protobuf:"bytes,2,opt,name=task_handle,json=taskHandle" json:"task_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloneVmRet_CreateCloneResult) Reset()         { *m = CloneVmRet_CreateCloneResult{} }
func (m *CloneVmRet_CreateCloneResult) String() string { return proto.CompactTextString(m) }
func (*CloneVmRet_CreateCloneResult) ProtoMessage()    {}
func (*CloneVmRet_CreateCloneResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{50, 0}
}

func (m *CloneVmRet_CreateCloneResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloneVmRet_CreateCloneResult.Unmarshal(m, b)
}
func (m *CloneVmRet_CreateCloneResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloneVmRet_CreateCloneResult.Marshal(b, m, deterministic)
}
func (m *CloneVmRet_CreateCloneResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneVmRet_CreateCloneResult.Merge(m, src)
}
func (m *CloneVmRet_CreateCloneResult) XXX_Size() int {
	return xxx_messageInfo_CloneVmRet_CreateCloneResult.Size(m)
}
func (m *CloneVmRet_CreateCloneResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneVmRet_CreateCloneResult.DiscardUnknown(m)
}

var xxx_messageInfo_CloneVmRet_CreateCloneResult proto.InternalMessageInfo

func (m *CloneVmRet_CreateCloneResult) GetCloneResult() CloneVmRet_Error {
	if m != nil && m.CloneResult != nil {
		return *m.CloneResult
	}
	return CloneVmRet_kNoError
}

func (m *CloneVmRet_CreateCloneResult) GetTaskHandle() string {
	if m != nil && m.TaskHandle != nil {
		return *m.TaskHandle
	}
	return ""
}

type CloneVmRet_QueryCloneResult struct {
	// Overall result for the query clone request.
	QueryResult *CloneVmRet_Error `protobuf:"varint,1,opt,name=query_result,json=queryResult,enum=nutanix.hyperint.CloneVmRet_Error" json:"query_result,omitempty"`
	// If successful i.e. 'query_result' is kNoError, information about the VM
	// clone created in the queried task.
	ClonedVmInfo         *VmInfo  `protobuf:"bytes,2,opt,name=cloned_vm_info,json=clonedVmInfo" json:"cloned_vm_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloneVmRet_QueryCloneResult) Reset()         { *m = CloneVmRet_QueryCloneResult{} }
func (m *CloneVmRet_QueryCloneResult) String() string { return proto.CompactTextString(m) }
func (*CloneVmRet_QueryCloneResult) ProtoMessage()    {}
func (*CloneVmRet_QueryCloneResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{50, 1}
}

func (m *CloneVmRet_QueryCloneResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloneVmRet_QueryCloneResult.Unmarshal(m, b)
}
func (m *CloneVmRet_QueryCloneResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloneVmRet_QueryCloneResult.Marshal(b, m, deterministic)
}
func (m *CloneVmRet_QueryCloneResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneVmRet_QueryCloneResult.Merge(m, src)
}
func (m *CloneVmRet_QueryCloneResult) XXX_Size() int {
	return xxx_messageInfo_CloneVmRet_QueryCloneResult.Size(m)
}
func (m *CloneVmRet_QueryCloneResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneVmRet_QueryCloneResult.DiscardUnknown(m)
}

var xxx_messageInfo_CloneVmRet_QueryCloneResult proto.InternalMessageInfo

func (m *CloneVmRet_QueryCloneResult) GetQueryResult() CloneVmRet_Error {
	if m != nil && m.QueryResult != nil {
		return *m.QueryResult
	}
	return CloneVmRet_kNoError
}

func (m *CloneVmRet_QueryCloneResult) GetClonedVmInfo() *VmInfo {
	if m != nil {
		return m.ClonedVmInfo
	}
	return nil
}

type ConfigureHypervNodeArg struct {
	// This parameter specifies the configuration to be performed on the nodes
	// and dictates the parameters that will be considered when processing
	// the request.
	ConfigurationType *ConfigureHypervNodeArg_ConfigurationType `protobuf:"varint,1,req,name=configuration_type,json=configurationType,enum=nutanix.hyperint.ConfigureHypervNodeArg_ConfigurationType" json:"configuration_type,omitempty"`
	// List of the IDs of the nodes. This list must not be empty and must specify
	// only the IDs of the nodes running Hyper-V.
	NodeIds []int64 `protobuf:"varint,2,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	// This parameter must be populated when the configuration_type is set to
	// 'kSetDefaultVmVhdLocation'. The number of elements in this list must be
	// equal to the number of node ids specified. The position of an element in
	// this list determines the node on which the corresponding setting will be
	// applied.
	DefaultVmVhdLocation []*ConfigureHypervNodeArg_DefaultVmVhdLocation `protobuf:"bytes,3,rep,name=default_vm_vhd_location,json=defaultVmVhdLocation" json:"default_vm_vhd_location,omitempty"`
	// This parameter must be populated when the configuration_type is set to
	// 'kJoinDomain' or 'kUnjoinFromDomain'. The number of elements in this
	// list must be equal to the number of node ids specified. The position of an
	// element in this list determines the node on which the corresponding setting
	// will be applied.
	DomainConfiguration []*ConfigureHypervNodeArg_DomainConfiguration `protobuf:"bytes,4,rep,name=domain_configuration,json=domainConfiguration" json:"domain_configuration,omitempty"`
	// This parameter must be populated when the configuration_type is set to
	// 'kRestartComputer'. The number of elements in this list must be equal to
	// the number of node ids specified. The position of an element in this list
	// determines the node on which the corresponding setting will be applied.
	RestartConfiguration []*ConfigureHypervNodeArg_RestartConfiguration `protobuf:"bytes,5,rep,name=restart_configuration,json=restartConfiguration" json:"restart_configuration,omitempty"`
	// This parameter must be set when the configuration_type is set to any of
	// kCreateFailoverCluster, kAddNodeToFailoverCluster,
	// kRemoveNodeFromFailoverCluster.
	FailoverConfiguration *ConfigureHypervNodeArg_FailoverClusterConfiguration `protobuf:"bytes,6,opt,name=failover_configuration,json=failoverConfiguration" json:"failover_configuration,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                             `json:"-"`
	XXX_unrecognized      []byte                                               `json:"-"`
	XXX_sizecache         int32                                                `json:"-"`
}

func (m *ConfigureHypervNodeArg) Reset()         { *m = ConfigureHypervNodeArg{} }
func (m *ConfigureHypervNodeArg) String() string { return proto.CompactTextString(m) }
func (*ConfigureHypervNodeArg) ProtoMessage()    {}
func (*ConfigureHypervNodeArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{51}
}

func (m *ConfigureHypervNodeArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeArg.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeArg.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeArg.Merge(m, src)
}
func (m *ConfigureHypervNodeArg) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeArg.Size(m)
}
func (m *ConfigureHypervNodeArg) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeArg.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeArg proto.InternalMessageInfo

func (m *ConfigureHypervNodeArg) GetConfigurationType() ConfigureHypervNodeArg_ConfigurationType {
	if m != nil && m.ConfigurationType != nil {
		return *m.ConfigurationType
	}
	return ConfigureHypervNodeArg_kSetDefaultVmVhdLocation
}

func (m *ConfigureHypervNodeArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

func (m *ConfigureHypervNodeArg) GetDefaultVmVhdLocation() []*ConfigureHypervNodeArg_DefaultVmVhdLocation {
	if m != nil {
		return m.DefaultVmVhdLocation
	}
	return nil
}

func (m *ConfigureHypervNodeArg) GetDomainConfiguration() []*ConfigureHypervNodeArg_DomainConfiguration {
	if m != nil {
		return m.DomainConfiguration
	}
	return nil
}

func (m *ConfigureHypervNodeArg) GetRestartConfiguration() []*ConfigureHypervNodeArg_RestartConfiguration {
	if m != nil {
		return m.RestartConfiguration
	}
	return nil
}

func (m *ConfigureHypervNodeArg) GetFailoverConfiguration() *ConfigureHypervNodeArg_FailoverClusterConfiguration {
	if m != nil {
		return m.FailoverConfiguration
	}
	return nil
}

type ConfigureHypervNodeArg_DefaultVmVhdLocation struct {
	// Specifies the Zeus ID of the NDFS container that must be set as the
	// default location for storing virtual machine configuration on the nodes
	// specified by node_ids. When not set, the corresponding property on the
	// Hyper-V node(s) will be reset to the 'factory' default value.
	VmConfigLocationContainerId *int64 `protobuf:"varint,1,opt,name=vm_config_location_container_id,json=vmConfigLocationContainerId" json:"vm_config_location_container_id,omitempty"`
	// Specifies the Zeus ID of the NDFS container that must be set as the
	// default location for storing virtual hard disk files on the nodes
	// specified by node_ids. When not set, the corresponding property on the
	// Hyper-V node(s) will be reset to the 'factory' default value.
	VhdLocationContainerId *int64   `protobuf:"varint,2,opt,name=vhd_location_container_id,json=vhdLocationContainerId" json:"vhd_location_container_id,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) Reset() {
	*m = ConfigureHypervNodeArg_DefaultVmVhdLocation{}
}
func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigureHypervNodeArg_DefaultVmVhdLocation) ProtoMessage() {}
func (*ConfigureHypervNodeArg_DefaultVmVhdLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{51, 0}
}

func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeArg_DefaultVmVhdLocation.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeArg_DefaultVmVhdLocation.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeArg_DefaultVmVhdLocation.Merge(m, src)
}
func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeArg_DefaultVmVhdLocation.Size(m)
}
func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeArg_DefaultVmVhdLocation.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeArg_DefaultVmVhdLocation proto.InternalMessageInfo

func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) GetVmConfigLocationContainerId() int64 {
	if m != nil && m.VmConfigLocationContainerId != nil {
		return *m.VmConfigLocationContainerId
	}
	return 0
}

func (m *ConfigureHypervNodeArg_DefaultVmVhdLocation) GetVhdLocationContainerId() int64 {
	if m != nil && m.VhdLocationContainerId != nil {
		return *m.VhdLocationContainerId
	}
	return 0
}

type ConfigureHypervNodeArg_DomainConfiguration struct {
	// The name that the computer has to be renamed to during domain-joining.
	// If not set, the current name will be used.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The full name of the domain to join to. Mandatory for joining the
	// host(s) to domain.
	DomainName *string `protobuf:"bytes,2,opt,name=domain_name,json=domainName" json:"domain_name,omitempty"`
	// The IP address of the nameserver that can resolve the domain_name above.
	Nameserver *string `protobuf:"bytes,3,opt,name=nameserver" json:"nameserver,omitempty"`
	// The OUPath of the container within which to create the computer object
	// during domain-joining.
	Oupath *string `protobuf:"bytes,4,opt,name=oupath" json:"oupath,omitempty"`
	// Credential of a domain account that has privileges to add new computers
	// to the specified domain.
	DomainCredential *Credential `protobuf:"bytes,5,opt,name=domain_credential,json=domainCredential" json:"domain_credential,omitempty"`
	// Credential of a local account belonging to the local administrators
	// group.
	LocalAdminCredential *Credential `protobuf:"bytes,6,opt,name=local_admin_credential,json=localAdminCredential" json:"local_admin_credential,omitempty"`
	// When used during unjoining, unjoins the host(s) from the domain even
	// when the domain controller is not reachable.
	Force *bool `protobuf:"varint,7,opt,name=force" json:"force,omitempty"`
	// Prefix path required during domain configuration
	// of LaJolla cluster
	NamePrefix           *string  `protobuf:"bytes,8,opt,name=namePrefix" json:"namePrefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) Reset() {
	*m = ConfigureHypervNodeArg_DomainConfiguration{}
}
func (m *ConfigureHypervNodeArg_DomainConfiguration) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigureHypervNodeArg_DomainConfiguration) ProtoMessage() {}
func (*ConfigureHypervNodeArg_DomainConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{51, 1}
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeArg_DomainConfiguration.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeArg_DomainConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeArg_DomainConfiguration.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeArg_DomainConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeArg_DomainConfiguration.Merge(m, src)
}
func (m *ConfigureHypervNodeArg_DomainConfiguration) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeArg_DomainConfiguration.Size(m)
}
func (m *ConfigureHypervNodeArg_DomainConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeArg_DomainConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeArg_DomainConfiguration proto.InternalMessageInfo

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetDomainName() string {
	if m != nil && m.DomainName != nil {
		return *m.DomainName
	}
	return ""
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetNameserver() string {
	if m != nil && m.Nameserver != nil {
		return *m.Nameserver
	}
	return ""
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetOupath() string {
	if m != nil && m.Oupath != nil {
		return *m.Oupath
	}
	return ""
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetDomainCredential() *Credential {
	if m != nil {
		return m.DomainCredential
	}
	return nil
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetLocalAdminCredential() *Credential {
	if m != nil {
		return m.LocalAdminCredential
	}
	return nil
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

func (m *ConfigureHypervNodeArg_DomainConfiguration) GetNamePrefix() string {
	if m != nil && m.NamePrefix != nil {
		return *m.NamePrefix
	}
	return ""
}

type ConfigureHypervNodeArg_RestartConfiguration struct {
	// Schedules a restart of the host after the specified number of seconds.
	DelaySecs            *int32   `protobuf:"varint,1,opt,name=delay_secs,json=delaySecs,def=30" json:"delay_secs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigureHypervNodeArg_RestartConfiguration) Reset() {
	*m = ConfigureHypervNodeArg_RestartConfiguration{}
}
func (m *ConfigureHypervNodeArg_RestartConfiguration) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigureHypervNodeArg_RestartConfiguration) ProtoMessage() {}
func (*ConfigureHypervNodeArg_RestartConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{51, 2}
}

func (m *ConfigureHypervNodeArg_RestartConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeArg_RestartConfiguration.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeArg_RestartConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeArg_RestartConfiguration.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeArg_RestartConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeArg_RestartConfiguration.Merge(m, src)
}
func (m *ConfigureHypervNodeArg_RestartConfiguration) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeArg_RestartConfiguration.Size(m)
}
func (m *ConfigureHypervNodeArg_RestartConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeArg_RestartConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeArg_RestartConfiguration proto.InternalMessageInfo

const Default_ConfigureHypervNodeArg_RestartConfiguration_DelaySecs int32 = 30

func (m *ConfigureHypervNodeArg_RestartConfiguration) GetDelaySecs() int32 {
	if m != nil && m.DelaySecs != nil {
		return *m.DelaySecs
	}
	return Default_ConfigureHypervNodeArg_RestartConfiguration_DelaySecs
}

type ConfigureHypervNodeArg_FailoverClusterConfiguration struct {
	// Simple name of the failover cluster. Mandatory for the following
	// configuration types: kCreateAndJoinFailoverCluster, kJoinFailoverCluster,
	// kUnjoinFromFailoverCluster.
	FailoverClusterName *string `protobuf:"bytes,1,opt,name=failover_cluster_name,json=failoverClusterName" json:"failover_cluster_name,omitempty"`
	// The IP of the failover cluster. Required only for configuration type
	// kCreateAndJoinFailoverCluster.
	FailoverClusterIp *string `protobuf:"bytes,2,opt,name=failover_cluster_ip,json=failoverClusterIp" json:"failover_cluster_ip,omitempty"`
	// Credential of a domain account that has privileges to create/modify
	// failover cluster virtual computer object in AD.
	DomainCredential     *Credential `protobuf:"bytes,3,opt,name=domain_credential,json=domainCredential" json:"domain_credential,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) Reset() {
	*m = ConfigureHypervNodeArg_FailoverClusterConfiguration{}
}
func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigureHypervNodeArg_FailoverClusterConfiguration) ProtoMessage() {}
func (*ConfigureHypervNodeArg_FailoverClusterConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{51, 3}
}

func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeArg_FailoverClusterConfiguration.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeArg_FailoverClusterConfiguration.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeArg_FailoverClusterConfiguration.Merge(m, src)
}
func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeArg_FailoverClusterConfiguration.Size(m)
}
func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeArg_FailoverClusterConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeArg_FailoverClusterConfiguration proto.InternalMessageInfo

func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) GetFailoverClusterName() string {
	if m != nil && m.FailoverClusterName != nil {
		return *m.FailoverClusterName
	}
	return ""
}

func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) GetFailoverClusterIp() string {
	if m != nil && m.FailoverClusterIp != nil {
		return *m.FailoverClusterIp
	}
	return ""
}

func (m *ConfigureHypervNodeArg_FailoverClusterConfiguration) GetDomainCredential() *Credential {
	if m != nil {
		return m.DomainCredential
	}
	return nil
}

type ConfigureHypervNodeRet struct {
	// The order of elements in the following list is determined by the order of
	// node_ids in the ConfigureHypervNodeArg.
	ConfigureResult      []*ConfigureHypervNodeRet_ConfigureResult `protobuf:"bytes,1,rep,name=configure_result,json=configureResult" json:"configure_result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *ConfigureHypervNodeRet) Reset()         { *m = ConfigureHypervNodeRet{} }
func (m *ConfigureHypervNodeRet) String() string { return proto.CompactTextString(m) }
func (*ConfigureHypervNodeRet) ProtoMessage()    {}
func (*ConfigureHypervNodeRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{52}
}

func (m *ConfigureHypervNodeRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeRet.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeRet.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeRet.Merge(m, src)
}
func (m *ConfigureHypervNodeRet) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeRet.Size(m)
}
func (m *ConfigureHypervNodeRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeRet.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeRet proto.InternalMessageInfo

func (m *ConfigureHypervNodeRet) GetConfigureResult() []*ConfigureHypervNodeRet_ConfigureResult {
	if m != nil {
		return m.ConfigureResult
	}
	return nil
}

type ConfigureHypervNodeRet_ConfigureResult struct {
	// Error that was encountered while performing the requested configuration
	// action on the node.
	Error *ConfigureHypervNodeRet_Error `protobuf:"varint,1,opt,name=error,enum=nutanix.hyperint.ConfigureHypervNodeRet_Error,def=0" json:"error,omitempty"`
	// Additional error detail. Set only when 'error' is not kNoError.
	ErrorDetail *string `protobuf:"bytes,2,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	// The id of the node for which this result applies.
	NodeId *int64 `protobuf:"varint,3,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Whether the requested configuration action requires a reboot of the
	// host to take effect. Applies only when 'error' is kNoError.
	RebootRequired       *bool    `protobuf:"varint,4,opt,name=reboot_required,json=rebootRequired,def=0" json:"reboot_required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigureHypervNodeRet_ConfigureResult) Reset() {
	*m = ConfigureHypervNodeRet_ConfigureResult{}
}
func (m *ConfigureHypervNodeRet_ConfigureResult) String() string { return proto.CompactTextString(m) }
func (*ConfigureHypervNodeRet_ConfigureResult) ProtoMessage()    {}
func (*ConfigureHypervNodeRet_ConfigureResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{52, 0}
}

func (m *ConfigureHypervNodeRet_ConfigureResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervNodeRet_ConfigureResult.Unmarshal(m, b)
}
func (m *ConfigureHypervNodeRet_ConfigureResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervNodeRet_ConfigureResult.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervNodeRet_ConfigureResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervNodeRet_ConfigureResult.Merge(m, src)
}
func (m *ConfigureHypervNodeRet_ConfigureResult) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervNodeRet_ConfigureResult.Size(m)
}
func (m *ConfigureHypervNodeRet_ConfigureResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervNodeRet_ConfigureResult.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervNodeRet_ConfigureResult proto.InternalMessageInfo

const Default_ConfigureHypervNodeRet_ConfigureResult_Error ConfigureHypervNodeRet_Error = ConfigureHypervNodeRet_kNoError
const Default_ConfigureHypervNodeRet_ConfigureResult_RebootRequired bool = false

func (m *ConfigureHypervNodeRet_ConfigureResult) GetError() ConfigureHypervNodeRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_ConfigureHypervNodeRet_ConfigureResult_Error
}

func (m *ConfigureHypervNodeRet_ConfigureResult) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

func (m *ConfigureHypervNodeRet_ConfigureResult) GetNodeId() int64 {
	if m != nil && m.NodeId != nil {
		return *m.NodeId
	}
	return 0
}

func (m *ConfigureHypervNodeRet_ConfigureResult) GetRebootRequired() bool {
	if m != nil && m.RebootRequired != nil {
		return *m.RebootRequired
	}
	return Default_ConfigureHypervNodeRet_ConfigureResult_RebootRequired
}

type PublishToArithmosArg struct {
	// List of node ids to which this request must be dispatched to. If no
	// node_id is specified, the request will be processed only by the Hyperint
	// agent running on the node that received the request and will not be
	// dispatched to agents running on other nodes.
	NodeIds []int64 `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	// The type of information to publish.
	InformationType *PublishToArithmosArg_InformationType `protobuf:"varint,2,opt,name=information_type,json=informationType,enum=nutanix.hyperint.PublishToArithmosArg_InformationType,def=1" json:"information_type,omitempty"`
	// The type of the entity whose information should be published.
	EntityType *PublishToArithmosArg_EntityType `protobuf:"varint,3,opt,name=entity_type,json=entityType,enum=nutanix.hyperint.PublishToArithmosArg_EntityType,def=1" json:"entity_type,omitempty"`
	// If no entity_id is specified, all entities of the specified type will be
	// included.
	EntityIds            [][]byte `protobuf:"bytes,4,rep,name=entity_ids,json=entityIds" json:"entity_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishToArithmosArg) Reset()         { *m = PublishToArithmosArg{} }
func (m *PublishToArithmosArg) String() string { return proto.CompactTextString(m) }
func (*PublishToArithmosArg) ProtoMessage()    {}
func (*PublishToArithmosArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{53}
}

func (m *PublishToArithmosArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishToArithmosArg.Unmarshal(m, b)
}
func (m *PublishToArithmosArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishToArithmosArg.Marshal(b, m, deterministic)
}
func (m *PublishToArithmosArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishToArithmosArg.Merge(m, src)
}
func (m *PublishToArithmosArg) XXX_Size() int {
	return xxx_messageInfo_PublishToArithmosArg.Size(m)
}
func (m *PublishToArithmosArg) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishToArithmosArg.DiscardUnknown(m)
}

var xxx_messageInfo_PublishToArithmosArg proto.InternalMessageInfo

const Default_PublishToArithmosArg_InformationType PublishToArithmosArg_InformationType = PublishToArithmosArg_kAllAvailable
const Default_PublishToArithmosArg_EntityType PublishToArithmosArg_EntityType = PublishToArithmosArg_kAll

func (m *PublishToArithmosArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

func (m *PublishToArithmosArg) GetInformationType() PublishToArithmosArg_InformationType {
	if m != nil && m.InformationType != nil {
		return *m.InformationType
	}
	return Default_PublishToArithmosArg_InformationType
}

func (m *PublishToArithmosArg) GetEntityType() PublishToArithmosArg_EntityType {
	if m != nil && m.EntityType != nil {
		return *m.EntityType
	}
	return Default_PublishToArithmosArg_EntityType
}

func (m *PublishToArithmosArg) GetEntityIds() [][]byte {
	if m != nil {
		return m.EntityIds
	}
	return nil
}

type PublishToArithmosRet struct {
	// The list of node ids.
	NodeIds []int64 `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	// The status of the request as it applies to each node. The order of the
	// elements in this list matches the order of node ids in the node_ids list.
	Error                []PublishToArithmosRet_Error `protobuf:"varint,2,rep,name=error,enum=nutanix.hyperint.PublishToArithmosRet_Error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *PublishToArithmosRet) Reset()         { *m = PublishToArithmosRet{} }
func (m *PublishToArithmosRet) String() string { return proto.CompactTextString(m) }
func (*PublishToArithmosRet) ProtoMessage()    {}
func (*PublishToArithmosRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{54}
}

func (m *PublishToArithmosRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishToArithmosRet.Unmarshal(m, b)
}
func (m *PublishToArithmosRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishToArithmosRet.Marshal(b, m, deterministic)
}
func (m *PublishToArithmosRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishToArithmosRet.Merge(m, src)
}
func (m *PublishToArithmosRet) XXX_Size() int {
	return xxx_messageInfo_PublishToArithmosRet.Size(m)
}
func (m *PublishToArithmosRet) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishToArithmosRet.DiscardUnknown(m)
}

var xxx_messageInfo_PublishToArithmosRet proto.InternalMessageInfo

func (m *PublishToArithmosRet) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

func (m *PublishToArithmosRet) GetError() []PublishToArithmosRet_Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type ConfigureHypervClusterArg struct {
	// This parameter specifies the configuration to be performed on the cluster
	// and dictates the parameters that will be considered when processing
	// the request.
	ConfigurationType *ConfigureHypervClusterArg_ConfigurationType `protobuf:"varint,1,opt,name=configuration_type,json=configurationType,enum=nutanix.hyperint.ConfigureHypervClusterArg_ConfigurationType" json:"configuration_type,omitempty"`
	// Must be set for all configuration types.
	ClusterDomainConfig  *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration `protobuf:"bytes,2,opt,name=cluster_domain_config,json=clusterDomainConfig" json:"cluster_domain_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                  `json:"-"`
	XXX_unrecognized     []byte                                                    `json:"-"`
	XXX_sizecache        int32                                                     `json:"-"`
}

func (m *ConfigureHypervClusterArg) Reset()         { *m = ConfigureHypervClusterArg{} }
func (m *ConfigureHypervClusterArg) String() string { return proto.CompactTextString(m) }
func (*ConfigureHypervClusterArg) ProtoMessage()    {}
func (*ConfigureHypervClusterArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{55}
}

func (m *ConfigureHypervClusterArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervClusterArg.Unmarshal(m, b)
}
func (m *ConfigureHypervClusterArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervClusterArg.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervClusterArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervClusterArg.Merge(m, src)
}
func (m *ConfigureHypervClusterArg) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervClusterArg.Size(m)
}
func (m *ConfigureHypervClusterArg) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervClusterArg.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervClusterArg proto.InternalMessageInfo

func (m *ConfigureHypervClusterArg) GetConfigurationType() ConfigureHypervClusterArg_ConfigurationType {
	if m != nil && m.ConfigurationType != nil {
		return *m.ConfigurationType
	}
	return ConfigureHypervClusterArg_kJoinNdfsClusterToDomain
}

func (m *ConfigureHypervClusterArg) GetClusterDomainConfig() *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration {
	if m != nil {
		return m.ClusterDomainConfig
	}
	return nil
}

type ConfigureHypervClusterArg_NdfsClusterDomainConfiguration struct {
	// Simple name (aka common name, CN) of the NOS/NDFS cluster that is
	// currently active. Must be always set for all configuration type requests.
	NdfsActiveClusterCommonName *string `protobuf:"bytes,1,opt,name=ndfs_active_cluster_common_name,json=ndfsActiveClusterCommonName" json:"ndfs_active_cluster_common_name,omitempty"`
	// Full domain name. Must be always set for all configuration type requests.
	DomainName *string `protobuf:"bytes,2,opt,name=domain_name,json=domainName" json:"domain_name,omitempty"`
	// Must be set for configuration type kRenameNdfsCluster. The value must be
	// the simple name to which the NDFS cluster must be renamed to.
	NdfsNewClusterCommonName *string `protobuf:"bytes,3,opt,name=ndfs_new_cluster_common_name,json=ndfsNewClusterCommonName" json:"ndfs_new_cluster_common_name,omitempty"`
	// The IP of the nameserver that can resolve the domain_name above.
	Nameserver *string `protobuf:"bytes,4,opt,name=nameserver" json:"nameserver,omitempty"`
	// The OUPath or the distinguished name (DN) of the container in AD that
	// will house the computer object representing the NDFS cluster.
	Oupath *string `protobuf:"bytes,5,opt,name=oupath" json:"oupath,omitempty"`
	// Highly-available virtual IP of the NDFS cluster. Must be set to the IP v4
	// address for configuration types, kJoinNdfsClusterToDomain and
	// kChangeNdfsClusterVip.
	Vip *string `protobuf:"bytes,6,opt,name=vip" json:"vip,omitempty"`
	// Password of the computer account that will be created to represent the
	// NDFS cluster in the domain. Must be set for kJoinDomain.
	NdfsDomainAccountPassword *string `protobuf:"bytes,7,opt,name=ndfs_domain_account_password,json=ndfsDomainAccountPassword" json:"ndfs_domain_account_password,omitempty"`
	// Credential of a domain account that has privileges to add new/modify/
	// delete computers to/in/from the specified domain.
	DomainCredential *Credential `protobuf:"bytes,8,opt,name=domain_credential,json=domainCredential" json:"domain_credential,omitempty"`
	// Force the operation. For kJoinNdfsClusterToDomain, the existing
	// computer account representing NDFS, if any, will be deleted and a new
	// one created.
	Force *bool `protobuf:"varint,9,opt,name=force" json:"force,omitempty"`
	// The Prefix path required during domain configuration
	// for LaJolla cluster
	NamePrefix           *string  `protobuf:"bytes,10,opt,name=namePrefix" json:"namePrefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) Reset() {
	*m = ConfigureHypervClusterArg_NdfsClusterDomainConfiguration{}
}
func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) String() string {
	return proto.CompactTextString(m)
}
func (*ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) ProtoMessage() {}
func (*ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{55, 0}
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervClusterArg_NdfsClusterDomainConfiguration.Unmarshal(m, b)
}
func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervClusterArg_NdfsClusterDomainConfiguration.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervClusterArg_NdfsClusterDomainConfiguration.Merge(m, src)
}
func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervClusterArg_NdfsClusterDomainConfiguration.Size(m)
}
func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervClusterArg_NdfsClusterDomainConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervClusterArg_NdfsClusterDomainConfiguration proto.InternalMessageInfo

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetNdfsActiveClusterCommonName() string {
	if m != nil && m.NdfsActiveClusterCommonName != nil {
		return *m.NdfsActiveClusterCommonName
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetDomainName() string {
	if m != nil && m.DomainName != nil {
		return *m.DomainName
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetNdfsNewClusterCommonName() string {
	if m != nil && m.NdfsNewClusterCommonName != nil {
		return *m.NdfsNewClusterCommonName
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetNameserver() string {
	if m != nil && m.Nameserver != nil {
		return *m.Nameserver
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetOupath() string {
	if m != nil && m.Oupath != nil {
		return *m.Oupath
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetVip() string {
	if m != nil && m.Vip != nil {
		return *m.Vip
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetNdfsDomainAccountPassword() string {
	if m != nil && m.NdfsDomainAccountPassword != nil {
		return *m.NdfsDomainAccountPassword
	}
	return ""
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetDomainCredential() *Credential {
	if m != nil {
		return m.DomainCredential
	}
	return nil
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

func (m *ConfigureHypervClusterArg_NdfsClusterDomainConfiguration) GetNamePrefix() string {
	if m != nil && m.NamePrefix != nil {
		return *m.NamePrefix
	}
	return ""
}

type ConfigureHypervClusterRet struct {
	// Error that was encountered while performing the requested configuration
	// action.
	Error *ConfigureHypervClusterRet_Error `protobuf:"varint,1,opt,name=error,enum=nutanix.hyperint.ConfigureHypervClusterRet_Error,def=0" json:"error,omitempty"`
	// Additional error detail. Set only when 'error' is not kNoError.
	ErrorDetail *string `protobuf:"bytes,2,opt,name=error_detail,json=errorDetail" json:"error_detail,omitempty"`
	// List of the IPs of the domain controllers in the domain that the NOS
	// cluster is joined to. This property is set only in the response for the
	// kJoinNdfsClusterToDomain request.
	// (The IPs of the domain controllers in the domain will be set as the
	// time servers in the CVMs of the NOS cluster.)
	DomainControllerIps []string `protobuf:"bytes,3,rep,name=domain_controller_ips,json=domainControllerIps" json:"domain_controller_ips,omitempty"`
	// Windows 2016 does not allow guest/anonymous access to the SMB.
	// So Kerberos for SMB is not optional beginning 2016.
	// While domain-joining the NOS cluster, if we find that we're running
	// on Windows 2016, we automatically enable Kerberos SMB and set
	// this property to true.
	// In 2012 R2, this property will not be set and have the default value
	// of false.
	KerberosForSmbEnabled *bool    `protobuf:"varint,4,opt,name=kerberos_for_smb_enabled,json=kerberosForSmbEnabled,def=0" json:"kerberos_for_smb_enabled,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ConfigureHypervClusterRet) Reset()         { *m = ConfigureHypervClusterRet{} }
func (m *ConfigureHypervClusterRet) String() string { return proto.CompactTextString(m) }
func (*ConfigureHypervClusterRet) ProtoMessage()    {}
func (*ConfigureHypervClusterRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{56}
}

func (m *ConfigureHypervClusterRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigureHypervClusterRet.Unmarshal(m, b)
}
func (m *ConfigureHypervClusterRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigureHypervClusterRet.Marshal(b, m, deterministic)
}
func (m *ConfigureHypervClusterRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureHypervClusterRet.Merge(m, src)
}
func (m *ConfigureHypervClusterRet) XXX_Size() int {
	return xxx_messageInfo_ConfigureHypervClusterRet.Size(m)
}
func (m *ConfigureHypervClusterRet) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureHypervClusterRet.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureHypervClusterRet proto.InternalMessageInfo

const Default_ConfigureHypervClusterRet_Error ConfigureHypervClusterRet_Error = ConfigureHypervClusterRet_kNoError
const Default_ConfigureHypervClusterRet_KerberosForSmbEnabled bool = false

func (m *ConfigureHypervClusterRet) GetError() ConfigureHypervClusterRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_ConfigureHypervClusterRet_Error
}

func (m *ConfigureHypervClusterRet) GetErrorDetail() string {
	if m != nil && m.ErrorDetail != nil {
		return *m.ErrorDetail
	}
	return ""
}

func (m *ConfigureHypervClusterRet) GetDomainControllerIps() []string {
	if m != nil {
		return m.DomainControllerIps
	}
	return nil
}

func (m *ConfigureHypervClusterRet) GetKerberosForSmbEnabled() bool {
	if m != nil && m.KerberosForSmbEnabled != nil {
		return *m.KerberosForSmbEnabled
	}
	return Default_ConfigureHypervClusterRet_KerberosForSmbEnabled
}

//-----------------------------------------------------------------------------
type GetNetworkAdapterArg struct {
	// List of the IDs of the nodes whose network adapters need to be fetched.
	NodeIds              []int64  `protobuf:"varint,1,rep,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetNetworkAdapterArg) Reset()         { *m = GetNetworkAdapterArg{} }
func (m *GetNetworkAdapterArg) String() string { return proto.CompactTextString(m) }
func (*GetNetworkAdapterArg) ProtoMessage()    {}
func (*GetNetworkAdapterArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{57}
}

func (m *GetNetworkAdapterArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNetworkAdapterArg.Unmarshal(m, b)
}
func (m *GetNetworkAdapterArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNetworkAdapterArg.Marshal(b, m, deterministic)
}
func (m *GetNetworkAdapterArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNetworkAdapterArg.Merge(m, src)
}
func (m *GetNetworkAdapterArg) XXX_Size() int {
	return xxx_messageInfo_GetNetworkAdapterArg.Size(m)
}
func (m *GetNetworkAdapterArg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNetworkAdapterArg.DiscardUnknown(m)
}

var xxx_messageInfo_GetNetworkAdapterArg proto.InternalMessageInfo

func (m *GetNetworkAdapterArg) GetNodeIds() []int64 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

type GetNetworkAdapterRet struct {
	// The results from the various nodes identified in GetNetworkAdapterArg.
	Results              []*GetNetworkAdapterRet_Result `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *GetNetworkAdapterRet) Reset()         { *m = GetNetworkAdapterRet{} }
func (m *GetNetworkAdapterRet) String() string { return proto.CompactTextString(m) }
func (*GetNetworkAdapterRet) ProtoMessage()    {}
func (*GetNetworkAdapterRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{58}
}

func (m *GetNetworkAdapterRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNetworkAdapterRet.Unmarshal(m, b)
}
func (m *GetNetworkAdapterRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNetworkAdapterRet.Marshal(b, m, deterministic)
}
func (m *GetNetworkAdapterRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNetworkAdapterRet.Merge(m, src)
}
func (m *GetNetworkAdapterRet) XXX_Size() int {
	return xxx_messageInfo_GetNetworkAdapterRet.Size(m)
}
func (m *GetNetworkAdapterRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNetworkAdapterRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetNetworkAdapterRet proto.InternalMessageInfo

func (m *GetNetworkAdapterRet) GetResults() []*GetNetworkAdapterRet_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type GetNetworkAdapterRet_Result struct {
	// A non-default value indicates either the absence of a node with a given
	// ID or some error in processing the node for the requested information.
	Error *GetNetworkAdapterRet_Error `protobuf:"varint,1,opt,name=error,enum=nutanix.hyperint.GetNetworkAdapterRet_Error,def=0" json:"error,omitempty"`
	// List of network adapters on the node.
	NetworkAdapter       []*NetworkAdapter `protobuf:"bytes,2,rep,name=network_adapter,json=networkAdapter" json:"network_adapter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetNetworkAdapterRet_Result) Reset()         { *m = GetNetworkAdapterRet_Result{} }
func (m *GetNetworkAdapterRet_Result) String() string { return proto.CompactTextString(m) }
func (*GetNetworkAdapterRet_Result) ProtoMessage()    {}
func (*GetNetworkAdapterRet_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{58, 0}
}

func (m *GetNetworkAdapterRet_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetNetworkAdapterRet_Result.Unmarshal(m, b)
}
func (m *GetNetworkAdapterRet_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetNetworkAdapterRet_Result.Marshal(b, m, deterministic)
}
func (m *GetNetworkAdapterRet_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNetworkAdapterRet_Result.Merge(m, src)
}
func (m *GetNetworkAdapterRet_Result) XXX_Size() int {
	return xxx_messageInfo_GetNetworkAdapterRet_Result.Size(m)
}
func (m *GetNetworkAdapterRet_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNetworkAdapterRet_Result.DiscardUnknown(m)
}

var xxx_messageInfo_GetNetworkAdapterRet_Result proto.InternalMessageInfo

const Default_GetNetworkAdapterRet_Result_Error GetNetworkAdapterRet_Error = GetNetworkAdapterRet_kNoError

func (m *GetNetworkAdapterRet_Result) GetError() GetNetworkAdapterRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_GetNetworkAdapterRet_Result_Error
}

func (m *GetNetworkAdapterRet_Result) GetNetworkAdapter() []*NetworkAdapter {
	if m != nil {
		return m.NetworkAdapter
	}
	return nil
}

type HypervFailoverCluster struct {
	// Name of the failover cluster.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// IP address of the failover cluster.
	IpAddress *string `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	// List of nodes that make this failover cluster.
	MemberNodes          []*HypervFailoverCluster_MemberNode `protobuf:"bytes,3,rep,name=member_nodes,json=memberNodes" json:"member_nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *HypervFailoverCluster) Reset()         { *m = HypervFailoverCluster{} }
func (m *HypervFailoverCluster) String() string { return proto.CompactTextString(m) }
func (*HypervFailoverCluster) ProtoMessage()    {}
func (*HypervFailoverCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{59}
}

func (m *HypervFailoverCluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HypervFailoverCluster.Unmarshal(m, b)
}
func (m *HypervFailoverCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HypervFailoverCluster.Marshal(b, m, deterministic)
}
func (m *HypervFailoverCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HypervFailoverCluster.Merge(m, src)
}
func (m *HypervFailoverCluster) XXX_Size() int {
	return xxx_messageInfo_HypervFailoverCluster.Size(m)
}
func (m *HypervFailoverCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_HypervFailoverCluster.DiscardUnknown(m)
}

var xxx_messageInfo_HypervFailoverCluster proto.InternalMessageInfo

func (m *HypervFailoverCluster) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *HypervFailoverCluster) GetIpAddress() string {
	if m != nil && m.IpAddress != nil {
		return *m.IpAddress
	}
	return ""
}

func (m *HypervFailoverCluster) GetMemberNodes() []*HypervFailoverCluster_MemberNode {
	if m != nil {
		return m.MemberNodes
	}
	return nil
}

type HypervFailoverCluster_MemberNode struct {
	// Zeus ID of the node (aka the service VM ID).
	Id *int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Name of the node.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// The state of the node in the failover cluster.
	State *string `protobuf:"bytes,3,opt,name=state" json:"state,omitempty"`
	// Node UUID (aka the service VM UUID).
	Uuid                 *string  `protobuf:"bytes,4,opt,name=uuid" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HypervFailoverCluster_MemberNode) Reset()         { *m = HypervFailoverCluster_MemberNode{} }
func (m *HypervFailoverCluster_MemberNode) String() string { return proto.CompactTextString(m) }
func (*HypervFailoverCluster_MemberNode) ProtoMessage()    {}
func (*HypervFailoverCluster_MemberNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{59, 0}
}

func (m *HypervFailoverCluster_MemberNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HypervFailoverCluster_MemberNode.Unmarshal(m, b)
}
func (m *HypervFailoverCluster_MemberNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HypervFailoverCluster_MemberNode.Marshal(b, m, deterministic)
}
func (m *HypervFailoverCluster_MemberNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HypervFailoverCluster_MemberNode.Merge(m, src)
}
func (m *HypervFailoverCluster_MemberNode) XXX_Size() int {
	return xxx_messageInfo_HypervFailoverCluster_MemberNode.Size(m)
}
func (m *HypervFailoverCluster_MemberNode) XXX_DiscardUnknown() {
	xxx_messageInfo_HypervFailoverCluster_MemberNode.DiscardUnknown(m)
}

var xxx_messageInfo_HypervFailoverCluster_MemberNode proto.InternalMessageInfo

func (m *HypervFailoverCluster_MemberNode) GetId() int64 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *HypervFailoverCluster_MemberNode) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *HypervFailoverCluster_MemberNode) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

func (m *HypervFailoverCluster_MemberNode) GetUuid() string {
	if m != nil && m.Uuid != nil {
		return *m.Uuid
	}
	return ""
}

type GetHypervFailoverClusterArg struct {
	// Name of the failover cluster. If not specified, all failover clusters
	// that encompass the nodes of the NOS cluster will be returned.
	FailoverClusterName  *string  `protobuf:"bytes,1,opt,name=failover_cluster_name,json=failoverClusterName" json:"failover_cluster_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHypervFailoverClusterArg) Reset()         { *m = GetHypervFailoverClusterArg{} }
func (m *GetHypervFailoverClusterArg) String() string { return proto.CompactTextString(m) }
func (*GetHypervFailoverClusterArg) ProtoMessage()    {}
func (*GetHypervFailoverClusterArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{60}
}

func (m *GetHypervFailoverClusterArg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetHypervFailoverClusterArg.Unmarshal(m, b)
}
func (m *GetHypervFailoverClusterArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetHypervFailoverClusterArg.Marshal(b, m, deterministic)
}
func (m *GetHypervFailoverClusterArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHypervFailoverClusterArg.Merge(m, src)
}
func (m *GetHypervFailoverClusterArg) XXX_Size() int {
	return xxx_messageInfo_GetHypervFailoverClusterArg.Size(m)
}
func (m *GetHypervFailoverClusterArg) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHypervFailoverClusterArg.DiscardUnknown(m)
}

var xxx_messageInfo_GetHypervFailoverClusterArg proto.InternalMessageInfo

func (m *GetHypervFailoverClusterArg) GetFailoverClusterName() string {
	if m != nil && m.FailoverClusterName != nil {
		return *m.FailoverClusterName
	}
	return ""
}

type GetHypervFailoverClusterRet struct {
	// Error that was encountered when getting the failover cluster state.
	Error *GetHypervFailoverClusterRet_Error `protobuf:"varint,1,opt,name=error,enum=nutanix.hyperint.GetHypervFailoverClusterRet_Error,def=0" json:"error,omitempty"`
	// Failover cluster. Set only when 'error' is kNoError.
	FailoverClusters     []*HypervFailoverCluster `protobuf:"bytes,2,rep,name=failover_clusters,json=failoverClusters" json:"failover_clusters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetHypervFailoverClusterRet) Reset()         { *m = GetHypervFailoverClusterRet{} }
func (m *GetHypervFailoverClusterRet) String() string { return proto.CompactTextString(m) }
func (*GetHypervFailoverClusterRet) ProtoMessage()    {}
func (*GetHypervFailoverClusterRet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0fb843cb6a8c7940, []int{61}
}

func (m *GetHypervFailoverClusterRet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetHypervFailoverClusterRet.Unmarshal(m, b)
}
func (m *GetHypervFailoverClusterRet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetHypervFailoverClusterRet.Marshal(b, m, deterministic)
}
func (m *GetHypervFailoverClusterRet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHypervFailoverClusterRet.Merge(m, src)
}
func (m *GetHypervFailoverClusterRet) XXX_Size() int {
	return xxx_messageInfo_GetHypervFailoverClusterRet.Size(m)
}
func (m *GetHypervFailoverClusterRet) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHypervFailoverClusterRet.DiscardUnknown(m)
}

var xxx_messageInfo_GetHypervFailoverClusterRet proto.InternalMessageInfo

const Default_GetHypervFailoverClusterRet_Error GetHypervFailoverClusterRet_Error = GetHypervFailoverClusterRet_kNoError

func (m *GetHypervFailoverClusterRet) GetError() GetHypervFailoverClusterRet_Error {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return Default_GetHypervFailoverClusterRet_Error
}

func (m *GetHypervFailoverClusterRet) GetFailoverClusters() []*HypervFailoverCluster {
	if m != nil {
		return m.FailoverClusters
	}
	return nil
}

func init() {
	proto.RegisterEnum("nutanix.hyperint.HyperintError_Type", HyperintError_Type_name, HyperintError_Type_value)
	proto.RegisterEnum("nutanix.hyperint.VirtualCd_Type", VirtualCd_Type_name, VirtualCd_Type_value)
	proto.RegisterEnum("nutanix.hyperint.VirtualCd_AdapterType", VirtualCd_AdapterType_name, VirtualCd_AdapterType_value)
	proto.RegisterEnum("nutanix.hyperint.VirtualDisk_Type", VirtualDisk_Type_name, VirtualDisk_Type_value)
	proto.RegisterEnum("nutanix.hyperint.VirtualDisk_AdapterType", VirtualDisk_AdapterType_name, VirtualDisk_AdapterType_value)
	proto.RegisterEnum("nutanix.hyperint.VmFileConfig_Type", VmFileConfig_Type_name, VmFileConfig_Type_value)
	proto.RegisterEnum("nutanix.hyperint.VirtualNetworkAdapterConfig_MacAddressType", VirtualNetworkAdapterConfig_MacAddressType_name, VirtualNetworkAdapterConfig_MacAddressType_value)
	proto.RegisterEnum("nutanix.hyperint.VmInfo_PowerState", VmInfo_PowerState_name, VmInfo_PowerState_value)
	proto.RegisterEnum("nutanix.hyperint.GetNodeInfoRet_Error", GetNodeInfoRet_Error_name, GetNodeInfoRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.GetVmInfoRet_Error", GetVmInfoRet_Error_name, GetVmInfoRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.SnapshotVmRet_Error", SnapshotVmRet_Error_name, SnapshotVmRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.AdjustVmSnapshotRet_Error", AdjustVmSnapshotRet_Error_name, AdjustVmSnapshotRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.ChangeVmStateRet_Error", ChangeVmStateRet_Error_name, ChangeVmStateRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType", RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType_name, RegisterVmArg_RegisterVm_EntityDbIncarnationId_EntityType_value)
	proto.RegisterEnum("nutanix.hyperint.RegisterVmRet_Error", RegisterVmRet_Error_name, RegisterVmRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.GetDatastoresRet_Error", GetDatastoresRet_Error_name, GetDatastoresRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.MountDatastoreRet_Error", MountDatastoreRet_Error_name, MountDatastoreRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.UnmountDatastoreRet_Error", UnmountDatastoreRet_Error_name, UnmountDatastoreRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.AttachVirtualCdRet_Error", AttachVirtualCdRet_Error_name, AttachVirtualCdRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.DetachVirtualCdRet_Error", DetachVirtualCdRet_Error_name, DetachVirtualCdRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.AttachVirtualDiskRet_Error", AttachVirtualDiskRet_Error_name, AttachVirtualDiskRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.DetachVirtualDiskRet_Error", DetachVirtualDiskRet_Error_name, DetachVirtualDiskRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.ModifyVirtualDiskRet_Error", ModifyVirtualDiskRet_Error_name, ModifyVirtualDiskRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.CreateVmRet_Error", CreateVmRet_Error_name, CreateVmRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.CloneVmRet_Error", CloneVmRet_Error_name, CloneVmRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.ConfigureHypervNodeArg_ConfigurationType", ConfigureHypervNodeArg_ConfigurationType_name, ConfigureHypervNodeArg_ConfigurationType_value)
	proto.RegisterEnum("nutanix.hyperint.ConfigureHypervNodeRet_Error", ConfigureHypervNodeRet_Error_name, ConfigureHypervNodeRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.PublishToArithmosArg_InformationType", PublishToArithmosArg_InformationType_name, PublishToArithmosArg_InformationType_value)
	proto.RegisterEnum("nutanix.hyperint.PublishToArithmosArg_EntityType", PublishToArithmosArg_EntityType_name, PublishToArithmosArg_EntityType_value)
	proto.RegisterEnum("nutanix.hyperint.PublishToArithmosRet_Error", PublishToArithmosRet_Error_name, PublishToArithmosRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.ConfigureHypervClusterArg_ConfigurationType", ConfigureHypervClusterArg_ConfigurationType_name, ConfigureHypervClusterArg_ConfigurationType_value)
	proto.RegisterEnum("nutanix.hyperint.ConfigureHypervClusterRet_Error", ConfigureHypervClusterRet_Error_name, ConfigureHypervClusterRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.GetNetworkAdapterRet_Error", GetNetworkAdapterRet_Error_name, GetNetworkAdapterRet_Error_value)
	proto.RegisterEnum("nutanix.hyperint.GetHypervFailoverClusterRet_Error", GetHypervFailoverClusterRet_Error_name, GetHypervFailoverClusterRet_Error_value)
	proto.RegisterType((*HyperintError)(nil), "nutanix.hyperint.HyperintError")
	proto.RegisterType((*NetworkAdapter)(nil), "nutanix.hyperint.NetworkAdapter")
	proto.RegisterType((*VmBootConfig)(nil), "nutanix.hyperint.VmBootConfig")
	proto.RegisterType((*VmConfig)(nil), "nutanix.hyperint.VmConfig")
	proto.RegisterType((*VirtualCd)(nil), "nutanix.hyperint.VirtualCd")
	proto.RegisterType((*VirtualCd_FileOnNfs)(nil), "nutanix.hyperint.VirtualCd.FileOnNfs")
	proto.RegisterType((*VirtualDisk)(nil), "nutanix.hyperint.VirtualDisk")
	proto.RegisterType((*VirtualDisk_FileOnNfs)(nil), "nutanix.hyperint.VirtualDisk.FileOnNfs")
	proto.RegisterType((*VirtualDisk_FileOnDas)(nil), "nutanix.hyperint.VirtualDisk.FileOnDas")
	proto.RegisterType((*VirtualDisk_IscsiTarget)(nil), "nutanix.hyperint.VirtualDisk.IscsiTarget")
	proto.RegisterType((*VirtualDisk_FileOnSharedIscsiVDisk)(nil), "nutanix.hyperint.VirtualDisk.FileOnSharedIscsiVDisk")
	proto.RegisterType((*VirtualDisk_IscsiVDisk)(nil), "nutanix.hyperint.VirtualDisk.IscsiVDisk")
	proto.RegisterType((*VirtualDisk_Das)(nil), "nutanix.hyperint.VirtualDisk.Das")
	proto.RegisterType((*VmFileConfig)(nil), "nutanix.hyperint.VmFileConfig")
	proto.RegisterType((*VirtualNetworkAdapterConfig)(nil), "nutanix.hyperint.VirtualNetworkAdapterConfig")
	proto.RegisterType((*VmNetworkConfig)(nil), "nutanix.hyperint.VmNetworkConfig")
	proto.RegisterType((*VmInfo)(nil), "nutanix.hyperint.VmInfo")
	proto.RegisterType((*VmInfo_VgAttachmentConfig)(nil), "nutanix.hyperint.VmInfo.VgAttachmentConfig")
	proto.RegisterType((*DatastoreInfo)(nil), "nutanix.hyperint.DatastoreInfo")
	proto.RegisterType((*HostL2NetworkConfig)(nil), "nutanix.hyperint.HostL2NetworkConfig")
	proto.RegisterType((*HostL2NetworkConfig_VMwareNetworkConfig)(nil), "nutanix.hyperint.HostL2NetworkConfig.VMwareNetworkConfig")
	proto.RegisterType((*HostL2NetworkConfig_HyperVNetworkConfig)(nil), "nutanix.hyperint.HostL2NetworkConfig.HyperVNetworkConfig")
	proto.RegisterType((*HostL2NetworkConfig_AcropolisNetworkConfig)(nil), "nutanix.hyperint.HostL2NetworkConfig.AcropolisNetworkConfig")
	proto.RegisterType((*HostL2NetworkConfig_AWSNetworkConfig)(nil), "nutanix.hyperint.HostL2NetworkConfig.AWSNetworkConfig")
	proto.RegisterType((*HostL2NetworkConfig_AzureNetworkConfig)(nil), "nutanix.hyperint.HostL2NetworkConfig.AzureNetworkConfig")
	proto.RegisterType((*VmL2NetworkConfig)(nil), "nutanix.hyperint.VmL2NetworkConfig")
	proto.RegisterType((*VmL2NetworkConfig_VMwareVmNetworkConfig)(nil), "nutanix.hyperint.VmL2NetworkConfig.VMwareVmNetworkConfig")
	proto.RegisterType((*VmL2NetworkConfig_HyperVVmNetworkConfig)(nil), "nutanix.hyperint.VmL2NetworkConfig.HyperVVmNetworkConfig")
	proto.RegisterType((*VmL2NetworkConfig_AcropolisVmNetworkConfig)(nil), "nutanix.hyperint.VmL2NetworkConfig.AcropolisVmNetworkConfig")
	proto.RegisterType((*VmL2NetworkConfig_AWSVmNetworkConfig)(nil), "nutanix.hyperint.VmL2NetworkConfig.AWSVmNetworkConfig")
	proto.RegisterType((*VmL2NetworkConfig_AzureVmNetworkConfig)(nil), "nutanix.hyperint.VmL2NetworkConfig.AzureVmNetworkConfig")
	proto.RegisterType((*L2NetworkMapping)(nil), "nutanix.hyperint.L2NetworkMapping")
	proto.RegisterType((*L3NetworkMapping)(nil), "nutanix.hyperint.L3NetworkMapping")
	proto.RegisterType((*L3NetworkMapping_AddressMapping)(nil), "nutanix.hyperint.L3NetworkMapping.AddressMapping")
	proto.RegisterType((*NetworkMapping)(nil), "nutanix.hyperint.NetworkMapping")
	proto.RegisterType((*HostNetworkMapping)(nil), "nutanix.hyperint.HostNetworkMapping")
	proto.RegisterType((*NetworkMappingRepository)(nil), "nutanix.hyperint.NetworkMappingRepository")
	proto.RegisterType((*Credential)(nil), "nutanix.hyperint.Credential")
	proto.RegisterType((*GetNodeInfoArg)(nil), "nutanix.hyperint.GetNodeInfoArg")
	proto.RegisterType((*GetNodeInfoRet)(nil), "nutanix.hyperint.GetNodeInfoRet")
	proto.RegisterType((*GetNodeInfoRet_NodeInfoResult)(nil), "nutanix.hyperint.GetNodeInfoRet.NodeInfoResult")
	proto.RegisterType((*GetVmInfoArg)(nil), "nutanix.hyperint.GetVmInfoArg")
	proto.RegisterType((*GetVmInfoArg_VmPaths)(nil), "nutanix.hyperint.GetVmInfoArg.VmPaths")
	proto.RegisterType((*GetVmInfoRet)(nil), "nutanix.hyperint.GetVmInfoRet")
	proto.RegisterType((*GetVmInfoRet_VmInfoResult)(nil), "nutanix.hyperint.GetVmInfoRet.VmInfoResult")
	proto.RegisterType((*SnapshotVmArg)(nil), "nutanix.hyperint.SnapshotVmArg")
	proto.RegisterType((*SnapshotVmArg_RemoveSnapshot)(nil), "nutanix.hyperint.SnapshotVmArg.RemoveSnapshot")
	proto.RegisterType((*SnapshotVmArg_CreateSnapshot)(nil), "nutanix.hyperint.SnapshotVmArg.CreateSnapshot")
	proto.RegisterType((*SnapshotVmArg_QuerySnapshot)(nil), "nutanix.hyperint.SnapshotVmArg.QuerySnapshot")
	proto.RegisterType((*SnapshotVmRet)(nil), "nutanix.hyperint.SnapshotVmRet")
	proto.RegisterType((*SnapshotVmRet_RemoveSnapshotResult)(nil), "nutanix.hyperint.SnapshotVmRet.RemoveSnapshotResult")
	proto.RegisterType((*SnapshotVmRet_CreateSnapshotResult)(nil), "nutanix.hyperint.SnapshotVmRet.CreateSnapshotResult")
	proto.RegisterType((*SnapshotVmRet_QuerySnapshotResult)(nil), "nutanix.hyperint.SnapshotVmRet.QuerySnapshotResult")
	proto.RegisterType((*AdjustVmSnapshotArg)(nil), "nutanix.hyperint.AdjustVmSnapshotArg")
	proto.RegisterType((*AdjustVmSnapshotArg_VmSnapshot)(nil), "nutanix.hyperint.AdjustVmSnapshotArg.VmSnapshot")
	proto.RegisterType((*AdjustVmSnapshotRet)(nil), "nutanix.hyperint.AdjustVmSnapshotRet")
	proto.RegisterType((*AdjustVmSnapshotRet_AdjustVmSnapshotResult)(nil), "nutanix.hyperint.AdjustVmSnapshotRet.AdjustVmSnapshotResult")
	proto.RegisterType((*ChangeVmStateArg)(nil), "nutanix.hyperint.ChangeVmStateArg")
	proto.RegisterType((*ChangeVmStateRet)(nil), "nutanix.hyperint.ChangeVmStateRet")
	proto.RegisterType((*RegisterVmArg)(nil), "nutanix.hyperint.RegisterVmArg")
	proto.RegisterType((*RegisterVmArg_RegisterVm)(nil), "nutanix.hyperint.RegisterVmArg.RegisterVm")
	proto.RegisterType((*RegisterVmArg_RegisterVm_EntityDbIncarnationId)(nil), "nutanix.hyperint.RegisterVmArg.RegisterVm.EntityDbIncarnationId")
	proto.RegisterType((*RegisterVmRet)(nil), "nutanix.hyperint.RegisterVmRet")
	proto.RegisterType((*RegisterVmRet_VmResult)(nil), "nutanix.hyperint.RegisterVmRet.VmResult")
	proto.RegisterType((*GetDatastoresArg)(nil), "nutanix.hyperint.GetDatastoresArg")
	proto.RegisterType((*GetDatastoresRet)(nil), "nutanix.hyperint.GetDatastoresRet")
	proto.RegisterType((*GetDatastoresRet_GetDatastoresResult)(nil), "nutanix.hyperint.GetDatastoresRet.GetDatastoresResult")
	proto.RegisterType((*MountDatastoreArg)(nil), "nutanix.hyperint.MountDatastoreArg")
	proto.RegisterType((*MountDatastoreRet)(nil), "nutanix.hyperint.MountDatastoreRet")
	proto.RegisterType((*MountDatastoreRet_MountDatastoreResult)(nil), "nutanix.hyperint.MountDatastoreRet.MountDatastoreResult")
	proto.RegisterType((*UnmountDatastoreArg)(nil), "nutanix.hyperint.UnmountDatastoreArg")
	proto.RegisterType((*UnmountDatastoreRet)(nil), "nutanix.hyperint.UnmountDatastoreRet")
	proto.RegisterType((*UnmountDatastoreRet_UnmountDatastoreResult)(nil), "nutanix.hyperint.UnmountDatastoreRet.UnmountDatastoreResult")
	proto.RegisterType((*AttachVirtualCdArg)(nil), "nutanix.hyperint.AttachVirtualCdArg")
	proto.RegisterType((*AttachVirtualCdRet)(nil), "nutanix.hyperint.AttachVirtualCdRet")
	proto.RegisterType((*DetachVirtualCdArg)(nil), "nutanix.hyperint.DetachVirtualCdArg")
	proto.RegisterType((*DetachVirtualCdRet)(nil), "nutanix.hyperint.DetachVirtualCdRet")
	proto.RegisterType((*AttachVirtualDiskArg)(nil), "nutanix.hyperint.AttachVirtualDiskArg")
	proto.RegisterType((*AttachVirtualDiskArg_VirtualDiskSpec)(nil), "nutanix.hyperint.AttachVirtualDiskArg.VirtualDiskSpec")
	proto.RegisterType((*AttachVirtualDiskRet)(nil), "nutanix.hyperint.AttachVirtualDiskRet")
	proto.RegisterType((*AttachVirtualDiskRet_AttachedDiskInfo)(nil), "nutanix.hyperint.AttachVirtualDiskRet.AttachedDiskInfo")
	proto.RegisterType((*DetachVirtualDiskArg)(nil), "nutanix.hyperint.DetachVirtualDiskArg")
	proto.RegisterType((*DetachVirtualDiskRet)(nil), "nutanix.hyperint.DetachVirtualDiskRet")
	proto.RegisterType((*ModifyVirtualDiskArg)(nil), "nutanix.hyperint.ModifyVirtualDiskArg")
	proto.RegisterType((*ModifyVirtualDiskRet)(nil), "nutanix.hyperint.ModifyVirtualDiskRet")
	proto.RegisterType((*CreateVmArg)(nil), "nutanix.hyperint.CreateVmArg")
	proto.RegisterType((*CreateVmArg_VirtualStorageDeviceConfig)(nil), "nutanix.hyperint.CreateVmArg.VirtualStorageDeviceConfig")
	proto.RegisterType((*CreateVmArg_VirtualL2NetworkAdapterConfig)(nil), "nutanix.hyperint.CreateVmArg.VirtualL2NetworkAdapterConfig")
	proto.RegisterType((*CreateVmRet)(nil), "nutanix.hyperint.CreateVmRet")
	proto.RegisterType((*CloneVmArg)(nil), "nutanix.hyperint.CloneVmArg")
	proto.RegisterType((*CloneVmArg_CreateClone)(nil), "nutanix.hyperint.CloneVmArg.CreateClone")
	proto.RegisterType((*CloneVmArg_QueryCloneTask)(nil), "nutanix.hyperint.CloneVmArg.QueryCloneTask")
	proto.RegisterType((*CloneVmRet)(nil), "nutanix.hyperint.CloneVmRet")
	proto.RegisterType((*CloneVmRet_CreateCloneResult)(nil), "nutanix.hyperint.CloneVmRet.CreateCloneResult")
	proto.RegisterType((*CloneVmRet_QueryCloneResult)(nil), "nutanix.hyperint.CloneVmRet.QueryCloneResult")
	proto.RegisterType((*ConfigureHypervNodeArg)(nil), "nutanix.hyperint.ConfigureHypervNodeArg")
	proto.RegisterType((*ConfigureHypervNodeArg_DefaultVmVhdLocation)(nil), "nutanix.hyperint.ConfigureHypervNodeArg.DefaultVmVhdLocation")
	proto.RegisterType((*ConfigureHypervNodeArg_DomainConfiguration)(nil), "nutanix.hyperint.ConfigureHypervNodeArg.DomainConfiguration")
	proto.RegisterType((*ConfigureHypervNodeArg_RestartConfiguration)(nil), "nutanix.hyperint.ConfigureHypervNodeArg.RestartConfiguration")
	proto.RegisterType((*ConfigureHypervNodeArg_FailoverClusterConfiguration)(nil), "nutanix.hyperint.ConfigureHypervNodeArg.FailoverClusterConfiguration")
	proto.RegisterType((*ConfigureHypervNodeRet)(nil), "nutanix.hyperint.ConfigureHypervNodeRet")
	proto.RegisterType((*ConfigureHypervNodeRet_ConfigureResult)(nil), "nutanix.hyperint.ConfigureHypervNodeRet.ConfigureResult")
	proto.RegisterType((*PublishToArithmosArg)(nil), "nutanix.hyperint.PublishToArithmosArg")
	proto.RegisterType((*PublishToArithmosRet)(nil), "nutanix.hyperint.PublishToArithmosRet")
	proto.RegisterType((*ConfigureHypervClusterArg)(nil), "nutanix.hyperint.ConfigureHypervClusterArg")
	proto.RegisterType((*ConfigureHypervClusterArg_NdfsClusterDomainConfiguration)(nil), "nutanix.hyperint.ConfigureHypervClusterArg.NdfsClusterDomainConfiguration")
	proto.RegisterType((*ConfigureHypervClusterRet)(nil), "nutanix.hyperint.ConfigureHypervClusterRet")
	proto.RegisterType((*GetNetworkAdapterArg)(nil), "nutanix.hyperint.GetNetworkAdapterArg")
	proto.RegisterType((*GetNetworkAdapterRet)(nil), "nutanix.hyperint.GetNetworkAdapterRet")
	proto.RegisterType((*GetNetworkAdapterRet_Result)(nil), "nutanix.hyperint.GetNetworkAdapterRet.Result")
	proto.RegisterType((*HypervFailoverCluster)(nil), "nutanix.hyperint.HypervFailoverCluster")
	proto.RegisterType((*HypervFailoverCluster_MemberNode)(nil), "nutanix.hyperint.HypervFailoverCluster.MemberNode")
	proto.RegisterType((*GetHypervFailoverClusterArg)(nil), "nutanix.hyperint.GetHypervFailoverClusterArg")
	proto.RegisterType((*GetHypervFailoverClusterRet)(nil), "nutanix.hyperint.GetHypervFailoverClusterRet")
}

func init() { proto.RegisterFile("hyperint/hyperint.proto", fileDescriptor_0fb843cb6a8c7940) }

var fileDescriptor_0fb843cb6a8c7940 = []byte{
	// 8900 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x7d, 0x69, 0x8f, 0x24, 0x47,
	0x76, 0x18, 0xeb, 0xea, 0xe3, 0x55, 0x77, 0x55, 0x76, 0xf4, 0x31, 0x35, 0x35, 0x9c, 0x83, 0x45,
	0x72, 0x38, 0xe4, 0x90, 0x3d, 0x9c, 0x1e, 0x9a, 0xcb, 0x1d, 0x71, 0x49, 0x36, 0xbb, 0x7b, 0x86,
	0x45, 0x4e, 0xf7, 0xf4, 0x66, 0xf7, 0xf4, 0x7a, 0x49, 0x59, 0xe9, 0xec, 0xcc, 0xa8, 0xee, 0x64,
	0x55, 0x1e, 0xcc, 0xc8, 0xaa, 0x99, 0xa6, 0xe5, 0x05, 0x01, 0xd9, 0xd0, 0x1a, 0xf0, 0xb1, 0x96,
	0x85, 0x95, 0x2c, 0xc8, 0xb0, 0x2c, 0x43, 0x32, 0xf6, 0x83, 0x01, 0xe9, 0xc3, 0xc2, 0xf0, 0x01,
	0x5b, 0x80, 0x0d, 0xdb, 0x5f, 0xbc, 0xf2, 0xf1, 0xc1, 0x92, 0x0f, 0x40, 0x80, 0x01, 0x01, 0x36,
	0xec, 0x3f, 0x60, 0xd8, 0xb2, 0x11, 0x47, 0x66, 0x46, 0x64, 0x66, 0x55, 0xd7, 0x0c, 0x65, 0x7f,
	0xab, 0x7c, 0x11, 0xf1, 0xe2, 0x78, 0x47, 0xbc, 0xf7, 0xe2, 0x45, 0x14, 0x5c, 0x38, 0x3d, 0x0b,
	0x70, 0xe8, 0x78, 0xd1, 0xad, 0xf8, 0xc7, 0x7a, 0x10, 0xfa, 0x91, 0x8f, 0x34, 0x6f, 0x18, 0x99,
	0x9e, 0xf3, 0x64, 0x3d, 0x86, 0xb7, 0x5f, 0x27, 0x91, 0x19, 0x91, 0x5b, 0x66, 0xe8, 0x44, 0xa7,
	0xae, 0x4f, 0x6e, 0x39, 0x5e, 0x84, 0xc3, 0x9e, 0x69, 0xe1, 0x04, 0x64, 0x44, 0x67, 0x01, 0xe6,
	0xed, 0xdb, 0x97, 0x02, 0x27, 0x3a, 0xf5, 0xc9, 0x2d, 0x12, 0x85, 0x38, 0xb2, 0x4e, 0x8d, 0xc0,
	0x0c, 0x4d, 0x97, 0x88, 0xc2, 0xf6, 0x30, 0x72, 0x06, 0xb7, 0xc8, 0xc0, 0x38, 0x1e, 0xf6, 0xc8,
	0x2d, 0x0f, 0x47, 0xb7, 0xc2, 0xc0, 0x12, 0x65, 0xad, 0x2f, 0xf1, 0x90, 0xdc, 0xb2, 0x7c, 0xaf,
	0xe7, 0x9c, 0x0c, 0x43, 0x33, 0x72, 0x7c, 0x8f, 0x97, 0x74, 0x7e, 0xa5, 0x04, 0x8b, 0x1f, 0x89,
	0xd1, 0xec, 0x84, 0xa1, 0x1f, 0x76, 0xbe, 0x5f, 0x82, 0xea, 0xe1, 0x59, 0x80, 0xd1, 0x02, 0xcc,
	0xf5, 0xf7, 0x7c, 0x06, 0xd4, 0x9e, 0x43, 0x00, 0x33, 0x7d, 0x1d, 0x47, 0xe1, 0x99, 0x56, 0x42,
	0x8b, 0x30, 0xdf, 0xdf, 0x32, 0x3d, 0x0b, 0x0f, 0xb0, 0xad, 0x95, 0x59, 0xc5, 0x43, 0xc7, 0xc5,
	0xfe, 0x30, 0xd2, 0x2a, 0x68, 0x15, 0x96, 0xfa, 0xbb, 0xe6, 0xa0, 0xe7, 0x87, 0x2e, 0xb6, 0x75,
	0xfc, 0xc5, 0x10, 0x93, 0x48, 0xab, 0xa2, 0x0b, 0xb0, 0xdc, 0xdf, 0xc5, 0xd1, 0xa9, 0x6f, 0xef,
	0xf9, 0xd1, 0xc1, 0x30, 0x08, 0xfc, 0x30, 0xc2, 0xb6, 0x56, 0x63, 0xc8, 0xf6, 0xfc, 0xe8, 0x9e,
	0x3f, 0xf4, 0x6c, 0x6d, 0x86, 0xf5, 0xf3, 0x30, 0x3a, 0xc5, 0xa1, 0x66, 0x77, 0xfe, 0x7b, 0x19,
	0x1a, 0x7b, 0x38, 0x7a, 0xec, 0x87, 0xfd, 0x4d, 0xdb, 0x0c, 0x22, 0x1c, 0x22, 0x04, 0x55, 0xcf,
	0x74, 0x71, 0xab, 0x74, 0xad, 0x74, 0x63, 0x5e, 0x67, 0xbf, 0xd1, 0x35, 0xa8, 0xdb, 0x98, 0x58,
	0xa1, 0x13, 0xd0, 0x89, 0xb5, 0xca, 0xac, 0x48, 0x06, 0xa1, 0x16, 0xcc, 0x8e, 0x9c, 0x30, 0x1a,
	0x9a, 0x83, 0x56, 0xe5, 0x5a, 0xe9, 0xc6, 0x9c, 0x1e, 0x7f, 0xa2, 0xab, 0x50, 0x77, 0x4d, 0xcb,
	0x30, 0x6d, 0x3b, 0xc4, 0x84, 0xb4, 0xaa, 0xac, 0x2d, 0xb8, 0xa6, 0xb5, 0xc9, 0x21, 0xe8, 0x05,
	0x58, 0xb0, 0x4f, 0xad, 0xc0, 0xc0, 0x9e, 0x79, 0x3c, 0xc0, 0x76, 0xab, 0xc6, 0xda, 0xd7, 0x29,
	0x6c, 0x87, 0x83, 0xd0, 0xcb, 0xd0, 0x70, 0x82, 0xd1, 0x5b, 0x31, 0x12, 0x4c, 0x5a, 0x33, 0xd7,
	0x2a, 0x37, 0xe6, 0xf5, 0x45, 0x0a, 0xdd, 0x8c, 0x81, 0xe8, 0x15, 0x68, 0xda, 0xb8, 0x67, 0x0e,
	0x07, 0x91, 0x71, 0x62, 0x46, 0xf8, 0xb1, 0x79, 0xd6, 0x9a, 0x65, 0xdd, 0x35, 0x04, 0xf8, 0x3e,
	0x87, 0xd2, 0x2e, 0xe9, 0xbc, 0x0c, 0x82, 0xc3, 0x11, 0x0e, 0x49, 0x6b, 0x8e, 0x61, 0xab, 0x53,
	0xd8, 0x01, 0x07, 0xa1, 0x97, 0xa0, 0x31, 0x70, 0xbc, 0xbe, 0x41, 0x02, 0x8c, 0x6d, 0xe3, 0x38,
	0x20, 0xad, 0xf9, 0x6b, 0xa5, 0x1b, 0x15, 0x7d, 0x81, 0x42, 0x0f, 0x28, 0xf0, 0xc3, 0x80, 0xa0,
	0x37, 0x00, 0x51, 0xfe, 0x1a, 0x12, 0x43, 0x5e, 0x1f, 0x60, 0x9d, 0x2e, 0xf1, 0x92, 0xed, 0xb4,
	0xa0, 0xf3, 0xeb, 0x25, 0x58, 0x38, 0x72, 0x3f, 0xf4, 0xfd, 0x68, 0x8b, 0x71, 0x0a, 0x7a, 0x0d,
	0x16, 0x87, 0xb8, 0xe7, 0x18, 0x3d, 0x27, 0x74, 0x1f, 0x9b, 0x21, 0x5f, 0xf5, 0xb9, 0xbb, 0xb5,
	0x9e, 0x39, 0x20, 0x58, 0x5f, 0xa0, 0x65, 0xf7, 0x44, 0x11, 0xba, 0x0e, 0x75, 0x82, 0xad, 0x61,
	0x88, 0x8d, 0x63, 0xdf, 0x8f, 0x18, 0x11, 0x92, 0x9a, 0xc0, 0x4b, 0x28, 0x66, 0xf4, 0x1e, 0x5c,
	0x38, 0x35, 0x43, 0x9b, 0xb6, 0x31, 0x04, 0x11, 0x9c, 0x2f, 0x19, 0x47, 0x72, 0xd2, 0xc4, 0x6d,
	0xd6, 0xe2, 0x5a, 0x47, 0x4a, 0xa5, 0xce, 0x3f, 0x9d, 0x85, 0xb9, 0x23, 0x57, 0x0c, 0xf0, 0x12,
	0xcc, 0x7b, 0x43, 0xd7, 0x18, 0x59, 0xc1, 0x90, 0xb0, 0xc1, 0xd5, 0xf4, 0x39, 0x6f, 0xe8, 0x1e,
	0xd1, 0x6f, 0xf4, 0x3a, 0x20, 0x2b, 0x18, 0x1a, 0x21, 0xa6, 0xeb, 0xc8, 0x1a, 0x1b, 0xa7, 0x5f,
	0xb2, 0x81, 0x55, 0x74, 0xcd, 0x0a, 0x86, 0x7a, 0x5a, 0xf0, 0xd1, 0x97, 0x74, 0x45, 0x5d, 0xec,
	0x1a, 0xc4, 0xf9, 0x12, 0x1b, 0xc7, 0x67, 0x11, 0x26, 0x6c, 0x38, 0x15, 0x7d, 0xc1, 0xc5, 0xee,
	0x81, 0xf3, 0x25, 0xfe, 0x90, 0xc2, 0x28, 0x4e, 0x5a, 0x8b, 0xe3, 0xa4, 0x2b, 0xcf, 0x6a, 0x56,
	0x39, 0x4e, 0x17, 0xbb, 0xba, 0x28, 0xe0, 0xb5, 0xdf, 0x84, 0x15, 0x3a, 0x3c, 0x8f, 0xb3, 0xb0,
	0x61, 0x72, 0x1e, 0x26, 0x8c, 0x87, 0x6a, 0x3a, 0xf2, 0x86, 0xae, 0xca, 0xdd, 0x04, 0xbd, 0x06,
	0x4b, 0x6c, 0x42, 0x7c, 0xce, 0x86, 0xed, 0x90, 0x3e, 0xe5, 0x26, 0x5a, 0xbd, 0x49, 0x27, 0xc6,
	0xe1, 0xdb, 0x14, 0x8c, 0x3a, 0xb0, 0x78, 0x42, 0x85, 0xcb, 0xf0, 0x89, 0xc1, 0x64, 0x82, 0x73,
	0x53, 0x9d, 0x01, 0x1f, 0x92, 0x3d, 0x2a, 0x1a, 0x1f, 0xc2, 0xa2, 0x8a, 0x8b, 0xf2, 0x52, 0x7d,
	0xe3, 0xf2, 0x7a, 0x56, 0x13, 0xad, 0x4b, 0xa8, 0xf5, 0x85, 0x91, 0xdc, 0x8f, 0x03, 0x4d, 0x56,
	0x6b, 0xe4, 0x10, 0x3f, 0x64, 0xea, 0x88, 0x31, 0x5b, 0x63, 0xe3, 0x83, 0x04, 0x0b, 0x55, 0x2f,
	0xeb, 0x5b, 0xb2, 0x7a, 0xd9, 0xa7, 0xda, 0x65, 0x7d, 0xd7, 0xf4, 0xcc, 0x13, 0xec, 0x62, 0x2f,
	0xe2, 0x8c, 0xbb, 0xfe, 0x51, 0x82, 0x88, 0xaa, 0x18, 0xbd, 0x71, 0xaa, 0x7c, 0xa3, 0xeb, 0xd0,
	0x94, 0xa7, 0x6f, 0xd9, 0x84, 0x71, 0x6b, 0x4d, 0x5f, 0x4c, 0x27, 0xbf, 0x65, 0x13, 0xf4, 0x2e,
	0xd4, 0xe5, 0x3a, 0x75, 0x36, 0xa9, 0x4b, 0x63, 0x27, 0xb5, 0x65, 0xeb, 0x30, 0x4a, 0x5b, 0xdf,
	0x00, 0x8d, 0xab, 0x42, 0xa3, 0xe7, 0x0c, 0xb0, 0x11, 0x98, 0xd1, 0x69, 0x6b, 0x81, 0x4b, 0x22,
	0x87, 0xdf, 0x73, 0x06, 0x78, 0xdf, 0x8c, 0x4e, 0x29, 0x39, 0x88, 0x67, 0x06, 0xe4, 0xd4, 0x8f,
	0x0c, 0xdb, 0x09, 0x79, 0xd5, 0x45, 0x56, 0xb5, 0x19, 0x17, 0x6c, 0x3b, 0x21, 0xab, 0x7b, 0x13,
	0x28, 0x41, 0x0d, 0xcb, 0x0f, 0x31, 0x31, 0x02, 0x1c, 0x32, 0xae, 0x6c, 0x35, 0x12, 0xda, 0x6d,
	0xd1, 0x82, 0x7d, 0x1c, 0x52, 0xe6, 0x44, 0x9f, 0xc0, 0x8b, 0x32, 0x5d, 0x8c, 0xe1, 0xd0, 0xb1,
	0x8d, 0x10, 0x73, 0xa5, 0x68, 0x44, 0xbe, 0xc1, 0x88, 0xd8, 0x6a, 0x32, 0x65, 0x73, 0x45, 0x22,
	0xc7, 0xa3, 0xa1, 0x63, 0xeb, 0xa2, 0xde, 0xa1, 0x7f, 0x9f, 0xd6, 0x42, 0xef, 0xc3, 0xf3, 0x4e,
	0x10, 0x6b, 0x1f, 0xc3, 0xc6, 0x11, 0xb6, 0x18, 0xb7, 0xc7, 0x2a, 0x4b, 0x63, 0x58, 0x2e, 0x3a,
	0x81, 0xd0, 0x45, 0xdb, 0x71, 0x8d, 0x58, 0x81, 0xbd, 0x0f, 0x75, 0x2a, 0xb4, 0x06, 0x9f, 0x7d,
	0x6b, 0xe9, 0x5a, 0xe9, 0x46, 0x7d, 0xe3, 0x4a, 0xc1, 0x72, 0x4a, 0xca, 0x41, 0x87, 0xe3, 0x54,
	0x51, 0xdc, 0xe2, 0x8c, 0x1e, 0x9d, 0x86, 0xd8, 0xb4, 0xf9, 0xec, 0xe9, 0x3a, 0xb4, 0x10, 0x9b,
	0x3d, 0x65, 0xe9, 0x43, 0x5e, 0xb4, 0x8f, 0x43, 0xba, 0x0e, 0x9d, 0x9f, 0x54, 0x61, 0x3e, 0x21,
	0x0e, 0x7a, 0x0b, 0xaa, 0x8c, 0xad, 0x4a, 0xd7, 0xca, 0x37, 0x1a, 0x1b, 0xd7, 0x26, 0xd0, 0x71,
	0x9d, 0xb1, 0x0d, 0xab, 0x8d, 0x76, 0xa0, 0xce, 0xe8, 0xe7, 0x7b, 0x86, 0xd7, 0x23, 0x4c, 0xb0,
	0xeb, 0x1b, 0x2f, 0x4f, 0x6a, 0x4c, 0xe9, 0xfa, 0xd0, 0xdb, 0xeb, 0x11, 0x7d, 0xbe, 0x17, 0xff,
	0x44, 0x1f, 0xc3, 0x82, 0x10, 0x4c, 0x99, 0xb7, 0x5f, 0x99, 0x84, 0x47, 0x88, 0x2b, 0x1b, 0x4b,
	0xdd, 0x4c, 0x3f, 0xd0, 0x45, 0x98, 0xb3, 0x6c, 0x63, 0x60, 0x1e, 0xe3, 0x81, 0x50, 0xb3, 0xb3,
	0x96, 0xfd, 0x80, 0x7e, 0xa2, 0x57, 0x60, 0xc1, 0x21, 0x74, 0x85, 0x3d, 0x6c, 0x45, 0xd8, 0x6e,
	0xd5, 0x99, 0xb2, 0xab, 0x46, 0xe1, 0x10, 0xeb, 0x75, 0x87, 0x6c, 0xc5, 0x05, 0x6c, 0xc3, 0xc1,
	0x23, 0xc7, 0xc2, 0x86, 0xe3, 0xd9, 0xf8, 0x09, 0xe3, 0xcc, 0x1a, 0xdd, 0xce, 0x28, 0xac, 0x4b,
	0x41, 0x68, 0x05, 0x6a, 0xd8, 0x0d, 0xa2, 0x33, 0xc6, 0x8a, 0x73, 0x3a, 0xff, 0x68, 0xff, 0x42,
	0x09, 0xe6, 0x93, 0x19, 0x52, 0x7d, 0x96, 0x70, 0xb7, 0x21, 0x6d, 0x99, 0x0b, 0x3d, 0xc1, 0xdc,
	0x4c, 0x3f, 0x5c, 0x85, 0x7a, 0x88, 0x5d, 0x3f, 0x12, 0x52, 0x50, 0xe1, 0xdb, 0x1f, 0x07, 0x31,
	0xae, 0x5e, 0x83, 0x19, 0xbe, 0x0d, 0x89, 0x6d, 0x55, 0x7c, 0x51, 0x49, 0x25, 0xfe, 0x30, 0xb4,
	0x30, 0x5d, 0x7b, 0xde, 0x98, 0xef, 0x9d, 0x8b, 0x1c, 0xbc, 0xd7, 0x23, 0xb4, 0x7d, 0x67, 0x4d,
	0x18, 0x13, 0x0d, 0x80, 0x7e, 0x32, 0x38, 0xed, 0xb9, 0xce, 0x1e, 0xd4, 0xa5, 0x55, 0x44, 0xf3,
	0x50, 0xeb, 0x1f, 0x6c, 0x1d, 0x74, 0xb5, 0xe7, 0xd0, 0x1c, 0x54, 0xfb, 0xdd, 0xed, 0x1d, 0xad,
	0xc4, 0x4c, 0x81, 0x83, 0xfd, 0xcd, 0x7d, 0x5d, 0x2b, 0x33, 0xe8, 0xfe, 0x56, 0x57, 0xab, 0xf0,
	0xaa, 0x9b, 0x87, 0x9b, 0x5a, 0x95, 0xfd, 0xdc, 0x3b, 0xda, 0xdd, 0xd1, 0x6a, 0x9d, 0x5f, 0x59,
	0x80, 0xba, 0xa4, 0xc2, 0xd0, 0xdb, 0x0a, 0x4b, 0x75, 0x26, 0xea, 0x3b, 0x99, 0xa9, 0xee, 0x17,
	0x31, 0xd5, 0x2b, 0x93, 0x9b, 0x17, 0xb2, 0x95, 0x84, 0xc8, 0x36, 0xf9, 0x66, 0x32, 0x25, 0xa2,
	0x6d, 0x33, 0x41, 0xb4, 0x6d, 0x12, 0x14, 0x40, 0x3b, 0x46, 0x44, 0x4e, 0xcd, 0x10, 0xdb, 0x86,
	0x43, 0x2c, 0xe2, 0x18, 0x23, 0xaa, 0x38, 0xd8, 0xa2, 0xd7, 0x37, 0xde, 0x9a, 0x06, 0xef, 0x01,
	0x6b, 0xdd, 0xa5, 0x8d, 0x8f, 0x98, 0x9a, 0x5f, 0xeb, 0xe5, 0xe0, 0x14, 0x27, 0xea, 0x42, 0x5d,
	0xee, 0xa2, 0xc6, 0xba, 0xb8, 0x31, 0xb9, 0x0b, 0x09, 0x2d, 0x38, 0x29, 0xaa, 0x3b, 0x50, 0xa1,
	0xb3, 0x9f, 0x61, 0x28, 0x5e, 0x98, 0x8c, 0x82, 0xce, 0x9b, 0xd6, 0xa6, 0xf6, 0x94, 0x65, 0x06,
	0xa6, 0xe5, 0x44, 0x67, 0x62, 0x83, 0x9d, 0x65, 0x1b, 0xec, 0x62, 0x0c, 0xe5, 0xbb, 0x2b, 0x82,
	0x2a, 0x55, 0x9b, 0xad, 0x39, 0x6e, 0x0a, 0xd2, 0xdf, 0xe8, 0x41, 0xa1, 0x30, 0xbf, 0x3a, 0xb9,
	0xe3, 0xb1, 0xe2, 0x7c, 0x19, 0x80, 0x69, 0x67, 0x59, 0xa0, 0xe7, 0x29, 0x84, 0x8b, 0xf4, 0x3a,
	0x2c, 0x3b, 0xc4, 0x88, 0x4e, 0x1d, 0xcf, 0x08, 0x42, 0x7f, 0xe4, 0x10, 0xc7, 0xf7, 0xb0, 0x2d,
	0x84, 0x72, 0xc9, 0x21, 0x87, 0xa7, 0x0e, 0xdd, 0x07, 0xe3, 0x82, 0x9c, 0x64, 0xd7, 0xf3, 0x92,
	0x7d, 0x09, 0xe6, 0x1d, 0x22, 0xe8, 0xcc, 0x24, 0x7f, 0x4e, 0x9f, 0x73, 0x08, 0xa7, 0x50, 0xfb,
	0xaf, 0x95, 0xcf, 0x13, 0xf0, 0x72, 0x4e, 0xc0, 0x65, 0xf9, 0x2d, 0x4b, 0xf2, 0x9b, 0x13, 0xfc,
	0x72, 0x46, 0xf0, 0xef, 0x42, 0x9b, 0xcd, 0x1d, 0x3f, 0x89, 0xb0, 0x17, 0x19, 0x99, 0xae, 0xaa,
	0xcc, 0x24, 0x5d, 0xa3, 0x35, 0x76, 0x58, 0x85, 0x7b, 0x72, 0xa7, 0xd7, 0x98, 0xae, 0xeb, 0x0d,
	0x4c, 0xde, 0x4e, 0xd8, 0xcc, 0xe0, 0x90, 0x7b, 0x03, 0x93, 0xd5, 0xa4, 0x4b, 0x61, 0xf9, 0x5e,
	0x64, 0x3a, 0x1e, 0x0e, 0x0d, 0xc7, 0x66, 0x0c, 0x52, 0xd1, 0xeb, 0x09, 0xac, 0x6b, 0x17, 0x69,
	0x98, 0xd9, 0x02, 0x0d, 0xd3, 0xbe, 0x1d, 0x2f, 0x0a, 0x15, 0x96, 0xa9, 0x16, 0xa5, 0xfd, 0x00,
	0xea, 0x8c, 0x5f, 0x0f, 0xcd, 0xf0, 0x04, 0x47, 0xe8, 0x79, 0x98, 0x4f, 0x4d, 0xf7, 0x12, 0x9b,
	0x59, 0x0a, 0xa0, 0x2b, 0x15, 0xb1, 0x7a, 0x1c, 0x1f, 0x5f, 0x46, 0xe0, 0x20, 0x86, 0xed, 0x2f,
	0x96, 0x60, 0xad, 0x58, 0xc2, 0xa6, 0xa4, 0xd1, 0x03, 0xba, 0x5c, 0x54, 0xde, 0x38, 0xd2, 0x56,
	0x99, 0x99, 0x33, 0xaf, 0x4e, 0x21, 0x70, 0x7c, 0x02, 0x3a, 0x17, 0x57, 0xfe, 0xd1, 0xfe, 0x14,
	0x40, 0x1a, 0x41, 0x16, 0x37, 0xed, 0xff, 0xd9, 0x71, 0xd7, 0xa0, 0xb2, 0x6d, 0x92, 0xce, 0xcf,
	0x14, 0x2b, 0x75, 0xe9, 0x7b, 0xdb, 0x24, 0x5a, 0x09, 0x5d, 0x82, 0x0b, 0xfd, 0xe2, 0x95, 0xd1,
	0xca, 0xa8, 0x09, 0xf5, 0xbe, 0x04, 0xa8, 0x30, 0x15, 0x4f, 0xdb, 0x55, 0xff, 0xd8, 0x37, 0x87,
	0x7f, 0xc9, 0x1c, 0x1b, 0x3a, 0x12, 0x61, 0xaf, 0x74, 0x60, 0x91, 0x32, 0x55, 0x6a, 0xfe, 0x95,
	0x84, 0x8b, 0xd5, 0x23, 0x89, 0xed, 0xf7, 0x0d, 0xb1, 0x83, 0x50, 0x6a, 0x34, 0x36, 0x5e, 0x2c,
	0xb2, 0x86, 0x52, 0x8c, 0xd2, 0x16, 0xd2, 0xf9, 0x4c, 0xac, 0x4e, 0x1d, 0x66, 0xfb, 0xbc, 0x54,
	0x0c, 0xfc, 0x81, 0x7f, 0xa2, 0x95, 0xd8, 0xb8, 0xc4, 0x12, 0x30, 0xc7, 0xd9, 0x0d, 0xc4, 0xfc,
	0xa9, 0x23, 0x7c, 0x20, 0x8c, 0x4a, 0xad, 0xca, 0xa7, 0x7a, 0xf0, 0x50, 0xab, 0xb1, 0xa9, 0xee,
	0x1d, 0xe9, 0x9b, 0xbb, 0xda, 0x4c, 0xe7, 0x7f, 0x55, 0xe1, 0x92, 0x20, 0x95, 0xea, 0x3b, 0x88,
	0x99, 0x51, 0xdf, 0x51, 0xb8, 0x1b, 0xd2, 0xa6, 0x5f, 0x17, 0x30, 0xc6, 0x6e, 0x2f, 0x64, 0x74,
	0xa4, 0xf0, 0x97, 0x65, 0xc5, 0xb7, 0x02, 0x35, 0xae, 0xf3, 0xb8, 0x41, 0xc0, 0x3f, 0xce, 0xf7,
	0x95, 0x7b, 0xa0, 0x49, 0x15, 0x38, 0xf6, 0x1a, 0xd3, 0xc0, 0xef, 0x8e, 0x65, 0xb8, 0xa2, 0x59,
	0xac, 0xef, 0x26, 0x38, 0xb9, 0x9b, 0xe0, 0x2a, 0xdf, 0xe8, 0x0d, 0x58, 0x7e, 0x6c, 0xf6, 0xd9,
	0x96, 0x38, 0x30, 0x3d, 0x03, 0x0f, 0xb8, 0x9d, 0x3b, 0xc3, 0xd4, 0x8c, 0x46, 0x8b, 0x1e, 0x7a,
	0x0f, 0x4c, 0x6f, 0x87, 0xc3, 0xa9, 0x7c, 0xa7, 0x76, 0xd7, 0x2c, 0xab, 0x94, 0x02, 0x0a, 0xbc,
	0xf7, 0xb9, 0x22, 0xef, 0x9d, 0x57, 0x7b, 0x5b, 0xaa, 0x36, 0x9f, 0x54, 0x7b, 0x3b, 0xad, 0x76,
	0x01, 0x66, 0xa9, 0x71, 0x4e, 0x75, 0x1a, 0xdf, 0x2f, 0x66, 0xe8, 0x67, 0xd7, 0xa6, 0x3a, 0xf1,
	0xd4, 0x27, 0x91, 0xe1, 0x39, 0x96, 0xe1, 0x08, 0x9f, 0x65, 0x5e, 0x07, 0x0a, 0xdb, 0x73, 0xac,
	0xae, 0x4d, 0xd0, 0x43, 0x58, 0x1a, 0x6c, 0x24, 0xce, 0xa2, 0xb0, 0xc5, 0x17, 0xd8, 0xce, 0x59,
	0xc8, 0x7d, 0x0f, 0x36, 0xc4, 0xda, 0x09, 0x83, 0xbc, 0x39, 0x50, 0x01, 0xc9, 0x06, 0xb9, 0x98,
	0x6e, 0x90, 0x9d, 0x6f, 0x41, 0x43, 0x5d, 0x5c, 0xc6, 0xa6, 0x07, 0x91, 0x19, 0x39, 0x96, 0xf6,
	0x1c, 0xe3, 0xc1, 0x4d, 0x42, 0x9c, 0x13, 0x0f, 0xdb, 0x5a, 0x89, 0xc9, 0xe8, 0xee, 0x41, 0x02,
	0x28, 0x77, 0x7e, 0x1a, 0x9a, 0x47, 0xae, 0xda, 0x4b, 0x17, 0xe6, 0x12, 0xc7, 0xb6, 0xc4, 0x34,
	0xd7, 0x1b, 0x4f, 0x45, 0x6c, 0x3d, 0x69, 0xde, 0xf9, 0x61, 0x1d, 0x66, 0x8e, 0xdc, 0xae, 0xd7,
	0xf3, 0xd1, 0x32, 0xd4, 0x46, 0x2e, 0x5d, 0x45, 0xae, 0x30, 0xab, 0x23, 0xb7, 0xcb, 0x37, 0x50,
	0x87, 0x04, 0x03, 0xf3, 0x4c, 0xd6, 0xc5, 0x75, 0x01, 0x8b, 0x99, 0x3b, 0xf5, 0x85, 0x98, 0x13,
	0xcf, 0x04, 0x3b, 0xf1, 0x7d, 0x38, 0x89, 0x3c, 0xdf, 0xc6, 0x14, 0x39, 0x77, 0xdc, 0x67, 0xe8,
	0x67, 0xd7, 0x46, 0xdf, 0x80, 0xf9, 0x91, 0x1b, 0x2f, 0x3c, 0xb7, 0x7a, 0xda, 0x45, 0x0b, 0x1f,
	0x8f, 0x7b, 0x14, 0x87, 0x21, 0xb6, 0xa1, 0x31, 0x72, 0xb9, 0x36, 0x11, 0xad, 0x67, 0xc6, 0xbb,
	0x50, 0xa9, 0xd2, 0xd0, 0x17, 0x46, 0xb2, 0x52, 0xda, 0x86, 0x7a, 0xe0, 0x3f, 0xc6, 0xa1, 0x41,
	0x22, 0x33, 0xe2, 0xde, 0xfc, 0x18, 0xbd, 0x43, 0x57, 0x68, 0x7d, 0x9f, 0xd6, 0xa5, 0x84, 0xc3,
	0x3a, 0x04, 0xc9, 0x6f, 0xb4, 0x0b, 0x4b, 0x23, 0x37, 0xcb, 0x45, 0x73, 0x63, 0xed, 0x2f, 0x37,
	0xc3, 0x43, 0xa3, 0x0c, 0x75, 0x5b, 0x30, 0x43, 0xdd, 0x96, 0x91, 0xcb, 0x03, 0x4c, 0x77, 0x4b,
	0x6f, 0xea, 0x35, 0x87, 0x6c, 0x8d, 0x5c, 0xf4, 0x31, 0x40, 0xb2, 0x5d, 0x53, 0x37, 0x9d, 0x52,
	0xfe, 0xb5, 0x73, 0x23, 0x02, 0x5b, 0x71, 0x13, 0x5d, 0x6a, 0x4d, 0xf7, 0xc9, 0x91, 0x6b, 0xf8,
	0x81, 0xf9, 0xc5, 0x10, 0x1b, 0xb6, 0x19, 0x99, 0xcc, 0x36, 0x5a, 0xa0, 0x0b, 0xf4, 0x90, 0x01,
	0xb7, 0xcd, 0xc8, 0xa4, 0xb5, 0xe8, 0x58, 0x8e, 0x43, 0x83, 0x1a, 0x82, 0xc7, 0x03, 0x2c, 0x2c,
	0xa4, 0x05, 0x87, 0x6c, 0x1d, 0x87, 0x5b, 0x1c, 0x86, 0xee, 0xc0, 0x1a, 0xad, 0xe2, 0x51, 0x7f,
	0x96, 0x83, 0x8c, 0x10, 0x9b, 0xc4, 0xf7, 0x84, 0x1c, 0x2c, 0x5b, 0xc7, 0xe1, 0x9e, 0x1f, 0x89,
	0xea, 0x3a, 0x2b, 0x42, 0xf7, 0xe1, 0x9a, 0x19, 0x04, 0x74, 0xb9, 0x88, 0x43, 0x98, 0xc1, 0x93,
	0xf8, 0xfd, 0x21, 0xfe, 0x62, 0xe8, 0x50, 0x73, 0xac, 0xc1, 0x3a, 0xbb, 0x6c, 0x06, 0xc1, 0x56,
	0x52, 0x2d, 0xd6, 0xd7, 0xba, 0xa8, 0x84, 0x3e, 0x83, 0x9b, 0xe3, 0x10, 0x79, 0x12, 0xb2, 0x78,
	0x48, 0x4d, 0x36, 0xa4, 0xeb, 0x85, 0x38, 0xf7, 0x52, 0xb4, 0x62, 0x94, 0xef, 0x40, 0x2b, 0x8e,
	0x1a, 0xa4, 0x31, 0x34, 0x1c, 0x52, 0xf3, 0x92, 0x39, 0xf9, 0x35, 0x7d, 0x4d, 0x94, 0x7f, 0x14,
	0x07, 0xcf, 0x78, 0x29, 0x0b, 0x94, 0x51, 0x9e, 0x67, 0xfa, 0x60, 0x89, 0xad, 0xed, 0x1c, 0x05,
	0x3c, 0xa2, 0x46, 0xf3, 0x75, 0x68, 0x3a, 0xc4, 0x18, 0xf9, 0x83, 0xa1, 0x8b, 0x8d, 0x93, 0xd0,
	0x1f, 0x06, 0xcc, 0x71, 0x9f, 0xd3, 0x17, 0x1d, 0x72, 0xc4, 0xa0, 0xf7, 0x29, 0x10, 0x7d, 0x17,
	0x90, 0x19, 0x45, 0xa6, 0x75, 0x8a, 0x6d, 0x63, 0x74, 0x12, 0xf3, 0xd6, 0x32, 0xa3, 0xfc, 0xcd,
	0xb1, 0x7c, 0x7a, 0x74, 0xb2, 0xc9, 0x1a, 0xb9, 0xd8, 0x8b, 0x43, 0x07, 0x5a, 0x8c, 0xe6, 0xe8,
	0x24, 0x0d, 0xe4, 0x1d, 0x3b, 0x3e, 0xe1, 0xe3, 0x5b, 0x61, 0x8b, 0x32, 0x47, 0x01, 0x6c, 0x7c,
	0x1b, 0xb0, 0x46, 0xc7, 0xe7, 0x1a, 0x91, 0x49, 0xfa, 0x06, 0xb7, 0xb6, 0x4f, 0xd8, 0x16, 0xb4,
	0xca, 0x86, 0x89, 0x1c, 0x72, 0xe4, 0x1e, 0x9a, 0xa4, 0xdf, 0xa5, 0x4c, 0xc6, 0x4a, 0xd0, 0x23,
	0x58, 0x52, 0xa3, 0xe4, 0x54, 0xdc, 0xd7, 0x98, 0x18, 0xa4, 0xc6, 0x0f, 0x0f, 0xa7, 0xaf, 0x1f,
	0xf0, 0x8a, 0xfb, 0x3c, 0x9a, 0xfe, 0xc8, 0x73, 0xe8, 0x9a, 0x9a, 0x83, 0xae, 0xad, 0x37, 0x89,
	0x5c, 0xd4, 0xb5, 0xdb, 0xbf, 0x5a, 0x02, 0x94, 0x9f, 0x10, 0xd3, 0x56, 0x27, 0x5c, 0x5b, 0x31,
	0x55, 0x3b, 0x3a, 0xe9, 0xe6, 0xcd, 0xfd, 0x72, 0xde, 0xdc, 0x57, 0x1d, 0x8c, 0x4a, 0xd6, 0xc1,
	0x50, 0xbc, 0x81, 0xaa, 0xea, 0x0d, 0x24, 0x91, 0xf0, 0x5a, 0x1a, 0x09, 0xef, 0x1c, 0x01, 0xa4,
	0x6a, 0x81, 0x69, 0x6f, 0xf6, 0x89, 0xed, 0x87, 0xbd, 0x9e, 0xb0, 0xcf, 0x62, 0x80, 0xa7, 0x95,
	0xd8, 0xf7, 0xc1, 0x90, 0x04, 0xd8, 0xb3, 0x59, 0x20, 0x9f, 0x6e, 0x05, 0xfb, 0xe6, 0x90, 0x60,
	0x5b, 0xab, 0x48, 0x81, 0xf8, 0x6a, 0xe7, 0x1f, 0x54, 0x60, 0x91, 0x8a, 0x20, 0x89, 0xfc, 0x10,
	0x33, 0xfd, 0x2c, 0x29, 0x51, 0xaa, 0xa1, 0x53, 0x25, 0x9a, 0xb5, 0xec, 0xcb, 0xac, 0x54, 0xb1,
	0xec, 0xa9, 0x1d, 0xe1, 0x0f, 0xbd, 0xc8, 0x08, 0x7c, 0xc7, 0x8b, 0xe2, 0xa0, 0x03, 0x03, 0xed,
	0x53, 0x08, 0x73, 0x00, 0x13, 0x1c, 0xc2, 0xdf, 0x60, 0x96, 0x7f, 0x02, 0x65, 0xba, 0xfe, 0x65,
	0x68, 0xd8, 0xf1, 0xa0, 0x0c, 0x69, 0x2d, 0x16, 0x13, 0x28, 0xab, 0x76, 0x1d, 0x9a, 0x6c, 0xe7,
	0x4d, 0xf7, 0x05, 0xa6, 0x9e, 0xe7, 0xf5, 0x45, 0x0a, 0xee, 0xc6, 0x3b, 0x03, 0x6a, 0xc3, 0x5c,
	0xec, 0x60, 0x0a, 0x87, 0x33, 0xf9, 0xa6, 0x84, 0xea, 0x85, 0x18, 0x1b, 0x24, 0x30, 0x2d, 0xcc,
	0xd4, 0x69, 0x45, 0x9f, 0xa7, 0x90, 0x03, 0x0a, 0x40, 0xab, 0x30, 0xc3, 0x76, 0xab, 0xd8, 0x28,
	0xa8, 0xd1, 0xed, 0x8a, 0xa0, 0x8b, 0x30, 0x47, 0x75, 0xb1, 0xe9, 0x62, 0xae, 0x20, 0xe7, 0xf5,
	0xd9, 0x91, 0x4b, 0xc7, 0x44, 0xd4, 0xb1, 0x33, 0xae, 0xaf, 0x67, 0xc6, 0xce, 0x58, 0x5f, 0x91,
	0x5b, 0x1e, 0xa3, 0x4c, 0xe5, 0x56, 0x59, 0x26, 0x69, 0xa7, 0x4f, 0x97, 0x89, 0x56, 0xeb, 0xfc,
	0xdb, 0x59, 0x58, 0xfe, 0xc8, 0x27, 0x51, 0xc6, 0x5e, 0x40, 0x2f, 0xc2, 0x62, 0x2f, 0x74, 0xb0,
	0x67, 0x0f, 0xce, 0xd4, 0x00, 0x91, 0x00, 0xb2, 0xc5, 0x73, 0x61, 0x75, 0xc4, 0x02, 0xfc, 0xd9,
	0x2d, 0x85, 0x47, 0x46, 0xbe, 0x99, 0x17, 0xfb, 0x82, 0xae, 0xd6, 0x8f, 0x76, 0x29, 0x0a, 0x75,
	0xab, 0x59, 0xe6, 0x78, 0xd5, 0x31, 0xb9, 0xb0, 0xca, 0x43, 0xc2, 0xd9, 0xee, 0x2a, 0x4f, 0xd3,
	0x1d, 0x8b, 0x32, 0x1f, 0x65, 0xba, 0xe3, 0x78, 0xd5, 0xee, 0x46, 0xd0, 0x32, 0xad, 0xd0, 0x0f,
	0xfc, 0x81, 0x43, 0xb2, 0x3d, 0xf2, 0xc8, 0xca, 0xbb, 0xd3, 0xf5, 0xb8, 0x19, 0x63, 0x51, 0x3b,
	0x5d, 0x33, 0x0b, 0xe1, 0xc8, 0x06, 0x64, 0x3e, 0xce, 0xf5, 0xc8, 0x4d, 0x8e, 0xb7, 0xa7, 0xec,
	0xf1, 0x3b, 0x07, 0x6a, 0x5f, 0x9a, 0xf9, 0x38, 0xd3, 0xcb, 0xe7, 0xb0, 0x62, 0x7e, 0x39, 0xcc,
	0x93, 0x8e, 0x1b, 0x27, 0xef, 0x4c, 0xd9, 0x0f, 0xc5, 0xa0, 0xf6, 0x84, 0xcc, 0x1c, 0xac, 0xfd,
	0x04, 0x96, 0x0b, 0x88, 0x4c, 0x65, 0x8f, 0x99, 0xc3, 0x6c, 0x57, 0x91, 0xb9, 0x6c, 0x91, 0x82,
	0xd9, 0xb6, 0xc2, 0xd8, 0xec, 0x9b, 0x70, 0xd1, 0x21, 0x86, 0xed, 0x90, 0x28, 0x74, 0x8e, 0x87,
	0x11, 0xb6, 0x8d, 0xb4, 0x19, 0x3f, 0x4b, 0xd2, 0xd7, 0x1c, 0xb2, 0x9d, 0x96, 0xef, 0xc7, 0xcd,
	0xdb, 0xef, 0xc0, 0x72, 0x01, 0xbd, 0xa7, 0x70, 0x84, 0xda, 0x3f, 0x05, 0x6b, 0xc5, 0x74, 0x93,
	0x1b, 0x33, 0xb9, 0x2a, 0xb1, 0x1d, 0x33, 0x6e, 0x4c, 0xa5, 0xaa, 0x7d, 0x0b, 0xb4, 0x2c, 0x09,
	0xa8, 0xb4, 0x92, 0xe1, 0xb1, 0x87, 0xa3, 0x74, 0x2b, 0x98, 0xe3, 0x80, 0xae, 0xdd, 0x7e, 0x00,
	0x28, 0xbf, 0x96, 0x13, 0x9b, 0x30, 0xfd, 0x11, 0x78, 0xb1, 0xad, 0xcb, 0xc2, 0xc9, 0xa3, 0xc0,
	0xa3, 0x63, 0xef, 0xfc, 0xcf, 0x19, 0x58, 0xca, 0xb9, 0x00, 0xe3, 0xa5, 0xb5, 0x34, 0x4e, 0x7c,
	0x72, 0x38, 0x84, 0xac, 0x66, 0x0d, 0xc3, 0xa7, 0x93, 0xd6, 0xf2, 0xf4, 0xdd, 0x71, 0xda, 0xe5,
	0xba, 0x7b, 0x5a, 0x69, 0xad, 0x8c, 0x93, 0xd6, 0x7c, 0x8f, 0x09, 0xcd, 0xb3, 0x9d, 0x3e, 0x9d,
	0xb4, 0x56, 0xc7, 0x49, 0x6b, 0x41, 0x8f, 0xdf, 0x39, 0xc8, 0xf6, 0x35, 0xbd, 0xb4, 0xd6, 0xc6,
	0x49, 0x6b, 0x41, 0x3f, 0xb4, 0x7d, 0xb6, 0xa7, 0x22, 0x69, 0x7d, 0x1f, 0x56, 0x0b, 0xc9, 0x3c,
	0xad, 0xbc, 0xb6, 0xef, 0xc2, 0x6a, 0x21, 0xe1, 0xa6, 0x11, 0xbb, 0x6f, 0x41, 0x6b, 0x1c, 0x09,
	0xa6, 0x11, 0xbc, 0xdb, 0x80, 0xf2, 0xeb, 0x39, 0x59, 0xf4, 0xf6, 0x60, 0xa5, 0x68, 0x69, 0x9e,
	0x59, 0xf8, 0xfe, 0x51, 0x09, 0xb4, 0x64, 0xed, 0x77, 0xcd, 0x20, 0x70, 0xbc, 0x13, 0x74, 0x00,
	0x88, 0x84, 0x56, 0xb1, 0xe0, 0xbd, 0x3c, 0x95, 0xae, 0xd5, 0x35, 0x12, 0x5a, 0xea, 0x08, 0x0f,
	0x00, 0xd9, 0x24, 0x2a, 0x16, 0xaf, 0x69, 0x91, 0xda, 0x24, 0x52, 0x20, 0x9d, 0x1f, 0x94, 0x41,
	0x7b, 0x70, 0x27, 0x33, 0xfc, 0x4f, 0xa1, 0x19, 0xc7, 0x6d, 0x5c, 0x0e, 0x12, 0xde, 0xfc, 0xed,
	0x7c, 0x37, 0xd9, 0xc6, 0xeb, 0xc2, 0x84, 0x12, 0x9f, 0x7a, 0xc3, 0x54, 0xbe, 0xdb, 0x7f, 0xb3,
	0x04, 0x0d, 0xb5, 0x0a, 0xba, 0x05, 0x2b, 0x74, 0xb5, 0x48, 0x64, 0x86, 0x8a, 0x65, 0xc6, 0x09,
	0xbe, 0x44, 0x42, 0xeb, 0x80, 0x16, 0xa5, 0xd6, 0xd9, 0x4d, 0xbe, 0xbc, 0xd8, 0xb3, 0xe5, 0xea,
	0x65, 0x56, 0xbd, 0x49, 0x42, 0x6b, 0xc7, 0xb3, 0xd3, 0xca, 0xb7, 0x60, 0x85, 0x2e, 0x5b, 0x0e,
	0x7b, 0x85, 0x63, 0xb7, 0x49, 0xa4, 0x62, 0xef, 0xfc, 0xb0, 0x94, 0x64, 0x9a, 0xc4, 0x23, 0xdc,
	0x04, 0x18, 0x6c, 0x48, 0x6b, 0x41, 0x97, 0xbc, 0xe0, 0x1c, 0x29, 0xcb, 0x07, 0xfa, 0xfc, 0x60,
	0x43, 0x46, 0x71, 0x27, 0x41, 0x51, 0x1e, 0x8b, 0xe2, 0x4e, 0x0e, 0xc5, 0x1d, 0xf1, 0xb3, 0xf3,
	0x7b, 0x25, 0x40, 0x94, 0xaa, 0x99, 0xc1, 0xc5, 0xa1, 0x1d, 0xbe, 0x5c, 0xfc, 0xec, 0xe3, 0x13,
	0xd0, 0x62, 0x3e, 0x11, 0x5d, 0x12, 0x11, 0x4a, 0x2e, 0x38, 0x51, 0xcd, 0xf4, 0xd8, 0xf4, 0x94,
	0x6f, 0x82, 0xde, 0x86, 0x0b, 0x03, 0x93, 0x44, 0x86, 0xeb, 0xdb, 0x4e, 0xcf, 0xc1, 0xb6, 0x11,
	0x39, 0x2e, 0x26, 0x91, 0xe9, 0x06, 0x22, 0x2f, 0x62, 0x95, 0x16, 0xef, 0x8a, 0xd2, 0xc3, 0xb8,
	0x10, 0xbd, 0x0a, 0x9a, 0x8d, 0x07, 0x38, 0xc2, 0x52, 0x03, 0x1e, 0x65, 0x69, 0x72, 0x78, 0x52,
	0xb5, 0xf3, 0x37, 0x4a, 0xd0, 0xca, 0x0c, 0x03, 0x07, 0x3e, 0x71, 0x22, 0x3f, 0x3c, 0x43, 0x87,
	0xb0, 0x9c, 0x99, 0x8c, 0x31, 0xc2, 0x96, 0x60, 0xc9, 0x97, 0x8a, 0x39, 0x3f, 0x83, 0x6c, 0x49,
	0x9d, 0xd3, 0x11, 0xb6, 0xd0, 0x4d, 0x58, 0x1a, 0xf8, 0x27, 0x8e, 0x65, 0x0e, 0xa4, 0xe1, 0x89,
	0x8c, 0x10, 0x51, 0x90, 0x8e, 0xef, 0x3e, 0xc0, 0x56, 0x88, 0x6d, 0xec, 0x45, 0x8e, 0x39, 0xa0,
	0x1e, 0xc0, 0xc0, 0x3f, 0xf1, 0x3d, 0x59, 0xad, 0xcd, 0x33, 0x08, 0x33, 0x60, 0xda, 0x30, 0x17,
	0x98, 0x84, 0x3c, 0xf6, 0x43, 0x5b, 0x38, 0x34, 0xc9, 0x77, 0xe7, 0x26, 0x34, 0xee, 0xe3, 0x68,
	0x8f, 0xfa, 0x47, 0x5e, 0xcf, 0xdf, 0x0c, 0x4f, 0xa8, 0x6e, 0x11, 0xde, 0x13, 0x8f, 0x99, 0x55,
	0xf4, 0x59, 0xee, 0x3e, 0x91, 0xce, 0x2f, 0x57, 0x94, 0xda, 0x3a, 0x8e, 0xd0, 0x67, 0xb0, 0xc4,
	0x6b, 0x7b, 0x3d, 0xdf, 0x08, 0x31, 0x19, 0x0e, 0xa2, 0x38, 0xd4, 0x76, 0x2b, 0xbf, 0x12, 0x6a,
	0xe3, 0xf5, 0xf4, 0x37, 0x6d, 0xa7, 0x37, 0x3d, 0xe5, 0x9b, 0xb4, 0xff, 0x23, 0xe5, 0x7c, 0x05,
	0x86, 0xee, 0x41, 0x0d, 0x87, 0xa1, 0x1f, 0xb2, 0x59, 0x36, 0x36, 0xae, 0x9f, 0xdb, 0x07, 0xcb,
	0x11, 0xbb, 0x9b, 0x64, 0x8b, 0xe9, 0xbc, 0x39, 0x7a, 0x0b, 0xaa, 0xb4, 0x37, 0xc1, 0xf8, 0x29,
	0x13, 0xc6, 0xa9, 0x6d, 0xeb, 0x49, 0xb6, 0x1b, 0x1b, 0xa5, 0xce, 0x6a, 0xcb, 0x6c, 0x9c, 0xc4,
	0x15, 0x2b, 0xe7, 0xb0, 0xb1, 0x08, 0x28, 0x26, 0x6c, 0x1c, 0xe7, 0xd3, 0x74, 0x3e, 0x81, 0x1a,
	0x1b, 0x52, 0x26, 0x99, 0x6d, 0x09, 0x16, 0xfb, 0xb4, 0xcb, 0x24, 0xef, 0xac, 0xc4, 0xd2, 0xd6,
	0x04, 0x48, 0xc7, 0xa6, 0x75, 0x6a, 0x1e, 0x0f, 0xb0, 0x56, 0x96, 0xbc, 0xe0, 0x4a, 0xe7, 0x3f,
	0xcd, 0xc0, 0xc2, 0x7d, 0x1c, 0xf1, 0xb8, 0xc6, 0x64, 0x32, 0x4a, 0x1e, 0x61, 0x59, 0xf6, 0x08,
	0x5f, 0x81, 0xa6, 0xea, 0xd9, 0xc6, 0x11, 0xca, 0x86, 0xe2, 0xda, 0xaa, 0xae, 0x63, 0x55, 0x75,
	0x1d, 0x37, 0x59, 0x51, 0x60, 0x46, 0xa7, 0xa4, 0x55, 0x63, 0x0b, 0x53, 0x4c, 0xa1, 0x64, 0x9c,
	0xeb, 0x47, 0xee, 0x3e, 0xad, 0x4d, 0x51, 0xb0, 0x1f, 0xe8, 0x15, 0x58, 0xb0, 0x06, 0x43, 0x12,
	0xe1, 0xd0, 0x78, 0xec, 0xd8, 0x58, 0x4d, 0x46, 0x10, 0x25, 0xdf, 0x71, 0x6c, 0x8c, 0x6e, 0xc3,
	0x92, 0xe3, 0x59, 0x83, 0xa1, 0x8d, 0x8d, 0x34, 0x34, 0xba, 0x20, 0xe7, 0x69, 0x35, 0x45, 0x79,
	0x92, 0x93, 0x75, 0x17, 0xd6, 0xa4, 0x26, 0x72, 0x50, 0x74, 0x51, 0x6e, 0xb7, 0x9c, 0xb4, 0x93,
	0x42, 0xa0, 0x6f, 0xc3, 0x8a, 0xef, 0x0d, 0xce, 0xe4, 0x18, 0x9f, 0x31, 0x72, 0x09, 0x0f, 0xbd,
	0xc5, 0x2d, 0x97, 0x68, 0x95, 0x34, 0xe0, 0x77, 0xe4, 0x12, 0xf4, 0x01, 0x5c, 0x94, 0xfa, 0xcc,
	0xec, 0x96, 0x4d, 0x25, 0xad, 0x2c, 0xe9, 0x36, 0x67, 0x78, 0x28, 0x71, 0x63, 0x2d, 0x1f, 0x37,
	0xbe, 0xa3, 0x4c, 0x4c, 0x0e, 0x56, 0x2e, 0x31, 0x07, 0x25, 0x9d, 0x91, 0x14, 0xb3, 0xbc, 0x0b,
	0x6b, 0x81, 0x19, 0x45, 0x38, 0xf4, 0x0c, 0xd7, 0x8c, 0xac, 0x53, 0x23, 0xa1, 0x2a, 0x52, 0x56,
	0x43, 0x54, 0xda, 0xa5, 0x75, 0x8e, 0x04, 0xa1, 0xdf, 0x57, 0x66, 0x45, 0x22, 0x3f, 0x34, 0x4f,
	0x70, 0x1a, 0x76, 0x4b, 0x49, 0x96, 0x4e, 0xea, 0x80, 0x57, 0x12, 0x93, 0xfa, 0x10, 0xda, 0x31,
	0x82, 0x82, 0xc0, 0xdd, 0x8a, 0x3c, 0x80, 0x0b, 0xa2, 0xe2, 0x66, 0x36, 0x32, 0x27, 0x2d, 0x6d,
	0x3e, 0xa0, 0xb6, 0x5a, 0xb4, 0xb4, 0x07, 0x99, 0x98, 0xd9, 0x75, 0x98, 0x15, 0x0c, 0xc8, 0xc2,
	0x19, 0xe2, 0x30, 0x37, 0x3e, 0x69, 0x9d, 0xf3, 0xf8, 0x39, 0x2e, 0xe9, 0xfc, 0xdd, 0xb2, 0x24,
	0x5e, 0x54, 0xef, 0x1d, 0x40, 0x93, 0xca, 0x50, 0x5e, 0xeb, 0xdd, 0x9c, 0xc0, 0xef, 0x54, 0x1f,
	0xc5, 0xbf, 0x98, 0xc6, 0x5b, 0x1c, 0xb9, 0xb2, 0xbe, 0xfb, 0x79, 0x76, 0x16, 0x28, 0x69, 0xbb,
	0xdb, 0x30, 0x2b, 0x7a, 0x11, 0x9b, 0x7c, 0x6b, 0x5c, 0x28, 0x53, 0x9f, 0xe1, 0xa8, 0xd0, 0x76,
	0xac, 0x20, 0xcb, 0x4c, 0x41, 0xbe, 0x74, 0xce, 0x70, 0x8a, 0xd5, 0x63, 0xe7, 0xbd, 0x62, 0xdd,
	0xd4, 0x84, 0x7a, 0xff, 0xc8, 0x95, 0x34, 0x53, 0xaa, 0x82, 0xca, 0x52, 0x16, 0x6e, 0xa5, 0xf3,
	0x5f, 0x6b, 0xb0, 0x18, 0xc7, 0x8a, 0x8f, 0x5c, 0xaa, 0x8f, 0xb2, 0x62, 0x5d, 0x1a, 0x27, 0xd6,
	0xdf, 0x05, 0x2d, 0xc4, 0xae, 0x3f, 0xc2, 0x49, 0x74, 0x3a, 0xd6, 0xb1, 0xeb, 0xf9, 0xb9, 0x28,
	0x7d, 0xac, 0xeb, 0xac, 0x5d, 0x12, 0xf7, 0x6e, 0x86, 0xca, 0x37, 0xa1, 0xa8, 0xad, 0x10, 0x9b,
	0x91, 0x8c, 0xba, 0x3c, 0x1d, 0xea, 0x2d, 0xd6, 0x2e, 0x45, 0x6d, 0x29, 0xdf, 0x04, 0x1d, 0x41,
	0xf3, 0x8b, 0x21, 0x0e, 0xcf, 0x24, 0xcc, 0xd5, 0x71, 0x07, 0x4e, 0x2a, 0xe6, 0x6f, 0xd3, 0x66,
	0x09, 0xe2, 0xc6, 0x17, 0xf2, 0x27, 0x69, 0xff, 0xb8, 0x04, 0x0d, 0x75, 0x5a, 0xc5, 0xc7, 0x4f,
	0x57, 0xa1, 0x9e, 0x04, 0xf3, 0x59, 0x64, 0x93, 0xc5, 0x2d, 0x63, 0x50, 0xd7, 0x46, 0x2f, 0xc2,
	0x62, 0x1a, 0xed, 0xa7, 0x66, 0x02, 0xb7, 0x04, 0x16, 0x62, 0x20, 0xb3, 0x14, 0x3e, 0x82, 0xcb,
	0xc2, 0x42, 0x32, 0x07, 0x03, 0xae, 0x14, 0xa8, 0x75, 0x23, 0xcf, 0x49, 0x12, 0xaa, 0x36, 0xaf,
	0xbb, 0x39, 0x18, 0xec, 0x8a, 0x9a, 0xe9, 0xb8, 0xff, 0x2c, 0x34, 0xd4, 0x25, 0x2b, 0x1e, 0x76,
	0x6e, 0x54, 0xfc, 0xd8, 0x4c, 0x1d, 0xd5, 0x6d, 0x58, 0x49, 0x33, 0x1d, 0xa5, 0x64, 0x61, 0x3e,
	0x83, 0xe5, 0x24, 0xd9, 0x31, 0x2d, 0x6a, 0x7f, 0x0e, 0x8b, 0xca, 0xba, 0x7e, 0x8d, 0xde, 0x59,
	0x8e, 0x05, 0xe9, 0x1b, 0xa7, 0xa6, 0x67, 0x0f, 0xe2, 0x65, 0x03, 0x0a, 0xfa, 0x88, 0x41, 0x3a,
	0xff, 0x7a, 0x56, 0xe6, 0x75, 0xaa, 0x1c, 0x06, 0x70, 0x21, 0xc3, 0xc2, 0x89, 0x92, 0xe0, 0xec,
	0xf6, 0xd6, 0x24, 0xa6, 0xa0, 0x62, 0x99, 0xe1, 0x64, 0xae, 0x2d, 0x56, 0xc3, 0x02, 0x28, 0xa1,
	0xbd, 0x65, 0xb8, 0x3a, 0xe9, 0xad, 0x32, 0x5d, 0x6f, 0x19, 0xe6, 0x16, 0xbd, 0x59, 0x05, 0x50,
	0x82, 0x1c, 0x58, 0x53, 0x19, 0x3d, 0xe9, 0x8c, 0xf3, 0xfb, 0x9d, 0xf3, 0x3a, 0x53, 0xf9, 0x9d,
	0xf7, 0xb5, 0xf2, 0x45, 0x1e, 0x48, 0xda, 0xa7, 0xb0, 0x52, 0xb4, 0x0e, 0xe8, 0xa7, 0x52, 0x1b,
	0xb0, 0x7c, 0xa3, 0x51, 0xe4, 0x6b, 0xaa, 0x3d, 0x2a, 0x86, 0x5f, 0xc2, 0x08, 0x65, 0x71, 0x1c,
	0xe2, 0x76, 0xed, 0x76, 0x04, 0x2b, 0x45, 0x6b, 0xf0, 0xf5, 0x7a, 0xca, 0x30, 0x4e, 0x39, 0xcb,
	0x38, 0xed, 0x7f, 0x58, 0x82, 0xe5, 0x82, 0xd5, 0xf8, 0xe3, 0x9f, 0x5f, 0x56, 0x3b, 0x54, 0x72,
	0xda, 0x41, 0xda, 0x68, 0xaa, 0xd3, 0x6d, 0x34, 0x9d, 0xdf, 0x2f, 0x15, 0xef, 0x11, 0xf4, 0xeb,
	0x91, 0xd7, 0xf7, 0xfc, 0xc7, 0x9e, 0x38, 0xa5, 0x97, 0x76, 0x0c, 0x65, 0x97, 0x40, 0x6b, 0x80,
	0x92, 0xac, 0x92, 0xed, 0x61, 0x30, 0x70, 0x2c, 0x33, 0xc2, 0x5a, 0x95, 0xd9, 0xbb, 0xd2, 0x49,
	0x23, 0x6f, 0x5a, 0x13, 0x96, 0xb1, 0x74, 0x41, 0x63, 0x86, 0x61, 0x48, 0x0e, 0x7f, 0x92, 0xaa,
	0xb3, 0xd2, 0xbe, 0x34, 0x87, 0x56, 0x40, 0xe3, 0x43, 0x48, 0xed, 0x32, 0x6d, 0x9e, 0xe5, 0xff,
	0xa4, 0x19, 0xdf, 0x7b, 0x7e, 0x44, 0x12, 0xb4, 0x76, 0xe7, 0x3f, 0x97, 0x60, 0x79, 0xd3, 0xfe,
	0x7c, 0x48, 0xa2, 0x23, 0x37, 0x1e, 0x08, 0xdd, 0xc4, 0xf6, 0x60, 0x3e, 0xd5, 0x85, 0x7c, 0xbf,
	0x7f, 0x33, 0xbf, 0x50, 0x05, 0x2d, 0xd7, 0xd3, 0x2f, 0x3d, 0x45, 0xd1, 0x1e, 0x01, 0xa4, 0x05,
	0x59, 0x2a, 0x71, 0x4d, 0x35, 0x51, 0x87, 0x17, 0xe9, 0xab, 0x5c, 0xfe, 0x50, 0x25, 0x97, 0x3f,
	0xd4, 0xf9, 0xa3, 0x72, 0x7e, 0x7e, 0x54, 0x71, 0x1d, 0xc1, 0xac, 0x6a, 0xcd, 0xbc, 0x7b, 0xfe,
	0xec, 0x28, 0x07, 0xe6, 0x61, 0x4c, 0xac, 0x63, 0x64, 0xed, 0xbf, 0x5c, 0x82, 0xb5, 0xe2, 0x3a,
	0x68, 0x53, 0x65, 0xf6, 0x9b, 0xd3, 0x75, 0xa8, 0xb0, 0xfc, 0x6d, 0x10, 0x9a, 0xd1, 0x36, 0xd4,
	0x99, 0x73, 0xf7, 0x06, 0x89, 0xc2, 0x3d, 0x69, 0x01, 0xbe, 0x37, 0x0d, 0xef, 0x22, 0x68, 0xf4,
	0xf7, 0x7a, 0x64, 0xd7, 0x1f, 0x8a, 0xfb, 0x47, 0x5a, 0x19, 0x2d, 0x43, 0x93, 0xc2, 0x1e, 0xf8,
	0x7e, 0x7f, 0x18, 0x70, 0x60, 0x25, 0x06, 0xea, 0x98, 0x12, 0x85, 0x03, 0xab, 0x93, 0x19, 0xec,
	0x77, 0xcb, 0xa0, 0x6d, 0x9d, 0x9a, 0xde, 0x09, 0xb3, 0x8b, 0xcd, 0x08, 0x53, 0xee, 0xba, 0x02,
	0x75, 0x12, 0xf9, 0x81, 0x21, 0x9c, 0x33, 0x91, 0xed, 0x47, 0x41, 0x47, 0xcc, 0x41, 0x7b, 0x09,
	0x1a, 0x36, 0x26, 0x51, 0xe8, 0x9f, 0x19, 0x8a, 0xff, 0xb6, 0x20, 0xa0, 0xbc, 0xd6, 0x35, 0x58,
	0xe0, 0xb1, 0x25, 0x51, 0x87, 0x93, 0x1f, 0x18, 0xec, 0x48, 0x38, 0x7a, 0xaa, 0x29, 0x56, 0x1d,
	0x67, 0x8a, 0xbd, 0x0e, 0x0d, 0x72, 0x3a, 0x8c, 0x6c, 0xff, 0xb1, 0x27, 0x92, 0xfe, 0x6b, 0xf2,
	0xfe, 0xbf, 0x18, 0x17, 0xf2, 0x54, 0xff, 0x07, 0xf0, 0x82, 0x5a, 0x9b, 0xc5, 0x31, 0xfc, 0x61,
	0x64, 0x38, 0x9e, 0x41, 0xb0, 0xe5, 0x7b, 0xb6, 0xb8, 0x2f, 0x72, 0xb7, 0xfc, 0xf6, 0x9b, 0xfa,
	0x65, 0xa5, 0xb5, 0xb8, 0xa3, 0xd5, 0xf5, 0x0e, 0x78, 0x45, 0xb4, 0x0e, 0xcd, 0xa1, 0x17, 0xe2,
	0x13, 0x87, 0x8d, 0x93, 0xba, 0x55, 0x3c, 0x3d, 0x2a, 0xee, 0xbc, 0x91, 0x96, 0x3e, 0xf4, 0x06,
	0x67, 0x9d, 0x3f, 0xcc, 0xae, 0x28, 0xe5, 0xe7, 0x3d, 0x68, 0xc4, 0x2b, 0xca, 0x58, 0x85, 0x2f,
	0x6a, 0xa3, 0x28, 0x61, 0x38, 0xdb, 0x56, 0xb0, 0xd8, 0x02, 0x5f, 0x7e, 0xf6, 0x41, 0xd0, 0x21,
	0x2c, 0x49, 0x14, 0x10, 0x28, 0xcb, 0x4f, 0x89, 0xb2, 0x99, 0x90, 0x4b, 0x60, 0xdd, 0x87, 0x66,
	0x42, 0x31, 0x81, 0xb3, 0xf2, 0x94, 0x38, 0x17, 0x05, 0x79, 0x39, 0xc6, 0xce, 0xa7, 0x53, 0x9a,
	0xef, 0xf3, 0x50, 0xeb, 0x7f, 0x38, 0x24, 0x67, 0x6a, 0x30, 0x61, 0x32, 0xeb, 0xfe, 0x85, 0x06,
	0x2c, 0xea, 0x62, 0xe5, 0xb9, 0x69, 0xff, 0x09, 0xd4, 0x13, 0x42, 0x8d, 0x5c, 0xa1, 0x39, 0x5e,
	0xcb, 0x8f, 0x5d, 0x69, 0x25, 0x7d, 0xe9, 0x10, 0x26, 0xbf, 0x73, 0xcc, 0x59, 0x1e, 0xcf, 0x9c,
	0x2c, 0xe8, 0x9a, 0x39, 0xa9, 0xe6, 0xdc, 0xae, 0x91, 0xd0, 0xda, 0x56, 0x0e, 0xab, 0x5f, 0x07,
	0x24, 0x32, 0x65, 0x47, 0xd2, 0x99, 0x3c, 0x8f, 0x5e, 0x68, 0xbc, 0xe4, 0x28, 0x3d, 0x96, 0xdf,
	0x85, 0x66, 0x26, 0xc2, 0x27, 0x8e, 0x3a, 0xa6, 0x8b, 0xee, 0x35, 0xd4, 0xe8, 0x1e, 0x72, 0xe0,
	0x56, 0x6c, 0x0f, 0x9a, 0x54, 0x4b, 0xb1, 0x24, 0x2a, 0xc3, 0x67, 0xc9, 0x22, 0x16, 0x26, 0xc4,
	0x0f, 0x0d, 0xc7, 0xb3, 0x7c, 0x37, 0x30, 0x23, 0xe7, 0xd8, 0x19, 0x38, 0xd1, 0x19, 0xcf, 0x17,
	0x14, 0xd3, 0x7e, 0x4d, 0xd8, 0x7d, 0xb4, 0x2d, 0xa3, 0xfb, 0x43, 0x6f, 0x3f, 0x6e, 0xd8, 0x55,
	0xdb, 0xa1, 0xd7, 0x60, 0xc9, 0x3e, 0xa6, 0xd8, 0xcc, 0xd0, 0xe3, 0xf7, 0xca, 0x1c, 0x9e, 0x57,
	0x58, 0xd5, 0x9b, 0xf6, 0x71, 0x37, 0x85, 0x77, 0xed, 0xf6, 0x3f, 0x01, 0x80, 0x94, 0x0a, 0xe8,
	0x02, 0xb3, 0x01, 0xa4, 0x4c, 0xe0, 0x19, 0x1e, 0xd5, 0xa1, 0x7a, 0x47, 0xd1, 0xab, 0x89, 0xde,
	0x91, 0xb6, 0x14, 0x82, 0xfe, 0x04, 0x5c, 0xf0, 0x43, 0xe7, 0xc4, 0xf1, 0xcc, 0x81, 0x91, 0xa9,
	0xce, 0x89, 0xb2, 0x12, 0x17, 0xef, 0xc9, 0xcd, 0x5e, 0x86, 0x86, 0x35, 0xc0, 0x66, 0x68, 0x38,
	0x2c, 0x9a, 0x19, 0x9d, 0x89, 0x64, 0x92, 0x45, 0x06, 0xed, 0x0a, 0x20, 0xc5, 0x1e, 0xe2, 0x11,
	0x0e, 0x23, 0x23, 0xf2, 0x0d, 0x75, 0x13, 0xe4, 0x89, 0x15, 0x2b, 0xbc, 0xf8, 0xd0, 0x3f, 0x90,
	0x37, 0xc3, 0x7c, 0xf2, 0xd6, 0x4c, 0x41, 0xf2, 0x96, 0x94, 0x30, 0x32, 0xab, 0x64, 0xdd, 0xbd,
	0x03, 0x17, 0x47, 0xae, 0x91, 0xa6, 0xc1, 0x10, 0xda, 0x3b, 0x7e, 0xc2, 0x42, 0x09, 0x22, 0x15,
	0x73, 0x75, 0xe4, 0x6e, 0xc7, 0x49, 0x31, 0xe4, 0xd0, 0xdf, 0xe1, 0x85, 0xe8, 0x55, 0x58, 0x8a,
	0x6f, 0xdb, 0xd0, 0x36, 0x21, 0x26, 0x38, 0x62, 0x69, 0x6a, 0xf3, 0x7a, 0x43, 0x5c, 0xbb, 0x39,
	0xa4, 0x5e, 0x3e, 0xa6, 0xe6, 0x5e, 0xdb, 0xf1, 0x4e, 0x71, 0xe8, 0x44, 0x06, 0xcb, 0x86, 0x26,
	0x38, 0x74, 0xe8, 0x1a, 0x0e, 0xdd, 0x63, 0x1c, 0xb2, 0x4c, 0xcd, 0x39, 0xfd, 0x82, 0xa8, 0x71,
	0x60, 0x11, 0xe7, 0x80, 0x95, 0xef, 0xb1, 0xe2, 0xa2, 0x0b, 0x70, 0xf5, 0xff, 0x47, 0x17, 0xe0,
	0xbe, 0x05, 0x97, 0xa4, 0xae, 0xcc, 0x13, 0xcf, 0x27, 0x91, 0x63, 0x51, 0xa5, 0x95, 0x64, 0x80,
	0x2c, 0xe8, 0xad, 0xb4, 0xca, 0xa6, 0xa8, 0x71, 0xe4, 0x8a, 0x4c, 0xa9, 0x55, 0xd2, 0x77, 0x82,
	0x24, 0x02, 0x16, 0x62, 0xcb, 0x1f, 0xe1, 0x30, 0xbe, 0x28, 0xb4, 0x4c, 0x0b, 0x85, 0x1c, 0xe9,
	0xa2, 0x88, 0x92, 0x4f, 0xe4, 0xd9, 0xc7, 0xbd, 0x34, 0x38, 0xf9, 0x38, 0x54, 0x60, 0x7e, 0x13,
	0x56, 0x02, 0x71, 0xeb, 0xd1, 0x90, 0x93, 0x80, 0xf9, 0x0d, 0x35, 0x14, 0x97, 0xa5, 0xb9, 0xa5,
	0xe8, 0x0e, 0xac, 0x25, 0x2d, 0x62, 0x02, 0x53, 0xf4, 0x44, 0xdc, 0x47, 0x5b, 0x8e, 0x4b, 0x8f,
	0xdc, 0xf8, 0x62, 0x1b, 0x41, 0x7f, 0xa9, 0x04, 0x2f, 0x5a, 0xa7, 0xce, 0xc0, 0x36, 0x38, 0x4f,
	0x1a, 0x39, 0x41, 0x33, 0x06, 0x0e, 0x89, 0x5a, 0x4b, 0x4c, 0xff, 0x7d, 0x30, 0xbd, 0xfe, 0x5b,
	0xdf, 0x61, 0xf8, 0xb6, 0x55, 0xf1, 0xd4, 0xaf, 0xb0, 0xce, 0x0a, 0xcb, 0x1e, 0x38, 0x24, 0x42,
	0xdf, 0x80, 0x56, 0x32, 0x09, 0x27, 0x30, 0x5d, 0xf9, 0x30, 0x89, 0xe7, 0xc8, 0xad, 0xc6, 0xe5,
	0xdd, 0xc0, 0x74, 0xd3, 0x13, 0xa8, 0xdb, 0xb0, 0x2a, 0xcf, 0xde, 0x73, 0x2c, 0x31, 0xf9, 0x65,
	0x75, 0xc1, 0x8e, 0xdc, 0x3d, 0xc7, 0x62, 0x73, 0x6f, 0xff, 0x62, 0x19, 0x56, 0x0b, 0x47, 0x42,
	0x8d, 0x56, 0xb1, 0x1c, 0xd2, 0xa1, 0x0f, 0x70, 0x10, 0xa3, 0xce, 0x20, 0xa9, 0x90, 0x64, 0x74,
	0x37, 0x36, 0x3e, 0xf9, 0xba, 0xab, 0x23, 0xa0, 0x8c, 0x51, 0x45, 0x6f, 0x8c, 0x49, 0x0b, 0xf5,
	0x5f, 0xa5, 0x50, 0xff, 0x75, 0x3e, 0x00, 0x48, 0xb1, 0x20, 0x0d, 0x16, 0xfa, 0xd2, 0x45, 0x83,
	0xd8, 0x77, 0x11, 0xc9, 0xc1, 0x8e, 0x25, 0xae, 0x05, 0x08, 0xc0, 0xfd, 0x60, 0xa8, 0x55, 0x3a,
	0x7f, 0xae, 0x2a, 0xef, 0x85, 0xd4, 0xe2, 0xd8, 0x61, 0x79, 0xba, 0xdc, 0xee, 0x15, 0x3b, 0xe1,
	0x8d, 0x49, 0x73, 0xe5, 0x21, 0x41, 0x61, 0x2f, 0xcf, 0x8d, 0xc4, 0xaf, 0xf6, 0x6f, 0x94, 0x60,
	0x2e, 0x06, 0x3f, 0x4b, 0x14, 0x70, 0x47, 0x8d, 0x02, 0xbe, 0x7c, 0xde, 0x10, 0xc6, 0x9c, 0x92,
	0x5c, 0x85, 0xfa, 0x63, 0x33, 0xf4, 0x1c, 0xef, 0xc4, 0x70, 0xc9, 0x49, 0xec, 0x37, 0x0a, 0xd0,
	0x2e, 0x39, 0xe9, 0xfc, 0x5c, 0xb9, 0xd8, 0xd2, 0x50, 0x2e, 0xce, 0x97, 0x98, 0xe7, 0xd6, 0xf5,
	0x46, 0xe6, 0xc0, 0xe1, 0x1b, 0x98, 0x56, 0x46, 0x6d, 0x58, 0xeb, 0x77, 0x3d, 0x32, 0xec, 0xf5,
	0x1c, 0xcb, 0xc1, 0x1e, 0x75, 0x07, 0x98, 0x4c, 0x13, 0xad, 0xc2, 0xaa, 0x0b, 0x33, 0x3c, 0xb6,
	0xa6, 0x29, 0x75, 0x04, 0x86, 0x3d, 0xdf, 0xc6, 0x5a, 0x8d, 0x39, 0x89, 0xe9, 0xee, 0x37, 0xc0,
	0x74, 0x1f, 0xd6, 0x66, 0x94, 0x0b, 0xff, 0xb3, 0x92, 0xb7, 0xc9, 0xfd, 0x40, 0xa1, 0x60, 0x92,
	0xa1, 0xcd, 0xb3, 0x1a, 0x5d, 0xef, 0x11, 0xc1, 0x1a, 0xa0, 0x8b, 0xb0, 0xda, 0x17, 0x42, 0xb2,
	0xef, 0xfb, 0x83, 0x9d, 0x27, 0xa7, 0x26, 0xb5, 0x37, 0x6c, 0xad, 0x3e, 0xd9, 0x24, 0x7a, 0x03,
	0xb4, 0xfb, 0x38, 0x4a, 0x0c, 0x0e, 0x72, 0xce, 0x31, 0xda, 0xff, 0x29, 0x67, 0xea, 0x53, 0xc6,
	0xc1, 0x80, 0x12, 0x53, 0x86, 0x64, 0x62, 0xca, 0x6f, 0x17, 0x06, 0x71, 0x95, 0xf6, 0x59, 0x00,
	0xe3, 0xa7, 0x25, 0x3b, 0x03, 0x21, 0xed, 0xdf, 0x2a, 0xc1, 0x72, 0x41, 0x55, 0xf4, 0x10, 0x96,
	0x53, 0x4b, 0x8a, 0x85, 0xb5, 0x99, 0x2e, 0xe3, 0xfd, 0x5f, 0xcd, 0xf7, 0xaf, 0x64, 0x5c, 0x4a,
	0x1d, 0xd1, 0x4f, 0xa6, 0x9d, 0x3e, 0x52, 0x39, 0xf0, 0xc6, 0x14, 0x53, 0x18, 0x13, 0x8b, 0xfe,
	0xf6, 0xd4, 0xe7, 0x64, 0x72, 0x34, 0x7a, 0x22, 0xc1, 0xfe, 0x4b, 0x09, 0x96, 0x98, 0x5b, 0x97,
	0x0c, 0xe0, 0x9c, 0x23, 0xb3, 0x7c, 0x3a, 0x67, 0xb9, 0x28, 0x9d, 0x33, 0x9b, 0x60, 0x5a, 0xc9,
	0x5f, 0x1d, 0x9b, 0x32, 0x7f, 0xf4, 0x05, 0x98, 0x0b, 0xb1, 0x69, 0x33, 0xbf, 0x47, 0x71, 0xba,
	0x12, 0xb0, 0x74, 0xf9, 0x8b, 0x39, 0xbb, 0x33, 0x71, 0x7c, 0x89, 0x82, 0x98, 0x93, 0xfb, 0xdb,
	0x95, 0xec, 0x2c, 0x29, 0xa3, 0x05, 0x70, 0x81, 0x67, 0xb8, 0xa6, 0x13, 0x52, 0xb9, 0xad, 0x20,
	0x9d, 0x27, 0x87, 0x25, 0x07, 0xe1, 0x21, 0x43, 0xb7, 0x00, 0x4a, 0xda, 0x3f, 0x2a, 0xc1, 0x4a,
	0x51, 0x7d, 0x74, 0x4f, 0x5e, 0x55, 0x49, 0xbf, 0x9d, 0xcb, 0x6f, 0x8b, 0x0a, 0xbf, 0xa1, 0xae,
	0xca, 0x6b, 0xaf, 0x4e, 0x33, 0x81, 0x31, 0xcc, 0xf6, 0xbd, 0xa9, 0x99, 0x6d, 0x0d, 0x50, 0x3f,
	0xb9, 0x31, 0x20, 0x05, 0xb8, 0x96, 0xa1, 0x99, 0x86, 0xa4, 0x76, 0x9e, 0x38, 0x24, 0x52, 0x13,
	0x96, 0x27, 0x73, 0x66, 0x04, 0xcb, 0x8f, 0x3c, 0xf7, 0x69, 0x58, 0x33, 0x93, 0xb1, 0x5c, 0xce,
	0x65, 0x2c, 0x9f, 0xcf, 0x94, 0x9d, 0xbf, 0x52, 0xc9, 0x77, 0x4b, 0x79, 0xe5, 0x09, 0x5c, 0x1c,
	0x7a, 0x93, 0xb9, 0xa5, 0x20, 0x42, 0x54, 0x80, 0xa9, 0x00, 0xc6, 0x38, 0xe6, 0xc2, 0xd0, 0x2b,
	0xe6, 0x19, 0x0c, 0x6b, 0xc5, 0x4d, 0xd0, 0x27, 0x2a, 0xb1, 0x6f, 0x4e, 0xd7, 0xff, 0x18, 0x72,
	0xff, 0xb0, 0xf4, 0xb5, 0xe9, 0x5d, 0x1c, 0x82, 0xac, 0xa8, 0x7c, 0xc0, 0x77, 0x98, 0xaa, 0xc4,
	0x07, 0xb5, 0xc9, 0x7c, 0xf0, 0x1b, 0x25, 0x40, 0xfc, 0xbc, 0x33, 0xb9, 0xda, 0x4f, 0xf9, 0x40,
	0x3a, 0xc6, 0x48, 0xa3, 0xbb, 0xb9, 0x88, 0x9f, 0xb8, 0x35, 0x27, 0xdf, 0x18, 0xcc, 0xba, 0xd5,
	0x95, 0x71, 0x6e, 0x75, 0x9c, 0xbd, 0x53, 0x95, 0x6e, 0x2e, 0xcb, 0x4f, 0x07, 0xd4, 0x94, 0xa7,
	0x03, 0x3a, 0xff, 0x23, 0x3f, 0x4e, 0xca, 0x38, 0x0f, 0x61, 0x91, 0x9f, 0xea, 0xa6, 0xa6, 0x10,
	0x25, 0x56, 0x41, 0x50, 0x20, 0xdf, 0x38, 0x8e, 0xbc, 0x70, 0x04, 0x82, 0xea, 0xf2, 0x10, 0xca,
	0xea, 0x10, 0xfa, 0x53, 0x06, 0x3b, 0x28, 0x60, 0xcf, 0xbf, 0x17, 0x62, 0x7c, 0x30, 0xf0, 0x23,
	0xad, 0x9c, 0x46, 0x3f, 0x64, 0xf9, 0xb4, 0x27, 0xd1, 0x05, 0x77, 0x7e, 0x52, 0x02, 0xb4, 0x8d,
	0xa7, 0xa3, 0xcb, 0xf8, 0x31, 0x4f, 0x4f, 0x8e, 0xbb, 0xb0, 0xe6, 0x9c, 0x78, 0x6c, 0xd7, 0xf1,
	0x3d, 0x03, 0x3f, 0x11, 0x17, 0x77, 0x2c, 0x5b, 0x3d, 0x8a, 0x5b, 0xe6, 0x95, 0xf6, 0x7c, 0x6f,
	0x47, 0x54, 0xd9, 0x62, 0xe1, 0xe2, 0x9e, 0x4f, 0x9d, 0x27, 0x21, 0x64, 0xe2, 0xae, 0xf3, 0x02,
	0x03, 0x0a, 0x21, 0xe9, 0xfc, 0x7e, 0x7e, 0x42, 0x82, 0x80, 0x36, 0x9e, 0x8a, 0x80, 0xf9, 0xc6,
	0x31, 0x01, 0x39, 0x02, 0x4e, 0xc0, 0x4e, 0x38, 0x25, 0x95, 0xa8, 0x38, 0x25, 0xc8, 0x24, 0x31,
	0x7b, 0x16, 0x62, 0xfd, 0x7c, 0x05, 0x56, 0x14, 0xfe, 0xa2, 0x86, 0xfd, 0x58, 0x72, 0x7d, 0x96,
	0x7d, 0x8f, 0xa6, 0x3c, 0xce, 0xf8, 0x2a, 0xc2, 0x29, 0x5f, 0x52, 0x3e, 0x08, 0xb0, 0x95, 0x79,
	0xa8, 0xe6, 0x69, 0x08, 0x7e, 0x82, 0x3d, 0x1c, 0x9a, 0x11, 0x36, 0x3c, 0xfc, 0x38, 0xf5, 0x4d,
	0x33, 0x04, 0x8f, 0x2b, 0xed, 0xe1, 0xc7, 0xb1, 0x8b, 0xda, 0xfe, 0xa5, 0x12, 0x34, 0x33, 0xc3,
	0x28, 0xba, 0x4e, 0x9c, 0x53, 0x0e, 0x0f, 0x0a, 0x6e, 0xdd, 0x3e, 0xfb, 0xcb, 0x04, 0xb1, 0x06,
	0xa9, 0x48, 0x57, 0x3b, 0x7f, 0xaf, 0x88, 0x12, 0x94, 0xcf, 0xbe, 0x5d, 0xac, 0x28, 0x5e, 0x9f,
	0x62, 0xd1, 0xc7, 0xa9, 0x0a, 0x2c, 0x5d, 0x05, 0x63, 0xab, 0xc7, 0x2c, 0x0b, 0x4e, 0xcc, 0x6f,
	0x4c, 0x89, 0x37, 0x4e, 0x35, 0xa1, 0xdf, 0xcc, 0xe2, 0x48, 0xae, 0x85, 0xc5, 0x10, 0xba, 0xad,
	0xb2, 0x3d, 0xc4, 0xa0, 0x6c, 0xee, 0xc4, 0x37, 0xa4, 0xea, 0x0c, 0xb6, 0xcd, 0x40, 0xed, 0x3d,
	0xd0, 0xb2, 0x88, 0x32, 0xd7, 0xaa, 0x4a, 0x05, 0xd7, 0xaa, 0x52, 0x8a, 0x73, 0xa5, 0x31, 0x67,
	0x0b, 0xfa, 0x76, 0x7e, 0xa1, 0x34, 0xa5, 0x10, 0xb5, 0x60, 0x45, 0xf6, 0x65, 0x25, 0x31, 0x7a,
	0x1e, 0x5a, 0x72, 0xc9, 0xa3, 0xc0, 0x36, 0x23, 0x7c, 0xcf, 0x74, 0x06, 0xec, 0x5e, 0x55, 0x22,
	0x64, 0xd5, 0xe9, 0x85, 0xec, 0xef, 0x95, 0x60, 0x45, 0xd1, 0x01, 0x13, 0x85, 0xec, 0x2a, 0xd4,
	0xa5, 0x70, 0x9a, 0x08, 0x24, 0x42, 0x32, 0xff, 0xa7, 0x10, 0x94, 0x0f, 0xe0, 0x62, 0x91, 0x66,
	0xe4, 0xa2, 0x5b, 0x55, 0x93, 0x7f, 0xb2, 0xca, 0x91, 0xc9, 0x64, 0xe7, 0xb7, 0xcb, 0x05, 0x23,
	0x17, 0x4c, 0x59, 0xa4, 0xfc, 0x5e, 0x3f, 0x47, 0xf9, 0x65, 0x98, 0x52, 0x56, 0x7f, 0x39, 0x6e,
	0x29, 0xe7, 0xb8, 0xa5, 0xf3, 0xeb, 0x5f, 0x9f, 0xba, 0x92, 0x92, 0x64, 0x66, 0x09, 0x63, 0xba,
	0x1d, 0xf2, 0x44, 0xba, 0xba, 0x4f, 0xbd, 0x60, 0xe1, 0x48, 0xc7, 0x3a, 0x42, 0x5c, 0xe3, 0x9f,
	0x8a, 0xda, 0xa7, 0xd4, 0x94, 0xb7, 0x9d, 0xde, 0x59, 0x86, 0xd8, 0xf9, 0x18, 0x71, 0xa9, 0x20,
	0x46, 0xfc, 0x1a, 0x2c, 0x29, 0xca, 0x2d, 0xe1, 0xf2, 0x39, 0xbd, 0x29, 0x29, 0x34, 0xc6, 0xec,
	0x7f, 0x58, 0x2a, 0xe8, 0x8a, 0xa7, 0x5e, 0x35, 0x58, 0xe6, 0xef, 0x99, 0x62, 0x89, 0x16, 0x92,
	0xa7, 0xa8, 0x7d, 0x7c, 0x62, 0xc2, 0x71, 0xc4, 0x69, 0x0d, 0x97, 0x60, 0x3e, 0x1e, 0x50, 0xcc,
	0x95, 0x73, 0x1e, 0x1f, 0x09, 0xe9, 0xfc, 0x74, 0x31, 0x61, 0x26, 0xc9, 0x52, 0x69, 0xfa, 0x25,
	0xfd, 0x01, 0x40, 0x9d, 0x67, 0x1f, 0xf0, 0xe3, 0x94, 0x42, 0xb9, 0x91, 0x82, 0xf3, 0xe2, 0xb1,
	0x23, 0x11, 0x9c, 0x57, 0x9e, 0x99, 0xa3, 0xc2, 0xb2, 0x28, 0x3d, 0x33, 0x57, 0xfc, 0xee, 0x57,
	0x95, 0xd5, 0xca, 0xbd, 0xfb, 0xb5, 0x0e, 0xcb, 0xa3, 0x82, 0x47, 0xe9, 0x6a, 0x2c, 0x78, 0xb6,
	0x34, 0xca, 0xbd, 0x4a, 0xf7, 0x1a, 0x2c, 0xb9, 0xd8, 0xf5, 0xc3, 0x33, 0xf9, 0x61, 0xba, 0x19,
	0x1e, 0x6a, 0xe3, 0x05, 0xe9, 0xdb, 0x74, 0xef, 0x40, 0x4b, 0xd4, 0x95, 0xb1, 0xa7, 0x0f, 0xe8,
	0x54, 0xf5, 0x35, 0x5e, 0x2e, 0x75, 0xc1, 0x5b, 0x06, 0x70, 0x21, 0xde, 0x95, 0xe3, 0x2c, 0x43,
	0x7e, 0x4b, 0x35, 0x7e, 0x2f, 0xae, 0xc0, 0x5d, 0x95, 0x56, 0x33, 0xde, 0xb2, 0x44, 0xf2, 0xe1,
	0x36, 0x6b, 0x2a, 0x6e, 0x1f, 0xac, 0x8e, 0x0a, 0xca, 0xfe, 0xbf, 0xbe, 0x29, 0x27, 0x1d, 0x3c,
	0x80, 0x72, 0xf0, 0xd0, 0x2b, 0x48, 0x34, 0xe6, 0x2f, 0xc9, 0xfd, 0xd4, 0x54, 0xd3, 0x4d, 0x32,
	0xff, 0xd5, 0xe7, 0x0c, 0xb2, 0x39, 0xc8, 0x94, 0x86, 0x3c, 0x77, 0x56, 0x0e, 0x48, 0xf0, 0xbb,
	0x9c, 0x4d, 0xf6, 0x84, 0x80, 0x14, 0x92, 0xb8, 0x02, 0xf5, 0xe4, 0x4d, 0xbf, 0xe4, 0x3e, 0xe7,
	0xbc, 0x78, 0xd1, 0x8f, 0xbb, 0x21, 0xea, 0x9b, 0x7f, 0x8d, 0xfc, 0x9b, 0x7f, 0xfc, 0x3c, 0x86,
	0x3d, 0x39, 0x13, 0x84, 0xb8, 0xe7, 0x3c, 0x11, 0xb7, 0xcc, 0x17, 0x78, 0xf6, 0xef, 0x3e, 0x83,
	0x65, 0xdf, 0x7c, 0xd3, 0x9e, 0xf6, 0xcd, 0xb7, 0xf6, 0x7f, 0x28, 0x43, 0x7b, 0x3c, 0xe1, 0xa9,
	0x61, 0xee, 0x10, 0xc3, 0xb2, 0x43, 0xdf, 0xe5, 0x79, 0x88, 0xfa, 0xac, 0x43, 0xb6, 0xe8, 0x27,
	0x73, 0xb4, 0xe3, 0x27, 0x7d, 0x84, 0xcd, 0x2e, 0x92, 0x40, 0x73, 0x56, 0x52, 0xe5, 0x6b, 0x59,
	0x49, 0x2b, 0x50, 0xe3, 0x57, 0xaf, 0xb9, 0x34, 0xf2, 0x8f, 0xf8, 0x19, 0x01, 0x3a, 0x14, 0x83,
	0x3f, 0xa3, 0x56, 0x4b, 0x9e, 0x11, 0xa0, 0xc0, 0x1d, 0x0a, 0x2b, 0x78, 0x84, 0x8a, 0x8b, 0x5d,
	0xe6, 0x11, 0xaa, 0x31, 0x6f, 0x40, 0xcd, 0x8e, 0x7b, 0x03, 0x2a, 0x1f, 0x9a, 0x9a, 0x2b, 0x08,
	0x4d, 0xb5, 0x4d, 0xb8, 0x3c, 0x91, 0xcb, 0xd0, 0x07, 0x30, 0x3f, 0xd8, 0x50, 0x2f, 0x19, 0x4d,
	0xf5, 0x48, 0xc8, 0xdc, 0x60, 0x43, 0xdc, 0x02, 0xfa, 0x51, 0x39, 0x55, 0x89, 0x54, 0xe5, 0x7f,
	0x04, 0x8b, 0x22, 0xc5, 0x4d, 0xd9, 0x90, 0x5f, 0x1c, 0x2f, 0x0b, 0xd2, 0x3e, 0xcc, 0x5b, 0xe6,
	0x63, 0xe9, 0xe5, 0x29, 0x13, 0x9d, 0x7e, 0x75, 0xcc, 0xbe, 0x9c, 0x0d, 0x49, 0x97, 0xe4, 0xbd,
	0x35, 0x4e, 0x39, 0xd7, 0xca, 0x2c, 0xaa, 0x9c, 0x04, 0xbf, 0xa5, 0x14, 0x68, 0xad, 0x22, 0x17,
	0x29, 0x4b, 0xf1, 0x34, 0xf6, 0xd7, 0x2f, 0x96, 0x01, 0xb6, 0x06, 0xbe, 0x87, 0xe3, 0xc3, 0x78,
	0x31, 0x61, 0xc3, 0xa2, 0x40, 0xb1, 0xfe, 0x45, 0x99, 0x04, 0x49, 0x1b, 0xb1, 0x68, 0x0c, 0xa0,
	0xd7, 0xad, 0xf4, 0x03, 0x3d, 0x02, 0x8d, 0x27, 0xfb, 0x31, 0x5c, 0xec, 0x8d, 0x03, 0xb1, 0x6c,
	0x37, 0x27, 0x22, 0x64, 0x59, 0x6d, 0xec, 0xfb, 0xd0, 0x24, 0x7d, 0x91, 0xd4, 0x9a, 0x7c, 0xb7,
	0x6f, 0xc5, 0xd4, 0xe5, 0xbd, 0x5c, 0x83, 0x85, 0xf4, 0x94, 0x2f, 0xd9, 0xf7, 0x20, 0x3e, 0xe3,
	0xeb, 0xda, 0xed, 0xdb, 0xd0, 0x50, 0x51, 0x66, 0x93, 0xeb, 0x4a, 0xb9, 0xac, 0xcc, 0x7f, 0x5e,
	0x4d, 0x96, 0x85, 0x72, 0xd0, 0xcf, 0xc0, 0xb2, 0xbc, 0x2c, 0x32, 0x1f, 0x15, 0x66, 0xff, 0xa6,
	0x4d, 0x95, 0xd5, 0x11, 0x71, 0x75, 0x2b, 0x0b, 0x42, 0x9f, 0x01, 0x92, 0x57, 0x4a, 0xa0, 0xe7,
	0x6b, 0xf5, 0xc6, 0x44, 0xf4, 0xe9, 0xc4, 0x04, 0x76, 0xed, 0x8b, 0x0c, 0xa4, 0xfd, 0x67, 0x60,
	0x29, 0x37, 0x08, 0xb4, 0x43, 0x0d, 0xe5, 0xcc, 0x54, 0x0a, 0x5f, 0x13, 0x94, 0xfa, 0xe2, 0x12,
	0x51, 0xb7, 0x24, 0x34, 0xe7, 0x66, 0x29, 0xfe, 0xf5, 0x12, 0x68, 0xd9, 0x31, 0xd2, 0xce, 0xf9,
	0x74, 0x9f, 0xbe, 0x73, 0xd6, 0x4e, 0xa0, 0x79, 0x0f, 0x1a, 0x6c, 0x2c, 0xb6, 0x31, 0xad, 0x50,
	0xf2, 0x39, 0xdb, 0xfc, 0xab, 0x73, 0x3c, 0xa5, 0xc5, 0xbc, 0x04, 0x8b, 0x7d, 0xca, 0x36, 0x99,
	0x3c, 0xc4, 0xb1, 0xf2, 0x75, 0x20, 0xc9, 0xd7, 0xbf, 0x58, 0x80, 0xb5, 0x78, 0xab, 0xc7, 0xbc,
	0x16, 0x15, 0x77, 0x2a, 0x6b, 0x0e, 0x20, 0xe5, 0xdd, 0x6a, 0x43, 0x7a, 0xd6, 0xf1, 0x6e, 0xc1,
	0x5a, 0x14, 0x62, 0x51, 0xed, 0x08, 0xb6, 0x51, 0x2c, 0x59, 0x59, 0x90, 0x12, 0x00, 0x2e, 0xab,
	0x01, 0xe0, 0x08, 0x2e, 0xc4, 0x6f, 0x37, 0x8f, 0x5c, 0x63, 0x74, 0x6a, 0x1b, 0x03, 0xdf, 0x8a,
	0x5f, 0x2d, 0xa6, 0x26, 0xc3, 0xb7, 0xa6, 0x1e, 0xca, 0x36, 0xc7, 0x73, 0xe4, 0x1e, 0x9d, 0xda,
	0x0f, 0x04, 0x12, 0x7d, 0xc5, 0x2e, 0x80, 0x22, 0x1f, 0x56, 0x6c, 0xdf, 0x35, 0x1d, 0xcf, 0x50,
	0x06, 0x2b, 0xb2, 0x80, 0xdf, 0x9d, 0xbe, 0x4b, 0x86, 0x44, 0x59, 0x03, 0x7d, 0xd9, 0xce, 0x03,
	0x51, 0x08, 0xab, 0x21, 0xe6, 0x79, 0x52, 0x6a, 0x8f, 0xb5, 0xa7, 0x9c, 0xa4, 0xce, 0xb1, 0xa8,
	0x5d, 0xae, 0x84, 0x05, 0x50, 0xf4, 0xb3, 0xb0, 0xd6, 0x33, 0x9d, 0x81, 0x3f, 0x62, 0x8f, 0xc6,
	0xca, 0x9d, 0xf2, 0x77, 0x0a, 0x76, 0xa6, 0xee, 0xf4, 0x9e, 0x40, 0xb3, 0xc5, 0x3d, 0x58, 0xb5,
	0xf3, 0xd5, 0xb8, 0x13, 0x05, 0xdc, 0xfe, 0x25, 0xe6, 0x59, 0x17, 0xac, 0xfd, 0x36, 0x5c, 0x4d,
	0x6e, 0x3c, 0x25, 0xc4, 0x36, 0x94, 0x20, 0x7f, 0x89, 0x99, 0x93, 0x97, 0xe2, 0x67, 0xa0, 0xe2,
	0xa6, 0x5b, 0xd2, 0x49, 0xd4, 0x37, 0xe1, 0xa2, 0xcc, 0x2c, 0x46, 0xe6, 0x69, 0x14, 0xda, 0x7e,
	0x6d, 0x94, 0xf6, 0x2a, 0x35, 0x6d, 0xff, 0xfb, 0x32, 0x2c, 0x17, 0x10, 0xae, 0xf0, 0x05, 0x74,
	0xea, 0xf1, 0x73, 0x46, 0x91, 0xbc, 0x17, 0xe0, 0x20, 0x61, 0x57, 0x02, 0xbb, 0x75, 0xc4, 0x9f,
	0x82, 0x14, 0x67, 0xcc, 0x29, 0x04, 0xad, 0xc1, 0x8c, 0x3f, 0x94, 0x5e, 0x71, 0x15, 0x5f, 0xa8,
	0x0b, 0x4b, 0x31, 0x07, 0x26, 0x57, 0x21, 0x45, 0x9a, 0xd6, 0xf3, 0x85, 0x86, 0x81, 0xa8, 0xa3,
	0x6b, 0x82, 0xbd, 0xd2, 0x0b, 0x94, 0x3a, 0xac, 0xd1, 0x65, 0x18, 0x18, 0xa6, 0xed, 0xaa, 0xf8,
	0x66, 0xa6, 0xc0, 0xb7, 0xc2, 0xda, 0x6e, 0xd2, 0xa6, 0x12, 0xce, 0x15, 0xa8, 0xb1, 0x40, 0xab,
	0xb0, 0xb7, 0xf8, 0x47, 0x3c, 0x59, 0x6e, 0xe8, 0x0a, 0xfb, 0x4a, 0x82, 0xb4, 0xbf, 0x09, 0x2b,
	0x45, 0xfc, 0x89, 0x5e, 0x00, 0xb0, 0xf1, 0xc0, 0x3c, 0x33, 0x08, 0xb6, 0xc4, 0x73, 0xe2, 0x77,
	0xcb, 0x77, 0xde, 0xd4, 0xe7, 0x19, 0xf4, 0x00, 0x5b, 0xa4, 0xfd, 0xaf, 0x4a, 0xf0, 0xfc, 0x24,
	0x36, 0x43, 0x1b, 0xb0, 0x9a, 0x72, 0xb3, 0x88, 0xb1, 0x48, 0xe4, 0x5a, 0xee, 0xa9, 0x8d, 0x19,
	0x71, 0xd6, 0x61, 0x39, 0xd7, 0xc6, 0x09, 0x04, 0x15, 0x97, 0x32, 0x2d, 0xba, 0x41, 0x31, 0x51,
	0x2a, 0xcf, 0x42, 0x94, 0xce, 0x4f, 0x4a, 0xb0, 0x94, 0xd3, 0x8d, 0xcc, 0xe9, 0x3e, 0xc0, 0x51,
	0x91, 0x5c, 0x88, 0x18, 0xff, 0xc7, 0xbe, 0xe3, 0x71, 0xe6, 0xd4, 0xca, 0x2c, 0x4b, 0xe0, 0x91,
	0xf7, 0xb9, 0xef, 0x78, 0xf7, 0x42, 0xdf, 0x15, 0xe0, 0x0a, 0xcb, 0x3e, 0xe0, 0x5b, 0x6a, 0x66,
	0xc5, 0xb4, 0x2a, 0xba, 0x0c, 0x17, 0xfb, 0x9b, 0x36, 0xb3, 0xe9, 0x0e, 0xfd, 0x6c, 0x71, 0x0d,
	0x75, 0xe0, 0x4a, 0x9f, 0x5f, 0x4b, 0xa0, 0x35, 0x28, 0xd6, 0x6c, 0x9d, 0x19, 0x66, 0x08, 0x26,
	0x64, 0x74, 0x83, 0x21, 0x85, 0xce, 0x76, 0x7e, 0xad, 0x52, 0xb8, 0x93, 0x50, 0xf3, 0xc4, 0x8a,
	0x9f, 0xfd, 0x1e, 0x86, 0x58, 0xcd, 0x1e, 0x79, 0x67, 0x2a, 0x15, 0xc3, 0xec, 0x94, 0x18, 0x1c,
	0x5f, 0xa7, 0xb5, 0x54, 0x00, 0x65, 0x90, 0x66, 0xa6, 0x12, 0xda, 0x53, 0xef, 0xd3, 0xae, 0x4f,
	0xdd, 0xdb, 0x98, 0x8c, 0x91, 0xf3, 0xe3, 0x5c, 0xb2, 0xd3, 0x5b, 0x51, 0x9c, 0xde, 0x75, 0x68,
	0x86, 0x98, 0x39, 0x7e, 0xc9, 0xbb, 0x66, 0x4a, 0x1c, 0xaf, 0xc1, 0x4b, 0xe3, 0x87, 0xc7, 0x9e,
	0x29, 0x31, 0xe0, 0x3c, 0x63, 0xba, 0x02, 0x2b, 0xfb, 0xc3, 0xe3, 0x81, 0x43, 0x4e, 0x0f, 0xfd,
	0x4d, 0x71, 0x17, 0xf8, 0x9c, 0x03, 0xd8, 0x00, 0x34, 0x6a, 0xba, 0x84, 0xae, 0x64, 0x03, 0xf0,
	0x08, 0x7a, 0xc1, 0xd1, 0x41, 0x11, 0xf2, 0xf5, 0x6e, 0xda, 0x9c, 0xf2, 0xf8, 0xdd, 0xc5, 0xfe,
	0xe6, 0x60, 0xb0, 0x39, 0x32, 0x1d, 0xf6, 0x48, 0xa4, 0xde, 0x74, 0xd4, 0x72, 0xf4, 0x27, 0xd5,
	0x94, 0x2a, 0xee, 0x88, 0xde, 0x9e, 0xb2, 0xb3, 0x34, 0xe5, 0xe9, 0x6e, 0x95, 0xf6, 0xa3, 0xa4,
	0x4f, 0x5d, 0x06, 0xf1, 0xc5, 0x26, 0x4a, 0xf7, 0xf2, 0x05, 0x7d, 0x9e, 0x43, 0xba, 0x36, 0xe9,
	0x7c, 0x0c, 0xcd, 0xcc, 0x58, 0xd9, 0x6a, 0xcb, 0xa3, 0x15, 0x79, 0xf3, 0x8a, 0xe0, 0x6a, 0x65,
	0xe6, 0x2c, 0xed, 0xe3, 0x90, 0xb5, 0xf5, 0x2c, 0xac, 0x55, 0x3a, 0xaf, 0x29, 0xd9, 0x57, 0x73,
	0xc0, 0x06, 0x23, 0x72, 0x92, 0x99, 0x3f, 0x55, 0x46, 0xb3, 0x50, 0xe9, 0x1f, 0xb9, 0x5a, 0xa5,
	0xf3, 0x3b, 0xa5, 0x02, 0xb2, 0x50, 0xb9, 0x99, 0x40, 0x96, 0x0f, 0xd3, 0x73, 0xe2, 0x31, 0xd1,
	0xc1, 0x22, 0x8c, 0xca, 0xcd, 0x82, 0x4e, 0xb7, 0x88, 0xc3, 0x4a, 0x79, 0x0e, 0xe3, 0xa7, 0xfe,
	0x7c, 0x3a, 0xd2, 0x11, 0xb0, 0xfc, 0x4c, 0xd9, 0x9f, 0x9f, 0x85, 0x8b, 0x19, 0x51, 0x12, 0xfa,
	0x82, 0xb2, 0xd7, 0x60, 0x8c, 0x25, 0x49, 0x09, 0x7b, 0xbe, 0x65, 0x93, 0x22, 0x9a, 0xce, 0x98,
	0xfc, 0x1e, 0xac, 0xc6, 0xba, 0x5c, 0xb1, 0xe1, 0x84, 0xf5, 0xfd, 0xf1, 0xd3, 0x74, 0xb8, 0x67,
	0xf7, 0x88, 0xf8, 0x2c, 0x34, 0xe5, 0xac, 0x7c, 0x59, 0xfb, 0xdf, 0x55, 0xe0, 0xca, 0xe4, 0x76,
	0xd4, 0xc4, 0xf1, 0xec, 0x1e, 0x31, 0x4c, 0x2b, 0x72, 0x46, 0x38, 0xd9, 0x7a, 0x2c, 0xdf, 0x75,
	0xd5, 0x77, 0x0e, 0x2e, 0xd1, 0x6a, 0x9b, 0xac, 0x56, 0xb2, 0xe9, 0xd1, 0x3a, 0x7b, 0x53, 0xd9,
	0x1e, 0xef, 0xc1, 0xf3, 0xac, 0x1b, 0x0f, 0x3f, 0x2e, 0xec, 0x83, 0x5b, 0x23, 0x2d, 0x5a, 0x67,
	0x0f, 0x3f, 0xce, 0x77, 0xa0, 0xda, 0x2e, 0xd5, 0x09, 0xb6, 0x4b, 0x4d, 0xb1, 0x5d, 0x34, 0xa8,
	0x8c, 0x9c, 0x40, 0xe4, 0xec, 0xd0, 0x9f, 0xe8, 0x7d, 0x31, 0x12, 0x31, 0x5e, 0xd3, 0xb2, 0x78,
	0x52, 0x47, 0xfc, 0x70, 0x03, 0x7f, 0x5f, 0xfa, 0x22, 0xad, 0xc3, 0xd7, 0x6b, 0x93, 0xd7, 0xd8,
	0x17, 0x15, 0x8a, 0x77, 0xde, 0xb9, 0x67, 0x32, 0x87, 0x12, 0xd3, 0x65, 0x7e, 0xbc, 0xe9, 0x02,
	0x59, 0xd3, 0xa5, 0xf3, 0xb7, 0xc7, 0xee, 0xd7, 0x74, 0x47, 0x96, 0xe8, 0x7d, 0xe8, 0x8b, 0x7d,
	0xb8, 0x84, 0xae, 0xc1, 0xf3, 0x62, 0x7b, 0x96, 0xca, 0xa5, 0x9d, 0x9a, 0xa7, 0x57, 0xf0, 0x8b,
	0x35, 0x52, 0x0d, 0x11, 0x3a, 0xe1, 0x97, 0x21, 0x24, 0xf8, 0x91, 0x13, 0x68, 0x55, 0xf6, 0x54,
	0xe0, 0xa6, 0x6d, 0x1f, 0x04, 0x9e, 0x56, 0x63, 0xef, 0x08, 0x8a, 0x5b, 0x84, 0x81, 0xa7, 0xcd,
	0x74, 0x7e, 0xae, 0x32, 0x4e, 0x0e, 0xf9, 0xc9, 0x8f, 0xb2, 0x1d, 0xde, 0x9e, 0x56, 0x12, 0xbe,
	0xde, 0x8e, 0xb8, 0x01, 0xab, 0xa9, 0x1c, 0x46, 0xa1, 0x3f, 0x18, 0x30, 0x2b, 0x2b, 0x4e, 0x9c,
	0x4f, 0xdd, 0x21, 0x51, 0xd6, 0x0d, 0x08, 0x7a, 0x0f, 0x5a, 0x7d, 0x1c, 0x1e, 0xe3, 0xd0, 0x27,
	0x46, 0xcf, 0x0f, 0x0d, 0xe2, 0x1e, 0x27, 0x7f, 0xaa, 0xa1, 0xec, 0x9a, 0xab, 0x71, 0xb5, 0x7b,
	0x7e, 0x78, 0xe0, 0x1e, 0x8b, 0xff, 0xd5, 0xe8, 0xfc, 0x6c, 0xf1, 0xe6, 0x49, 0x0d, 0xa3, 0x3d,
	0x5f, 0xf2, 0x5d, 0x24, 0xbd, 0x4e, 0x0d, 0x23, 0x11, 0xad, 0xca, 0xd1, 0x59, 0x2b, 0xa3, 0x2b,
	0xd0, 0xee, 0xef, 0x9a, 0x9e, 0x6d, 0x46, 0x7e, 0x78, 0xb6, 0x19, 0x9e, 0x0c, 0x5d, 0xec, 0x45,
	0x64, 0xd7, 0x21, 0xc4, 0xf1, 0x4e, 0xd4, 0x63, 0xfb, 0xce, 0x6d, 0x58, 0xb9, 0x8f, 0x23, 0x35,
	0x7a, 0x78, 0x4e, 0xd6, 0xe4, 0xdf, 0x2f, 0x17, 0xb4, 0xa1, 0x34, 0xbb, 0x9f, 0xbd, 0xb4, 0xf6,
	0x46, 0xf1, 0xa3, 0x20, 0xd9, 0x86, 0xeb, 0xd9, 0x5b, 0x6a, 0x7f, 0xab, 0x04, 0x33, 0xc2, 0x2c,
	0x7a, 0xa0, 0xf2, 0xc1, 0xeb, 0x53, 0x62, 0x1c, 0xc3, 0x02, 0xdd, 0xf4, 0x3a, 0x89, 0x08, 0x01,
	0x9f, 0xfb, 0xf8, 0x4d, 0x8c, 0xb4, 0xa1, 0x46, 0xec, 0x3b, 0x6f, 0x3d, 0x8b, 0xcd, 0xd3, 0xf9,
	0xdf, 0x25, 0xf1, 0x26, 0xd6, 0x28, 0x63, 0xab, 0x16, 0x7a, 0x6c, 0x97, 0x01, 0x32, 0xcf, 0x18,
	0xcd, 0xeb, 0xf3, 0xc9, 0x6b, 0x13, 0xe8, 0x11, 0x2c, 0xb8, 0xd8, 0x3d, 0xa6, 0xce, 0x83, 0x6f,
	0xe3, 0xf8, 0x92, 0xf1, 0x46, 0xc1, 0xcd, 0x98, 0xa2, 0x1e, 0xd7, 0x77, 0x59, 0x5b, 0x66, 0x46,
	0xd6, 0xdd, 0xe4, 0x37, 0x69, 0x7f, 0x0a, 0x90, 0x16, 0xa1, 0x06, 0x94, 0x13, 0x2f, 0xb6, 0xec,
	0xa4, 0x2f, 0x8a, 0x96, 0xa5, 0x71, 0xae, 0x40, 0x8d, 0x3f, 0x47, 0x2c, 0x5e, 0x02, 0x67, 0x1f,
	0x45, 0x09, 0x4c, 0x9d, 0x6f, 0xc3, 0xa5, 0xfb, 0x38, 0x2a, 0x1c, 0x0f, 0xe5, 0xba, 0x67, 0x70,
	0x8c, 0x3a, 0x7f, 0xb5, 0x3c, 0x1e, 0x27, 0x3f, 0xa5, 0x54, 0x38, 0xe8, 0x4e, 0x21, 0x07, 0x8d,
	0x6b, 0x3d, 0x8e, 0x91, 0x0e, 0x61, 0x29, 0x3b, 0xd0, 0x38, 0x4d, 0xe5, 0x95, 0x29, 0xd7, 0x5f,
	0xd7, 0x32, 0xb3, 0x21, 0x9d, 0xfb, 0x53, 0xe5, 0x70, 0x9f, 0xfb, 0x08, 0x8d, 0xbd, 0xf1, 0x8f,
	0x9b, 0xd0, 0x8c, 0xff, 0xb0, 0xed, 0x80, 0x1a, 0xd8, 0x16, 0x46, 0xdf, 0x85, 0xba, 0xf4, 0x22,
	0x0f, 0xba, 0x36, 0xf1, 0xc1, 0x9e, 0xcd, 0xf0, 0xa4, 0x7d, 0xed, 0xbc, 0x27, 0x7d, 0x3a, 0x33,
	0x5f, 0xfd, 0xe6, 0xe5, 0xdf, 0xf9, 0xd1, 0x2c, 0x3a, 0x80, 0xf9, 0xe4, 0x2d, 0x0b, 0x74, 0x65,
	0xf2, 0x3b, 0x33, 0xed, 0x2b, 0x93, 0x1f, 0xc2, 0x60, 0x48, 0x7f, 0xed, 0xdf, 0x5c, 0x44, 0x06,
	0x2c, 0x2a, 0x77, 0xec, 0x50, 0xe7, 0x9c, 0x4b, 0x78, 0x14, 0x79, 0xe7, 0xfc, 0x8b, 0x7a, 0xbc,
	0x83, 0x3f, 0x58, 0x41, 0x47, 0xca, 0xa5, 0xab, 0xab, 0xe7, 0x5c, 0x84, 0x68, 0x5f, 0x3d, 0x27,
	0x75, 0x9f, 0xe1, 0xfd, 0xea, 0x9f, 0x2d, 0x53, 0xbc, 0xe9, 0xb5, 0xf0, 0x22, 0xbc, 0xca, 0xb3,
	0x13, 0xed, 0xab, 0xe7, 0xdc, 0x2a, 0xe7, 0xab, 0xfc, 0xbb, 0x2f, 0xa1, 0x3f, 0x0d, 0x5a, 0xf6,
	0x06, 0x2e, 0x7a, 0x79, 0xaa, 0x4b, 0xcf, 0xed, 0x97, 0xa7, 0xba, 0xcc, 0x8b, 0xbe, 0x03, 0x8b,
	0x4a, 0x2e, 0x78, 0xd1, 0x92, 0x67, 0xf3, 0xeb, 0xdb, 0x9d, 0xf3, 0x13, 0xca, 0xd1, 0xa7, 0xd0,
	0x50, 0x13, 0x7f, 0xd1, 0x8b, 0xe7, 0xa5, 0x06, 0x53, 0xd4, 0x2f, 0x4e, 0x91, 0x3f, 0x4c, 0x97,
	0x25, 0x9b, 0x67, 0x5a, 0xb4, 0x2c, 0x05, 0xc9, 0xbc, 0xed, 0x97, 0xa7, 0x4a, 0x59, 0x45, 0x16,
	0x2c, 0xe5, 0x72, 0x93, 0xd0, 0xf5, 0xe9, 0xb2, 0xd1, 0xda, 0xd7, 0xa7, 0x4b, 0x74, 0xa2, 0x9d,
	0xe4, 0x72, 0x58, 0x8a, 0x3a, 0x29, 0xca, 0xf0, 0x69, 0x5f, 0x9f, 0x2e, 0x21, 0x06, 0xfd, 0x29,
	0x68, 0x66, 0xd2, 0x3c, 0xd1, 0x4b, 0xe7, 0x66, 0x82, 0xd2, 0x0e, 0x5e, 0x9a, 0x26, 0x5f, 0x94,
	0xa2, 0xcf, 0x24, 0x21, 0x16, 0xa1, 0xcf, 0x67, 0x6d, 0xb6, 0x5f, 0x9a, 0x26, 0x9b, 0x91, 0x2e,
	0x51, 0x2e, 0x8f, 0xa4, 0x68, 0x89, 0x8a, 0xf2, 0x62, 0xda, 0xd7, 0xa7, 0x4b, 0x4a, 0x41, 0xfb,
	0x30, 0x17, 0x1f, 0x5d, 0xa2, 0xcb, 0x13, 0x8f, 0xf8, 0xdb, 0x97, 0x27, 0x9e, 0x7a, 0x72, 0x3d,
	0xf3, 0x47, 0x80, 0x76, 0x61, 0x56, 0x1c, 0xbe, 0xa0, 0xe7, 0x27, 0x1d, 0xd6, 0xb5, 0x9f, 0x9f,
	0x74, 0x6a, 0x93, 0xa8, 0x81, 0x2f, 0x60, 0xb9, 0x20, 0x12, 0x84, 0x6e, 0x4c, 0x1b, 0x01, 0x6f,
	0xdf, 0x98, 0x36, 0xb4, 0xc4, 0xba, 0xfc, 0x83, 0xbf, 0x83, 0xd0, 0xe7, 0xb0, 0x94, 0x73, 0xd1,
	0x8b, 0x16, 0xbe, 0x28, 0xcc, 0xd1, 0xbe, 0x3e, 0x9d, 0xbf, 0xdf, 0xa9, 0x7d, 0xf5, 0x9b, 0x97,
	0x7f, 0x79, 0x88, 0xbe, 0xcc, 0x85, 0xe6, 0x62, 0x0b, 0xe9, 0xe6, 0x53, 0x78, 0xc3, 0xed, 0x9b,
	0x4f, 0xe1, 0x30, 0x24, 0xfb, 0xd8, 0x13, 0x68, 0x8d, 0xb3, 0x05, 0xd0, 0x1b, 0xd3, 0xdb, 0x0d,
	0xb4, 0xff, 0x37, 0x9e, 0xca, 0xcc, 0x68, 0x37, 0xbe, 0xfa, 0x71, 0xeb, 0xb7, 0xfe, 0x5b, 0xe9,
	0xfb, 0x3f, 0x6e, 0x3d, 0xf7, 0x83, 0x1f, 0xb7, 0x9e, 0xfb, 0xf0, 0x1d, 0x58, 0xb1, 0x7c, 0x37,
	0x87, 0xe3, 0xc3, 0xe4, 0x6f, 0x58, 0x59, 0x9a, 0xcb, 0xa7, 0x73, 0x71, 0xc1, 0x57, 0xa5, 0xd2,
	0xf7, 0x4b, 0xa5, 0x1f, 0x94, 0x4a, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x87, 0xb4, 0x4f, 0x41,
	0x58, 0x76, 0x00, 0x00,
}

//Generated by ntnx_rpc plugin

// Service HyperintService
type IHyperintService interface {
	BeforeRpcCall(rpc *util_net.ProtobufRpc, arg interface{}, ret interface{}) error
	AfterRpcCall(rpc *util_net.ProtobufRpc, arg interface{}, ret interface{}, err error) error

	GetNodeInfo(*GetNodeInfoArg, *GetNodeInfoRet) error
	GetVmInfo(*GetVmInfoArg, *GetVmInfoRet) error
	ChangeVmState(*ChangeVmStateArg, *ChangeVmStateRet) error
	RegisterVm(*RegisterVmArg, *RegisterVmRet) error
	SnapshotVm(*SnapshotVmArg, *SnapshotVmRet) error
	AdjustVmSnapshot(*AdjustVmSnapshotArg, *AdjustVmSnapshotRet) error
	GetDatastores(*GetDatastoresArg, *GetDatastoresRet) error
	MountDatastore(*MountDatastoreArg, *MountDatastoreRet) error
	UnmountDatastore(*UnmountDatastoreArg, *UnmountDatastoreRet) error
	AttachVirtualDisk(*AttachVirtualDiskArg, *AttachVirtualDiskRet) error
	DetachVirtualDisk(*DetachVirtualDiskArg, *DetachVirtualDiskRet) error
	AttachVirtualCd(*AttachVirtualCdArg, *AttachVirtualCdRet) error
	DetachVirtualCd(*DetachVirtualCdArg, *DetachVirtualCdRet) error
	ModifyVirtualDisk(*ModifyVirtualDiskArg, *ModifyVirtualDiskRet) error
	CreateVm(*CreateVmArg, *CreateVmRet) error
	CloneVm(*CloneVmArg, *CloneVmRet) error
	ConfigureHypervNode(*ConfigureHypervNodeArg, *ConfigureHypervNodeRet) error
	PublishToArithmos(*PublishToArithmosArg, *PublishToArithmosRet) error
	ConfigureHypervCluster(*ConfigureHypervClusterArg, *ConfigureHypervClusterRet) error
	GetHypervFailoverCluster(*GetHypervFailoverClusterArg, *GetHypervFailoverClusterRet) error
}

func _HyperintService_GetNodeInfo_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(GetNodeInfoArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &GetNodeInfoRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.GetNodeInfo(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_GetVmInfo_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(GetVmInfoArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &GetVmInfoRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.GetVmInfo(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_ChangeVmState_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(ChangeVmStateArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &ChangeVmStateRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ChangeVmState(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_RegisterVm_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(RegisterVmArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &RegisterVmRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.RegisterVm(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_SnapshotVm_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(SnapshotVmArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &SnapshotVmRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.SnapshotVm(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_AdjustVmSnapshot_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(AdjustVmSnapshotArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &AdjustVmSnapshotRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.AdjustVmSnapshot(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_GetDatastores_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(GetDatastoresArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &GetDatastoresRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.GetDatastores(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_MountDatastore_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(MountDatastoreArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &MountDatastoreRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.MountDatastore(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_UnmountDatastore_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(UnmountDatastoreArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &UnmountDatastoreRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.UnmountDatastore(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_AttachVirtualDisk_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(AttachVirtualDiskArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &AttachVirtualDiskRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.AttachVirtualDisk(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_DetachVirtualDisk_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(DetachVirtualDiskArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &DetachVirtualDiskRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.DetachVirtualDisk(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_AttachVirtualCd_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(AttachVirtualCdArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &AttachVirtualCdRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.AttachVirtualCd(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_DetachVirtualCd_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(DetachVirtualCdArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &DetachVirtualCdRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.DetachVirtualCd(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_ModifyVirtualDisk_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(ModifyVirtualDiskArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &ModifyVirtualDiskRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ModifyVirtualDisk(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_CreateVm_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CreateVmArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CreateVmRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CreateVm(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_CloneVm_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(CloneVmArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &CloneVmRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.CloneVm(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_ConfigureHypervNode_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(ConfigureHypervNodeArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &ConfigureHypervNodeRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ConfigureHypervNode(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_PublishToArithmos_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(PublishToArithmosArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &PublishToArithmosRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.PublishToArithmos(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_ConfigureHypervCluster_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(ConfigureHypervClusterArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &ConfigureHypervClusterRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.ConfigureHypervCluster(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

func _HyperintService_GetHypervFailoverCluster_Handler(rpc *util_net.ProtobufRpc, handlers interface{}) error {
	handler, ok := handlers.(IHyperintService)
	if !ok {
		return util_net.ErrMethod
	}
	arg := new(GetHypervFailoverClusterArg)
	err := proto.Unmarshal(rpc.RequestPayload, arg)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Failed to unmarshal request"))
	}
	ret := &GetHypervFailoverClusterRet{}
	err = handler.BeforeRpcCall(rpc, arg, ret)
	if err != nil {
		return err
	}
	err = handler.GetHypervFailoverCluster(arg, ret)
	err = handler.AfterRpcCall(rpc, arg, ret, err)
	if err != nil {
		return err
	}
	rpc.ResponsePayload, err = proto.Marshal(ret)
	if err != nil {
		return util_net.ErrTransport.SetCause(
			errors.New("Error in marshaling response"))
	}
	return nil
}

var _HyperintServiceDesc = util_net.ServiceDesc{
	Name: "nutanix.hyperint.HyperintService",
	Methods: map[string]util_net.ServiceMethodFn{
		"GetNodeInfo":              _HyperintService_GetNodeInfo_Handler,
		"GetVmInfo":                _HyperintService_GetVmInfo_Handler,
		"ChangeVmState":            _HyperintService_ChangeVmState_Handler,
		"RegisterVm":               _HyperintService_RegisterVm_Handler,
		"SnapshotVm":               _HyperintService_SnapshotVm_Handler,
		"AdjustVmSnapshot":         _HyperintService_AdjustVmSnapshot_Handler,
		"GetDatastores":            _HyperintService_GetDatastores_Handler,
		"MountDatastore":           _HyperintService_MountDatastore_Handler,
		"UnmountDatastore":         _HyperintService_UnmountDatastore_Handler,
		"AttachVirtualDisk":        _HyperintService_AttachVirtualDisk_Handler,
		"DetachVirtualDisk":        _HyperintService_DetachVirtualDisk_Handler,
		"AttachVirtualCd":          _HyperintService_AttachVirtualCd_Handler,
		"DetachVirtualCd":          _HyperintService_DetachVirtualCd_Handler,
		"ModifyVirtualDisk":        _HyperintService_ModifyVirtualDisk_Handler,
		"CreateVm":                 _HyperintService_CreateVm_Handler,
		"CloneVm":                  _HyperintService_CloneVm_Handler,
		"ConfigureHypervNode":      _HyperintService_ConfigureHypervNode_Handler,
		"PublishToArithmos":        _HyperintService_PublishToArithmos_Handler,
		"ConfigureHypervCluster":   _HyperintService_ConfigureHypervCluster_Handler,
		"GetHypervFailoverCluster": _HyperintService_GetHypervFailoverCluster_Handler,
	},
}

func NewHyperintService(impl IHyperintService) *util_net.Service {
	return &util_net.Service{
		Desc: &_HyperintServiceDesc,
		Impl: impl,
	}
}

type IHyperintClient interface {
	GetNodeInfo(*GetNodeInfoArg) (*GetNodeInfoRet, error)
	GetVmInfo(*GetVmInfoArg) (*GetVmInfoRet, error)
	ChangeVmState(*ChangeVmStateArg) (*ChangeVmStateRet, error)
	RegisterVm(*RegisterVmArg) (*RegisterVmRet, error)
	SnapshotVm(*SnapshotVmArg) (*SnapshotVmRet, error)
	AdjustVmSnapshot(*AdjustVmSnapshotArg) (*AdjustVmSnapshotRet, error)
	GetDatastores(*GetDatastoresArg) (*GetDatastoresRet, error)
	MountDatastore(*MountDatastoreArg) (*MountDatastoreRet, error)
	UnmountDatastore(*UnmountDatastoreArg) (*UnmountDatastoreRet, error)
	AttachVirtualDisk(*AttachVirtualDiskArg) (*AttachVirtualDiskRet, error)
	DetachVirtualDisk(*DetachVirtualDiskArg) (*DetachVirtualDiskRet, error)
	AttachVirtualCd(*AttachVirtualCdArg) (*AttachVirtualCdRet, error)
	DetachVirtualCd(*DetachVirtualCdArg) (*DetachVirtualCdRet, error)
	ModifyVirtualDisk(*ModifyVirtualDiskArg) (*ModifyVirtualDiskRet, error)
	CreateVm(*CreateVmArg) (*CreateVmRet, error)
	CloneVm(*CloneVmArg) (*CloneVmRet, error)
	ConfigureHypervNode(*ConfigureHypervNodeArg) (*ConfigureHypervNodeRet, error)
	PublishToArithmos(*PublishToArithmosArg) (*PublishToArithmosRet, error)
	ConfigureHypervCluster(*ConfigureHypervClusterArg) (*ConfigureHypervClusterRet, error)
	GetHypervFailoverCluster(*GetHypervFailoverClusterArg) (*GetHypervFailoverClusterRet, error)
}

type HyperintClient struct {
	Impl util_net.ProtobufRPCClientIfc
}

func NewHyperintClient(impl util_net.ProtobufRPCClientIfc) IHyperintClient {
	return &HyperintClient{
		Impl: impl,
	}
}

func (client *HyperintClient) GetNodeInfo(
	arg *GetNodeInfoArg) (
	*GetNodeInfoRet, error) {

	ret := &GetNodeInfoRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "GetNodeInfo", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) GetVmInfo(
	arg *GetVmInfoArg) (
	*GetVmInfoRet, error) {

	ret := &GetVmInfoRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "GetVmInfo", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) ChangeVmState(
	arg *ChangeVmStateArg) (
	*ChangeVmStateRet, error) {

	ret := &ChangeVmStateRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "ChangeVmState", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) RegisterVm(
	arg *RegisterVmArg) (
	*RegisterVmRet, error) {

	ret := &RegisterVmRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "RegisterVm", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) SnapshotVm(
	arg *SnapshotVmArg) (
	*SnapshotVmRet, error) {

	ret := &SnapshotVmRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "SnapshotVm", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) AdjustVmSnapshot(
	arg *AdjustVmSnapshotArg) (
	*AdjustVmSnapshotRet, error) {

	ret := &AdjustVmSnapshotRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "AdjustVmSnapshot", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) GetDatastores(
	arg *GetDatastoresArg) (
	*GetDatastoresRet, error) {

	ret := &GetDatastoresRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "GetDatastores", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) MountDatastore(
	arg *MountDatastoreArg) (
	*MountDatastoreRet, error) {

	ret := &MountDatastoreRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "MountDatastore", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) UnmountDatastore(
	arg *UnmountDatastoreArg) (
	*UnmountDatastoreRet, error) {

	ret := &UnmountDatastoreRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "UnmountDatastore", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) AttachVirtualDisk(
	arg *AttachVirtualDiskArg) (
	*AttachVirtualDiskRet, error) {

	ret := &AttachVirtualDiskRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "AttachVirtualDisk", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) DetachVirtualDisk(
	arg *DetachVirtualDiskArg) (
	*DetachVirtualDiskRet, error) {

	ret := &DetachVirtualDiskRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "DetachVirtualDisk", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) AttachVirtualCd(
	arg *AttachVirtualCdArg) (
	*AttachVirtualCdRet, error) {

	ret := &AttachVirtualCdRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "AttachVirtualCd", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) DetachVirtualCd(
	arg *DetachVirtualCdArg) (
	*DetachVirtualCdRet, error) {

	ret := &DetachVirtualCdRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "DetachVirtualCd", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) ModifyVirtualDisk(
	arg *ModifyVirtualDiskArg) (
	*ModifyVirtualDiskRet, error) {

	ret := &ModifyVirtualDiskRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "ModifyVirtualDisk", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) CreateVm(
	arg *CreateVmArg) (
	*CreateVmRet, error) {

	ret := &CreateVmRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "CreateVm", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) CloneVm(
	arg *CloneVmArg) (
	*CloneVmRet, error) {

	ret := &CloneVmRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "CloneVm", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) ConfigureHypervNode(
	arg *ConfigureHypervNodeArg) (
	*ConfigureHypervNodeRet, error) {

	ret := &ConfigureHypervNodeRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "ConfigureHypervNode", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) PublishToArithmos(
	arg *PublishToArithmosArg) (
	*PublishToArithmosRet, error) {

	ret := &PublishToArithmosRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "PublishToArithmos", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) ConfigureHypervCluster(
	arg *ConfigureHypervClusterArg) (
	*ConfigureHypervClusterRet, error) {

	ret := &ConfigureHypervClusterRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "ConfigureHypervCluster", arg, ret, 0)
	return ret, err
}

func (client *HyperintClient) GetHypervFailoverCluster(
	arg *GetHypervFailoverClusterArg) (
	*GetHypervFailoverClusterRet, error) {

	ret := &GetHypervFailoverClusterRet{}
	err := client.Impl.CallMethodSync(
		"nutanix.hyperint.HyperintService", "GetHypervFailoverCluster", arg, ret, 0)
	return ret, err
}
