// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pithos/volume_group.proto

package pithos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// This field indicates what file system to use for volume group.
// This is supported for container volumes for now.
type VolumeGroupConfig_FileSystemType int32

const (
	VolumeGroupConfig_kUnknown VolumeGroupConfig_FileSystemType = 0
	VolumeGroupConfig_kExt4    VolumeGroupConfig_FileSystemType = 1
)

var VolumeGroupConfig_FileSystemType_name = map[int32]string{
	0: "kUnknown",
	1: "kExt4",
}

var VolumeGroupConfig_FileSystemType_value = map[string]int32{
	"kUnknown": 0,
	"kExt4":    1,
}

func (x VolumeGroupConfig_FileSystemType) Enum() *VolumeGroupConfig_FileSystemType {
	p := new(VolumeGroupConfig_FileSystemType)
	*p = x
	return p
}

func (x VolumeGroupConfig_FileSystemType) String() string {
	return proto.EnumName(VolumeGroupConfig_FileSystemType_name, int32(x))
}

func (x *VolumeGroupConfig_FileSystemType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VolumeGroupConfig_FileSystemType_value, data, "VolumeGroupConfig_FileSystemType")
	if err != nil {
		return err
	}
	*x = VolumeGroupConfig_FileSystemType(value)
	return nil
}

func (VolumeGroupConfig_FileSystemType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e38abda08a0ae273, []int{2, 0}
}

type VolumeDiskConfig struct {
	// Index of the volume disk in the group.
	Index *uint32 `protobuf:"varint,1,opt,name=index" json:"index,omitempty"`
	// UUID of the volume disk.
	VmdiskUuid []byte `protobuf:"bytes,2,opt,name=vmdisk_uuid,json=vmdiskUuid" json:"vmdisk_uuid,omitempty"`
	// Container ID of the volume where the disk resides.
	ContainerId *int64 `protobuf:"varint,3,opt,name=container_id,json=containerId" json:"container_id,omitempty"`
	// Disk size in bytes. This field is usually populated on-demand, during
	// certain queries. It is not stored in the Acropolis database.
	VmdiskSize *int64 `protobuf:"varint,4,opt,name=vmdisk_size,json=vmdiskSize" json:"vmdisk_size,omitempty"`
	// If true, this Volume disk was derived from an existing vmdisk.
	// This is needed for migrating shared vmdisks to volume groups.
	DerivedFromExistingVmdisk *bool `protobuf:"varint,5,opt,name=derived_from_existing_vmdisk,json=derivedFromExistingVmdisk" json:"derived_from_existing_vmdisk,omitempty"`
	// Disk NFS path. This field is usually populated on-demand, during certain
	// queries. It is not stored in the Acropolis database.
	VmdiskNfsPath *string `protobuf:"bytes,6,opt,name=vmdisk_nfs_path,json=vmdiskNfsPath" json:"vmdisk_nfs_path,omitempty"`
	// Whether flash mode is enabled on this disk. This value is inherited from
	// the VG, but can be explicitly overridden using VolumeDiskUpdate rpc.
	FlashMode *bool `protobuf:"varint,7,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	// If this disk is backed partially or fully by a data source in an external
	// repository, the following property is applicable. However, this property
	// is usually populated only on-demand, during certain queries. It is not
	// stored in the Acropolis database. In addition, this property is not a
	// static property -- the value of this property will be cleared when the
	// disk is no longer dependent on the data outside the AOS cluster.
	DataSourceUrl *string `protobuf:"bytes,8,opt,name=data_source_url,json=dataSourceUrl" json:"data_source_url,omitempty"`
	// String describing the volume disk.
	Annotation           *string  `protobuf:"bytes,9,opt,name=annotation" json:"annotation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeDiskConfig) Reset()         { *m = VolumeDiskConfig{} }
func (m *VolumeDiskConfig) String() string { return proto.CompactTextString(m) }
func (*VolumeDiskConfig) ProtoMessage()    {}
func (*VolumeDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e38abda08a0ae273, []int{0}
}

func (m *VolumeDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeDiskConfig.Unmarshal(m, b)
}
func (m *VolumeDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeDiskConfig.Marshal(b, m, deterministic)
}
func (m *VolumeDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeDiskConfig.Merge(m, src)
}
func (m *VolumeDiskConfig) XXX_Size() int {
	return xxx_messageInfo_VolumeDiskConfig.Size(m)
}
func (m *VolumeDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeDiskConfig proto.InternalMessageInfo

func (m *VolumeDiskConfig) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *VolumeDiskConfig) GetVmdiskUuid() []byte {
	if m != nil {
		return m.VmdiskUuid
	}
	return nil
}

func (m *VolumeDiskConfig) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VolumeDiskConfig) GetVmdiskSize() int64 {
	if m != nil && m.VmdiskSize != nil {
		return *m.VmdiskSize
	}
	return 0
}

func (m *VolumeDiskConfig) GetDerivedFromExistingVmdisk() bool {
	if m != nil && m.DerivedFromExistingVmdisk != nil {
		return *m.DerivedFromExistingVmdisk
	}
	return false
}

func (m *VolumeDiskConfig) GetVmdiskNfsPath() string {
	if m != nil && m.VmdiskNfsPath != nil {
		return *m.VmdiskNfsPath
	}
	return ""
}

func (m *VolumeDiskConfig) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

func (m *VolumeDiskConfig) GetDataSourceUrl() string {
	if m != nil && m.DataSourceUrl != nil {
		return *m.DataSourceUrl
	}
	return ""
}

func (m *VolumeDiskConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

type VolumeAttachment struct {
	// UUID of VM to which this volume is attached.
	VmUuid []byte `protobuf:"bytes,1,opt,name=vm_uuid,json=vmUuid" json:"vm_uuid,omitempty"`
	// Name of the external initiator.
	ExternalInitiatorName *string `protobuf:"bytes,2,opt,name=external_initiator_name,json=externalInitiatorName" json:"external_initiator_name,omitempty"`
	// iSCSI target params. See IscsiClientParams in pithos.proto
	TargetParams *IscsiClientParams_TargetParams `protobuf:"bytes,3,opt,name=target_params,json=targetParams" json:"target_params,omitempty"`
	// Network identifier of the external initiator.
	ExternalInitiatorNetworkId *string `protobuf:"bytes,4,opt,name=external_initiator_network_id,json=externalInitiatorNetworkId" json:"external_initiator_network_id,omitempty"`
	// UUID of the client.
	ClientUuid           []byte   `protobuf:"bytes,5,opt,name=client_uuid,json=clientUuid" json:"client_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeAttachment) Reset()         { *m = VolumeAttachment{} }
func (m *VolumeAttachment) String() string { return proto.CompactTextString(m) }
func (*VolumeAttachment) ProtoMessage()    {}
func (*VolumeAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e38abda08a0ae273, []int{1}
}

func (m *VolumeAttachment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeAttachment.Unmarshal(m, b)
}
func (m *VolumeAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeAttachment.Marshal(b, m, deterministic)
}
func (m *VolumeAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeAttachment.Merge(m, src)
}
func (m *VolumeAttachment) XXX_Size() int {
	return xxx_messageInfo_VolumeAttachment.Size(m)
}
func (m *VolumeAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeAttachment proto.InternalMessageInfo

func (m *VolumeAttachment) GetVmUuid() []byte {
	if m != nil {
		return m.VmUuid
	}
	return nil
}

func (m *VolumeAttachment) GetExternalInitiatorName() string {
	if m != nil && m.ExternalInitiatorName != nil {
		return *m.ExternalInitiatorName
	}
	return ""
}

func (m *VolumeAttachment) GetTargetParams() *IscsiClientParams_TargetParams {
	if m != nil {
		return m.TargetParams
	}
	return nil
}

func (m *VolumeAttachment) GetExternalInitiatorNetworkId() string {
	if m != nil && m.ExternalInitiatorNetworkId != nil {
		return *m.ExternalInitiatorNetworkId
	}
	return ""
}

func (m *VolumeAttachment) GetClientUuid() []byte {
	if m != nil {
		return m.ClientUuid
	}
	return nil
}

type VolumeGroupConfig struct {
	// Volume UUID
	Uuid []byte `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Volume name.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// String describing the volume.
	Annotation *string `protobuf:"bytes,3,opt,name=annotation" json:"annotation,omitempty"`
	// The logical timestamp.
	LogicalTimestamp *int64 `protobuf:"varint,4,opt,name=logical_timestamp,json=logicalTimestamp,def=-1" json:"logical_timestamp,omitempty"`
	// Whether the volume has been deleted.
	Deleted *bool `protobuf:"varint,5,opt,name=deleted" json:"deleted,omitempty"`
	// Ordered list of volume disks.
	DiskList []*VolumeDiskConfig `protobuf:"bytes,6,rep,name=disk_list,json=diskList" json:"disk_list,omitempty"`
	// iSCSI target name to assign to volume for external attachment.
	IscsiTargetName *string `protobuf:"bytes,7,opt,name=iscsi_target_name,json=iscsiTargetName" json:"iscsi_target_name,omitempty"`
	// List of entities that currently have this volume attached.
	AttachmentList []*VolumeAttachment `protobuf:"bytes,8,rep,name=attachment_list,json=attachmentList" json:"attachment_list,omitempty"`
	// Whether or not this volume can be shared.
	Shared *bool `protobuf:"varint,9,opt,name=shared" json:"shared,omitempty"`
	// Whether to delete the VolumeGroup when it is detached from a VM.
	// Note: This is nutanix internal only (used by cerebro) and must not be
	// exposed to user-facing endpoints such as ACLI/REST.
	DeleteOnDetach *bool `protobuf:"varint,10,opt,name=delete_on_detach,json=deleteOnDetach,def=0" json:"delete_on_detach,omitempty"`
	// If set to a non-empty string, this VG should be considered incompatible
	// with DR workflows.
	CbrNotCapableReason *string `protobuf:"bytes,11,opt,name=cbr_not_capable_reason,json=cbrNotCapableReason" json:"cbr_not_capable_reason,omitempty"`
	// Whether to enable flash mode for the VG. If true, all volume disks of the
	// VG will be pinned to SSD tier (unless the flash mode setting is explicitly
	// disabled for a volume disk).
	FlashMode *bool `protobuf:"varint,13,opt,name=flash_mode,json=flashMode" json:"flash_mode,omitempty"`
	// Obfuscated target_secret for CHAP authentication to be used by clients
	ObfuscatedTargetSecret *string                           `protobuf:"bytes,14,opt,name=obfuscated_target_secret,json=obfuscatedTargetSecret" json:"obfuscated_target_secret,omitempty"`
	FileSystemType         *VolumeGroupConfig_FileSystemType `protobuf:"varint,15,opt,name=file_system_type,json=fileSystemType,enum=nutanix.pithos.VolumeGroupConfig_FileSystemType" json:"file_system_type,omitempty"`
	// Only set during entity migration between clusters for a transient volume
	// group entity. Acropolis will use the incarnation_id to call AttachEntity
	// on EDB entity. The caller needs to pass in an incarnation_id greater
	// than the incarnation_id of the entity on the source cluster.
	IncarnationId *uint64 `protobuf:"varint,16,opt,name=incarnation_id,json=incarnationId" json:"incarnation_id,omitempty"`
	// Whether VG load balance VM attachments is enabled/disabled.
	LoadBalanceVmAttachments *bool `protobuf:"varint,17,opt,name=load_balance_vm_attachments,json=loadBalanceVmAttachments" json:"load_balance_vm_attachments,omitempty"`
	// Source VG uuid of which this VG is clone of.
	SourceVgUuid []byte `protobuf:"bytes,18,opt,name=source_vg_uuid,json=sourceVgUuid" json:"source_vg_uuid,omitempty"`
	// Name of the service/user which created this VG.
	CreatedBy *string `protobuf:"bytes,19,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	// List of container UUIDs associated to a VG. This field is populated
	// on-demand, during publishing VG to IDF. It is not stored in the Acropolis
	// database.
	ContainerUuids [][]byte `protobuf:"bytes,20,rep,name=container_uuids,json=containerUuids" json:"container_uuids,omitempty"`
	// List of volume disk UUIDs. This field is populated on-demand, during
	// publishing VG to IDF. It is not stored in the Acropolis database.
	NutanixNfsBasedVirtualDiskUuids [][]byte `protobuf:"bytes,21,rep,name=nutanix_nfs_based_virtual_disk_uuids,json=nutanixNfsBasedVirtualDiskUuids" json:"nutanix_nfs_based_virtual_disk_uuids,omitempty"`
	// Storage Configuration for the VG.
	StorageConfig *StorageConfig `protobuf:"bytes,22,opt,name=storage_config,json=storageConfig" json:"storage_config,omitempty"`
	// Sum of size in bytes of the underlying disks in a VG. This field is
	// populated on-demand, during publishing VG to IDF. It is not stored in
	// the Acropolis database.
	CapacityBytes *int64 `protobuf:"varint,23,opt,name=capacity_bytes,json=capacityBytes" json:"capacity_bytes,omitempty"`
	// List of the external attachment UUIDs associated to a VG. This field is
	// populated on-demand, during publishing VG to IDF. It is not stored in
	// the Acropolis database.
	ClientUuids          [][]byte `protobuf:"bytes,24,rep,name=client_uuids,json=clientUuids" json:"client_uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeGroupConfig) Reset()         { *m = VolumeGroupConfig{} }
func (m *VolumeGroupConfig) String() string { return proto.CompactTextString(m) }
func (*VolumeGroupConfig) ProtoMessage()    {}
func (*VolumeGroupConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e38abda08a0ae273, []int{2}
}

func (m *VolumeGroupConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeGroupConfig.Unmarshal(m, b)
}
func (m *VolumeGroupConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeGroupConfig.Marshal(b, m, deterministic)
}
func (m *VolumeGroupConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeGroupConfig.Merge(m, src)
}
func (m *VolumeGroupConfig) XXX_Size() int {
	return xxx_messageInfo_VolumeGroupConfig.Size(m)
}
func (m *VolumeGroupConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeGroupConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeGroupConfig proto.InternalMessageInfo

const Default_VolumeGroupConfig_LogicalTimestamp int64 = -1
const Default_VolumeGroupConfig_DeleteOnDetach bool = false

func (m *VolumeGroupConfig) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *VolumeGroupConfig) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *VolumeGroupConfig) GetAnnotation() string {
	if m != nil && m.Annotation != nil {
		return *m.Annotation
	}
	return ""
}

func (m *VolumeGroupConfig) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return Default_VolumeGroupConfig_LogicalTimestamp
}

func (m *VolumeGroupConfig) GetDeleted() bool {
	if m != nil && m.Deleted != nil {
		return *m.Deleted
	}
	return false
}

func (m *VolumeGroupConfig) GetDiskList() []*VolumeDiskConfig {
	if m != nil {
		return m.DiskList
	}
	return nil
}

func (m *VolumeGroupConfig) GetIscsiTargetName() string {
	if m != nil && m.IscsiTargetName != nil {
		return *m.IscsiTargetName
	}
	return ""
}

func (m *VolumeGroupConfig) GetAttachmentList() []*VolumeAttachment {
	if m != nil {
		return m.AttachmentList
	}
	return nil
}

func (m *VolumeGroupConfig) GetShared() bool {
	if m != nil && m.Shared != nil {
		return *m.Shared
	}
	return false
}

func (m *VolumeGroupConfig) GetDeleteOnDetach() bool {
	if m != nil && m.DeleteOnDetach != nil {
		return *m.DeleteOnDetach
	}
	return Default_VolumeGroupConfig_DeleteOnDetach
}

func (m *VolumeGroupConfig) GetCbrNotCapableReason() string {
	if m != nil && m.CbrNotCapableReason != nil {
		return *m.CbrNotCapableReason
	}
	return ""
}

func (m *VolumeGroupConfig) GetFlashMode() bool {
	if m != nil && m.FlashMode != nil {
		return *m.FlashMode
	}
	return false
}

func (m *VolumeGroupConfig) GetObfuscatedTargetSecret() string {
	if m != nil && m.ObfuscatedTargetSecret != nil {
		return *m.ObfuscatedTargetSecret
	}
	return ""
}

func (m *VolumeGroupConfig) GetFileSystemType() VolumeGroupConfig_FileSystemType {
	if m != nil && m.FileSystemType != nil {
		return *m.FileSystemType
	}
	return VolumeGroupConfig_kUnknown
}

func (m *VolumeGroupConfig) GetIncarnationId() uint64 {
	if m != nil && m.IncarnationId != nil {
		return *m.IncarnationId
	}
	return 0
}

func (m *VolumeGroupConfig) GetLoadBalanceVmAttachments() bool {
	if m != nil && m.LoadBalanceVmAttachments != nil {
		return *m.LoadBalanceVmAttachments
	}
	return false
}

func (m *VolumeGroupConfig) GetSourceVgUuid() []byte {
	if m != nil {
		return m.SourceVgUuid
	}
	return nil
}

func (m *VolumeGroupConfig) GetCreatedBy() string {
	if m != nil && m.CreatedBy != nil {
		return *m.CreatedBy
	}
	return ""
}

func (m *VolumeGroupConfig) GetContainerUuids() [][]byte {
	if m != nil {
		return m.ContainerUuids
	}
	return nil
}

func (m *VolumeGroupConfig) GetNutanixNfsBasedVirtualDiskUuids() [][]byte {
	if m != nil {
		return m.NutanixNfsBasedVirtualDiskUuids
	}
	return nil
}

func (m *VolumeGroupConfig) GetStorageConfig() *StorageConfig {
	if m != nil {
		return m.StorageConfig
	}
	return nil
}

func (m *VolumeGroupConfig) GetCapacityBytes() int64 {
	if m != nil && m.CapacityBytes != nil {
		return *m.CapacityBytes
	}
	return 0
}

func (m *VolumeGroupConfig) GetClientUuids() [][]byte {
	if m != nil {
		return m.ClientUuids
	}
	return nil
}

// TODO: In next few months, shift this to the file where StoragePolicy
// proto will be defined.
type StorageConfig struct {
	// QoS parameters to be applied on the entity.
	QosConfig            *StorageConfig_QosConfig `protobuf:"bytes,1,opt,name=qos_config,json=qosConfig" json:"qos_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *StorageConfig) Reset()         { *m = StorageConfig{} }
func (m *StorageConfig) String() string { return proto.CompactTextString(m) }
func (*StorageConfig) ProtoMessage()    {}
func (*StorageConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e38abda08a0ae273, []int{3}
}

func (m *StorageConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageConfig.Unmarshal(m, b)
}
func (m *StorageConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageConfig.Marshal(b, m, deterministic)
}
func (m *StorageConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageConfig.Merge(m, src)
}
func (m *StorageConfig) XXX_Size() int {
	return xxx_messageInfo_StorageConfig.Size(m)
}
func (m *StorageConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StorageConfig proto.InternalMessageInfo

func (m *StorageConfig) GetQosConfig() *StorageConfig_QosConfig {
	if m != nil {
		return m.QosConfig
	}
	return nil
}

type StorageConfig_QosConfig struct {
	// Throttled iops setting for the entity being governed. In order to
	// reset this field, pass -1.
	ThrottledIops        *int64   `protobuf:"varint,1,opt,name=throttled_iops,json=throttledIops" json:"throttled_iops,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageConfig_QosConfig) Reset()         { *m = StorageConfig_QosConfig{} }
func (m *StorageConfig_QosConfig) String() string { return proto.CompactTextString(m) }
func (*StorageConfig_QosConfig) ProtoMessage()    {}
func (*StorageConfig_QosConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e38abda08a0ae273, []int{3, 0}
}

func (m *StorageConfig_QosConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageConfig_QosConfig.Unmarshal(m, b)
}
func (m *StorageConfig_QosConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageConfig_QosConfig.Marshal(b, m, deterministic)
}
func (m *StorageConfig_QosConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageConfig_QosConfig.Merge(m, src)
}
func (m *StorageConfig_QosConfig) XXX_Size() int {
	return xxx_messageInfo_StorageConfig_QosConfig.Size(m)
}
func (m *StorageConfig_QosConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageConfig_QosConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StorageConfig_QosConfig proto.InternalMessageInfo

func (m *StorageConfig_QosConfig) GetThrottledIops() int64 {
	if m != nil && m.ThrottledIops != nil {
		return *m.ThrottledIops
	}
	return 0
}

func init() {
	proto.RegisterEnum("nutanix.pithos.VolumeGroupConfig_FileSystemType", VolumeGroupConfig_FileSystemType_name, VolumeGroupConfig_FileSystemType_value)
	proto.RegisterType((*VolumeDiskConfig)(nil), "nutanix.pithos.VolumeDiskConfig")
	proto.RegisterType((*VolumeAttachment)(nil), "nutanix.pithos.VolumeAttachment")
	proto.RegisterType((*VolumeGroupConfig)(nil), "nutanix.pithos.VolumeGroupConfig")
	proto.RegisterType((*StorageConfig)(nil), "nutanix.pithos.StorageConfig")
	proto.RegisterType((*StorageConfig_QosConfig)(nil), "nutanix.pithos.StorageConfig.QosConfig")
}

func init() { proto.RegisterFile("pithos/volume_group.proto", fileDescriptor_e38abda08a0ae273) }

var fileDescriptor_e38abda08a0ae273 = []byte{
	// 1037 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xdb, 0x6e, 0x1b, 0x37,
	0x10, 0xed, 0x46, 0xbe, 0x48, 0xa3, 0x8b, 0x65, 0x26, 0xb1, 0x19, 0x37, 0x6e, 0x54, 0x23, 0x6d,
	0xd4, 0x02, 0x95, 0x5b, 0xb7, 0x28, 0x8a, 0x00, 0x45, 0x11, 0xdb, 0x71, 0xa1, 0xa2, 0x71, 0xd3,
	0x95, 0xed, 0x87, 0xbc, 0x10, 0xd4, 0x2e, 0x25, 0x11, 0xda, 0x25, 0x37, 0x24, 0xa5, 0x58, 0xf9,
	0x85, 0xfe, 0x42, 0x7f, 0xad, 0x5f, 0xd1, 0x1f, 0x28, 0x76, 0xb8, 0xba, 0x58, 0x0d, 0xf2, 0xa4,
	0xe5, 0x99, 0xc3, 0x21, 0xe7, 0xcc, 0xe1, 0x08, 0x1e, 0x65, 0xd2, 0x8d, 0xb4, 0x3d, 0x9e, 0xea,
	0x64, 0x92, 0x0a, 0x36, 0x34, 0x7a, 0x92, 0x75, 0x32, 0xa3, 0x9d, 0x26, 0x0d, 0x35, 0x71, 0x5c,
	0xc9, 0xdb, 0x8e, 0xa7, 0x1c, 0xdc, 0x2f, 0xa8, 0xfe, 0xc7, 0x93, 0x8e, 0xfe, 0xb9, 0x07, 0xcd,
	0x1b, 0xdc, 0x7b, 0x2e, 0xed, 0xf8, 0x4c, 0xab, 0x81, 0x1c, 0x92, 0x07, 0xb0, 0x29, 0x55, 0x2c,
	0x6e, 0x69, 0xd0, 0x0a, 0xda, 0xf5, 0xd0, 0x2f, 0xc8, 0x13, 0xa8, 0x4e, 0xd3, 0x58, 0xda, 0x31,
	0x9b, 0x4c, 0x64, 0x4c, 0xef, 0xb5, 0x82, 0x76, 0x2d, 0x04, 0x0f, 0x5d, 0x4f, 0x64, 0x4c, 0x3e,
	0x87, 0x5a, 0xa4, 0x95, 0xe3, 0x52, 0x09, 0xc3, 0x64, 0x4c, 0x4b, 0xad, 0xa0, 0x5d, 0x0a, 0xab,
	0x0b, 0xac, 0x1b, 0xaf, 0xe4, 0xb0, 0xf2, 0xbd, 0xa0, 0x1b, 0xc8, 0x28, 0x72, 0xf4, 0xe4, 0x7b,
	0x41, 0x7e, 0x81, 0xc7, 0xb1, 0x30, 0x72, 0x2a, 0x62, 0x36, 0x30, 0x3a, 0x65, 0xe2, 0x56, 0x5a,
	0x27, 0xd5, 0x90, 0x79, 0x0e, 0xdd, 0x6c, 0x05, 0xed, 0x72, 0xf8, 0xa8, 0xe0, 0x5c, 0x18, 0x9d,
	0xbe, 0x2c, 0x18, 0x37, 0x48, 0x20, 0x5f, 0xc2, 0x4e, 0x71, 0x82, 0x1a, 0x58, 0x96, 0x71, 0x37,
	0xa2, 0x5b, 0xad, 0xa0, 0x5d, 0x09, 0xeb, 0x1e, 0xbe, 0x1c, 0xd8, 0xd7, 0xdc, 0x8d, 0xc8, 0x21,
	0xc0, 0x20, 0xe1, 0x76, 0xc4, 0x52, 0x1d, 0x0b, 0xba, 0x8d, 0x69, 0x2b, 0x88, 0xbc, 0xd2, 0xb1,
	0xc8, 0xd3, 0xc4, 0xdc, 0x71, 0x66, 0xf5, 0xc4, 0x44, 0x82, 0x4d, 0x4c, 0x42, 0xcb, 0x3e, 0x4d,
	0x0e, 0xf7, 0x10, 0xbd, 0x36, 0x09, 0xf9, 0x0c, 0x80, 0x2b, 0xa5, 0x1d, 0x77, 0x52, 0x2b, 0x5a,
	0x41, 0xca, 0x0a, 0x72, 0xf4, 0xf7, 0x42, 0xdf, 0x17, 0xce, 0xf1, 0x68, 0x94, 0x0a, 0xe5, 0xc8,
	0x3e, 0x6c, 0x4f, 0x53, 0xaf, 0x62, 0x80, 0x2a, 0x6e, 0x4d, 0x53, 0x54, 0xf0, 0x47, 0xd8, 0x17,
	0xb7, 0x4e, 0x18, 0xc5, 0x13, 0x26, 0x95, 0x74, 0x92, 0x3b, 0x6d, 0x98, 0xe2, 0xa9, 0x40, 0xb9,
	0x2b, 0xe1, 0xc3, 0x79, 0xb8, 0x3b, 0x8f, 0x5e, 0xf2, 0x54, 0x90, 0x1e, 0xd4, 0x1d, 0x37, 0x43,
	0xe1, 0x58, 0xc6, 0x0d, 0x4f, 0x2d, 0x4a, 0x5f, 0x3d, 0xe9, 0x74, 0xee, 0x5a, 0xa0, 0xd3, 0xb5,
	0x91, 0x95, 0x67, 0x89, 0x14, 0xca, 0xbd, 0x46, 0x62, 0xe7, 0x0a, 0xb7, 0xf9, 0x45, 0x58, 0x73,
	0x2b, 0x2b, 0xf2, 0x02, 0x0e, 0x3f, 0x74, 0x19, 0xe1, 0xde, 0x69, 0x33, 0xce, 0xfb, 0xbb, 0x81,
	0x57, 0x3a, 0xf8, 0xff, 0x95, 0x3c, 0xc5, 0xb7, 0x3b, 0xc2, 0xd3, 0x7c, 0xb1, 0x9b, 0xde, 0x32,
	0x1e, 0xca, 0x0b, 0x3e, 0xfa, 0xb7, 0x0c, 0xbb, 0x5e, 0x9e, 0x5f, 0x73, 0xe7, 0x16, 0xfe, 0x23,
	0xb0, 0xb1, 0x22, 0x0e, 0x7e, 0xe7, 0xd8, 0x8a, 0x0e, 0xf8, 0xbd, 0x26, 0x7e, 0x69, 0x5d, 0x7c,
	0x72, 0x0c, 0xbb, 0x89, 0x1e, 0xca, 0x88, 0x27, 0xcc, 0xc9, 0x54, 0x58, 0xc7, 0xd3, 0xcc, 0x7b,
	0xee, 0xf9, 0xbd, 0x6f, 0xbe, 0x0b, 0x9b, 0x45, 0xf0, 0x6a, 0x1e, 0x23, 0x14, 0xb6, 0x63, 0x91,
	0x08, 0x27, 0xe2, 0xc2, 0x68, 0xf3, 0x25, 0xf9, 0x19, 0x2a, 0x68, 0xaa, 0x44, 0x5a, 0x47, 0xb7,
	0x5a, 0xa5, 0x76, 0xf5, 0xa4, 0xb5, 0xae, 0xee, 0xfa, 0x3b, 0x0a, 0xcb, 0xf9, 0x96, 0xdf, 0xa5,
	0x75, 0xe4, 0x6b, 0xd8, 0x95, 0xb9, 0xf6, 0xac, 0x68, 0x13, 0x96, 0xb2, 0x8d, 0x17, 0xde, 0xc1,
	0x80, 0xef, 0x03, 0x36, 0xb3, 0x0b, 0x3b, 0x7c, 0xe1, 0x15, 0x7f, 0x60, 0xf9, 0x63, 0x07, 0x2e,
	0x8d, 0x15, 0x36, 0x96, 0x1b, 0xf1, 0xd8, 0x3d, 0xd8, 0xb2, 0x23, 0x6e, 0x44, 0x8c, 0xce, 0x2c,
	0x87, 0xc5, 0x8a, 0x1c, 0x43, 0xd3, 0x17, 0xc6, 0xb4, 0x62, 0xb1, 0xc8, 0xf7, 0x50, 0xc8, 0x19,
	0xcf, 0x37, 0x07, 0x3c, 0xb1, 0x22, 0x6c, 0xf8, 0xf0, 0x1f, 0xea, 0x1c, 0x83, 0xe4, 0x7b, 0xd8,
	0x8b, 0xfa, 0x86, 0x29, 0xed, 0x58, 0xc4, 0x33, 0xde, 0x4f, 0x04, 0x33, 0x82, 0x5b, 0xad, 0x68,
	0x15, 0x8b, 0xb8, 0x1f, 0xf5, 0xcd, 0xa5, 0x76, 0x67, 0x3e, 0x16, 0x62, 0x68, 0xed, 0x89, 0xd5,
	0xd7, 0x9f, 0xd8, 0x4f, 0x40, 0x75, 0x7f, 0x30, 0xb1, 0x11, 0x77, 0x22, 0x9e, 0x0b, 0x63, 0x45,
	0x64, 0x84, 0xa3, 0x0d, 0xcc, 0xba, 0xb7, 0x8c, 0x7b, 0x7d, 0x7a, 0x18, 0x25, 0x6f, 0xa0, 0x39,
	0x90, 0x89, 0x60, 0x76, 0x66, 0x9d, 0x48, 0x99, 0x9b, 0x65, 0x82, 0xee, 0xb4, 0x82, 0x76, 0xe3,
	0xe4, 0xdb, 0x0f, 0x4b, 0xb4, 0x62, 0xae, 0xce, 0x85, 0x4c, 0x44, 0x0f, 0x37, 0x5e, 0xcd, 0x32,
	0x11, 0x36, 0x06, 0x77, 0xd6, 0xe4, 0x0b, 0x68, 0x48, 0x15, 0x71, 0xa3, 0xd0, 0x42, 0xb9, 0xcd,
	0x9b, 0xad, 0xa0, 0xbd, 0x11, 0xd6, 0x57, 0xd0, 0x6e, 0xee, 0x87, 0x4f, 0x13, 0xcd, 0x63, 0xd6,
	0xe7, 0x09, 0x57, 0x91, 0x60, 0xd3, 0x94, 0x2d, 0xb5, 0xb7, 0x74, 0x17, 0x8b, 0xa5, 0x39, 0xe5,
	0xd4, 0x33, 0x6e, 0xd2, 0x65, 0x9f, 0x2c, 0x79, 0x0a, 0x8d, 0x62, 0xb2, 0x4c, 0x87, 0xfe, 0x6d,
	0x10, 0xf4, 0x7a, 0xcd, 0xa3, 0x37, 0x43, 0x1c, 0x07, 0x87, 0x00, 0x91, 0x11, 0x28, 0x4f, 0x7f,
	0x46, 0xef, 0xa3, 0x26, 0x95, 0x02, 0x39, 0x9d, 0x91, 0x67, 0xb0, 0xb3, 0x9c, 0xb7, 0x79, 0x12,
	0x4b, 0x1f, 0xb4, 0x4a, 0xed, 0x5a, 0xd8, 0x58, 0xc0, 0x79, 0x1a, 0x4b, 0x5e, 0xc1, 0xd3, 0x42,
	0x16, 0x1c, 0x8a, 0x7d, 0x6e, 0x45, 0xcc, 0xa6, 0xd2, 0xb8, 0x09, 0x4f, 0xd8, 0x62, 0xa2, 0x5b,
	0xfa, 0x10, 0x77, 0x3f, 0x29, 0xb8, 0x97, 0x03, 0x7b, 0x9a, 0x33, 0x6f, 0x3c, 0xf1, 0xbc, 0x18,
	0xf3, 0x96, 0x9c, 0x43, 0xc3, 0x3a, 0x6d, 0xf8, 0x50, 0xb0, 0x08, 0x35, 0xa5, 0x7b, 0x38, 0x6e,
	0x0e, 0xd7, 0xc5, 0xef, 0x79, 0x56, 0xf1, 0x1a, 0xea, 0x76, 0x75, 0x99, 0x0b, 0x9d, 0x5b, 0x29,
	0x92, 0x6e, 0xc6, 0xfa, 0x33, 0x27, 0x2c, 0xdd, 0xc7, 0x7f, 0x83, 0xfa, 0x1c, 0x3d, 0xcd, 0x41,
	0xfc, 0x53, 0x59, 0x8e, 0x10, 0x4b, 0x29, 0xde, 0xb1, 0xba, 0x9c, 0x21, 0xf6, 0xe8, 0x2b, 0x68,
	0xdc, 0x6d, 0x2a, 0xa9, 0x41, 0x79, 0x7c, 0xad, 0xc6, 0x4a, 0xbf, 0x53, 0xcd, 0x4f, 0x48, 0x05,
	0x36, 0xc7, 0x2f, 0x6f, 0xdd, 0x0f, 0xcd, 0xe0, 0xb7, 0x8d, 0x72, 0xad, 0x59, 0x3f, 0xfa, 0x2b,
	0x80, 0xfa, 0x9d, 0xbb, 0x91, 0x0b, 0x80, 0xb7, 0xda, 0xce, 0xcb, 0x09, 0xb0, 0x9c, 0x67, 0x1f,
	0x2d, 0xa7, 0xf3, 0xa7, 0xb6, 0x45, 0x61, 0x95, 0xb7, 0xf3, 0xcf, 0x83, 0x13, 0xa8, 0x2c, 0xf0,
	0xbc, 0x42, 0x37, 0x32, 0xda, 0xb9, 0x44, 0xc4, 0x4c, 0xea, 0xcc, 0x62, 0xe2, 0x52, 0x58, 0x5f,
	0xa0, 0x5d, 0x9d, 0xd9, 0xd3, 0xc7, 0x40, 0x22, 0x9d, 0xae, 0x1d, 0xf6, 0x66, 0xcb, 0xff, 0xfe,
	0x17, 0x00, 0x00, 0xff, 0xff, 0x76, 0x93, 0x7f, 0xc8, 0xe1, 0x07, 0x00, 0x00,
}
