// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pithos/pithos.proto

package pithos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
	medusa "github.com/nutanix-core/acs-aos-go/medusa"
	stretch_params "github.com/nutanix-core/acs-aos-go/pithos/stretch_params"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The various versions that Pithos can be at.
type PithosVersionInformation_PithosVersion int32

const (
	// A version only to be used in tests.
	PithosVersionInformation_kTestOnly PithosVersionInformation_PithosVersion = 0
	// Initial version for Pithos. All clusters must start with this version by
	// default.
	PithosVersionInformation_kInitial PithosVersionInformation_PithosVersion = 1
	// chain_id added as a VDiskConfig key.
	PithosVersionInformation_kChainIdKey PithosVersionInformation_PithosVersion = 10
)

var PithosVersionInformation_PithosVersion_name = map[int32]string{
	0:  "kTestOnly",
	1:  "kInitial",
	10: "kChainIdKey",
}

var PithosVersionInformation_PithosVersion_value = map[string]int32{
	"kTestOnly":   0,
	"kInitial":    1,
	"kChainIdKey": 10,
}

func (x PithosVersionInformation_PithosVersion) Enum() *PithosVersionInformation_PithosVersion {
	p := new(PithosVersionInformation_PithosVersion)
	*p = x
	return p
}

func (x PithosVersionInformation_PithosVersion) String() string {
	return proto.EnumName(PithosVersionInformation_PithosVersion_name, int32(x))
}

func (x *PithosVersionInformation_PithosVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PithosVersionInformation_PithosVersion_value, data, "PithosVersionInformation_PithosVersion")
	if err != nil {
		return err
	}
	*x = PithosVersionInformation_PithosVersion(value)
	return nil
}

func (PithosVersionInformation_PithosVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{0, 0}
}

// The policy used for a transformation (such as dedup) applied on the data
// of a vdisk.
type VDiskConfig_TransformationPolicy int32

const (
	// Transformation is off.
	VDiskConfig_kOff VDiskConfig_TransformationPolicy = 0
	// Transformation is done inline.
	VDiskConfig_kInline VDiskConfig_TransformationPolicy = 1
	// Transformation is done in the background.
	VDiskConfig_kPostProcess VDiskConfig_TransformationPolicy = 2
)

var VDiskConfig_TransformationPolicy_name = map[int32]string{
	0: "kOff",
	1: "kInline",
	2: "kPostProcess",
}

var VDiskConfig_TransformationPolicy_value = map[string]int32{
	"kOff":         0,
	"kInline":      1,
	"kPostProcess": 2,
}

func (x VDiskConfig_TransformationPolicy) Enum() *VDiskConfig_TransformationPolicy {
	p := new(VDiskConfig_TransformationPolicy)
	*p = x
	return p
}

func (x VDiskConfig_TransformationPolicy) String() string {
	return proto.EnumName(VDiskConfig_TransformationPolicy_name, int32(x))
}

func (x *VDiskConfig_TransformationPolicy) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VDiskConfig_TransformationPolicy_value, data, "VDiskConfig_TransformationPolicy")
	if err != nil {
		return err
	}
	*x = VDiskConfig_TransformationPolicy(value)
	return nil
}

func (VDiskConfig_TransformationPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 0}
}

// The mutability state for the vdisk.
type VDiskConfig_MutabilityState int32

const (
	// A normal, mutable vdisk.
	VDiskConfig_kMutable VDiskConfig_MutabilityState = 0
	// The vdisk is immutable. An immutable vdisk will not accept any further
	// user writes.
	VDiskConfig_kImmutable VDiskConfig_MutabilityState = 1
	// Indicates that this vdisk was created as an immutable snapshot from
	// another vdisk. Note that a vdisk may be an immutable snapshot and
	// have 'parent_vdisk_id' be false since the curator may sever vdisk
	// hierarchy information once the snapshot has no dependency on its
	// parent's vdisk block map. An immutable snapshot cannot change its
	// mutability state.
	VDiskConfig_kImmutableSnapshot VDiskConfig_MutabilityState = 2
	// Indicates that this vdisk was created to shadow read requests for its
	// parent vdisk.
	//
	// The curator should perform copy blockmap operations for the vdisk,
	// however it should not sever the hierarchy between this vdisk and its
	// parent. This vdisk can be removed when its parent becomes unnamed or
	// marked for removal, even though this vdisk may be named.
	VDiskConfig_kImmutableShadow VDiskConfig_MutabilityState = 3
)

var VDiskConfig_MutabilityState_name = map[int32]string{
	0: "kMutable",
	1: "kImmutable",
	2: "kImmutableSnapshot",
	3: "kImmutableShadow",
}

var VDiskConfig_MutabilityState_value = map[string]int32{
	"kMutable":           0,
	"kImmutable":         1,
	"kImmutableSnapshot": 2,
	"kImmutableShadow":   3,
}

func (x VDiskConfig_MutabilityState) Enum() *VDiskConfig_MutabilityState {
	p := new(VDiskConfig_MutabilityState)
	*p = x
	return p
}

func (x VDiskConfig_MutabilityState) String() string {
	return proto.EnumName(VDiskConfig_MutabilityState_name, int32(x))
}

func (x *VDiskConfig_MutabilityState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VDiskConfig_MutabilityState_value, data, "VDiskConfig_MutabilityState")
	if err != nil {
		return err
	}
	*x = VDiskConfig_MutabilityState(value)
	return nil
}

func (VDiskConfig_MutabilityState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 1}
}

// Multipath protocol to use for accessing a vdisk that's exposed as an iSCSI
// logical unit.
type VDiskConfig_IscsiMultipathProtocol int32

const (
	// Asymmetric logical unit access.
	VDiskConfig_kAlua VDiskConfig_IscsiMultipathProtocol = 0
	// Microsoft Multipath IO.
	VDiskConfig_kMpio VDiskConfig_IscsiMultipathProtocol = 1
)

var VDiskConfig_IscsiMultipathProtocol_name = map[int32]string{
	0: "kAlua",
	1: "kMpio",
}

var VDiskConfig_IscsiMultipathProtocol_value = map[string]int32{
	"kAlua": 0,
	"kMpio": 1,
}

func (x VDiskConfig_IscsiMultipathProtocol) Enum() *VDiskConfig_IscsiMultipathProtocol {
	p := new(VDiskConfig_IscsiMultipathProtocol)
	*p = x
	return p
}

func (x VDiskConfig_IscsiMultipathProtocol) String() string {
	return proto.EnumName(VDiskConfig_IscsiMultipathProtocol_name, int32(x))
}

func (x *VDiskConfig_IscsiMultipathProtocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VDiskConfig_IscsiMultipathProtocol_value, data, "VDiskConfig_IscsiMultipathProtocol")
	if err != nil {
		return err
	}
	*x = VDiskConfig_IscsiMultipathProtocol(value)
	return nil
}

func (VDiskConfig_IscsiMultipathProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 2}
}

// The oplog type in use by this vdisk.
type VDiskConfig_OplogType int32

const (
	// Legacy vdisk oplog.
	VDiskConfig_kVDiskOplog VDiskConfig_OplogType = 0
	// Both legacy vdisk oplog and distributed oplog.
	VDiskConfig_kVDiskAndDistributedOplog VDiskConfig_OplogType = 1
	// Distributed oplog.
	VDiskConfig_kDistributedOplog VDiskConfig_OplogType = 2
)

var VDiskConfig_OplogType_name = map[int32]string{
	0: "kVDiskOplog",
	1: "kVDiskAndDistributedOplog",
	2: "kDistributedOplog",
}

var VDiskConfig_OplogType_value = map[string]int32{
	"kVDiskOplog":               0,
	"kVDiskAndDistributedOplog": 1,
	"kDistributedOplog":         2,
}

func (x VDiskConfig_OplogType) Enum() *VDiskConfig_OplogType {
	p := new(VDiskConfig_OplogType)
	*p = x
	return p
}

func (x VDiskConfig_OplogType) String() string {
	return proto.EnumName(VDiskConfig_OplogType_name, int32(x))
}

func (x *VDiskConfig_OplogType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VDiskConfig_OplogType_value, data, "VDiskConfig_OplogType")
	if err != nil {
		return err
	}
	*x = VDiskConfig_OplogType(value)
	return nil
}

func (VDiskConfig_OplogType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 3}
}

// IOHandlingMode describes how reads and writes destined to this VDisk
// will be processed. If this property is not set explicitly, writes to
// this VDisk will be absorbed locally by the AOS cluster like any other
// vdisk and reads will follow the default path for locally available data.
// If not, the data will be paged-in on-demand from the external data
// source to serve the reads.
// If the 'io_handling_mode' is not explicitly set, writes never leave the
// AOS cluster and hence, the external data source can be immutable.
type VDiskConfig_BackingExternalDiskConfig_IOHandlingMode int32

const (
	// In the kForward mode, all reads and writes will be forwarded to the
	// external data source. Because writes are forwarded too, the external
	// data source must accept writes.
	VDiskConfig_BackingExternalDiskConfig_kForward VDiskConfig_BackingExternalDiskConfig_IOHandlingMode = 0
)

var VDiskConfig_BackingExternalDiskConfig_IOHandlingMode_name = map[int32]string{
	0: "kForward",
}

var VDiskConfig_BackingExternalDiskConfig_IOHandlingMode_value = map[string]int32{
	"kForward": 0,
}

func (x VDiskConfig_BackingExternalDiskConfig_IOHandlingMode) Enum() *VDiskConfig_BackingExternalDiskConfig_IOHandlingMode {
	p := new(VDiskConfig_BackingExternalDiskConfig_IOHandlingMode)
	*p = x
	return p
}

func (x VDiskConfig_BackingExternalDiskConfig_IOHandlingMode) String() string {
	return proto.EnumName(VDiskConfig_BackingExternalDiskConfig_IOHandlingMode_name, int32(x))
}

func (x *VDiskConfig_BackingExternalDiskConfig_IOHandlingMode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VDiskConfig_BackingExternalDiskConfig_IOHandlingMode_value, data, "VDiskConfig_BackingExternalDiskConfig_IOHandlingMode")
	if err != nil {
		return err
	}
	*x = VDiskConfig_BackingExternalDiskConfig_IOHandlingMode(value)
	return nil
}

func (VDiskConfig_BackingExternalDiskConfig_IOHandlingMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 2, 0}
}

// Pithos version information. Stores information on what version the Pithos
// master is currently in and what version the cluster is consistent with.
// It is used for enabling upgrade functionality for Pithos.
type PithosVersionInformation struct {
	// Current version that the Pithos master is at. The Pithos master
	// is in-charge of udpating this field.
	PithosVersion *PithosVersionInformation_PithosVersion `protobuf:"varint,1,opt,name=pithos_version,json=pithosVersion,enum=nutanix.pithos.PithosVersionInformation_PithosVersion,def=1" json:"pithos_version,omitempty"`
	// The version that the Pithos backend is consistent with. If pithos_version
	// is different to the current_consistent_version then it implies that a
	// background task is necessary to update the backend.
	CurrentConsistentVersion *PithosVersionInformation_PithosVersion `protobuf:"varint,2,opt,name=current_consistent_version,json=currentConsistentVersion,enum=nutanix.pithos.PithosVersionInformation_PithosVersion,def=1" json:"current_consistent_version,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                                `json:"-"`
	XXX_unrecognized         []byte                                  `json:"-"`
	XXX_sizecache            int32                                   `json:"-"`
}

func (m *PithosVersionInformation) Reset()         { *m = PithosVersionInformation{} }
func (m *PithosVersionInformation) String() string { return proto.CompactTextString(m) }
func (*PithosVersionInformation) ProtoMessage()    {}
func (*PithosVersionInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{0}
}

func (m *PithosVersionInformation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PithosVersionInformation.Unmarshal(m, b)
}
func (m *PithosVersionInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PithosVersionInformation.Marshal(b, m, deterministic)
}
func (m *PithosVersionInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PithosVersionInformation.Merge(m, src)
}
func (m *PithosVersionInformation) XXX_Size() int {
	return xxx_messageInfo_PithosVersionInformation.Size(m)
}
func (m *PithosVersionInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_PithosVersionInformation.DiscardUnknown(m)
}

var xxx_messageInfo_PithosVersionInformation proto.InternalMessageInfo

const Default_PithosVersionInformation_PithosVersion PithosVersionInformation_PithosVersion = PithosVersionInformation_kInitial
const Default_PithosVersionInformation_CurrentConsistentVersion PithosVersionInformation_PithosVersion = PithosVersionInformation_kInitial

func (m *PithosVersionInformation) GetPithosVersion() PithosVersionInformation_PithosVersion {
	if m != nil && m.PithosVersion != nil {
		return *m.PithosVersion
	}
	return Default_PithosVersionInformation_PithosVersion
}

func (m *PithosVersionInformation) GetCurrentConsistentVersion() PithosVersionInformation_PithosVersion {
	if m != nil && m.CurrentConsistentVersion != nil {
		return *m.CurrentConsistentVersion
	}
	return Default_PithosVersionInformation_CurrentConsistentVersion
}

// A VDisk and its associated parameters. A VDisk may be explicitly created
// by an admin (e.g., as an iSCSI lun) or implicitly (e.g., as the backing
// store for an NFS file, or during DR based replication). A VDisk is never
// removed directly from the pithos config by any component other than the
// curator - all other components may only mark the vdisk for removal by
// setting the to_remove flag on the vdisk.
//
// The curator can also automatically set the to_remove flag on the vdisk
// automatically under the following conditions:
//   (1) The vdisk shouldn't have an iscsi target/lun associated with it.
//   (2) The vdisk should either not have a NFS name associated with it (i.e.,
//       something like "NFS:xxxx"), or else the vdisk shouldn't be referred
//       to from the NFS filesystem tree.
//   (3) The vdisk shouldn't be a parent of another vdisk.
//   (4) The vdisk_creator_loc inside the vdisk config shouldn't indicate an
//       active op operating on the vdisk.
//
// If the to_remove flag is set on the vdisk, the curator can begin deleting
// all the entries in the vdisk block map of that vdisk. However, the vdisk
// config should only be deleted from pithos once there are no extent groups
// left that are owned by the vdisk.
type VDiskConfig struct {
	// Globally unique id assigned to this vdisk.
	VdiskId *int64 `protobuf:"varint,1,req,name=vdisk_id,json=vdiskId" json:"vdisk_id,omitempty"`
	// An optional name assigned to this vdisk. Note that this name may change
	// over time (e.g., after taking a snapshot, this name may be assigned to
	// a vdisk with a different vdisk_id). Also, this name is a canonical or
	// fully qualified name (the name specified by the admin at the time of
	// vdisk creation may be prefixed with other stuff like the container name
	// to get the fully qualified vdisk name).
	VdiskName *string `protobuf:"bytes,2,opt,name=vdisk_name,json=vdiskName" json:"vdisk_name,omitempty"`
	// The parent of this vdisk. If any vDisk block is not available in the
	// metadata for this vdisk, it will be looked for in the parent's address
	// space. Parents are created during snapshots.
	ParentVdiskId *int64 `protobuf:"varint,3,opt,name=parent_vdisk_id,json=parentVdiskId" json:"parent_vdisk_id,omitempty"`
	// Size in bytes of the vdisk address space.
	VdiskSize *int64 `protobuf:"varint,4,req,name=vdisk_size,json=vdiskSize" json:"vdisk_size,omitempty"`
	// iSCSI target name and logical unit number for accessing this VDisk. Both
	// of these values are assigned together by the UI when a VDisk is created
	// and needs to be accessible through iSCSI. The admin doesn't need to
	// worry about setting these values. Some VDisks are not accessible through
	// iSCSI (e.g., the parent VDisk when a snapshot is taken), hence these
	// fields are optional.
	//
	// If a vdisk is assigned a name (i.e., vdisk_name is set), then it must
	// also have an iSCSI target name and logical unit number assigned to it.
	IscsiTargetName *string `protobuf:"bytes,5,opt,name=iscsi_target_name,json=iscsiTargetName" json:"iscsi_target_name,omitempty"`
	IscsiLun        *int32  `protobuf:"varint,6,opt,name=iscsi_lun,json=iscsiLun" json:"iscsi_lun,omitempty"`
	// Some vdisks are meant to be used only by VMFS. Many service VMs can
	// simultaneously receive requests for such a vDisk but will automatically
	// forward them (through NAT) to the service VM that actually hosts that
	// vDisk. Addition/deletion of such vdisks should only be done after
	// bringing down all stargate processes on all the service VMs.
	//
	// The following field, if set, implies that this vdisk is one that is
	// meant to be used by VMFS. The value of the field specifies the
	// IP:port where VMFS will send iSCSI requests meant for this vdisk.
	// The IP address should be on the subnet specified by internal_subnet.
	// The port can be randomly chosen. The stargate on each service VM will
	// set the iptables on that service VM so as to transparently forward all
	// requests received on the given vmfs_host_port to the iscsi target of a
	// remote service VM that is the leader for the corresponding vdisk.
	VmfsHostPort *string `protobuf:"bytes,7,opt,name=vmfs_host_port,json=vmfsHostPort" json:"vmfs_host_port,omitempty"`
	// The container id to which this vdisk belongs.
	ContainerId *int64 `protobuf:"varint,8,req,name=container_id,json=containerId" json:"container_id,omitempty"`
	// The configuration parameters on this vdisk.
	Params *VDiskConfig_Params `protobuf:"bytes,9,opt,name=params" json:"params,omitempty"`
	// If true, disables access to the VDisk. Whenever an admin wants to
	// temporarily disable access to a VDisk, this field is used.
	Disabled *bool `protobuf:"varint,10,opt,name=disabled,def=0" json:"disabled,omitempty"`
	// If true, this is an intent to remove the VDisk and all its data (after
	// the curator has had a chance to garbage collect the relevant
	// metadata). This field is only set for non-parent VDisks (i.e., VDisks
	// with a name). Others are garbage collected automatically by the curator
	// when none of their metadata is referred to by any other VDisk.
	ToRemove *bool `protobuf:"varint,11,opt,name=to_remove,json=toRemove" json:"to_remove,omitempty"`
	// Vdisk creation date and time, measured in micro seconds,
	// from midnight, January 1, 1970 UTC. (Set by UI).
	// This field is inherited from the parent vdisk and records the time when
	// the NFS file corresponding to this vdisk chain was first created. This
	// field is not updated when subsequent snapshots are taken of the NFS file.
	CreationTimeUsecs *int64                       `protobuf:"varint,12,opt,name=creation_time_usecs,json=creationTimeUsecs" json:"creation_time_usecs,omitempty"`
	MutabilityState   *VDiskConfig_MutabilityState `protobuf:"varint,13,opt,name=mutability_state,json=mutabilityState,enum=nutanix.pithos.VDiskConfig_MutabilityState,def=0" json:"mutability_state,omitempty"`
	// The vdisk's closest named, living ancestor vdisk. This field is only
	// applicable to vdisks that may have a parent, and therefore were
	// created as snapshots. If the ancestor named by this field is deleted,
	// then this vdisk's closest named ancestor should be updated to the
	// deleted vdisk's value. This field is unaffected by the curator severing
	// vdisk's parent-child relationships, and therefore the value may be set
	// even if ancestors traversed via 'parent_vdisk_id' are all unnamed.
	ClosestNamedAncestor *string `protobuf:"bytes,14,opt,name=closest_named_ancestor,json=closestNamedAncestor" json:"closest_named_ancestor,omitempty"`
	// The set of vzones that this vdisk is assigned to. The union of nodes
	// in those vzones is where this vdisk will be visible as an iSCSI target.
	// If this vdisk is not assigned to any vzone, then it'll be visible on
	// all nodes that are also not assigned to any vzone. If it is desired that
	// a vdisk not be visible on any node, then one can assign it to a vzone
	// that has no node mapped to it.
	VzoneName []string `protobuf:"bytes,15,rep,name=vzone_name,json=vzoneName" json:"vzone_name,omitempty"`
	// Hint to the curator to not copy the parent's vdisk blockmap metadata
	// to this vdisk in case this vdisk is a leaf. Example use is for the
	// snapshots created by cerebro - these snapshots will ultimately be
	// garbage collected and therefore avoiding vdisk blockmap copies from the
	// parent is prudent.
	AvoidVblockCopyWhenLeaf *bool `protobuf:"varint,16,opt,name=avoid_vblock_copy_when_leaf,json=avoidVblockCopyWhenLeaf" json:"avoid_vblock_copy_when_leaf,omitempty"`
	// The following, if used, has three entries corresponding to the logical
	// operation clock of the creating op. The 3 entries are (component_id,
	// incarnation_id, operation_id).
	//
	// This field is used to notify the curator to not mark this vdisk as
	// to_remove automatically and to not remove the vdisk from pithos as
	// an active op may be operating on it.
	VdiskCreatorLoc []int64 `protobuf:"varint,17,rep,name=vdisk_creator_loc,json=vdiskCreatorLoc" json:"vdisk_creator_loc,omitempty"`
	// If this vdisk corresponds to a file in the NFS namespace, the following
	// field may be set to indicate the corresponding file. It may not be
	// unique though (there might be multiple files with the same name in
	// the NFS namespace).
	NfsFileName *string `protobuf:"bytes,18,opt,name=nfs_file_name,json=nfsFileName" json:"nfs_file_name,omitempty"`
	// Whether the vdisk may be a parent vdisk to a snapshot. If true and this
	// vdisk is mutable, then the vdisk will be implicitly snapshotted on the
	// next write. This field may be true even if no current vdisks are a
	// descendant of this vdisk.
	//
	// This field is not inherited.
	MayBeParent *bool `protobuf:"varint,19,opt,name=may_be_parent,json=mayBeParent" json:"may_be_parent,omitempty"`
	// If this vdisk was constructed to be a replica of a remote vdisk, then the
	// following fields will be used to universally identify the location of the
	// source. At most one vdisk per cluster shall be created as a clone of an
	// originating vdisk, so the originating vdisk's
	// (cluster id, cluster incarnation, vdisk id) may be used as a globally
	// unique identifier for this vdisk.
	//
	// The cluster incarnation changes whenever a clean-data is done on a
	// cluster. The cluster id on the other hand typically remains the same.
	OriginatingClusterId            *int64 `protobuf:"varint,20,opt,name=originating_cluster_id,json=originatingClusterId" json:"originating_cluster_id,omitempty"`
	OriginatingClusterIncarnationId *int64 `protobuf:"varint,21,opt,name=originating_cluster_incarnation_id,json=originatingClusterIncarnationId" json:"originating_cluster_incarnation_id,omitempty"`
	OriginatingVdiskId              *int64 `protobuf:"varint,22,opt,name=originating_vdisk_id,json=originatingVdiskId" json:"originating_vdisk_id,omitempty"`
	// Whether vblock copies should be generated for this vdisk. Given a snapshot
	// tree, we choose certain vdisks to which vblocks from their parents are
	// copied by the curator and their parent links severed. These vdisks are
	// chosen with the following objectives.
	// (1) Avoid having the curator do vblock copies to every vdisk in the tree.
	// (2) Keep the vdisk chains small.
	//
	// This flag is set and used only by the curator. It helps remind the curator
	// that it needs to act on this vdisk across multiple scans.
	//
	// This field is not inherited.
	GenerateVblockCopy *bool `protobuf:"varint,23,opt,name=generate_vblock_copy,json=generateVblockCopy" json:"generate_vblock_copy,omitempty"`
	// Whether read requests for this vdisk should be redirected to the
	// associated shadow vdisks. If true, then this vdisk is presumed to be
	// biased for reads, such that internal snapshots can be created for the
	// vdisk across multiple nodes to serve the read requests.
	//
	// This field is not inherited.
	ShadowReadRequests *bool `protobuf:"varint,24,opt,name=shadow_read_requests,json=shadowReadRequests" json:"shadow_read_requests,omitempty"`
	// Whether Curator may coalesce vdisk block map regions while doing a
	// periodic scan.
	MayCoalesceBlockMap *bool `protobuf:"varint,26,opt,name=may_coalesce_block_map,json=mayCoalesceBlockMap" json:"may_coalesce_block_map,omitempty"`
	// This field is a hint about the parent vdisk's NFS file name from which
	// this vdisk was derived from as a result of the the snapshot operation.
	ParentNfsFileNameHint *string `protobuf:"bytes,27,opt,name=parent_nfs_file_name_hint,json=parentNfsFileNameHint" json:"parent_nfs_file_name_hint,omitempty"`
	// The new parent of this vdisk. This field is set by curator when
	// it is configured to collapse partial chains of dead snapshots
	// by the way of copy block tasks. After successful completion of
	// the copy block tasks, the parent_vdisk_id will be set to this value.
	//
	// This field is not inherited.
	ExpectedParentVdiskId *int64                           `protobuf:"varint,29,opt,name=expected_parent_vdisk_id,json=expectedParentVdiskId" json:"expected_parent_vdisk_id,omitempty"`
	ExternalVdiskConfig   *VDiskConfig_ExternalVDiskConfig `protobuf:"bytes,30,opt,name=external_vdisk_config,json=externalVdiskConfig" json:"external_vdisk_config,omitempty"`
	// If set, this is the id of the external vdisk that this snapshot vdisk is
	// associated with. If not set, we might still have an external vdisk
	// asociated with this vdisk, but we crashed before we could set this.
	ExternalVdiskId *int64 `protobuf:"varint,31,opt,name=external_vdisk_id,json=externalVdiskId" json:"external_vdisk_id,omitempty"`
	// If this vdisk is stretched, then this will be set to contain the id of the
	// stretch parameters entry that it adheres to, and one or more of the
	// following 'stretch_*' fields may be set.
	StretchParamsId *stretch_params.StretchParams_UniversalId `protobuf:"bytes,25,opt,name=stretch_params_id,json=stretchParamsId" json:"stretch_params_id,omitempty"`
	// If this vdisk is stretched and is on a secondary site, then this contains
	// the name of the corresponding vdisk on the primary site for which it's
	// stretched. This name, in conjunction with the stretch parameters id, can
	// be used to map a remote primary vdisk's requests to the vdisk on the
	// secondary site that should handle the request. At most one vdisk per
	// cluster will be created with the provided stretch vdisk name and stretch
	// parameters id pair.
	StretchVdiskName *string `protobuf:"bytes,28,opt,name=stretch_vdisk_name,json=stretchVdiskName" json:"stretch_vdisk_name,omitempty"`
	// If this vdisk was created as a snapshot initiated for stretched protection
	// domain resynchronization purposes, this contains the name of the vdisk
	// for which the snapshot was generated for.
	//
	// In other words, this field will be set for vdisks that exist in the
	// /.snapshot directory, and will contain the name of the live vdisk that
	// they were snapshotted for. For example, if file /data has vdisk with name
	// "NFS:123", then the file /.snapshot/.../data will set its vdisk's
	// reference vdisk name to "NFS:123". Later, when the snapshot is replicated
	// to the secondary site(s), this will serve to link the generated live vdisk
	// to the vdisk on the primary for which it's stretched.
	StretchReferenceVdiskName *string `protobuf:"bytes,32,opt,name=stretch_reference_vdisk_name,json=stretchReferenceVdiskName" json:"stretch_reference_vdisk_name,omitempty"`
	// During stretched protection domain resynchronization with a secondary
	// site, this will be set on all secondary shell files with the originating
	// ids of the corresponding snapshot files on the primary. This will be used
	// to map the secondary's shell vdisk to the base snapshot vdisk that was
	// replicated to the remote site.
	//
	// After the protection domain has been fully resynchronized, this field may
	// be cleared.
	StretchLinkVdiskId *stretch_params.StretchParams_UniversalId `protobuf:"bytes,33,opt,name=stretch_link_vdisk_id,json=stretchLinkVdiskId" json:"stretch_link_vdisk_id,omitempty"`
	// If true, the vdisk is not allowed to be hosted.
	DisallowHosting *bool `protobuf:"varint,34,opt,name=disallow_hosting,json=disallowHosting,def=0" json:"disallow_hosting,omitempty"`
	// The following is used to indicate whether the vdisk is a shell vdisk.
	// A shell vdisk is created on the replication target when an extent with
	// an owner vdisk is received, for which there is no entry in pithos.
	ShellVdisk             *bool                               `protobuf:"varint,35,opt,name=shell_vdisk,json=shellVdisk,def=0" json:"shell_vdisk,omitempty"`
	IscsiMultipathProtocol *VDiskConfig_IscsiMultipathProtocol `protobuf:"varint,37,opt,name=iscsi_multipath_protocol,json=iscsiMultipathProtocol,enum=nutanix.pithos.VDiskConfig_IscsiMultipathProtocol,def=0" json:"iscsi_multipath_protocol,omitempty"`
	// This id is used to uniquely identify snapshot chain of a Vdisk.
	// A new chain_id will be assigned to a new standalone Vdisk as
	// well as to a cloned Vdisk whereas all snapshots (direct and descendants)
	// of a Vdisk will inherit the same chain_id.
	ChainId []byte `protobuf:"bytes,38,opt,name=chain_id,json=chainId" json:"chain_id,omitempty"`
	// Parent chain id. The chain_id of the source Vdisk from which a given
	// Vdisk is cloned.
	ParentChainId []byte `protobuf:"bytes,39,opt,name=parent_chain_id,json=parentChainId" json:"parent_chain_id,omitempty"`
	// Vdisk uuid.
	VdiskUuid []byte `protobuf:"bytes,40,opt,name=vdisk_uuid,json=vdiskUuid" json:"vdisk_uuid,omitempty"`
	// For every SCSI vdisk, OS inquires for the disk identifier using standard
	// SCSI protocol. The SCSI serial number is the disk identifier reported to
	// the OS during such inquiry.
	// If the following field is set, then its value will be reported to the OS
	// during SCSI inquiry. Otherwise, a new globally unique serial number will
	// be generated and provided to the OS.
	ScsiSerialNumber *string `protobuf:"bytes,41,opt,name=scsi_serial_number,json=scsiSerialNumber" json:"scsi_serial_number,omitempty"`
	// If set to true, then the chain_id assigned to this Vdisk may change
	// overtime.
	TentativeChainId *bool `protobuf:"varint,42,opt,name=tentative_chain_id,json=tentativeChainId,def=0" json:"tentative_chain_id,omitempty"`
	// For every SCSI vdisk, OS inquires for the SCSI disk name identifier.
	// The SCSI name string is one of the identifiers returned to the OS. If the
	// following field is set, then this is the value reported to the initiator.
	// Otherwise a new name should be generated.
	ScsiNameIdentifier *string `protobuf:"bytes,43,opt,name=scsi_name_identifier,json=scsiNameIdentifier" json:"scsi_name_identifier,omitempty"`
	// If true, indicates that the vdisk has never been hosted before.
	NeverHosted *bool `protobuf:"varint,44,opt,name=never_hosted,json=neverHosted,def=0" json:"never_hosted,omitempty"`
	// If the vdisk belongs to a near-sync CG, then the following specifies the
	// CG's id.
	CgId *medusa.ConsistencyGroupIdProto `protobuf:"bytes,45,opt,name=cg_id,json=cgId" json:"cg_id,omitempty"`
	// If true, this vdisk is draining its oplog. All of the descendants of this
	// vdisk (if any) will have snapshot_draining=false and parent_draining=true.
	// This flag will be false for vdisks that are not part of an oplog-sharing
	// chain. If snapshot_draining=true, then parent_draining=false.
	SnapshotDraining *bool `protobuf:"varint,46,opt,name=snapshot_draining,json=snapshotDraining" json:"snapshot_draining,omitempty"`
	// If true, this is the descendant of a read-only parent snapshot with a
	// dirty oplog that still needs to be drained. This child won't drain until
	// the closest ancestor parent with a dirty oplog has drained. This flag
	// will be false for vdisks that are not part of an oplog-sharing chain.
	// If parent_draining=true, then snapshot_draining=false;
	//
	// Time t0:
	// A(ro; dirty oplog; SD) <- B(ro; dirty oplog; PD) <- C(rw; dirty oplog; PD)
	//
	// Time t1 (A has drained and B starts draining):
	// A(ro) <- B(ro; dirty oplog; SD) <- C(rw; dirty oplog; PD)
	//
	// Time t2 (B had drained and C has no descendants):
	// A(ro) <- B(ro) <- C(rw; dirty oplog; SD)
	// (SD isn't cleared on C since there is no map to descendants. This is ok.)
	//
	// Time t3 (sometime in the future, C completely drains its oplog and clears
	// SD). This step is optional.
	// A(ro) <- B(ro) <- C(rw)
	//
	// Time t4alt1 (another snapshot is taken with a dirty oplog):
	// A(ro) <- B(ro) <- C(ro; dirty oplog; SD) <- D(rw, dirty oplog; PD)
	//
	// Time t4alt2 (another snapshot is taken with a clean oplog):
	// A(ro) <- B(ro) <- C(ro) <- D(rw)
	ParentDraining *bool `protobuf:"varint,47,opt,name=parent_draining,json=parentDraining" json:"parent_draining,omitempty"`
	// If true, this is a clone of a draining oplog-sharing chain. This flag
	// will be set when the clone is created, and will be cleared when
	// parent_draining is cleared.
	CloneParentDraining *bool `protobuf:"varint,48,opt,name=clone_parent_draining,json=cloneParentDraining" json:"clone_parent_draining,omitempty"`
	// This field identifies vdisks that belong to the same snapshot chain. It
	// comes from the same namespace as vdisk_id. It is shared only among a
	// linear chain of vdisks. No two siblings can have the same
	// snapshot_chain_id.
	// Note that this field may diverge from how chain_id is assigned. It is
	// possible that two sibling vdisks have the same chain_id.
	SnapshotChainId *int64 `protobuf:"varint,49,opt,name=snapshot_chain_id,json=snapshotChainId,def=-1" json:"snapshot_chain_id,omitempty"`
	// The near sync session's root vdisk id. This field is set if and only if
	// 'cg_id' is set and refers to the vdisk at which the file was added to
	// 'cg_id'.
	// TODO (Mayur): Should pithos support lookup by 'near_sync_session_id'?
	NearSyncSessionRootVdiskId *int64 `protobuf:"varint,50,opt,name=near_sync_session_root_vdisk_id,json=nearSyncSessionRootVdiskId,def=-1" json:"near_sync_session_root_vdisk_id,omitempty"`
	// This field only applies to immutable vdisks created through snapshot
	// process. If set to true, then there is no pending/on-going data being
	// written into the vdisk.
	HasCompleteData *bool `protobuf:"varint,51,opt,name=has_complete_data,json=hasCompleteData" json:"has_complete_data,omitempty"`
	// This field is set for individual vdisks when they become immutable in
	// order to uniquely identify their content across clusters. This UUID will
	// be propagated to remote sites when this vdisk is replicated. Vdisks
	// with the same snapshot UUID are considered to have logically equivalent
	// content. Note that this vdisk snapshot UUID is different from 'vdisk_uuid'
	// also defined in this proto in the following way:
	// 1. This UUID is only set for immutable vdisks while 'vdisk_uuid' is
	//    set for all vdisks.
	// The reasons for introducing this field instead of using 'vdisk_uuid' or
	// a tuple of ('originating_cluster_id',
	// 'originating_cluster_incarnation_id', 'originating_vdisk_id') to uniquely
	// identify vdisks are the following:
	// 1. Using the tuple is problematic in stretch scenarios because stretch
	//    does not have this mapping. Even after we create this mapping for
	//    stretch, we still face the problem that the content of vdisks are
	//    not physically equivalent. Hence, the same tuple does not imply the
	//    on-disk content of vdisks are the same. Finally, even if we have a
	//    way to identify that on-disk content is not physically equivalent,
	//    we will have trouble creating extents on replication target.
	//    In that case, the extents probably already exist on replication
	//    target due to previous replications but are not physically equivalent
	//    on disk. The mapping created by the tuple prevents new extents from
	//    being created.
	// 2. Using 'vdisk_uuid' becomes problematic when we do a reverse replication
	//    to a different container than the vdisk originally resided. In this
	//    approach, we stamp a vdisk replicated to the remote site with the same
	//    'vdisk_uuid' as the source. In a reverse replication to a different
	//    container, there will be a collision of 'vdisk_uuid' on source site due
	//    to the same vdisks in different containers.
	VdiskSnapshotUuid []byte `protobuf:"bytes,52,opt,name=vdisk_snapshot_uuid,json=vdiskSnapshotUuid" json:"vdisk_snapshot_uuid,omitempty"`
	// This field is set for cloned vdisks and their corresponding snapshot
	// vdisks. It indicates the vdisk id of the vdisk where the clone
	// originated from. The vdisk represented by this field may have been
	// deleted at a later stage.
	CloneSourceVdiskId *int64 `protobuf:"varint,53,opt,name=clone_source_vdisk_id,json=cloneSourceVdiskId" json:"clone_source_vdisk_id,omitempty"`
	// During CopyBlockmapMetadata operations to severe long snapshot vdisk
	// chains, we copy vdisk blockmaps from ancestors to selected descendants
	// in the vdisks chain. As the size of vdisks increase, this would lead to
	// signficant increase in the number of vdisk blocks we are copying down
	// in the vdisk chain.
	// Hence, to reduce excessive and unnecessary vblock copies, we use an
	// approach to intelligently copying (arguably less number of) vblocks from
	// descendants to ancestors in case of removable chains.
	// This field will be set to true when we are copying inherited vdisk blocks
	// to the expected parent instead of the CB candidate itself.
	CopyUpVblockMetadata *bool `protobuf:"varint,54,opt,name=copy_up_vblock_metadata,json=copyUpVblockMetadata,def=0" json:"copy_up_vblock_metadata,omitempty"`
	// If set, represents the distributed oplog instance that houses data
	// records for the vdisk.
	DataLogId *int64 `protobuf:"varint,55,opt,name=data_log_id,json=dataLogId" json:"data_log_id,omitempty"`
	// If set, represents the distributed oplog instance that houses flush
	// records for the vdisk.
	FlushLogId *int64 `protobuf:"varint,56,opt,name=flush_log_id,json=flushLogId" json:"flush_log_id,omitempty"`
	// This field is set when a vdisk is snapshotted. It indicates the time when
	// this vdisk could potentially expire.
	TimeToLiveUsecsHint *int64 `protobuf:"varint,57,opt,name=time_to_live_usecs_hint,json=timeToLiveUsecsHint" json:"time_to_live_usecs_hint,omitempty"`
	// This field is set when the vdisk is snapshotted and a live vdisk is
	// created. It indicates the time when the live vdisk could potentially get
	// snapshotted.
	NextSnapshotTimeUsecsHint *int64                                 `protobuf:"varint,58,opt,name=next_snapshot_time_usecs_hint,json=nextSnapshotTimeUsecsHint" json:"next_snapshot_time_usecs_hint,omitempty"`
	BackingExternalDiskConfig *VDiskConfig_BackingExternalDiskConfig `protobuf:"bytes,59,opt,name=backing_external_disk_config,json=backingExternalDiskConfig" json:"backing_external_disk_config,omitempty"`
	// Vdisk creation date and time, measured in micro seconds,
	// from midnight, January 1, 1970 UTC. This is set when the vdisk is
	// created. Unlike 'creation_time_usecs' this field is not inherited from
	// the parent vdisk.
	VdiskCreationTimeUsecs *int64 `protobuf:"varint,60,opt,name=vdisk_creation_time_usecs,json=vdiskCreationTimeUsecs" json:"vdisk_creation_time_usecs,omitempty"`
	// State of fencing applied to this vdisk. If true, then all requests are
	// blocked for this vdisk. As soon as a vdisk is fenced by the iSCSI adapter,
	// all active connections to the target, lun (backed by the vdisk) are
	// closed and all new requests are not serviced. This property is only
	// applicable to iSCSI based vdisks whose 'iscsi_target_name' is specified
	// above.
	IsFenced *bool `protobuf:"varint,61,opt,name=is_fenced,json=isFenced" json:"is_fenced,omitempty"`
	// If true, this vdisk backs a file that is in recycle bin. This will
	// always be the leaf vdisk in a snapshot chain.
	InRecycleBin *bool `protobuf:"varint,62,opt,name=in_recycle_bin,json=inRecycleBin,def=0" json:"in_recycle_bin,omitempty"`
	// This field is required for IDF-based vdisk reference resolution in order
	// to compute the time distance. Time distance is used to arrange the vdisks
	// in order those can potentially act as reference for the given source
	// vdisk. This indicates the snapshot time of the vdisk in the parent chain
	// from which the current clone was created. Vdisk in parent chain is known
	// as originating vdisk for the child chain and its snapshot time is known as
	// originating vdisk snapshot time (OVST). More details about this:
	// 1. This field will be inherited by each vdisk in the child chain.
	// 2. Since this is stored in the pithos, it will also be available for
	//    non-cerebro driven snapshot.
	// 3. It handle the race condition where originating vdisk is deleted before
	//    publishing the chain config to the IDF.
	// 4. It avoids unnecessary vdisk traversal in the child chain to figure out
	//    the OVST.
	OriginatingVdiskSnapshotTimeUsecs *int64 `protobuf:"varint,63,opt,name=originating_vdisk_snapshot_time_usecs,json=originatingVdiskSnapshotTimeUsecs" json:"originating_vdisk_snapshot_time_usecs,omitempty"`
	// Whether this vdisk is a root of removable subtree.
	RootOfRemovableSubtree *bool `protobuf:"varint,64,opt,name=root_of_removable_subtree,json=rootOfRemovableSubtree,def=0" json:"root_of_removable_subtree,omitempty"`
	// The oplog type is used to determine which oplog type to instantiate for
	// this vdisk. With the common store feature enabled, we need to be able to
	// tell whether a vdisk has data present in legacy vdisk oplog, the newer
	// distributed oplog created for common store or both for upgrade purposes.
	OplogType *VDiskConfig_OplogType `protobuf:"varint,65,opt,name=oplog_type,json=oplogType,enum=nutanix.pithos.VDiskConfig_OplogType,def=0" json:"oplog_type,omitempty"`
	// Vdisk snapshot date and time, measured in micro seconds, from midnight,
	// January 1, 1970 UTC. This is set when the vdisk is snapshotted. This is
	// used to populate the 'originating_vdisk_snapshot_time_usecs' for the
	// vdisks in the child chain for which this vdisk acts as originating vdisk.
	VdiskSnapshotTimeUsecs *int64 `protobuf:"varint,66,opt,name=vdisk_snapshot_time_usecs,json=vdiskSnapshotTimeUsecs" json:"vdisk_snapshot_time_usecs,omitempty"`
	// Vdisk lineage identifier. Whenever a vdisk is created in the storage
	// subsystem, a location agnostic lineage id will be assigned to it and it
	// will be inherited by the child vdisk after snapshot or clone creation.
	// This is used to serialize the very first disk recovery point creation in a
	// lineage on the target during async replication, subsequent disk recovery
	// point creation in the same lineage doesn't need to be serialized. Primary
	// use case for this is to support multi-clone (VDI clone) replication in
	// parallel. If all of these clones are replicated in parallel to the target
	// then one of them should do the baseline transfer while others should hold
	// the reference on the disk recovery point already created in the same
	// lineage.
	LineageId []byte `protobuf:"bytes,67,opt,name=lineage_id,json=lineageId" json:"lineage_id,omitempty"`
	// The Pithos version at which this VDiskConfig was last updated in.
	LastUpdatedPithosVersion *PithosVersionInformation_PithosVersion `protobuf:"varint,68,opt,name=last_updated_pithos_version,json=lastUpdatedPithosVersion,enum=nutanix.pithos.PithosVersionInformation_PithosVersion,def=1" json:"last_updated_pithos_version,omitempty"`
	// Name of the mirror vDisk during cross container vDisk migration.
	MirrorVdiskName *string `protobuf:"bytes,69,opt,name=mirror_vdisk_name,json=mirrorVdiskName" json:"mirror_vdisk_name,omitempty"`
	// If true, indicates that the vdisk has an ancestor which is still not
	// complete (still seeding). This should only be cleared once all ancestors
	// are complete.
	HasIncompleteAncestor *bool    `protobuf:"varint,70,opt,name=has_incomplete_ancestor,json=hasIncompleteAncestor" json:"has_incomplete_ancestor,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *VDiskConfig) Reset()         { *m = VDiskConfig{} }
func (m *VDiskConfig) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig) ProtoMessage()    {}
func (*VDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1}
}

func (m *VDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig.Unmarshal(m, b)
}
func (m *VDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig.Marshal(b, m, deterministic)
}
func (m *VDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig.Merge(m, src)
}
func (m *VDiskConfig) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig.Size(m)
}
func (m *VDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig proto.InternalMessageInfo

const Default_VDiskConfig_Disabled bool = false
const Default_VDiskConfig_MutabilityState VDiskConfig_MutabilityState = VDiskConfig_kMutable
const Default_VDiskConfig_DisallowHosting bool = false
const Default_VDiskConfig_ShellVdisk bool = false
const Default_VDiskConfig_IscsiMultipathProtocol VDiskConfig_IscsiMultipathProtocol = VDiskConfig_kAlua
const Default_VDiskConfig_TentativeChainId bool = false
const Default_VDiskConfig_NeverHosted bool = false
const Default_VDiskConfig_SnapshotChainId int64 = -1
const Default_VDiskConfig_NearSyncSessionRootVdiskId int64 = -1
const Default_VDiskConfig_CopyUpVblockMetadata bool = false
const Default_VDiskConfig_InRecycleBin bool = false
const Default_VDiskConfig_RootOfRemovableSubtree bool = false
const Default_VDiskConfig_OplogType VDiskConfig_OplogType = VDiskConfig_kVDiskOplog
const Default_VDiskConfig_LastUpdatedPithosVersion PithosVersionInformation_PithosVersion = PithosVersionInformation_kInitial

func (m *VDiskConfig) GetVdiskId() int64 {
	if m != nil && m.VdiskId != nil {
		return *m.VdiskId
	}
	return 0
}

func (m *VDiskConfig) GetVdiskName() string {
	if m != nil && m.VdiskName != nil {
		return *m.VdiskName
	}
	return ""
}

func (m *VDiskConfig) GetParentVdiskId() int64 {
	if m != nil && m.ParentVdiskId != nil {
		return *m.ParentVdiskId
	}
	return 0
}

func (m *VDiskConfig) GetVdiskSize() int64 {
	if m != nil && m.VdiskSize != nil {
		return *m.VdiskSize
	}
	return 0
}

func (m *VDiskConfig) GetIscsiTargetName() string {
	if m != nil && m.IscsiTargetName != nil {
		return *m.IscsiTargetName
	}
	return ""
}

func (m *VDiskConfig) GetIscsiLun() int32 {
	if m != nil && m.IscsiLun != nil {
		return *m.IscsiLun
	}
	return 0
}

func (m *VDiskConfig) GetVmfsHostPort() string {
	if m != nil && m.VmfsHostPort != nil {
		return *m.VmfsHostPort
	}
	return ""
}

func (m *VDiskConfig) GetContainerId() int64 {
	if m != nil && m.ContainerId != nil {
		return *m.ContainerId
	}
	return 0
}

func (m *VDiskConfig) GetParams() *VDiskConfig_Params {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *VDiskConfig) GetDisabled() bool {
	if m != nil && m.Disabled != nil {
		return *m.Disabled
	}
	return Default_VDiskConfig_Disabled
}

func (m *VDiskConfig) GetToRemove() bool {
	if m != nil && m.ToRemove != nil {
		return *m.ToRemove
	}
	return false
}

func (m *VDiskConfig) GetCreationTimeUsecs() int64 {
	if m != nil && m.CreationTimeUsecs != nil {
		return *m.CreationTimeUsecs
	}
	return 0
}

func (m *VDiskConfig) GetMutabilityState() VDiskConfig_MutabilityState {
	if m != nil && m.MutabilityState != nil {
		return *m.MutabilityState
	}
	return Default_VDiskConfig_MutabilityState
}

func (m *VDiskConfig) GetClosestNamedAncestor() string {
	if m != nil && m.ClosestNamedAncestor != nil {
		return *m.ClosestNamedAncestor
	}
	return ""
}

func (m *VDiskConfig) GetVzoneName() []string {
	if m != nil {
		return m.VzoneName
	}
	return nil
}

func (m *VDiskConfig) GetAvoidVblockCopyWhenLeaf() bool {
	if m != nil && m.AvoidVblockCopyWhenLeaf != nil {
		return *m.AvoidVblockCopyWhenLeaf
	}
	return false
}

func (m *VDiskConfig) GetVdiskCreatorLoc() []int64 {
	if m != nil {
		return m.VdiskCreatorLoc
	}
	return nil
}

func (m *VDiskConfig) GetNfsFileName() string {
	if m != nil && m.NfsFileName != nil {
		return *m.NfsFileName
	}
	return ""
}

func (m *VDiskConfig) GetMayBeParent() bool {
	if m != nil && m.MayBeParent != nil {
		return *m.MayBeParent
	}
	return false
}

func (m *VDiskConfig) GetOriginatingClusterId() int64 {
	if m != nil && m.OriginatingClusterId != nil {
		return *m.OriginatingClusterId
	}
	return 0
}

func (m *VDiskConfig) GetOriginatingClusterIncarnationId() int64 {
	if m != nil && m.OriginatingClusterIncarnationId != nil {
		return *m.OriginatingClusterIncarnationId
	}
	return 0
}

func (m *VDiskConfig) GetOriginatingVdiskId() int64 {
	if m != nil && m.OriginatingVdiskId != nil {
		return *m.OriginatingVdiskId
	}
	return 0
}

func (m *VDiskConfig) GetGenerateVblockCopy() bool {
	if m != nil && m.GenerateVblockCopy != nil {
		return *m.GenerateVblockCopy
	}
	return false
}

func (m *VDiskConfig) GetShadowReadRequests() bool {
	if m != nil && m.ShadowReadRequests != nil {
		return *m.ShadowReadRequests
	}
	return false
}

func (m *VDiskConfig) GetMayCoalesceBlockMap() bool {
	if m != nil && m.MayCoalesceBlockMap != nil {
		return *m.MayCoalesceBlockMap
	}
	return false
}

func (m *VDiskConfig) GetParentNfsFileNameHint() string {
	if m != nil && m.ParentNfsFileNameHint != nil {
		return *m.ParentNfsFileNameHint
	}
	return ""
}

func (m *VDiskConfig) GetExpectedParentVdiskId() int64 {
	if m != nil && m.ExpectedParentVdiskId != nil {
		return *m.ExpectedParentVdiskId
	}
	return 0
}

func (m *VDiskConfig) GetExternalVdiskConfig() *VDiskConfig_ExternalVDiskConfig {
	if m != nil {
		return m.ExternalVdiskConfig
	}
	return nil
}

func (m *VDiskConfig) GetExternalVdiskId() int64 {
	if m != nil && m.ExternalVdiskId != nil {
		return *m.ExternalVdiskId
	}
	return 0
}

func (m *VDiskConfig) GetStretchParamsId() *stretch_params.StretchParams_UniversalId {
	if m != nil {
		return m.StretchParamsId
	}
	return nil
}

func (m *VDiskConfig) GetStretchVdiskName() string {
	if m != nil && m.StretchVdiskName != nil {
		return *m.StretchVdiskName
	}
	return ""
}

func (m *VDiskConfig) GetStretchReferenceVdiskName() string {
	if m != nil && m.StretchReferenceVdiskName != nil {
		return *m.StretchReferenceVdiskName
	}
	return ""
}

func (m *VDiskConfig) GetStretchLinkVdiskId() *stretch_params.StretchParams_UniversalId {
	if m != nil {
		return m.StretchLinkVdiskId
	}
	return nil
}

func (m *VDiskConfig) GetDisallowHosting() bool {
	if m != nil && m.DisallowHosting != nil {
		return *m.DisallowHosting
	}
	return Default_VDiskConfig_DisallowHosting
}

func (m *VDiskConfig) GetShellVdisk() bool {
	if m != nil && m.ShellVdisk != nil {
		return *m.ShellVdisk
	}
	return Default_VDiskConfig_ShellVdisk
}

func (m *VDiskConfig) GetIscsiMultipathProtocol() VDiskConfig_IscsiMultipathProtocol {
	if m != nil && m.IscsiMultipathProtocol != nil {
		return *m.IscsiMultipathProtocol
	}
	return Default_VDiskConfig_IscsiMultipathProtocol
}

func (m *VDiskConfig) GetChainId() []byte {
	if m != nil {
		return m.ChainId
	}
	return nil
}

func (m *VDiskConfig) GetParentChainId() []byte {
	if m != nil {
		return m.ParentChainId
	}
	return nil
}

func (m *VDiskConfig) GetVdiskUuid() []byte {
	if m != nil {
		return m.VdiskUuid
	}
	return nil
}

func (m *VDiskConfig) GetScsiSerialNumber() string {
	if m != nil && m.ScsiSerialNumber != nil {
		return *m.ScsiSerialNumber
	}
	return ""
}

func (m *VDiskConfig) GetTentativeChainId() bool {
	if m != nil && m.TentativeChainId != nil {
		return *m.TentativeChainId
	}
	return Default_VDiskConfig_TentativeChainId
}

func (m *VDiskConfig) GetScsiNameIdentifier() string {
	if m != nil && m.ScsiNameIdentifier != nil {
		return *m.ScsiNameIdentifier
	}
	return ""
}

func (m *VDiskConfig) GetNeverHosted() bool {
	if m != nil && m.NeverHosted != nil {
		return *m.NeverHosted
	}
	return Default_VDiskConfig_NeverHosted
}

func (m *VDiskConfig) GetCgId() *medusa.ConsistencyGroupIdProto {
	if m != nil {
		return m.CgId
	}
	return nil
}

func (m *VDiskConfig) GetSnapshotDraining() bool {
	if m != nil && m.SnapshotDraining != nil {
		return *m.SnapshotDraining
	}
	return false
}

func (m *VDiskConfig) GetParentDraining() bool {
	if m != nil && m.ParentDraining != nil {
		return *m.ParentDraining
	}
	return false
}

func (m *VDiskConfig) GetCloneParentDraining() bool {
	if m != nil && m.CloneParentDraining != nil {
		return *m.CloneParentDraining
	}
	return false
}

func (m *VDiskConfig) GetSnapshotChainId() int64 {
	if m != nil && m.SnapshotChainId != nil {
		return *m.SnapshotChainId
	}
	return Default_VDiskConfig_SnapshotChainId
}

func (m *VDiskConfig) GetNearSyncSessionRootVdiskId() int64 {
	if m != nil && m.NearSyncSessionRootVdiskId != nil {
		return *m.NearSyncSessionRootVdiskId
	}
	return Default_VDiskConfig_NearSyncSessionRootVdiskId
}

func (m *VDiskConfig) GetHasCompleteData() bool {
	if m != nil && m.HasCompleteData != nil {
		return *m.HasCompleteData
	}
	return false
}

func (m *VDiskConfig) GetVdiskSnapshotUuid() []byte {
	if m != nil {
		return m.VdiskSnapshotUuid
	}
	return nil
}

func (m *VDiskConfig) GetCloneSourceVdiskId() int64 {
	if m != nil && m.CloneSourceVdiskId != nil {
		return *m.CloneSourceVdiskId
	}
	return 0
}

func (m *VDiskConfig) GetCopyUpVblockMetadata() bool {
	if m != nil && m.CopyUpVblockMetadata != nil {
		return *m.CopyUpVblockMetadata
	}
	return Default_VDiskConfig_CopyUpVblockMetadata
}

func (m *VDiskConfig) GetDataLogId() int64 {
	if m != nil && m.DataLogId != nil {
		return *m.DataLogId
	}
	return 0
}

func (m *VDiskConfig) GetFlushLogId() int64 {
	if m != nil && m.FlushLogId != nil {
		return *m.FlushLogId
	}
	return 0
}

func (m *VDiskConfig) GetTimeToLiveUsecsHint() int64 {
	if m != nil && m.TimeToLiveUsecsHint != nil {
		return *m.TimeToLiveUsecsHint
	}
	return 0
}

func (m *VDiskConfig) GetNextSnapshotTimeUsecsHint() int64 {
	if m != nil && m.NextSnapshotTimeUsecsHint != nil {
		return *m.NextSnapshotTimeUsecsHint
	}
	return 0
}

func (m *VDiskConfig) GetBackingExternalDiskConfig() *VDiskConfig_BackingExternalDiskConfig {
	if m != nil {
		return m.BackingExternalDiskConfig
	}
	return nil
}

func (m *VDiskConfig) GetVdiskCreationTimeUsecs() int64 {
	if m != nil && m.VdiskCreationTimeUsecs != nil {
		return *m.VdiskCreationTimeUsecs
	}
	return 0
}

func (m *VDiskConfig) GetIsFenced() bool {
	if m != nil && m.IsFenced != nil {
		return *m.IsFenced
	}
	return false
}

func (m *VDiskConfig) GetInRecycleBin() bool {
	if m != nil && m.InRecycleBin != nil {
		return *m.InRecycleBin
	}
	return Default_VDiskConfig_InRecycleBin
}

func (m *VDiskConfig) GetOriginatingVdiskSnapshotTimeUsecs() int64 {
	if m != nil && m.OriginatingVdiskSnapshotTimeUsecs != nil {
		return *m.OriginatingVdiskSnapshotTimeUsecs
	}
	return 0
}

func (m *VDiskConfig) GetRootOfRemovableSubtree() bool {
	if m != nil && m.RootOfRemovableSubtree != nil {
		return *m.RootOfRemovableSubtree
	}
	return Default_VDiskConfig_RootOfRemovableSubtree
}

func (m *VDiskConfig) GetOplogType() VDiskConfig_OplogType {
	if m != nil && m.OplogType != nil {
		return *m.OplogType
	}
	return Default_VDiskConfig_OplogType
}

func (m *VDiskConfig) GetVdiskSnapshotTimeUsecs() int64 {
	if m != nil && m.VdiskSnapshotTimeUsecs != nil {
		return *m.VdiskSnapshotTimeUsecs
	}
	return 0
}

func (m *VDiskConfig) GetLineageId() []byte {
	if m != nil {
		return m.LineageId
	}
	return nil
}

func (m *VDiskConfig) GetLastUpdatedPithosVersion() PithosVersionInformation_PithosVersion {
	if m != nil && m.LastUpdatedPithosVersion != nil {
		return *m.LastUpdatedPithosVersion
	}
	return Default_VDiskConfig_LastUpdatedPithosVersion
}

func (m *VDiskConfig) GetMirrorVdiskName() string {
	if m != nil && m.MirrorVdiskName != nil {
		return *m.MirrorVdiskName
	}
	return ""
}

func (m *VDiskConfig) GetHasIncompleteAncestor() bool {
	if m != nil && m.HasIncompleteAncestor != nil {
		return *m.HasIncompleteAncestor
	}
	return false
}

// The configuration parameters on a vdisk.
type VDiskConfig_Params struct {
	// Whether de-duplication is to be used for data in this vdisk. If yes,
	// then when de-duplication is done is determined by the data contraction
	// policy.
	Deduplicate           *bool                                     `protobuf:"varint,1,opt,name=deduplicate" json:"deduplicate,omitempty"`
	DataContractionPolicy *VDiskConfig_Params_DataContractionPolicy `protobuf:"bytes,2,opt,name=data_contraction_policy,json=dataContractionPolicy" json:"data_contraction_policy,omitempty"`
	// Name of the leaf QoS principal to which all work done on behalf of this
	// vdisk is accounted towards. If not set, then it inherits the QoS
	// principal set on the container to which this vdisk is assigned.
	QosPrincipalName *string `protobuf:"bytes,3,opt,name=qos_principal_name,json=qosPrincipalName" json:"qos_principal_name,omitempty"`
	// Total reserved capacity across all storage tiers in bytes for the vdisk.
	TotalReservedCapacity *int64 `protobuf:"varint,4,opt,name=total_reserved_capacity,json=totalReservedCapacity" json:"total_reserved_capacity,omitempty"`
	// Oplog params for this vdisk. If not set, they are inherited from the
	// settings in the container.
	OplogParams *VDiskConfig_Params_OplogParams `protobuf:"bytes,5,opt,name=oplog_params,json=oplogParams" json:"oplog_params,omitempty"`
	// If true, SHA1 fingerprints are computed on sequential writes. The
	// fingerprints are then used for deduping in the RAM/Flash tiers. By
	// default, fingerprinting is turned off. This VDisk level setting
	// overrides the container level setting.
	FingerprintOnWrite *bool `protobuf:"varint,6,opt,name=fingerprint_on_write,json=fingerprintOnWrite" json:"fingerprint_on_write,omitempty"`
	// This is for the purpose of keeping a copy of total_reserved_capacity in
	// snapshots such that when restoring from the snapshots, we can restore
	// the reserved capacity too.
	HintTotalReservedCapacity *int64 `protobuf:"varint,7,opt,name=hint_total_reserved_capacity,json=hintTotalReservedCapacity" json:"hint_total_reserved_capacity,omitempty"`
	// Tier preference (going from high to low) for random IO. If not
	// specified then owner container preferences will be used.
	// Over-ridden tier preferences: Using this, one can configure the vdisk to
	// have a different tier preference than the owning container. For example,
	// one could set the vdisk tier preference to SSD only which will force the
	// system to always place data for this vdisk on the SSD tier and fail the
	// IO otherwise. This is a means to do 100% SSD pinning. However, just
	// setting this does not guarantee that space will be available on that
	// tier for the vdisk.
	RandomIoTierPreference []string `protobuf:"bytes,8,rep,name=random_io_tier_preference,json=randomIoTierPreference" json:"random_io_tier_preference,omitempty"`
	// Tier preference (going from high to low) for sequential IO.
	// If not specified then owner container preferences will be used.
	SequentialIoTierPreference []string                         `protobuf:"bytes,9,rep,name=sequential_io_tier_preference,json=sequentialIoTierPreference" json:"sequential_io_tier_preference,omitempty"`
	TierParams                 []*VDiskConfig_Params_TierParams `protobuf:"bytes,10,rep,name=tier_params,json=tierParams" json:"tier_params,omitempty"`
	// Replica placement policy associated with this vdisk. If this field is
	// not set on vdisk, then the container level setting will be honored.
	ReplicaPlacementPolicyId *int64 `protobuf:"varint,11,opt,name=replica_placement_policy_id,json=replicaPlacementPolicyId" json:"replica_placement_policy_id,omitempty"`
	// Replica placement pool associated with this vdisk. Egroup replicas
	// belonging to this vdisk must be placed on entities that are part of the
	// pool given by 'replica_placement_pool_id'. If this field is not set on
	// vdisk, then the container level setting will be honored.
	ReplicaPlacementPoolId *int64 `protobuf:"varint,12,opt,name=replica_placement_pool_id,json=replicaPlacementPoolId" json:"replica_placement_pool_id,omitempty"`
	// Boolean indicating if the current default replica placement policy of
	// this vdisk is under transition. When cluster topology changes, replica
	// placement policy and pool may change, and egroup replicas may be in the
	// process of being migrated to fit into the new setting.
	UnderTransition      *bool    `protobuf:"varint,13,opt,name=under_transition,json=underTransition,def=0" json:"under_transition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VDiskConfig_Params) Reset()         { *m = VDiskConfig_Params{} }
func (m *VDiskConfig_Params) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig_Params) ProtoMessage()    {}
func (*VDiskConfig_Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 0}
}

func (m *VDiskConfig_Params) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig_Params.Unmarshal(m, b)
}
func (m *VDiskConfig_Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig_Params.Marshal(b, m, deterministic)
}
func (m *VDiskConfig_Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig_Params.Merge(m, src)
}
func (m *VDiskConfig_Params) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig_Params.Size(m)
}
func (m *VDiskConfig_Params) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig_Params.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig_Params proto.InternalMessageInfo

const Default_VDiskConfig_Params_UnderTransition bool = false

func (m *VDiskConfig_Params) GetDeduplicate() bool {
	if m != nil && m.Deduplicate != nil {
		return *m.Deduplicate
	}
	return false
}

func (m *VDiskConfig_Params) GetDataContractionPolicy() *VDiskConfig_Params_DataContractionPolicy {
	if m != nil {
		return m.DataContractionPolicy
	}
	return nil
}

func (m *VDiskConfig_Params) GetQosPrincipalName() string {
	if m != nil && m.QosPrincipalName != nil {
		return *m.QosPrincipalName
	}
	return ""
}

func (m *VDiskConfig_Params) GetTotalReservedCapacity() int64 {
	if m != nil && m.TotalReservedCapacity != nil {
		return *m.TotalReservedCapacity
	}
	return 0
}

func (m *VDiskConfig_Params) GetOplogParams() *VDiskConfig_Params_OplogParams {
	if m != nil {
		return m.OplogParams
	}
	return nil
}

func (m *VDiskConfig_Params) GetFingerprintOnWrite() bool {
	if m != nil && m.FingerprintOnWrite != nil {
		return *m.FingerprintOnWrite
	}
	return false
}

func (m *VDiskConfig_Params) GetHintTotalReservedCapacity() int64 {
	if m != nil && m.HintTotalReservedCapacity != nil {
		return *m.HintTotalReservedCapacity
	}
	return 0
}

func (m *VDiskConfig_Params) GetRandomIoTierPreference() []string {
	if m != nil {
		return m.RandomIoTierPreference
	}
	return nil
}

func (m *VDiskConfig_Params) GetSequentialIoTierPreference() []string {
	if m != nil {
		return m.SequentialIoTierPreference
	}
	return nil
}

func (m *VDiskConfig_Params) GetTierParams() []*VDiskConfig_Params_TierParams {
	if m != nil {
		return m.TierParams
	}
	return nil
}

func (m *VDiskConfig_Params) GetReplicaPlacementPolicyId() int64 {
	if m != nil && m.ReplicaPlacementPolicyId != nil {
		return *m.ReplicaPlacementPolicyId
	}
	return 0
}

func (m *VDiskConfig_Params) GetReplicaPlacementPoolId() int64 {
	if m != nil && m.ReplicaPlacementPoolId != nil {
		return *m.ReplicaPlacementPoolId
	}
	return 0
}

func (m *VDiskConfig_Params) GetUnderTransition() bool {
	if m != nil && m.UnderTransition != nil {
		return *m.UnderTransition
	}
	return Default_VDiskConfig_Params_UnderTransition
}

// The data contraction policy.
type VDiskConfig_Params_DataContractionPolicy struct {
	// Time delay for deduplicating/compressing the data. Deduplication
	// and compression is done at the same time if both are required. If 0,
	// then deduplication/compression is done inline.
	DedupCompressDelaySecs *int32 `protobuf:"varint,1,opt,name=dedup_compress_delay_secs,json=dedupCompressDelaySecs" json:"dedup_compress_delay_secs,omitempty"`
	// Time delay for converting the data to erasure encoding. If not
	// specified, then data is never converted to use erasure encoding.
	ErasureCodeDelaySecs *int32 `protobuf:"varint,2,opt,name=erasure_code_delay_secs,json=erasureCodeDelaySecs" json:"erasure_code_delay_secs,omitempty"`
	// Specifies the policy in effect for deduplication of data on the disk.
	OnDiskDedupPolicy    *VDiskConfig_TransformationPolicy `protobuf:"varint,3,opt,name=on_disk_dedup_policy,json=onDiskDedupPolicy,enum=nutanix.pithos.VDiskConfig_TransformationPolicy,def=0" json:"on_disk_dedup_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *VDiskConfig_Params_DataContractionPolicy) Reset() {
	*m = VDiskConfig_Params_DataContractionPolicy{}
}
func (m *VDiskConfig_Params_DataContractionPolicy) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig_Params_DataContractionPolicy) ProtoMessage()    {}
func (*VDiskConfig_Params_DataContractionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 0, 0}
}

func (m *VDiskConfig_Params_DataContractionPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig_Params_DataContractionPolicy.Unmarshal(m, b)
}
func (m *VDiskConfig_Params_DataContractionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig_Params_DataContractionPolicy.Marshal(b, m, deterministic)
}
func (m *VDiskConfig_Params_DataContractionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig_Params_DataContractionPolicy.Merge(m, src)
}
func (m *VDiskConfig_Params_DataContractionPolicy) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig_Params_DataContractionPolicy.Size(m)
}
func (m *VDiskConfig_Params_DataContractionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig_Params_DataContractionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig_Params_DataContractionPolicy proto.InternalMessageInfo

const Default_VDiskConfig_Params_DataContractionPolicy_OnDiskDedupPolicy VDiskConfig_TransformationPolicy = VDiskConfig_kOff

func (m *VDiskConfig_Params_DataContractionPolicy) GetDedupCompressDelaySecs() int32 {
	if m != nil && m.DedupCompressDelaySecs != nil {
		return *m.DedupCompressDelaySecs
	}
	return 0
}

func (m *VDiskConfig_Params_DataContractionPolicy) GetErasureCodeDelaySecs() int32 {
	if m != nil && m.ErasureCodeDelaySecs != nil {
		return *m.ErasureCodeDelaySecs
	}
	return 0
}

func (m *VDiskConfig_Params_DataContractionPolicy) GetOnDiskDedupPolicy() VDiskConfig_TransformationPolicy {
	if m != nil && m.OnDiskDedupPolicy != nil {
		return *m.OnDiskDedupPolicy
	}
	return Default_VDiskConfig_Params_DataContractionPolicy_OnDiskDedupPolicy
}

// Description about the default oplog settings used by each vdisk assigned
// to this container. These settings can be overridden by any specific
// vdisk.
type VDiskConfig_Params_OplogParams struct {
	// Number of times any data in the oplog is replicated.
	ReplicationFactor *int32 `protobuf:"varint,1,opt,name=replication_factor,json=replicationFactor,def=1" json:"replication_factor,omitempty"`
	// There used to be an option to strip an individual episode across
	// multiple replicas. This was found never to be beneficial, and
	// gradually deprecated as oplog evolved.
	NumStripes *int32 `protobuf:"varint,2,opt,name=num_stripes,json=numStripes,def=1" json:"num_stripes,omitempty"` // Deprecated: Do not use.
	// Whether writes to the oplog need to by sync'd to disk before an
	// acknowledgment is returned for the corresponding write op.
	NeedSync *bool `protobuf:"varint,3,opt,name=need_sync,json=needSync" json:"need_sync,omitempty"`
	// If true, writes will skip the oplog, and go directly to the extent
	// store.
	SkipOplog            *bool    `protobuf:"varint,4,opt,name=skip_oplog,json=skipOplog" json:"skip_oplog,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VDiskConfig_Params_OplogParams) Reset()         { *m = VDiskConfig_Params_OplogParams{} }
func (m *VDiskConfig_Params_OplogParams) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig_Params_OplogParams) ProtoMessage()    {}
func (*VDiskConfig_Params_OplogParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 0, 1}
}

func (m *VDiskConfig_Params_OplogParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig_Params_OplogParams.Unmarshal(m, b)
}
func (m *VDiskConfig_Params_OplogParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig_Params_OplogParams.Marshal(b, m, deterministic)
}
func (m *VDiskConfig_Params_OplogParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig_Params_OplogParams.Merge(m, src)
}
func (m *VDiskConfig_Params_OplogParams) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig_Params_OplogParams.Size(m)
}
func (m *VDiskConfig_Params_OplogParams) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig_Params_OplogParams.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig_Params_OplogParams proto.InternalMessageInfo

const Default_VDiskConfig_Params_OplogParams_ReplicationFactor int32 = 1
const Default_VDiskConfig_Params_OplogParams_NumStripes int32 = 1

func (m *VDiskConfig_Params_OplogParams) GetReplicationFactor() int32 {
	if m != nil && m.ReplicationFactor != nil {
		return *m.ReplicationFactor
	}
	return Default_VDiskConfig_Params_OplogParams_ReplicationFactor
}

// Deprecated: Do not use.
func (m *VDiskConfig_Params_OplogParams) GetNumStripes() int32 {
	if m != nil && m.NumStripes != nil {
		return *m.NumStripes
	}
	return Default_VDiskConfig_Params_OplogParams_NumStripes
}

func (m *VDiskConfig_Params_OplogParams) GetNeedSync() bool {
	if m != nil && m.NeedSync != nil {
		return *m.NeedSync
	}
	return false
}

func (m *VDiskConfig_Params_OplogParams) GetSkipOplog() bool {
	if m != nil && m.SkipOplog != nil {
		return *m.SkipOplog
	}
	return false
}

// Tier specific vdisk params.
// Using this param, one can reserve a minimum amount of space of a vdisk
// on a given storage tier. Thus, one could provide a config which sets the
// pinned size of the vdisk to 20G in the SSD tier. This ensures that 20GB
// of the hot working set of the vdisk is always kept in the SSD.
type VDiskConfig_Params_TierParams struct {
	// Required : tier name.
	TierName *string `protobuf:"bytes,1,opt,name=tier_name,json=tierName" json:"tier_name,omitempty"`
	// Required : The minimum amount of data to be pinned on this tier in
	// bytes. At anytime the minimum amount of pinned data on the tier will
	// be minimum of actual usage or 'min_pinned_usage_bytes'.
	MinPinnedUsageBytes  *int64   `protobuf:"varint,2,opt,name=min_pinned_usage_bytes,json=minPinnedUsageBytes" json:"min_pinned_usage_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VDiskConfig_Params_TierParams) Reset()         { *m = VDiskConfig_Params_TierParams{} }
func (m *VDiskConfig_Params_TierParams) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig_Params_TierParams) ProtoMessage()    {}
func (*VDiskConfig_Params_TierParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 0, 2}
}

func (m *VDiskConfig_Params_TierParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig_Params_TierParams.Unmarshal(m, b)
}
func (m *VDiskConfig_Params_TierParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig_Params_TierParams.Marshal(b, m, deterministic)
}
func (m *VDiskConfig_Params_TierParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig_Params_TierParams.Merge(m, src)
}
func (m *VDiskConfig_Params_TierParams) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig_Params_TierParams.Size(m)
}
func (m *VDiskConfig_Params_TierParams) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig_Params_TierParams.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig_Params_TierParams proto.InternalMessageInfo

func (m *VDiskConfig_Params_TierParams) GetTierName() string {
	if m != nil && m.TierName != nil {
		return *m.TierName
	}
	return ""
}

func (m *VDiskConfig_Params_TierParams) GetMinPinnedUsageBytes() int64 {
	if m != nil && m.MinPinnedUsageBytes != nil {
		return *m.MinPinnedUsageBytes
	}
	return 0
}

// Configuration for an external VDisk. An external VDisk is a special type
// of VDisk which exists in Pithos and maps directly to a block storage
// entity in an external system. In general, external VDisks do not have any
// associated block map metadata in Nutanix. In future when we implement
// the ability to read data from external storage systems (eg. with filter
// drivers), external vdisks will have associated block map metadata.
//
// There are three possible types of external vdisks:
//
// Type 1. External vdisks for .hydrated NFS files. Each of these external
// vdisks always has 'original_snapshot_vdisk_id' set to point to the
// immutable snapshot vdisk corresponding to the .snapshot NFS file that
// we're prehydrating in the .hydrated namespace.
//
// Type 2. External vdisks for normal NFS files (i.e., non-.snapshot and
// non-.hydrated NFS files). When restoring a VM on a cloud cluster, for
// example, each of the VM's virtual disk files would point to external
// vdisks for normal NFS files.
//
// Type 3. External vdisks for .snapshot NFS files. Always with
// 'mutability_state' kImmutableSnapshot, these are external vdisks created
// by Type 2 external vdisk snapshots which would be created during a
// protection domain snapshot on a cloud cluster.
type VDiskConfig_ExternalVDiskConfig struct {
	// If set, this implies that this external vdisk is for a .hydrated NFS
	// file. In that case, this field points to the immutable snapshot vdisk
	// corresponding to the .snapshot NFS file that we're prehydrating in the
	// .hydrated namespace.
	OriginalSnapshotVdiskId *int64 `protobuf:"varint,1,opt,name=original_snapshot_vdisk_id,json=originalSnapshotVdiskId" json:"original_snapshot_vdisk_id,omitempty"`
	// If set, this field has the following meaning:
	//
	// Type 1 external vdisk: the identifier to the block storage snapshot
	// entity created when all the data for the vdisk with id
	// 'original_snapshot_vdisk_id' is written. The data in the snapshot is
	// identical to the data in the vdisk 'original_snapshot_vdisk_id'.
	//
	// Type 2 and Type 3 external vdisks: the identifier to the block storage
	// snapshot entity created when the external vdisk was first created. The
	// data in the snapshot is the initial state of the external vdisk.
	//
	// The identifier is opaque from the perspective of Pithos.
	DiskSnapshotId []byte `protobuf:"bytes,2,opt,name=disk_snapshot_id,json=diskSnapshotId" json:"disk_snapshot_id,omitempty"`
	// If set, this field has the following meaning:
	//
	// Type 1 external vdisk: the identifier of the block storage entity that
	// contains the data currently being written for the vdisk with id
	// 'original_snapshot_vdisk_id'.
	//
	// Type 2 external vdisk: the identifier of the block storage entity that
	// contains the data currently being written for the external vdisk. In the
	// common case, the block storage entity is being written to by a cloud VM
	// that was restored on a cloud cluster.
	//
	// Type 3 external vdisk: the identifier of the block storage entity that
	// contains the same data as 'disk_snapshot_id'.
	//
	// The identifier is opaque from the perspective of Pithos. If this field
	// is set, 'tentative_disk_id' must not be set.
	DiskId []byte `protobuf:"bytes,3,opt,name=disk_id,json=diskId" json:"disk_id,omitempty"`
	// The tentative value that we want to assign to 'disk_id'. If this field
	// is set, 'disk_id' must not be set.
	TentativeDiskId      []byte   `protobuf:"bytes,4,opt,name=tentative_disk_id,json=tentativeDiskId" json:"tentative_disk_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VDiskConfig_ExternalVDiskConfig) Reset()         { *m = VDiskConfig_ExternalVDiskConfig{} }
func (m *VDiskConfig_ExternalVDiskConfig) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig_ExternalVDiskConfig) ProtoMessage()    {}
func (*VDiskConfig_ExternalVDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 1}
}

func (m *VDiskConfig_ExternalVDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig_ExternalVDiskConfig.Unmarshal(m, b)
}
func (m *VDiskConfig_ExternalVDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig_ExternalVDiskConfig.Marshal(b, m, deterministic)
}
func (m *VDiskConfig_ExternalVDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig_ExternalVDiskConfig.Merge(m, src)
}
func (m *VDiskConfig_ExternalVDiskConfig) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig_ExternalVDiskConfig.Size(m)
}
func (m *VDiskConfig_ExternalVDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig_ExternalVDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig_ExternalVDiskConfig proto.InternalMessageInfo

func (m *VDiskConfig_ExternalVDiskConfig) GetOriginalSnapshotVdiskId() int64 {
	if m != nil && m.OriginalSnapshotVdiskId != nil {
		return *m.OriginalSnapshotVdiskId
	}
	return 0
}

func (m *VDiskConfig_ExternalVDiskConfig) GetDiskSnapshotId() []byte {
	if m != nil {
		return m.DiskSnapshotId
	}
	return nil
}

func (m *VDiskConfig_ExternalVDiskConfig) GetDiskId() []byte {
	if m != nil {
		return m.DiskId
	}
	return nil
}

func (m *VDiskConfig_ExternalVDiskConfig) GetTentativeDiskId() []byte {
	if m != nil {
		return m.TentativeDiskId
	}
	return nil
}

// Configuration of a VDisk that's backed by data in an external disk or a
// datasource. The backing external disk can be either external to the
// container having this vdisk or external to the AOS cluster.
//
// If the data that's backing this vdisk is in another container in the same
// AOS cluster, the 'source_vdisk_name' identifies the source of the data.
//
// If the data that's backing this vdisk is outside the cluster, the
// the repository hosting the data source is identified by
// 'external_repository_id'. Recall that an external repository models a
// storage repository such as an NFS export or an S3 bucket that exists
// outside an AOS cluster.
//
// A VDisk with this configuration set has some or all of its data outside
// the AOS cluster or in another container in the same AOS cluster and if no
// data has been copied into the VDisk yet, the block map for the VDisk will
// be empty.
//
// Stargate uses this configuration to forward reads and writes appropriately
// to the external data source depending on the io_handling_mode configured.
//
// Either 'source_vdisk_name' OR 'external_repository_id' AND 'relative_path'
// must be set. For a datasource within an AOS cluster,
// external_repository_id and relative_path will not be set. Instead, only
// the source_vdisk_name will be set.
//
// This configuration should not be confused with the ExternalVDiskConfig
// which was introduced for the (now-defunct) Cloud DR feature.
type VDiskConfig_BackingExternalDiskConfig struct {
	// The ID of the external repository that surfaces this virtual disk.
	// The protocol and the parameters required for accessing this external
	// repository can be found in the Zeus configuration.
	ExternalRepositoryId *int64 `protobuf:"varint,1,opt,name=external_repository_id,json=externalRepositoryId" json:"external_repository_id,omitempty"`
	// Path to the virtual disk relative to the external repository. If the
	// repository is an NFS export, relative_path gives the path within that
	// NFS export.
	RelativePath   *string                                               `protobuf:"bytes,2,opt,name=relative_path,json=relativePath" json:"relative_path,omitempty"`
	IoHandlingMode *VDiskConfig_BackingExternalDiskConfig_IOHandlingMode `protobuf:"varint,3,opt,name=io_handling_mode,json=ioHandlingMode,enum=nutanix.pithos.VDiskConfig_BackingExternalDiskConfig_IOHandlingMode,def=0" json:"io_handling_mode,omitempty"`
	// Name of the vdisk residing on different container.
	SourceVdiskName      *string  `protobuf:"bytes,4,opt,name=source_vdisk_name,json=sourceVdiskName" json:"source_vdisk_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VDiskConfig_BackingExternalDiskConfig) Reset()         { *m = VDiskConfig_BackingExternalDiskConfig{} }
func (m *VDiskConfig_BackingExternalDiskConfig) String() string { return proto.CompactTextString(m) }
func (*VDiskConfig_BackingExternalDiskConfig) ProtoMessage()    {}
func (*VDiskConfig_BackingExternalDiskConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{1, 2}
}

func (m *VDiskConfig_BackingExternalDiskConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfig_BackingExternalDiskConfig.Unmarshal(m, b)
}
func (m *VDiskConfig_BackingExternalDiskConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfig_BackingExternalDiskConfig.Marshal(b, m, deterministic)
}
func (m *VDiskConfig_BackingExternalDiskConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfig_BackingExternalDiskConfig.Merge(m, src)
}
func (m *VDiskConfig_BackingExternalDiskConfig) XXX_Size() int {
	return xxx_messageInfo_VDiskConfig_BackingExternalDiskConfig.Size(m)
}
func (m *VDiskConfig_BackingExternalDiskConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfig_BackingExternalDiskConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfig_BackingExternalDiskConfig proto.InternalMessageInfo

const Default_VDiskConfig_BackingExternalDiskConfig_IoHandlingMode VDiskConfig_BackingExternalDiskConfig_IOHandlingMode = VDiskConfig_BackingExternalDiskConfig_kForward

func (m *VDiskConfig_BackingExternalDiskConfig) GetExternalRepositoryId() int64 {
	if m != nil && m.ExternalRepositoryId != nil {
		return *m.ExternalRepositoryId
	}
	return 0
}

func (m *VDiskConfig_BackingExternalDiskConfig) GetRelativePath() string {
	if m != nil && m.RelativePath != nil {
		return *m.RelativePath
	}
	return ""
}

func (m *VDiskConfig_BackingExternalDiskConfig) GetIoHandlingMode() VDiskConfig_BackingExternalDiskConfig_IOHandlingMode {
	if m != nil && m.IoHandlingMode != nil {
		return *m.IoHandlingMode
	}
	return Default_VDiskConfig_BackingExternalDiskConfig_IoHandlingMode
}

func (m *VDiskConfig_BackingExternalDiskConfig) GetSourceVdiskName() string {
	if m != nil && m.SourceVdiskName != nil {
		return *m.SourceVdiskName
	}
	return ""
}

type VDiskConfigEntryProto struct {
	// Context of proto. For example, whether used in UpdateVDiskConfig.
	// This is simpler than writing a custom string to BINARY_LOG.
	Context *string `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	// Pithos logical timestamp of vdisk config entry.
	LogicalTimestamp *int64 `protobuf:"varint,2,opt,name=logical_timestamp,json=logicalTimestamp" json:"logical_timestamp,omitempty"`
	// See comments for 'VDiskConfig'.
	VdiskConfig          *VDiskConfig `protobuf:"bytes,3,opt,name=vdisk_config,json=vdiskConfig" json:"vdisk_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VDiskConfigEntryProto) Reset()         { *m = VDiskConfigEntryProto{} }
func (m *VDiskConfigEntryProto) String() string { return proto.CompactTextString(m) }
func (*VDiskConfigEntryProto) ProtoMessage()    {}
func (*VDiskConfigEntryProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{2}
}

func (m *VDiskConfigEntryProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VDiskConfigEntryProto.Unmarshal(m, b)
}
func (m *VDiskConfigEntryProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VDiskConfigEntryProto.Marshal(b, m, deterministic)
}
func (m *VDiskConfigEntryProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VDiskConfigEntryProto.Merge(m, src)
}
func (m *VDiskConfigEntryProto) XXX_Size() int {
	return xxx_messageInfo_VDiskConfigEntryProto.Size(m)
}
func (m *VDiskConfigEntryProto) XXX_DiscardUnknown() {
	xxx_messageInfo_VDiskConfigEntryProto.DiscardUnknown(m)
}

var xxx_messageInfo_VDiskConfigEntryProto proto.InternalMessageInfo

func (m *VDiskConfigEntryProto) GetContext() string {
	if m != nil && m.Context != nil {
		return *m.Context
	}
	return ""
}

func (m *VDiskConfigEntryProto) GetLogicalTimestamp() int64 {
	if m != nil && m.LogicalTimestamp != nil {
		return *m.LogicalTimestamp
	}
	return 0
}

func (m *VDiskConfigEntryProto) GetVdiskConfig() *VDiskConfig {
	if m != nil {
		return m.VdiskConfig
	}
	return nil
}

type IscsiClientParams struct {
	// iSCSI client identifier.
	IscsiClientId *IscsiClientParams_IscsiClientIdentifier `protobuf:"bytes,1,opt,name=iscsi_client_id,json=iscsiClientId" json:"iscsi_client_id,omitempty"`
	// List of iSCSI targets that will be visible and accessible to
	// 'iscsi_client_id'.
	IscsiTargetName []string `protobuf:"bytes,2,rep,name=iscsi_target_name,json=iscsiTargetName" json:"iscsi_target_name,omitempty"`
	// List of params corresponding to each 'iscsi_target_name' in above list.
	TargetParams []*IscsiClientParams_TargetParams `protobuf:"bytes,3,rep,name=target_params,json=targetParams" json:"target_params,omitempty"`
	// iSCSI initiator secret in obfuscated form. This secret is used by the
	// client to authenticate the target. This secret is sent back to the client
	// during security negotiation phase. This secret, along with 'target_secret'
	// denotes that MUTUAL CHAP is enabled.
	IscsiClientSecret *string `protobuf:"bytes,4,opt,name=iscsi_client_secret,json=iscsiClientSecret" json:"iscsi_client_secret,omitempty"`
	// UUID for the client. This is generated by Acropolis for each client when
	// it is created and is the same as client_uuid. The purpose of adding this
	// duplicate field is to ensure that the service that publishes this message
	// to any DB does not need to worry about the message internals and refer to
	// uuid directly. Any future VGs created after this change will set this
	// field.
	Uuid                 []byte   `protobuf:"bytes,5,opt,name=uuid" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IscsiClientParams) Reset()         { *m = IscsiClientParams{} }
func (m *IscsiClientParams) String() string { return proto.CompactTextString(m) }
func (*IscsiClientParams) ProtoMessage()    {}
func (*IscsiClientParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{3}
}

func (m *IscsiClientParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IscsiClientParams.Unmarshal(m, b)
}
func (m *IscsiClientParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IscsiClientParams.Marshal(b, m, deterministic)
}
func (m *IscsiClientParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IscsiClientParams.Merge(m, src)
}
func (m *IscsiClientParams) XXX_Size() int {
	return xxx_messageInfo_IscsiClientParams.Size(m)
}
func (m *IscsiClientParams) XXX_DiscardUnknown() {
	xxx_messageInfo_IscsiClientParams.DiscardUnknown(m)
}

var xxx_messageInfo_IscsiClientParams proto.InternalMessageInfo

func (m *IscsiClientParams) GetIscsiClientId() *IscsiClientParams_IscsiClientIdentifier {
	if m != nil {
		return m.IscsiClientId
	}
	return nil
}

func (m *IscsiClientParams) GetIscsiTargetName() []string {
	if m != nil {
		return m.IscsiTargetName
	}
	return nil
}

func (m *IscsiClientParams) GetTargetParams() []*IscsiClientParams_TargetParams {
	if m != nil {
		return m.TargetParams
	}
	return nil
}

func (m *IscsiClientParams) GetIscsiClientSecret() string {
	if m != nil && m.IscsiClientSecret != nil {
		return *m.IscsiClientSecret
	}
	return ""
}

func (m *IscsiClientParams) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

// We support whitelisting of iSCSI initiators based on their IP address or
// iSCSI name. IscsiClientIdentifier should contain either
// iscsi_initiator_name or iscsi_initiator_network_id of the initiator, but
// not both. Additionally, client_uuid can be set.
type IscsiClientParams_IscsiClientIdentifier struct {
	// iSCSI initiator name.
	IscsiInitiatorName *string `protobuf:"bytes,1,opt,name=iscsi_initiator_name,json=iscsiInitiatorName" json:"iscsi_initiator_name,omitempty"`
	// iSCSI initiator network identifier.
	IscsiInitiatorNetworkId *string `protobuf:"bytes,2,opt,name=iscsi_initiator_network_id,json=iscsiInitiatorNetworkId" json:"iscsi_initiator_network_id,omitempty"`
	// UUID of the client, assigned by Acropolis.
	ClientUuid           []byte   `protobuf:"bytes,3,opt,name=client_uuid,json=clientUuid" json:"client_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IscsiClientParams_IscsiClientIdentifier) Reset() {
	*m = IscsiClientParams_IscsiClientIdentifier{}
}
func (m *IscsiClientParams_IscsiClientIdentifier) String() string { return proto.CompactTextString(m) }
func (*IscsiClientParams_IscsiClientIdentifier) ProtoMessage()    {}
func (*IscsiClientParams_IscsiClientIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{3, 0}
}

func (m *IscsiClientParams_IscsiClientIdentifier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IscsiClientParams_IscsiClientIdentifier.Unmarshal(m, b)
}
func (m *IscsiClientParams_IscsiClientIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IscsiClientParams_IscsiClientIdentifier.Marshal(b, m, deterministic)
}
func (m *IscsiClientParams_IscsiClientIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IscsiClientParams_IscsiClientIdentifier.Merge(m, src)
}
func (m *IscsiClientParams_IscsiClientIdentifier) XXX_Size() int {
	return xxx_messageInfo_IscsiClientParams_IscsiClientIdentifier.Size(m)
}
func (m *IscsiClientParams_IscsiClientIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_IscsiClientParams_IscsiClientIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_IscsiClientParams_IscsiClientIdentifier proto.InternalMessageInfo

func (m *IscsiClientParams_IscsiClientIdentifier) GetIscsiInitiatorName() string {
	if m != nil && m.IscsiInitiatorName != nil {
		return *m.IscsiInitiatorName
	}
	return ""
}

func (m *IscsiClientParams_IscsiClientIdentifier) GetIscsiInitiatorNetworkId() string {
	if m != nil && m.IscsiInitiatorNetworkId != nil {
		return *m.IscsiInitiatorNetworkId
	}
	return ""
}

func (m *IscsiClientParams_IscsiClientIdentifier) GetClientUuid() []byte {
	if m != nil {
		return m.ClientUuid
	}
	return nil
}

// Parameters for each 'iscsi_target_name' target.
type IscsiClientParams_TargetParams struct {
	// Number of virtual targets to generate for 'iscsi_target_name'. If
	// 'num_virtual_targets' is not set, 'iscsi_target_name' is directly
	// exposed to the iSCSI clients. If 'num_virtual_targets' is set, then we
	// use 'iscsi_target_name' as prefix for the virtual targets. E.g., if
	// 'num_virtual_targets' is 4, then the virtual targets generated will be
	// 1) 'iscsi_target_name'-tgt0
	// 2) 'iscsi_target_name'-tgt1
	// 3) 'iscsi_target_name'-tgt2
	// 4) 'iscsi_target_name'-tgt3
	// All the LUNs belonging to 'iscsi_target_name' will be assigned to each
	// virtual target in a round-robin manner. E.g., if there are 18 LUNs with
	// LUN ids 0-17. So with 4 virtual targets, LUNs will be
	// reported as follows:
	// 1) 'iscsi_target_name'-tgt0 will report LUNs [0-4] mapped to vdisks
	//    with LUN ids 0, 4, 8, 12, 16
	// 2) 'iscsi_target_name'-tgt1 will report LUNs [0-4] mapped to vdisks
	//    with LUN ids 1, 5, 9, 13, 17
	// 3) 'iscsi_target_name'-tgt2 will report LUNs [0-3] mapped to vdisks
	//    with LUN ids 2, 6, 10, 14
	// 4) 'iscsi_target_name'-tgt3 will report LUNs [0-3] mapped to vdisks
	//    with LUN ids 3, 7, 11, 15
	NumVirtualTargets *int32 `protobuf:"varint,1,opt,name=num_virtual_targets,json=numVirtualTargets" json:"num_virtual_targets,omitempty"`
	// Whether to use iSCSI redirection for iSCSI login to this target.
	UseRedirection *bool `protobuf:"varint,2,opt,name=use_redirection,json=useRedirection" json:"use_redirection,omitempty"`
	// If 'preferred_svm_id' is set, it is given preference for redirection
	// of all the virtual targets or the base target for 'iscsi_target_name'.
	PreferredSvmId *int64 `protobuf:"varint,3,opt,name=preferred_svm_id,json=preferredSvmId" json:"preferred_svm_id,omitempty"`
	// Secret specific to a target in obfuscated form. This secret is used by
	// the target to authenticate a client. If this field is set, it denotes
	// that CHAP is enabled for this target. The target secret is unique to a
	// target and will be the same across multiple IscsiClientParams if the
	// target remains the same. The user needs to configure this secret in
	// order to connect.
	TargetSecret *string `protobuf:"bytes,4,opt,name=target_secret,json=targetSecret" json:"target_secret,omitempty"`
	// Whether UNMAP support is disabled for this target. If set, stargate
	// will not support handling UNMAP command sent from the client and also
	// not advertise the parameters necessary for UNMAP.
	DisableUnmap         *bool    `protobuf:"varint,5,opt,name=disable_unmap,json=disableUnmap" json:"disable_unmap,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IscsiClientParams_TargetParams) Reset()         { *m = IscsiClientParams_TargetParams{} }
func (m *IscsiClientParams_TargetParams) String() string { return proto.CompactTextString(m) }
func (*IscsiClientParams_TargetParams) ProtoMessage()    {}
func (*IscsiClientParams_TargetParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{3, 1}
}

func (m *IscsiClientParams_TargetParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IscsiClientParams_TargetParams.Unmarshal(m, b)
}
func (m *IscsiClientParams_TargetParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IscsiClientParams_TargetParams.Marshal(b, m, deterministic)
}
func (m *IscsiClientParams_TargetParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IscsiClientParams_TargetParams.Merge(m, src)
}
func (m *IscsiClientParams_TargetParams) XXX_Size() int {
	return xxx_messageInfo_IscsiClientParams_TargetParams.Size(m)
}
func (m *IscsiClientParams_TargetParams) XXX_DiscardUnknown() {
	xxx_messageInfo_IscsiClientParams_TargetParams.DiscardUnknown(m)
}

var xxx_messageInfo_IscsiClientParams_TargetParams proto.InternalMessageInfo

func (m *IscsiClientParams_TargetParams) GetNumVirtualTargets() int32 {
	if m != nil && m.NumVirtualTargets != nil {
		return *m.NumVirtualTargets
	}
	return 0
}

func (m *IscsiClientParams_TargetParams) GetUseRedirection() bool {
	if m != nil && m.UseRedirection != nil {
		return *m.UseRedirection
	}
	return false
}

func (m *IscsiClientParams_TargetParams) GetPreferredSvmId() int64 {
	if m != nil && m.PreferredSvmId != nil {
		return *m.PreferredSvmId
	}
	return 0
}

func (m *IscsiClientParams_TargetParams) GetTargetSecret() string {
	if m != nil && m.TargetSecret != nil {
		return *m.TargetSecret
	}
	return ""
}

func (m *IscsiClientParams_TargetParams) GetDisableUnmap() bool {
	if m != nil && m.DisableUnmap != nil {
		return *m.DisableUnmap
	}
	return false
}

// For unit test only.
type PithosGenValTest struct {
	// Arbitrary fields.
	ValueString          *string  `protobuf:"bytes,1,opt,name=value_string,json=valueString" json:"value_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PithosGenValTest) Reset()         { *m = PithosGenValTest{} }
func (m *PithosGenValTest) String() string { return proto.CompactTextString(m) }
func (*PithosGenValTest) ProtoMessage()    {}
func (*PithosGenValTest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebd2f922aa7834fa, []int{4}
}

func (m *PithosGenValTest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PithosGenValTest.Unmarshal(m, b)
}
func (m *PithosGenValTest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PithosGenValTest.Marshal(b, m, deterministic)
}
func (m *PithosGenValTest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PithosGenValTest.Merge(m, src)
}
func (m *PithosGenValTest) XXX_Size() int {
	return xxx_messageInfo_PithosGenValTest.Size(m)
}
func (m *PithosGenValTest) XXX_DiscardUnknown() {
	xxx_messageInfo_PithosGenValTest.DiscardUnknown(m)
}

var xxx_messageInfo_PithosGenValTest proto.InternalMessageInfo

func (m *PithosGenValTest) GetValueString() string {
	if m != nil && m.ValueString != nil {
		return *m.ValueString
	}
	return ""
}

func init() {
	proto.RegisterEnum("nutanix.pithos.PithosVersionInformation_PithosVersion", PithosVersionInformation_PithosVersion_name, PithosVersionInformation_PithosVersion_value)
	proto.RegisterEnum("nutanix.pithos.VDiskConfig_TransformationPolicy", VDiskConfig_TransformationPolicy_name, VDiskConfig_TransformationPolicy_value)
	proto.RegisterEnum("nutanix.pithos.VDiskConfig_MutabilityState", VDiskConfig_MutabilityState_name, VDiskConfig_MutabilityState_value)
	proto.RegisterEnum("nutanix.pithos.VDiskConfig_IscsiMultipathProtocol", VDiskConfig_IscsiMultipathProtocol_name, VDiskConfig_IscsiMultipathProtocol_value)
	proto.RegisterEnum("nutanix.pithos.VDiskConfig_OplogType", VDiskConfig_OplogType_name, VDiskConfig_OplogType_value)
	proto.RegisterEnum("nutanix.pithos.VDiskConfig_BackingExternalDiskConfig_IOHandlingMode", VDiskConfig_BackingExternalDiskConfig_IOHandlingMode_name, VDiskConfig_BackingExternalDiskConfig_IOHandlingMode_value)
	proto.RegisterType((*PithosVersionInformation)(nil), "nutanix.pithos.PithosVersionInformation")
	proto.RegisterType((*VDiskConfig)(nil), "nutanix.pithos.VDiskConfig")
	proto.RegisterType((*VDiskConfig_Params)(nil), "nutanix.pithos.VDiskConfig.Params")
	proto.RegisterType((*VDiskConfig_Params_DataContractionPolicy)(nil), "nutanix.pithos.VDiskConfig.Params.DataContractionPolicy")
	proto.RegisterType((*VDiskConfig_Params_OplogParams)(nil), "nutanix.pithos.VDiskConfig.Params.OplogParams")
	proto.RegisterType((*VDiskConfig_Params_TierParams)(nil), "nutanix.pithos.VDiskConfig.Params.TierParams")
	proto.RegisterType((*VDiskConfig_ExternalVDiskConfig)(nil), "nutanix.pithos.VDiskConfig.ExternalVDiskConfig")
	proto.RegisterType((*VDiskConfig_BackingExternalDiskConfig)(nil), "nutanix.pithos.VDiskConfig.BackingExternalDiskConfig")
	proto.RegisterType((*VDiskConfigEntryProto)(nil), "nutanix.pithos.VDiskConfigEntryProto")
	proto.RegisterType((*IscsiClientParams)(nil), "nutanix.pithos.IscsiClientParams")
	proto.RegisterType((*IscsiClientParams_IscsiClientIdentifier)(nil), "nutanix.pithos.IscsiClientParams.IscsiClientIdentifier")
	proto.RegisterType((*IscsiClientParams_TargetParams)(nil), "nutanix.pithos.IscsiClientParams.TargetParams")
	proto.RegisterType((*PithosGenValTest)(nil), "nutanix.pithos.PithosGenValTest")
}

func init() { proto.RegisterFile("pithos/pithos.proto", fileDescriptor_ebd2f922aa7834fa) }

var fileDescriptor_ebd2f922aa7834fa = []byte{
	// 3057 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x59, 0x5b, 0x77, 0x1b, 0x37,
	0x92, 0x36, 0x25, 0xcb, 0xa6, 0x40, 0x4a, 0xa2, 0xa0, 0x5b, 0x8b, 0x8e, 0x63, 0x99, 0xd9, 0xc4,
	0x8a, 0x1d, 0xcb, 0xb6, 0x62, 0xe7, 0xa2, 0x38, 0x17, 0x4b, 0x8a, 0x63, 0x9e, 0xf8, 0xc2, 0xb4,
	0x24, 0xe7, 0x9c, 0x3d, 0xbb, 0x8b, 0x85, 0xba, 0x41, 0x11, 0x87, 0xdd, 0x40, 0x07, 0x40, 0xd3,
	0x66, 0x1e, 0x76, 0xff, 0xc9, 0xbc, 0xcc, 0xc3, 0xfc, 0x89, 0x99, 0x87, 0xcc, 0xdf, 0x98, 0xdf,
	0x30, 0x2f, 0xf3, 0x0b, 0xe6, 0xa0, 0xd0, 0x37, 0x4a, 0xb2, 0x93, 0x99, 0x93, 0x27, 0xa9, 0xeb,
	0xab, 0x2a, 0x14, 0x0a, 0x85, 0xba, 0x80, 0x68, 0x29, 0xe1, 0x66, 0x20, 0xf5, 0x1d, 0xf7, 0x67,
	0x2b, 0x51, 0xd2, 0x48, 0x3c, 0x2f, 0x52, 0x43, 0x05, 0x7f, 0xbd, 0xe5, 0xa8, 0xed, 0xeb, 0x31,
	0x0b, 0x53, 0x4d, 0xef, 0x04, 0x52, 0x68, 0xae, 0x0d, 0x13, 0xc1, 0x98, 0x9c, 0x28, 0x99, 0x26,
	0x84, 0x87, 0x4e, 0xa4, 0x7d, 0x25, 0xd3, 0xa3, 0x8d, 0x62, 0x26, 0x18, 0x90, 0x84, 0x2a, 0x1a,
	0x67, 0xfa, 0x3a, 0x7f, 0x9d, 0x42, 0x5e, 0x0f, 0xf0, 0x97, 0x4c, 0x69, 0x2e, 0x45, 0x57, 0xf4,
	0xa5, 0x8a, 0xa9, 0xe1, 0x52, 0xe0, 0x13, 0x34, 0xef, 0x64, 0xc9, 0xc8, 0x81, 0x5e, 0x6d, 0xa3,
	0xb6, 0x39, 0xbf, 0xfd, 0xc9, 0xd6, 0xa4, 0x15, 0x5b, 0x6f, 0xd2, 0x30, 0x09, 0xec, 0xd4, 0x87,
	0x5d, 0xc1, 0x0d, 0xa7, 0x91, 0x3f, 0x97, 0x54, 0x01, 0xfc, 0x7f, 0xa8, 0x1d, 0xa4, 0x4a, 0x31,
	0x61, 0x48, 0xb1, 0x11, 0x53, 0x2c, 0x3a, 0xf5, 0x3b, 0x2d, 0xea, 0x65, 0x6b, 0xec, 0x15, 0x4b,
	0x64, 0x3c, 0x9d, 0x2f, 0xd1, 0xdc, 0x84, 0x10, 0x9e, 0x43, 0xb3, 0xc3, 0x43, 0xa6, 0xcd, 0x0b,
	0x11, 0x8d, 0x5b, 0x17, 0x70, 0x13, 0x15, 0x5a, 0x5a, 0x35, 0xbc, 0x80, 0x1a, 0xc3, 0xbd, 0x01,
	0xe5, 0xa2, 0x1b, 0x7e, 0xcf, 0xc6, 0x2d, 0xd4, 0xf9, 0xfb, 0x6d, 0xd4, 0x78, 0xb9, 0xcf, 0xf5,
	0x70, 0x4f, 0x8a, 0x3e, 0x3f, 0xc1, 0xeb, 0xa8, 0x3e, 0x0a, 0xb9, 0x1e, 0x12, 0x1e, 0x7a, 0xb5,
	0x8d, 0xa9, 0xcd, 0x69, 0xff, 0x32, 0x7c, 0x77, 0x43, 0x7c, 0x15, 0x21, 0x07, 0x09, 0x1a, 0x33,
	0xd8, 0xd9, 0xac, 0x3f, 0x0b, 0x94, 0xe7, 0x34, 0x66, 0xf8, 0x03, 0xb4, 0x90, 0x50, 0xf0, 0x43,
	0xa1, 0x60, 0x7a, 0xa3, 0xb6, 0x39, 0xed, 0xcf, 0x39, 0xf2, 0xcb, 0xd3, 0x6a, 0x34, 0xff, 0x99,
	0x79, 0x17, 0x61, 0x0d, 0xa7, 0xe6, 0x80, 0xff, 0xcc, 0xf0, 0x4d, 0xb4, 0xc8, 0x75, 0xa0, 0x39,
	0x31, 0x54, 0x9d, 0x30, 0xe3, 0x16, 0x9b, 0x81, 0xc5, 0x16, 0x00, 0x38, 0x04, 0x3a, 0x2c, 0x79,
	0x05, 0xcd, 0x3a, 0xde, 0x28, 0x15, 0xde, 0xa5, 0x8d, 0xda, 0xe6, 0x8c, 0x5f, 0x07, 0xc2, 0xd3,
	0x54, 0xe0, 0xff, 0x40, 0xf3, 0xa3, 0xb8, 0xaf, 0xc9, 0x40, 0x6a, 0x43, 0x12, 0xa9, 0x8c, 0x77,
	0x19, 0xb4, 0x34, 0x2d, 0xf5, 0x89, 0xd4, 0xa6, 0x27, 0x95, 0xc1, 0xd7, 0x51, 0x33, 0x90, 0xc2,
	0x50, 0x2e, 0x98, 0xb2, 0x26, 0xd7, 0xc1, 0x9e, 0x46, 0x41, 0xeb, 0x86, 0x78, 0x07, 0x5d, 0x72,
	0x71, 0xe7, 0xcd, 0x6e, 0xd4, 0x36, 0x1b, 0xdb, 0x9d, 0xd3, 0xa7, 0x59, 0xf1, 0xdf, 0x56, 0x0f,
	0x38, 0xfd, 0x4c, 0x02, 0x5f, 0x47, 0xf5, 0x90, 0x6b, 0x7a, 0x1c, 0xb1, 0xd0, 0x43, 0x1b, 0xb5,
	0xcd, 0xfa, 0xce, 0x4c, 0x9f, 0x46, 0x9a, 0xf9, 0x05, 0xd9, 0x6e, 0xc2, 0x48, 0xa2, 0x58, 0x2c,
	0x47, 0xcc, 0x6b, 0x58, 0x1e, 0xbf, 0x6e, 0xa4, 0x0f, 0xdf, 0x78, 0x0b, 0x2d, 0x05, 0x8a, 0x41,
	0x6c, 0x10, 0xc3, 0x63, 0x46, 0x52, 0xcd, 0x02, 0xed, 0x35, 0xc1, 0xb1, 0x8b, 0x39, 0x74, 0xc8,
	0x63, 0x76, 0x64, 0x01, 0xfc, 0xbf, 0xa8, 0x15, 0xa7, 0x86, 0x1e, 0xf3, 0x88, 0x9b, 0x31, 0xd1,
	0x86, 0x1a, 0xe6, 0xcd, 0x41, 0x0c, 0xde, 0x7a, 0x9b, 0xd5, 0xcf, 0x0a, 0x99, 0x03, 0x2b, 0xb2,
	0x53, 0x1f, 0x02, 0x25, 0x62, 0xfe, 0x42, 0x3c, 0x09, 0xe1, 0xfb, 0x68, 0x35, 0x88, 0xa4, 0x66,
	0xda, 0x1d, 0x4d, 0x48, 0xa8, 0x08, 0x98, 0x36, 0x52, 0x79, 0xf3, 0xe0, 0xde, 0xe5, 0x0c, 0xb5,
	0x07, 0x14, 0x3e, 0xca, 0x30, 0x38, 0xf4, 0x9f, 0xa5, 0x60, 0xee, 0x38, 0x17, 0x36, 0xa6, 0x21,
	0x76, 0x2c, 0x05, 0x0e, 0xf2, 0x21, 0xba, 0x42, 0x47, 0x92, 0x87, 0x64, 0x74, 0x1c, 0xc9, 0x60,
	0x48, 0x02, 0x99, 0x8c, 0xc9, 0xab, 0x01, 0x13, 0x24, 0x62, 0xb4, 0xef, 0xb5, 0xc0, 0x2b, 0x6b,
	0xc0, 0xf2, 0x12, 0x38, 0xf6, 0x64, 0x32, 0xfe, 0x71, 0xc0, 0xc4, 0x53, 0x46, 0xfb, 0x36, 0x64,
	0x5c, 0x44, 0x81, 0x3f, 0xa4, 0x22, 0x91, 0x0c, 0xbc, 0xc5, 0x8d, 0xe9, 0xcd, 0x69, 0x7f, 0x01,
	0x80, 0x3d, 0x47, 0x7f, 0x2a, 0x03, 0xdc, 0x41, 0x73, 0xa2, 0xaf, 0x49, 0x9f, 0x47, 0x99, 0x2d,
	0x18, 0xac, 0x6e, 0x88, 0xbe, 0x7e, 0xcc, 0x23, 0x67, 0x4d, 0x07, 0xcd, 0xc5, 0x74, 0x4c, 0x8e,
	0x19, 0x71, 0x91, 0xeb, 0x2d, 0xc1, 0xfa, 0x8d, 0x98, 0x8e, 0x77, 0x59, 0x0f, 0x48, 0xd6, 0x0d,
	0x52, 0xf1, 0x13, 0x2e, 0xa8, 0xe1, 0xe2, 0x84, 0x04, 0x51, 0xaa, 0x8d, 0x8b, 0xa0, 0x65, 0x38,
	0x9b, 0xe5, 0x0a, 0xba, 0xe7, 0xc0, 0x6e, 0x88, 0xbf, 0x47, 0x9d, 0x73, 0xa5, 0x44, 0x40, 0x95,
	0x70, 0xa7, 0xcc, 0x43, 0x6f, 0x05, 0x34, 0x5c, 0x3b, 0x47, 0x43, 0xc9, 0xd7, 0x0d, 0xf1, 0x5d,
	0x54, 0x5d, 0xa4, 0xbc, 0x75, 0xab, 0x20, 0x8e, 0x2b, 0x58, 0x7e, 0xf5, 0xee, 0xa2, 0xe5, 0x13,
	0x26, 0x98, 0xa2, 0x86, 0x55, 0x3d, 0xed, 0xad, 0xc1, 0xfe, 0x70, 0x8e, 0x95, 0x2e, 0xb6, 0x12,
	0x7a, 0x40, 0x43, 0xf9, 0x8a, 0x28, 0x46, 0x43, 0xa2, 0xd8, 0x4f, 0x29, 0xd3, 0x46, 0x7b, 0x9e,
	0x93, 0x70, 0x98, 0xcf, 0x68, 0xe8, 0x67, 0x08, 0xfe, 0x18, 0xad, 0x5a, 0xe7, 0x05, 0x92, 0x46,
	0x4c, 0x07, 0x8c, 0xb8, 0x65, 0x62, 0x9a, 0x78, 0x6d, 0x90, 0x59, 0x8a, 0xe9, 0x78, 0x2f, 0x03,
	0x77, 0x2d, 0xf6, 0x8c, 0x26, 0xf8, 0x33, 0xb4, 0x9e, 0xe5, 0x8e, 0x89, 0xc3, 0x21, 0x03, 0x2e,
	0x8c, 0x77, 0x05, 0x4e, 0x68, 0xc5, 0x31, 0x3c, 0x2f, 0xcf, 0xe9, 0x09, 0x17, 0x06, 0x7f, 0x8a,
	0x3c, 0xf6, 0x3a, 0x61, 0x81, 0x61, 0x21, 0x39, 0x9d, 0x7e, 0xae, 0x82, 0x23, 0x56, 0x72, 0xbc,
	0x37, 0x91, 0x86, 0x02, 0xb4, 0xc2, 0x5e, 0x1b, 0xa6, 0x04, 0x8d, 0x32, 0x89, 0x00, 0xee, 0x82,
	0xf7, 0x2e, 0x5c, 0xf2, 0x3b, 0x6f, 0xbb, 0x2e, 0xdf, 0x66, 0x82, 0x15, 0x9a, 0xbf, 0x94, 0x6b,
	0x83, 0x05, 0xb2, 0x6c, 0x7a, 0x13, 0x2d, 0x9e, 0x5a, 0x84, 0x87, 0xde, 0x35, 0x30, 0x6b, 0x61,
	0x82, 0xbf, 0x1b, 0xe2, 0x23, 0xb4, 0x38, 0x59, 0xe6, 0x2c, 0xef, 0x3a, 0x18, 0xf3, 0xe1, 0x69,
	0x63, 0x0e, 0x1c, 0xa3, 0x4b, 0x36, 0x5b, 0x47, 0x82, 0xdb, 0x7a, 0x43, 0xa3, 0x6e, 0xe8, 0x2f,
	0xe8, 0x2a, 0xd4, 0x0d, 0xf1, 0x47, 0x08, 0xe7, 0x6a, 0x2b, 0xd9, 0xfb, 0x1d, 0xf0, 0x69, 0x2b,
	0x43, 0x5e, 0x16, 0x49, 0xfc, 0x6b, 0xf4, 0x4e, 0xce, 0xad, 0x58, 0x9f, 0x29, 0x26, 0x02, 0x56,
	0x95, 0xdb, 0x00, 0xb9, 0xf5, 0x8c, 0xc7, 0xcf, 0x59, 0x4a, 0x05, 0xff, 0x85, 0x56, 0x72, 0x05,
	0x11, 0x17, 0xc3, 0x72, 0xd7, 0xd7, 0xff, 0xd5, 0x9d, 0xe4, 0x66, 0x3f, 0xe5, 0x62, 0x58, 0x06,
	0x70, 0xcb, 0xe6, 0xcd, 0x28, 0x92, 0xaf, 0x20, 0xaf, 0x73, 0x71, 0xe2, 0x75, 0xaa, 0x69, 0x75,
	0x21, 0x87, 0x9f, 0x38, 0x14, 0x7f, 0x80, 0x1a, 0x7a, 0xc0, 0xa2, 0xcc, 0xfd, 0xde, 0x7b, 0x55,
	0x66, 0x04, 0x08, 0xe8, 0xc6, 0x1a, 0x79, 0xae, 0x94, 0xc4, 0x69, 0x64, 0x78, 0x42, 0xcd, 0x80,
	0x40, 0x97, 0x11, 0xc8, 0xc8, 0x7b, 0x1f, 0x12, 0xe8, 0xf6, 0xdb, 0x22, 0xa2, 0x6b, 0x65, 0x9f,
	0xe5, 0xa2, 0xbd, 0x4c, 0x72, 0x67, 0x66, 0xf8, 0x28, 0x4a, 0xa9, 0xbf, 0xca, 0xcf, 0x85, 0x6d,
	0xb1, 0x0d, 0x6c, 0x31, 0xb6, 0xfe, 0xf9, 0x60, 0xa3, 0xb6, 0xd9, 0xf4, 0x2f, 0x07, 0xae, 0x38,
	0x57, 0xaa, 0x69, 0xc1, 0x71, 0x03, 0x38, 0xb2, 0x6a, 0x9a, 0x15, 0xf1, 0xb2, 0x9a, 0xa6, 0x29,
	0x0f, 0xbd, 0x4d, 0x60, 0x71, 0xd5, 0xf4, 0x28, 0xe5, 0xee, 0xf4, 0xed, 0xae, 0x34, 0x53, 0x9c,
	0x46, 0x44, 0xa4, 0xf1, 0x31, 0x53, 0xde, 0x87, 0xd9, 0xe9, 0x07, 0x9a, 0x1f, 0x00, 0xf0, 0x1c,
	0xe8, 0xf8, 0x63, 0x84, 0x6d, 0x6b, 0x41, 0x0d, 0x1f, 0xb1, 0x72, 0xdd, 0x9b, 0x55, 0x9f, 0xb5,
	0x0a, 0x86, 0xdc, 0x02, 0x9b, 0x22, 0xec, 0x12, 0x70, 0x61, 0x79, 0xc8, 0x84, 0xe1, 0x7d, 0xce,
	0x94, 0x77, 0x0b, 0x16, 0x81, 0xe5, 0x6d, 0x64, 0x74, 0x0b, 0x04, 0x6f, 0xa2, 0xa6, 0x60, 0x23,
	0xa6, 0xe0, 0x08, 0x59, 0xe8, 0x7d, 0x54, 0x5d, 0xa0, 0x01, 0xd0, 0x13, 0x40, 0xf0, 0x43, 0x34,
	0x13, 0x9c, 0x58, 0x1b, 0x6e, 0x43, 0xf4, 0xdc, 0x28, 0x8e, 0xc0, 0xb5, 0x8e, 0x5b, 0x7b, 0x65,
	0xeb, 0xf8, 0x9d, 0xed, 0x1c, 0xbb, 0x21, 0xf8, 0xd6, 0xbf, 0x18, 0x9c, 0x74, 0x43, 0x7c, 0x0b,
	0x2d, 0x6a, 0x41, 0x13, 0x3d, 0x90, 0x86, 0x84, 0x8a, 0x72, 0x61, 0xc3, 0x65, 0x0b, 0xb2, 0x50,
	0x2b, 0x07, 0xf6, 0x33, 0x3a, 0xbe, 0x51, 0x38, 0xbc, 0x60, 0xbd, 0x03, 0xac, 0xf3, 0x8e, 0x5c,
	0x30, 0x6e, 0xa3, 0x95, 0x20, 0xb2, 0xa5, 0xec, 0x34, 0xfb, 0x5d, 0x97, 0xdf, 0x00, 0xec, 0x4d,
	0xca, 0x6c, 0x55, 0x2c, 0x29, 0xfc, 0x7a, 0xcf, 0xe6, 0x81, 0x9d, 0xa9, 0xdb, 0xf7, 0xfc, 0x85,
	0x1c, 0xcc, 0x7d, 0xfa, 0x1d, 0xba, 0x26, 0x18, 0x55, 0x44, 0x8f, 0x45, 0x40, 0x34, 0xd3, 0xb6,
	0xb1, 0x23, 0x4a, 0xca, 0x4a, 0x72, 0xdb, 0x2e, 0xa4, 0xdb, 0x96, 0xf5, 0x60, 0x2c, 0x82, 0x03,
	0xc7, 0xe8, 0x4b, 0x59, 0x64, 0xb9, 0x9b, 0x68, 0x71, 0x40, 0x35, 0x09, 0x64, 0x9c, 0x44, 0xcc,
	0x30, 0x12, 0x52, 0x43, 0xbd, 0x8f, 0xc1, 0xd0, 0x85, 0x01, 0xd5, 0x7b, 0x19, 0x7d, 0x9f, 0x1a,
	0x6a, 0x7b, 0x8d, 0xac, 0x31, 0xcb, 0x4d, 0x85, 0x98, 0xba, 0x0f, 0x31, 0xe5, 0x2a, 0xec, 0x41,
	0x86, 0x40, 0x6c, 0xdd, 0xcb, 0x1d, 0xa1, 0x65, 0xaa, 0x8a, 0x34, 0xc1, 0x43, 0xef, 0x81, 0x2b,
	0x40, 0x00, 0x1e, 0x00, 0x96, 0x9b, 0xf3, 0x10, 0xad, 0x41, 0x69, 0x4f, 0x93, 0xbc, 0xfe, 0xc4,
	0xcc, 0x50, 0x30, 0xea, 0x93, 0x6a, 0x10, 0x2c, 0x5b, 0xae, 0xa3, 0xc4, 0x15, 0xa2, 0x67, 0x19,
	0x0b, 0x7e, 0x17, 0x35, 0xec, 0x5f, 0x12, 0x49, 0x88, 0x89, 0x4f, 0x61, 0x99, 0x59, 0x4b, 0x7a,
	0x2a, 0xed, 0x79, 0x6f, 0xa0, 0x66, 0x3f, 0x4a, 0xf5, 0x20, 0x67, 0xf8, 0x0c, 0x18, 0x10, 0xd0,
	0x1c, 0xc7, 0x7d, 0xb4, 0x06, 0x5d, 0x94, 0x91, 0x24, 0xb2, 0x31, 0x0e, 0xdd, 0x94, 0xab, 0x32,
	0x9f, 0x03, 0xf3, 0x92, 0x85, 0x0f, 0xe5, 0x53, 0x3e, 0x72, 0x0d, 0x15, 0xd4, 0x98, 0x6f, 0xd0,
	0x55, 0xc1, 0x5e, 0x9b, 0xd2, 0x2f, 0x65, 0x27, 0xe6, 0x64, 0x77, 0x40, 0x76, 0xdd, 0x32, 0xe5,
	0x1e, 0x2a, 0x5a, 0x32, 0xd0, 0x30, 0x42, 0xef, 0x1c, 0xd3, 0x60, 0x68, 0xcb, 0x74, 0x51, 0x0f,
	0xaa, 0x35, 0xe7, 0x0b, 0x08, 0xef, 0x07, 0x6f, 0xcb, 0x30, 0xbb, 0x4e, 0x3e, 0x2f, 0x3d, 0x95,
	0xca, 0xb3, 0x7e, 0xfc, 0x26, 0x08, 0x7f, 0x8e, 0xd6, 0x2b, 0x9d, 0xd1, 0xa9, 0x26, 0xf2, 0x21,
	0x58, 0xbd, 0x5a, 0x76, 0x48, 0x13, 0x9d, 0x24, 0xf4, 0xd6, 0xa4, 0x6f, 0xb3, 0x7b, 0xe8, 0x7d,
	0xe9, 0xda, 0x52, 0xae, 0x1f, 0xc3, 0x37, 0xbe, 0x85, 0xe6, 0xb9, 0x20, 0x8a, 0x05, 0xe3, 0x20,
	0x62, 0xe4, 0x98, 0x0b, 0xef, 0xab, 0xea, 0xf1, 0x35, 0xb9, 0xf0, 0x1d, 0xb6, 0xcb, 0x05, 0xee,
	0xa1, 0xf7, 0xcf, 0xf6, 0x29, 0xe7, 0xf8, 0xd2, 0xfb, 0x1a, 0x0c, 0xba, 0x7e, 0xba, 0x71, 0x39,
	0xe3, 0x52, 0xfc, 0x0d, 0x5a, 0x87, 0xcb, 0x20, 0xfb, 0xae, 0x6f, 0xb6, 0x9d, 0x2a, 0xd1, 0xe9,
	0xb1, 0x51, 0x8c, 0x79, 0xdf, 0x54, 0x2d, 0x59, 0xb5, 0x7c, 0x2f, 0xfa, 0x7e, 0xce, 0x75, 0xe0,
	0x98, 0xf0, 0x0f, 0x08, 0xc9, 0xc4, 0x86, 0x89, 0x19, 0x27, 0xcc, 0x7b, 0x04, 0x09, 0xfe, 0xfd,
	0xb7, 0xb9, 0xff, 0x85, 0xe5, 0x3e, 0x1c, 0x27, 0x6c, 0xa7, 0x31, 0x04, 0x3a, 0x10, 0xfc, 0x59,
	0x99, 0xd3, 0x4b, 0x5f, 0x9f, 0xb7, 0xb5, 0xdd, 0x8a, 0xaf, 0xcf, 0xee, 0xe7, 0x2a, 0x42, 0x11,
	0x17, 0x8c, 0x9e, 0xd8, 0x04, 0xea, 0xed, 0xb9, 0x24, 0x9e, 0x51, 0xba, 0x21, 0xfe, 0x7f, 0x74,
	0x25, 0xa2, 0xda, 0x90, 0x34, 0x09, 0x29, 0xf4, 0x39, 0x93, 0x83, 0xed, 0xfe, 0xef, 0x35, 0x63,
	0xda, 0x45, 0x8e, 0xdc, 0x1a, 0x93, 0x23, 0xe5, 0x4d, 0xb4, 0x18, 0x73, 0xa5, 0xa4, 0xaa, 0xb6,
	0x02, 0xdf, 0xba, 0x99, 0xcc, 0x01, 0x65, 0x03, 0xf0, 0x09, 0x5a, 0xb3, 0x19, 0x87, 0x8b, 0x22,
	0xe7, 0x14, 0x03, 0xc2, 0x63, 0x88, 0xa2, 0x95, 0x01, 0xd5, 0xdd, 0x02, 0xcd, 0x27, 0x84, 0xf6,
	0x5f, 0x10, 0xba, 0xe4, 0xba, 0x00, 0xbc, 0x81, 0x1a, 0x21, 0x0b, 0xd3, 0x24, 0xe2, 0x81, 0x9d,
	0x5f, 0x6a, 0xae, 0xfb, 0xae, 0x90, 0x70, 0x82, 0xd6, 0x20, 0x13, 0xd8, 0x31, 0x4d, 0xd1, 0x00,
	0x22, 0x3b, 0x91, 0x11, 0x0f, 0xc6, 0x30, 0x97, 0x36, 0xb6, 0x3f, 0xfb, 0xf5, 0x19, 0x6d, 0xcb,
	0x26, 0xbd, 0xbd, 0x52, 0x41, 0x0f, 0xe4, 0xfd, 0x95, 0xf0, 0x3c, 0xb2, 0x2d, 0xa4, 0x3f, 0x49,
	0x4d, 0x12, 0xc5, 0x45, 0xc0, 0x13, 0x5b, 0x4a, 0xad, 0x0f, 0xa6, 0x5d, 0x21, 0xfd, 0x49, 0xea,
	0x5e, 0x0e, 0xe4, 0x4e, 0x30, 0xd2, 0xd0, 0x88, 0x28, 0xa6, 0x99, 0x1a, 0xb1, 0x90, 0x04, 0x34,
	0xa1, 0x01, 0x37, 0x63, 0xef, 0xa2, 0x6b, 0x4a, 0x01, 0xf6, 0x33, 0x74, 0x2f, 0x03, 0xf1, 0x0f,
	0xa8, 0xe9, 0xc2, 0x32, 0x1b, 0x38, 0x67, 0x60, 0x33, 0x5b, 0xbf, 0x61, 0x33, 0x10, 0x8e, 0xd9,
	0xf0, 0xd9, 0x90, 0xe5, 0x87, 0x2d, 0xcf, 0x7d, 0x2e, 0x4e, 0x98, 0xb2, 0xa6, 0x1b, 0x22, 0x05,
	0x79, 0xa5, 0xb8, 0x61, 0x30, 0x2e, 0xd7, 0x7d, 0x5c, 0xc1, 0x5e, 0x88, 0x1f, 0x2d, 0x62, 0x7b,
	0x40, 0x9b, 0xd5, 0xc8, 0x9b, 0x76, 0x70, 0xd9, 0x65, 0x3b, 0xcb, 0x73, 0x78, 0xee, 0x2e, 0x3e,
	0x47, 0xeb, 0x8a, 0x8a, 0x50, 0xc6, 0x84, 0x4b, 0x62, 0x38, 0x53, 0x24, 0x29, 0x9a, 0x49, 0xaf,
	0x0e, 0xb3, 0xdf, 0xaa, 0x63, 0xe8, 0xca, 0x43, 0xce, 0x54, 0xaf, 0x40, 0xf1, 0x23, 0x74, 0x55,
	0xdb, 0x49, 0x42, 0xd8, 0x88, 0x3c, 0x4f, 0x7c, 0x16, 0xc4, 0xdb, 0x25, 0xd3, 0x19, 0x15, 0xcf,
	0x51, 0xc3, 0x09, 0x39, 0x17, 0xa2, 0x8d, 0xe9, 0xcd, 0xc6, 0xf6, 0xed, 0xdf, 0xe0, 0x42, 0xd0,
	0xe3, 0x3c, 0x88, 0x4c, 0xf1, 0x3f, 0xfe, 0x12, 0x5d, 0x51, 0x0c, 0x02, 0x8f, 0x24, 0x11, 0x0d,
	0x58, 0x6c, 0x8b, 0xbe, 0x0b, 0x36, 0x7b, 0x5b, 0x1b, 0xe0, 0x0d, 0x2f, 0x63, 0xe9, 0xe5, 0x1c,
	0x2e, 0x6c, 0xba, 0x21, 0x38, 0xe3, 0x1c, 0x71, 0x19, 0x59, 0x61, 0x37, 0xc7, 0xaf, 0x9e, 0x15,
	0x96, 0x91, 0xeb, 0x76, 0x53, 0x11, 0x32, 0x45, 0x8c, 0xa2, 0x42, 0x73, 0x1b, 0x8d, 0x30, 0xcc,
	0x97, 0xdd, 0x2e, 0xc0, 0x87, 0x05, 0xda, 0xfe, 0x47, 0x0d, 0xad, 0x9c, 0x1b, 0xd6, 0xd6, 0x0c,
	0xb8, 0x40, 0xd0, 0x0a, 0x28, 0xa6, 0x35, 0x09, 0x59, 0x44, 0xc7, 0x04, 0xb2, 0x53, 0x0d, 0x9e,
	0x4e, 0x56, 0x81, 0x61, 0x2f, 0xc3, 0xf7, 0x2d, 0x7c, 0x60, 0xb3, 0xd3, 0x03, 0xb4, 0xc6, 0x14,
	0xd5, 0xa9, 0x62, 0x24, 0x90, 0x21, 0xab, 0x0a, 0x4e, 0x81, 0xe0, 0x72, 0x06, 0xef, 0xc9, 0x90,
	0x95, 0x62, 0x27, 0x68, 0x59, 0x0a, 0x57, 0xe5, 0xdc, 0xca, 0xd9, 0x05, 0x9d, 0x86, 0x74, 0x75,
	0xf7, 0x6d, 0x07, 0x02, 0x3b, 0x2a, 0x12, 0x96, 0xdb, 0xc1, 0xce, 0xc5, 0xe1, 0x8b, 0x7e, 0xdf,
	0x5f, 0x94, 0xc2, 0x32, 0xee, 0x5b, 0x8d, 0x0e, 0x68, 0xff, 0xb1, 0x86, 0x1a, 0x2f, 0x26, 0x22,
	0x1e, 0x67, 0x0e, 0x85, 0xbc, 0xd0, 0xa7, 0x81, 0x4d, 0x3e, 0xb0, 0xc7, 0x9d, 0xda, 0x3d, 0x7f,
	0xb1, 0x02, 0x3e, 0x06, 0xcc, 0x0e, 0x09, 0x22, 0x8d, 0x89, 0x36, 0x8a, 0x27, 0x2c, 0xdb, 0xd5,
	0x4e, 0xed, 0xde, 0xee, 0x94, 0x57, 0xf3, 0x91, 0x48, 0xe3, 0x03, 0x07, 0xd8, 0x9a, 0x28, 0x18,
	0x0b, 0xa1, 0x2d, 0x83, 0x7d, 0xd4, 0xfd, 0xba, 0x25, 0xd8, 0xe6, 0xcb, 0x26, 0x71, 0x3d, 0xe4,
	0x09, 0x81, 0xcb, 0x07, 0xd7, 0xbc, 0xee, 0xcf, 0x5a, 0x0a, 0xd8, 0xd6, 0xfe, 0x1f, 0x84, 0xca,
	0x00, 0x83, 0x47, 0x1f, 0x1b, 0xa4, 0x90, 0x45, 0x6a, 0x90, 0x45, 0xea, 0x96, 0x00, 0xd9, 0xc3,
	0x8e, 0xd0, 0x5c, 0x90, 0x84, 0x0b, 0xc1, 0x42, 0x92, 0x6a, 0x5b, 0x17, 0x8e, 0xc7, 0x26, 0xb3,
	0x6c, 0xda, 0x5f, 0x8a, 0xb9, 0xe8, 0x01, 0x78, 0x64, 0xb1, 0x5d, 0x0b, 0xb5, 0x7f, 0xa9, 0xa1,
	0xa5, 0x73, 0xe6, 0x52, 0xfc, 0x05, 0x6a, 0x67, 0x05, 0x35, 0x2a, 0x2b, 0x53, 0xe5, 0x89, 0xcf,
	0x2a, 0x5c, 0xcb, 0x39, 0xf2, 0xd2, 0x94, 0xf7, 0x6b, 0x9b, 0x30, 0x6f, 0x55, 0x4a, 0x1a, 0x0f,
	0xc1, 0x86, 0xa6, 0x3f, 0x5f, 0xad, 0x64, 0xdd, 0x10, 0xaf, 0xa1, 0xcb, 0xd5, 0x57, 0xbf, 0xa6,
	0x7f, 0xa9, 0xec, 0x40, 0xcb, 0x99, 0x22, 0x67, 0xb9, 0x08, 0x2c, 0x0b, 0x05, 0xb0, 0x0f, 0xbc,
	0xed, 0x3f, 0x4f, 0xa1, 0xf5, 0x37, 0xf6, 0x39, 0xf8, 0x3e, 0x5a, 0x2d, 0x9a, 0x27, 0xc5, 0x12,
	0xa9, 0xb9, 0x91, 0x6a, 0x5c, 0xee, 0x62, 0x39, 0x47, 0xfd, 0x02, 0xec, 0x86, 0xf8, 0x3d, 0x34,
	0xa7, 0x58, 0xe4, 0x96, 0xb7, 0xc3, 0x57, 0xf6, 0x70, 0xd9, 0xcc, 0x89, 0x3d, 0x6a, 0x06, 0xf8,
	0x35, 0x6a, 0x71, 0x49, 0x06, 0x54, 0x84, 0x91, 0x6d, 0x51, 0x62, 0x19, 0xb2, 0x2c, 0x4e, 0xf7,
	0xff, 0xad, 0x9e, 0x6c, 0xab, 0xfb, 0xe2, 0x49, 0xa6, 0xec, 0x99, 0x0c, 0xd9, 0x4e, 0x7d, 0xf8,
	0x58, 0xaa, 0x57, 0x54, 0x85, 0xfe, 0x3c, 0x97, 0x55, 0xc4, 0xba, 0x67, 0xa2, 0x7d, 0x86, 0x80,
	0xb8, 0xe8, 0x4a, 0xab, 0x2e, 0x7b, 0x67, 0x1b, 0x17, 0x9d, 0x77, 0xd1, 0xfc, 0xa4, 0x5e, 0x78,
	0xdc, 0xcd, 0x34, 0xb7, 0x2e, 0x74, 0xbe, 0x46, 0xcb, 0xe7, 0xdd, 0x1c, 0x5c, 0x47, 0x70, 0x77,
	0x5a, 0x17, 0x70, 0x03, 0x5d, 0x1e, 0x76, 0x85, 0xed, 0x2c, 0x5a, 0x35, 0xdc, 0x42, 0xcd, 0x61,
	0x4f, 0x6a, 0xd3, 0x53, 0x32, 0x60, 0x5a, 0xb7, 0xa6, 0x3a, 0xff, 0x8d, 0x16, 0x4e, 0xbd, 0x04,
	0xc2, 0x0a, 0xd9, 0x5b, 0x60, 0xeb, 0x02, 0x9e, 0x47, 0x68, 0xd8, 0x8d, 0xe3, 0xec, 0xbb, 0x86,
	0x57, 0x11, 0x2e, 0xbf, 0xf3, 0x68, 0x68, 0x4d, 0xe1, 0x65, 0xd4, 0xaa, 0xd0, 0xe1, 0x91, 0xa8,
	0x35, 0xdd, 0xd9, 0x42, 0xab, 0xe7, 0xcf, 0xc9, 0x78, 0x16, 0xb9, 0x49, 0xb9, 0x75, 0x01, 0xfe,
	0x7d, 0x96, 0x70, 0xd9, 0xaa, 0x75, 0x7c, 0x34, 0x5b, 0xb4, 0x5d, 0xf0, 0x72, 0x5d, 0x36, 0x5e,
	0xad, 0x0b, 0xf8, 0x2a, 0x5a, 0x77, 0x84, 0x47, 0x22, 0xdc, 0xe7, 0xf6, 0xee, 0x1e, 0xa7, 0x86,
	0x85, 0x0e, 0xae, 0xe1, 0x15, 0xb4, 0x38, 0x3c, 0x43, 0x9e, 0xea, 0xfc, 0xa1, 0x86, 0x56, 0x2a,
	0x47, 0xf8, 0xad, 0x30, 0x6a, 0x0c, 0x66, 0x60, 0x0f, 0x5d, 0xb6, 0xed, 0x04, 0x7b, 0x6d, 0xb2,
	0x0b, 0x99, 0x7f, 0xda, 0x39, 0x32, 0x92, 0x27, 0x3c, 0xa0, 0x11, 0xb4, 0x74, 0xda, 0xd0, 0x38,
	0xc9, 0xae, 0x62, 0x2b, 0x03, 0x0e, 0x73, 0x3a, 0xfe, 0x0a, 0x35, 0x27, 0x9e, 0x93, 0xa6, 0xa1,
	0x84, 0x5f, 0x79, 0x4b, 0x18, 0xf9, 0x8d, 0x51, 0xf9, 0x64, 0xd4, 0xf9, 0x65, 0x06, 0x2d, 0x82,
	0x97, 0xf6, 0x22, 0x6e, 0x4b, 0x81, 0xcb, 0x17, 0x04, 0xb9, 0xc7, 0x6f, 0x12, 0x00, 0x35, 0x0f,
	0xfa, 0xc6, 0xf6, 0xa7, 0xa7, 0x15, 0x9f, 0x91, 0xad, 0x52, 0xca, 0x21, 0xdc, 0x9f, 0xe3, 0x55,
	0xf2, 0xf9, 0xcf, 0xee, 0x53, 0x50, 0x6c, 0xcf, 0x3c, 0xbb, 0x1f, 0xa0, 0xb9, 0x8c, 0x2b, 0xab,
	0xb1, 0xd3, 0x50, 0x63, 0xb7, 0x7e, 0xdd, 0x14, 0xa7, 0x24, 0x2b, 0xb2, 0x4d, 0x53, 0xf9, 0xb2,
	0xd3, 0xe7, 0xc4, 0x0e, 0x35, 0x0b, 0x14, 0x33, 0xd9, 0x55, 0x58, 0xac, 0x18, 0x7b, 0x00, 0x00,
	0xc6, 0xe8, 0x22, 0x8c, 0xa7, 0x33, 0x90, 0x4a, 0xe0, 0xff, 0xf6, 0x9f, 0x6a, 0x68, 0xe5, 0xdc,
	0xdd, 0xda, 0x2e, 0xc8, 0x69, 0xe7, 0xd0, 0xec, 0x1a, 0x39, 0x91, 0x7a, 0x31, 0x60, 0xdd, 0x1c,
	0x82, 0x4d, 0x7e, 0x81, 0xda, 0x67, 0x24, 0x98, 0x79, 0x25, 0xd5, 0x30, 0x4f, 0x82, 0xb3, 0xfe,
	0xda, 0x29, 0x39, 0x87, 0x77, 0x43, 0x7c, 0x0d, 0x35, 0xb2, 0x6d, 0x80, 0x8d, 0x2e, 0x23, 0x22,
	0x47, 0xb2, 0xb3, 0x73, 0xfb, 0x6f, 0x35, 0xd4, 0x3c, 0x3c, 0xb5, 0x7d, 0x5b, 0x82, 0x46, 0x5c,
	0x99, 0xd4, 0xc6, 0x19, 0x60, 0x79, 0x65, 0x5e, 0x14, 0x69, 0xfc, 0xd2, 0x21, 0x4e, 0x48, 0xe3,
	0x1b, 0x68, 0x21, 0xd5, 0x8c, 0x28, 0x16, 0x72, 0xc5, 0xa0, 0xd0, 0x83, 0x4d, 0x75, 0x7f, 0x3e,
	0xd5, 0xcc, 0x2f, 0xa9, 0x36, 0x85, 0xbb, 0xf6, 0x49, 0xd9, 0xc2, 0x35, 0x8a, 0xcb, 0xdf, 0x65,
	0xe6, 0x0b, 0xfa, 0xc1, 0x28, 0x76, 0x99, 0x32, 0x3b, 0xd6, 0x09, 0xdf, 0x67, 0xc7, 0x94, 0xb9,
	0xfd, 0x3d, 0x34, 0x97, 0xfd, 0x72, 0x41, 0x52, 0x11, 0xd3, 0x04, 0xfc, 0x5f, 0xf7, 0x9b, 0x19,
	0xf1, 0xc8, 0xd2, 0x3a, 0x0f, 0x50, 0xcb, 0x0d, 0x10, 0xdf, 0x31, 0xf1, 0x92, 0x46, 0x87, 0x4c,
	0xc3, 0x0f, 0x2d, 0x23, 0x1a, 0xa5, 0x0c, 0xaa, 0xac, 0x38, 0xc9, 0x3c, 0xdf, 0x00, 0xda, 0x01,
	0x90, 0x76, 0x3f, 0x44, 0x38, 0x90, 0xf1, 0xa9, 0x28, 0xda, 0x6d, 0x38, 0x55, 0x70, 0x49, 0xff,
	0xf3, 0x92, 0x23, 0xfe, 0x33, 0x00, 0x00, 0xff, 0xff, 0xa5, 0xee, 0x7b, 0xda, 0x61, 0x1c, 0x00,
	0x00,
}
