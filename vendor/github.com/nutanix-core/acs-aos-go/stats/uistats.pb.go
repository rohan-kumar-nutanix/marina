// Code generated by protoc-gen-go. DO NOT EDIT.
// source: stats/uistats.proto

package stats

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Stat maintained for every vm, host, container, and appliance.
type UsageStatProto struct {
	// Total logical storage used by this entity measured in bytes. This size
	// is before transformation (e.g., compression, encryption) and replication.
	TotalLogicalUsageBytes *int64 `protobuf:"varint,1,opt,name=total_logical_usage_bytes,json=totalLogicalUsageBytes" json:"total_logical_usage_bytes,omitempty"`
	// Total physical storage used by this entity measured in bytes. This
	// size is after transformation and replication.
	TotalPhysicalUsageBytes *int64 `protobuf:"varint,2,opt,name=total_physical_usage_bytes,json=totalPhysicalUsageBytes" json:"total_physical_usage_bytes,omitempty"`
	// The list of disks that have bytes from this entity.
	Disks []int64 `protobuf:"varint,3,rep,name=disks" json:"disks,omitempty"`
	// Current usage in disk bytes for this entity on each of the above
	// mentioned disks.
	DiskUsageBytes []int64 `protobuf:"varint,4,rep,name=disk_usage_bytes,json=diskUsageBytes" json:"disk_usage_bytes,omitempty"`
	// Total storage capacity available to the entity.
	TotalCapacityBytes *int64 `protobuf:"varint,5,opt,name=total_capacity_bytes,json=totalCapacityBytes" json:"total_capacity_bytes,omitempty"`
	// Total reserved usage in bytes. This field is applicable to storage pool
	// and container usage. The size is after replication, and it does not
	// account for any transformations applied to the vdisks.
	//
	// Container:
	// It is the summation of min(vdisk_usage, vdisk_reservation).
	//
	// Storage Pool:
	// It is the summation of min(container_usage,
	// container_explicit_reservation). Note that container_usage includes
	// the reserved_free of the container.
	TotalReservedUsageBytes *int64 `protobuf:"varint,6,opt,name=total_reserved_usage_bytes,json=totalReservedUsageBytes" json:"total_reserved_usage_bytes,omitempty"`
	// Total reclaimable garbage storage used by this entity measured in bytes.
	TotalGarbageBytes *int64 `protobuf:"varint,7,opt,name=total_garbage_bytes,json=totalGarbageBytes" json:"total_garbage_bytes,omitempty"`
	// Total unreserved usage in bytes. This field is applicable to storage pool
	// and container usage. The size is after replication.
	//
	// Container:
	// It is the container_physical_usage - container_reserved_usage.
	//
	// Storage Pool:
	// It is the total_container_usage - total_reserved_usage of storage pool.
	// Note that container_usage includes the reserved_free of the container.
	TotalUnreservedUsageBytes *int64 `protobuf:"varint,8,opt,name=total_unreserved_usage_bytes,json=totalUnreservedUsageBytes" json:"total_unreserved_usage_bytes,omitempty"`
	// The logical timestamp of the Zeus Configuration that is used to compute
	// the usages.
	ZeusLogicalTimestamp *int64   `protobuf:"varint,9,opt,name=zeus_logical_timestamp,json=zeusLogicalTimestamp" json:"zeus_logical_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageStatProto) Reset()         { *m = UsageStatProto{} }
func (m *UsageStatProto) String() string { return proto.CompactTextString(m) }
func (*UsageStatProto) ProtoMessage()    {}
func (*UsageStatProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c7ca023696c8ea8, []int{0}
}

func (m *UsageStatProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UsageStatProto.Unmarshal(m, b)
}
func (m *UsageStatProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UsageStatProto.Marshal(b, m, deterministic)
}
func (m *UsageStatProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageStatProto.Merge(m, src)
}
func (m *UsageStatProto) XXX_Size() int {
	return xxx_messageInfo_UsageStatProto.Size(m)
}
func (m *UsageStatProto) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageStatProto.DiscardUnknown(m)
}

var xxx_messageInfo_UsageStatProto proto.InternalMessageInfo

func (m *UsageStatProto) GetTotalLogicalUsageBytes() int64 {
	if m != nil && m.TotalLogicalUsageBytes != nil {
		return *m.TotalLogicalUsageBytes
	}
	return 0
}

func (m *UsageStatProto) GetTotalPhysicalUsageBytes() int64 {
	if m != nil && m.TotalPhysicalUsageBytes != nil {
		return *m.TotalPhysicalUsageBytes
	}
	return 0
}

func (m *UsageStatProto) GetDisks() []int64 {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *UsageStatProto) GetDiskUsageBytes() []int64 {
	if m != nil {
		return m.DiskUsageBytes
	}
	return nil
}

func (m *UsageStatProto) GetTotalCapacityBytes() int64 {
	if m != nil && m.TotalCapacityBytes != nil {
		return *m.TotalCapacityBytes
	}
	return 0
}

func (m *UsageStatProto) GetTotalReservedUsageBytes() int64 {
	if m != nil && m.TotalReservedUsageBytes != nil {
		return *m.TotalReservedUsageBytes
	}
	return 0
}

func (m *UsageStatProto) GetTotalGarbageBytes() int64 {
	if m != nil && m.TotalGarbageBytes != nil {
		return *m.TotalGarbageBytes
	}
	return 0
}

func (m *UsageStatProto) GetTotalUnreservedUsageBytes() int64 {
	if m != nil && m.TotalUnreservedUsageBytes != nil {
		return *m.TotalUnreservedUsageBytes
	}
	return 0
}

func (m *UsageStatProto) GetZeusLogicalTimestamp() int64 {
	if m != nil && m.ZeusLogicalTimestamp != nil {
		return *m.ZeusLogicalTimestamp
	}
	return 0
}

// Stat maintained for every vdisk, vm, node, container, and the complete
// appliance. Storage map denotes where (node-wise) the data from a
// particular entity is located in the appliance.
type StorageMapStatProto struct {
	// The list of nodes where the data from an entity is stored.
	Nodes []int64 `protobuf:"varint,1,rep,name=nodes" json:"nodes,omitempty"`
	// Usage stats for each of the above mentioned nodes.
	NodeUsageStats       []*UsageStatProto `protobuf:"bytes,2,rep,name=node_usage_stats,json=nodeUsageStats" json:"node_usage_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *StorageMapStatProto) Reset()         { *m = StorageMapStatProto{} }
func (m *StorageMapStatProto) String() string { return proto.CompactTextString(m) }
func (*StorageMapStatProto) ProtoMessage()    {}
func (*StorageMapStatProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c7ca023696c8ea8, []int{1}
}

func (m *StorageMapStatProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageMapStatProto.Unmarshal(m, b)
}
func (m *StorageMapStatProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageMapStatProto.Marshal(b, m, deterministic)
}
func (m *StorageMapStatProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageMapStatProto.Merge(m, src)
}
func (m *StorageMapStatProto) XXX_Size() int {
	return xxx_messageInfo_StorageMapStatProto.Size(m)
}
func (m *StorageMapStatProto) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageMapStatProto.DiscardUnknown(m)
}

var xxx_messageInfo_StorageMapStatProto proto.InternalMessageInfo

func (m *StorageMapStatProto) GetNodes() []int64 {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *StorageMapStatProto) GetNodeUsageStats() []*UsageStatProto {
	if m != nil {
		return m.NodeUsageStats
	}
	return nil
}

// Stat maintained for every vdisk, vm, node, container, and the whole
// appliance. Individual statistics are the aggregated/average values
// computed from the samples collected over some time unit. The time unit
// is configurable by the administrator through prism UI and ranges from
// one second to one day.
//
// Heat map denotes the level of activity of a given entity and how it is
// spread across the appliance.
type HeatMapStatProto struct {
	// The list of nodes that were refered by the entity.
	Nodes []int64 `protobuf:"varint,1,rep,name=nodes" json:"nodes,omitempty"`
	// Io activity from the given entity to each of the above mentioned nodes.
	NodeIoStats []*IoStatProto `protobuf:"bytes,2,rep,name=node_io_stats,json=nodeIoStats" json:"node_io_stats,omitempty"`
	// Disk wise io activity from the given entity for each of the above
	// mentioned nodes.
	NodeHeatMap []*HeatMapStatProto_HeatMap `protobuf:"bytes,3,rep,name=node_heat_map,json=nodeHeatMap" json:"node_heat_map,omitempty"`
	// Time span in micro seconds for which the above stats were observed.
	TimeSpanUsec         *int64   `protobuf:"varint,4,opt,name=time_span_usec,json=timeSpanUsec" json:"time_span_usec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeatMapStatProto) Reset()         { *m = HeatMapStatProto{} }
func (m *HeatMapStatProto) String() string { return proto.CompactTextString(m) }
func (*HeatMapStatProto) ProtoMessage()    {}
func (*HeatMapStatProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c7ca023696c8ea8, []int{2}
}

func (m *HeatMapStatProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeatMapStatProto.Unmarshal(m, b)
}
func (m *HeatMapStatProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeatMapStatProto.Marshal(b, m, deterministic)
}
func (m *HeatMapStatProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeatMapStatProto.Merge(m, src)
}
func (m *HeatMapStatProto) XXX_Size() int {
	return xxx_messageInfo_HeatMapStatProto.Size(m)
}
func (m *HeatMapStatProto) XXX_DiscardUnknown() {
	xxx_messageInfo_HeatMapStatProto.DiscardUnknown(m)
}

var xxx_messageInfo_HeatMapStatProto proto.InternalMessageInfo

func (m *HeatMapStatProto) GetNodes() []int64 {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *HeatMapStatProto) GetNodeIoStats() []*IoStatProto {
	if m != nil {
		return m.NodeIoStats
	}
	return nil
}

func (m *HeatMapStatProto) GetNodeHeatMap() []*HeatMapStatProto_HeatMap {
	if m != nil {
		return m.NodeHeatMap
	}
	return nil
}

func (m *HeatMapStatProto) GetTimeSpanUsec() int64 {
	if m != nil && m.TimeSpanUsec != nil {
		return *m.TimeSpanUsec
	}
	return 0
}

// Heat map stat.
type HeatMapStatProto_HeatMap struct {
	Disks                []int64        `protobuf:"varint,1,rep,name=disks" json:"disks,omitempty"`
	DiskIoStats          []*IoStatProto `protobuf:"bytes,2,rep,name=disk_io_stats,json=diskIoStats" json:"disk_io_stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *HeatMapStatProto_HeatMap) Reset()         { *m = HeatMapStatProto_HeatMap{} }
func (m *HeatMapStatProto_HeatMap) String() string { return proto.CompactTextString(m) }
func (*HeatMapStatProto_HeatMap) ProtoMessage()    {}
func (*HeatMapStatProto_HeatMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c7ca023696c8ea8, []int{2, 0}
}

func (m *HeatMapStatProto_HeatMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeatMapStatProto_HeatMap.Unmarshal(m, b)
}
func (m *HeatMapStatProto_HeatMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeatMapStatProto_HeatMap.Marshal(b, m, deterministic)
}
func (m *HeatMapStatProto_HeatMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeatMapStatProto_HeatMap.Merge(m, src)
}
func (m *HeatMapStatProto_HeatMap) XXX_Size() int {
	return xxx_messageInfo_HeatMapStatProto_HeatMap.Size(m)
}
func (m *HeatMapStatProto_HeatMap) XXX_DiscardUnknown() {
	xxx_messageInfo_HeatMapStatProto_HeatMap.DiscardUnknown(m)
}

var xxx_messageInfo_HeatMapStatProto_HeatMap proto.InternalMessageInfo

func (m *HeatMapStatProto_HeatMap) GetDisks() []int64 {
	if m != nil {
		return m.Disks
	}
	return nil
}

func (m *HeatMapStatProto_HeatMap) GetDiskIoStats() []*IoStatProto {
	if m != nil {
		return m.DiskIoStats
	}
	return nil
}

func init() {
	proto.RegisterType((*UsageStatProto)(nil), "nutanix.stats.UsageStatProto")
	proto.RegisterType((*StorageMapStatProto)(nil), "nutanix.stats.StorageMapStatProto")
	proto.RegisterType((*HeatMapStatProto)(nil), "nutanix.stats.HeatMapStatProto")
	proto.RegisterType((*HeatMapStatProto_HeatMap)(nil), "nutanix.stats.HeatMapStatProto.HeatMap")
}

func init() { proto.RegisterFile("stats/uistats.proto", fileDescriptor_6c7ca023696c8ea8) }

var fileDescriptor_6c7ca023696c8ea8 = []byte{
	// 455 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x51, 0x8b, 0xd3, 0x40,
	0x10, 0xc7, 0x69, 0x73, 0xf5, 0x74, 0x6a, 0x4b, 0x9b, 0x96, 0x33, 0x06, 0x85, 0x52, 0x04, 0xfb,
	0x14, 0xe5, 0xf0, 0x45, 0x84, 0x13, 0xce, 0x87, 0x53, 0x54, 0x38, 0x5a, 0xfb, 0xe2, 0x4b, 0x98,
	0x4b, 0x97, 0x5e, 0xb0, 0xc9, 0x2e, 0xd9, 0x89, 0x58, 0x3f, 0x9b, 0x9f, 0xc5, 0xcf, 0x22, 0x3b,
	0xbb, 0x4d, 0x93, 0xe8, 0x83, 0xf7, 0x94, 0xec, 0xfc, 0xff, 0xbf, 0xfc, 0x37, 0x33, 0x03, 0x13,
	0x4d, 0x48, 0xfa, 0x45, 0x99, 0xf2, 0x33, 0x52, 0x85, 0x24, 0xe9, 0x0f, 0xf2, 0x92, 0x30, 0x4f,
	0x7f, 0x44, 0x5c, 0x0c, 0xc7, 0xd6, 0x53, 0x73, 0xcc, 0x7f, 0x7b, 0x30, 0x5c, 0x6b, 0xdc, 0x8a,
	0x15, 0x21, 0x5d, 0x33, 0xf4, 0x1a, 0x1e, 0x93, 0x24, 0xdc, 0xc5, 0x3b, 0xb9, 0x4d, 0x13, 0xdc,
	0xc5, 0xa5, 0xd1, 0xe3, 0x9b, 0x3d, 0x09, 0x1d, 0x74, 0x66, 0x9d, 0x85, 0xb7, 0x3c, 0x63, 0xc3,
	0x27, 0xab, 0x33, 0x7e, 0x69, 0x54, 0xff, 0x0d, 0x84, 0x16, 0x55, 0xb7, 0x7b, 0xfd, 0x17, 0xdb,
	0x65, 0xf6, 0x11, 0x3b, 0xae, 0x9d, 0xa1, 0x06, 0x4f, 0xa1, 0xb7, 0x49, 0xf5, 0x37, 0x1d, 0x78,
	0x33, 0x6f, 0xe1, 0x2d, 0xed, 0xc1, 0x5f, 0xc0, 0xc8, 0xbc, 0x34, 0x3e, 0x74, 0xc2, 0x86, 0xa1,
	0xa9, 0xd7, 0xf8, 0x97, 0x30, 0xb5, 0xe1, 0x09, 0x2a, 0x4c, 0x52, 0xda, 0x3b, 0x77, 0x8f, 0x63,
	0x7d, 0xd6, 0xde, 0x39, 0xa9, 0x75, 0xdd, 0x42, 0x68, 0x51, 0x7c, 0x17, 0x9b, 0x46, 0xca, 0xbd,
	0xda, 0x75, 0x97, 0xce, 0x50, 0x8b, 0x8b, 0x60, 0x62, 0xe1, 0x2d, 0x16, 0x37, 0x47, 0xea, 0x94,
	0xa9, 0x31, 0x4b, 0x57, 0x56, 0xb1, 0xfe, 0xb7, 0xf0, 0xc4, 0xfa, 0xcb, 0xfc, 0x9f, 0x71, 0xf7,
	0x19, 0xb4, 0xad, 0x5f, 0x57, 0x96, 0x5a, 0xe0, 0x2b, 0x38, 0xfb, 0x29, 0x4a, 0x5d, 0x8d, 0x85,
	0xd2, 0x4c, 0x68, 0xc2, 0x4c, 0x05, 0x0f, 0x18, 0x9d, 0x1a, 0xd5, 0xcd, 0xe4, 0xcb, 0x41, 0x9b,
	0x13, 0x4c, 0x56, 0x24, 0x0b, 0xdc, 0x8a, 0xcf, 0xa8, 0x8e, 0x43, 0x9e, 0x42, 0x2f, 0x97, 0x1b,
	0x1e, 0x28, 0x37, 0x9b, 0x0f, 0xfe, 0x15, 0x8c, 0xcc, 0x8b, 0xbb, 0x17, 0xef, 0x49, 0xd0, 0x9d,
	0x79, 0x8b, 0xfe, 0xf9, 0xd3, 0xa8, 0xb1, 0x4a, 0x51, 0x73, 0x67, 0x96, 0x43, 0x83, 0x55, 0x35,
	0x3d, 0xff, 0xd5, 0x85, 0xd1, 0x7b, 0x81, 0xf4, 0x1f, 0x99, 0x17, 0x30, 0xe0, 0xcc, 0x54, 0x36,
	0x02, 0xc3, 0x56, 0xe0, 0x07, 0x79, 0x4c, 0xeb, 0x1b, 0xc0, 0x16, 0xb4, 0xff, 0xd1, 0xf1, 0xb7,
	0x02, 0x29, 0xce, 0x50, 0xf1, 0xfa, 0xf4, 0xcf, 0x9f, 0xb7, 0xf8, 0xf6, 0x6d, 0x0e, 0x05, 0xfb,
	0x31, 0x77, 0xf0, 0x9f, 0xc1, 0xd0, 0xb4, 0x35, 0xd6, 0x0a, 0xf3, 0xb8, 0xd4, 0x22, 0x09, 0x4e,
	0xb8, 0xb7, 0x0f, 0x4d, 0x75, 0xa5, 0x30, 0x5f, 0x6b, 0x91, 0x84, 0x31, 0x9c, 0x1e, 0x80, 0x6a,
	0x69, 0x3b, 0xf5, 0xa5, 0xbd, 0x80, 0x01, 0x2f, 0xed, 0x5d, 0xfe, 0xc9, 0x00, 0xee, 0x9f, 0x2e,
	0x43, 0x18, 0x27, 0x32, 0x6b, 0xba, 0xbf, 0xf6, 0xf8, 0xf1, 0x27, 0x00, 0x00, 0xff, 0xff, 0xbb,
	0x3d, 0xe0, 0x38, 0xe9, 0x03, 0x00, 0x00,
}
